<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>linux</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="linux-1-daily.html"><strong aria-hidden="true">1.</strong> 日常使用</a></li><li class="chapter-item expanded "><a href="linux-1-exception.html"><strong aria-hidden="true">2.</strong> 报错维护</a></li><li class="chapter-item expanded "><a href="linux-1-systemd.html"><strong aria-hidden="true">3.</strong> systemd</a></li><li class="chapter-item expanded "><a href="linux-1-gnome.html"><strong aria-hidden="true">4.</strong> gnome 桌面</a></li><li class="chapter-item expanded "><a href="linux-2-process.html"><strong aria-hidden="true">5.</strong> unix-进程</a></li><li class="chapter-item expanded "><a href="linux-3-zsh-termux.html"><strong aria-hidden="true">6.</strong> zsh,termux</a></li><li class="chapter-item expanded "><a href="linux-3-package.html"><strong aria-hidden="true">7.</strong> linux 包管理</a></li><li class="chapter-item expanded "><a href="linux-5-owner.html"><strong aria-hidden="true">8.</strong> 权限,shell 环境</a></li><li class="chapter-item expanded "><a href="linux-6-network.html"><strong aria-hidden="true">9.</strong> 网络</a></li><li class="chapter-item expanded "><a href="linux-6-package-mount.html"><strong aria-hidden="true">10.</strong> 包管理,挂载</a></li><li class="chapter-item expanded "><a href="linux-7-tar-sync.html"><strong aria-hidden="true">11.</strong> 压缩,同步文件</a></li><li class="chapter-item expanded "><a href="linux-7-text-operation.html"><strong aria-hidden="true">12.</strong> 文本操作</a></li><li class="chapter-item expanded "><a href="linux-8-printer.html"><strong aria-hidden="true">13.</strong> 打印机</a></li><li class="chapter-item expanded "><a href="manjaro.html"><strong aria-hidden="true">14.</strong> manjaro</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">bash 手册</li><li class="chapter-item expanded "><a href="bash-1.html"><strong aria-hidden="true">15.</strong> bash常用命令</a></li><li class="chapter-item expanded "><a href="bash-2.html"><strong aria-hidden="true">16.</strong> bash 变量,脚本参数</a></li><li class="chapter-item expanded "><a href="bash-4.html"><strong aria-hidden="true">17.</strong> 内核风格</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">其他工具</li><li class="chapter-item expanded "><a href="awk.html"><strong aria-hidden="true">18.</strong> w3c awk</a></li><li class="chapter-item expanded "><a href="awk-2.html"><strong aria-hidden="true">19.</strong> awk another</a></li><li class="chapter-item expanded "><a href="linux-gpg.html"><strong aria-hidden="true">20.</strong> GnuPG</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">linux</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-1-daily"><a class="header" href="#linux-1-daily">linux-1-daily</a></h1>
<hr />
<p><code>ls *.tex</code> and <code>&quot;ls *.tex&quot;</code>
前一种 bash 认为 <code>*.tex</code> 是参数,后一种 bash 认为 <code>&quot;ls *.tex&quot;</code> 是一个整体命令的名字.</p>
<p>bash 物理行上单个语句不用分号,两个语句并列时,采用分号.</p>
<hr />
<p>如果用显式字符串作 <code>cd</code> 的参数,应该用绝对路径避免<code>~</code>的解析问题.如</p>
<pre><code class="language-bash">cd  /home/tom/Downloads
</code></pre>
<hr />
<p><code>whoami</code>会输出用户的名称</p>
<hr />
<p>bash -c <code>command</code> arg1 arg2 ...</p>
<p>这种调用形式,会读取 <code>-c</code>后面的<code>command_string</code>并执行命令,然后退出
如果在<code>command_string</code>之后有参数,则第一个参数分配给<code>$0</code>,其余所有参数分配给<code>位置参数</code>.
<code>$0</code>的赋值设置<code>shell</code>的名称,该名称用于<code>warning</code>和<code>error</code>消息.如</p>
<pre><code class="language-bash">bash -c 'ls;echo;uptime'
</code></pre>
<h2 id="命令类型"><a class="header" href="#命令类型">命令类型</a></h2>
<p>命令可以是下面四种形式之一:</p>
<ol>
<li>是一个可执行程序,就像我们所看到的位于目录<code>/usr/bin</code> 中的文件一样.
属于这一类的程序,可以编译成二进制文件,诸如用 <code>C</code> 和 <code>C++</code>语言写成的程序, 也可以是由脚本语言写成的程序,比如说 <code>shell</code>,<code>perl</code>,<code>python</code>,<code>ruby</code>,等等.</li>
<li>是一个内建于 <code>shell</code> 自身的命令.bash 支持若干命令,内部叫做 shell 内部命令 <code>(builtins</code>).例如,<code>cd</code> 命
令,就是一个 <code>shell</code> 内部命令.</li>
<li>是一个 <code>shell</code> 函数.这些是小规模的 <code>shell</code> 脚本,它们混合到环境变量中. 在后续的章节里,我们将讨论配
置环境变量以及书写 shell 函数.但是现在, 仅仅意识到它们的存在就可以了.</li>
<li>是一个命令别名.我们可以定义自己的命令,建立在其它命令之上</li>
</ol>
<hr />
<p><a href="https://ohmyz.sh/#install">oh_my_zsh</a></p>
<p>查看或设置主题</p>
<pre><code class="language-zsh">_omz::theme list agnoster
_omz::theme set agnoster
</code></pre>
<p>更新 <code>omz</code></p>
<pre><code>_omz::update
</code></pre>
<hr />
<p>powerline</p>
<p><a href="https://github.com/powerline/powerline">Powerline is a statusline plugin</a>
<a href="https://powerline.readthedocs.io/en/latest/installation/linux.html">Installation on Linux</a></p>
<p>get the latest release version</p>
<pre><code class="language-powershell">pip install --user powerline-status
</code></pre>
<h2 id="基本命令"><a class="header" href="#基本命令">基本命令</a></h2>
<ul>
<li><code>type</code> – 说明怎样解释一个命令名</li>
<li><code>which</code> – 显示会执行哪个可执行程序</li>
<li><code>man</code> – 许多希望被命令行使用的可执行程序,提供了一个正式的文档,叫做手册或手册页(man page).一个特殊的叫做<code>man</code> 的分页程序,可用来浏览他们</li>
<li><code>apropos</code> - 显示适当的命令,基于某个关键字的匹配项.虽然很粗糙但有时很有用.</li>
<li><code>info</code> – 项目提供了一个命令程序手册页的替代物,称为<code>info</code>.</li>
<li><code>whatis</code> – 程序显示匹配特定关键字的手册页的名字和一行命令说明</li>
<li><code>alias</code> – 创建命令别名</li>
<li><code>type</code> 命令是 <code>shell</code> 内部命令,它会显示命令的类别</li>
<li><code>which</code>这个命令只对可执行程序有效,不包括内部命令和命令别名,别名是真正的可执行程序的替代物</li>
<li><code>bash</code> 有一个内建的帮助工具,可供每一个 <code>shell</code> 内部命令使用.输入<code>help</code>,接着是 <code>shell</code> 内部命令名.例如: <code>help cd</code></li>
<li><code> --help</code> : 许多可执行程序支持这个选项, 显示命令所支持的语法和选项说明.</li>
<li><code>less </code> 浏览文件内容</li>
<li><code>basename file suffix</code> 用来去掉文件后缀名</li>
<li><code>/bin/kill -L</code> : 查看linux <code>kill</code> 的数字对应的短语</li>
<li><code>ldd</code>查看依赖信息</li>
<li><code>sha256sum</code>: 计算并检查 <code>SHA256</code> message digest (消息摘要)</li>
<li><code>xdg-open</code>: 可以设置别名为<code>open</code>, 使用默认的程序打开文件或者<code>url</code>.</li>
<li><code>lsusb</code>: 用于显示系统中的<code>USB</code>总线和连接到它们的设备信息的工具.</li>
<li><code>lspci</code>: 用于显示系统中的<code>PCI</code>总线和连接到它们的设备的信息的工具. Peripheral Component Interconnect, 外围组件互连标准. <code>pcie</code>--express:高速串行总线.</li>
<li><code>ssh remote-sys 'ls * &gt; dirlist.txt'</code> ; 远程连接到<code>remote-sys</code>, 并执行<code>ls * &gt; dirlist.txt</code> 命令.</li>
</ul>
<hr />
<p><code>echo</code>输出的时候,可以考虑改变颜色增加辨认度</p>
<pre><code class="language-bash">echo  -e &quot;\033[1;47m\033[1;32m Testing output... &quot;
</code></pre>
<hr />
<p><code>ls --color=always | less -R</code>: 这个命令可以保持颜色控制字符的传递.</p>
<p><code>less -R</code> or <code>--RAW-CONTROL-CHARS</code>:</p>
<p>和<code>-r</code>一样, 但只把ANSI &quot;color&quot;转义序列以 &quot;raw&quot; 形式输出.  大多数情况下幕外观保持正确.
ANSI &quot;颜色&quot;转义序列是以下形式的序列: <code>ESC [ ... m</code>. 其中<code>...</code>是<code>0</code>个或更多的颜色规范字符. 为了保持屏幕外观, <code>ANSI</code>颜色转义序列被认为不会移动光标.
你可以设置<code>m</code>之外的结束字符, 方法是将环境变量<code>LESSANSIENDCHARS</code>设为结束颜色转义序列的字符列表.
也可以设置环境变量<code>LESSANSIMIDCHARS</code>,使标准字符之外的字符出现在<code>ESC</code>和<code>m</code>之间</p>
<p>或者可以使用<code>git diff --word-diff --no-index file1 file2 </code>. <code>--word-diff</code>指定按单词模式显示差异, <code>--no-index</code>表明不是与<code>cached</code>作比较, 而是比较工作区中的文件.</p>
<hr />
<ul>
<li><code>date</code> :日期</li>
<li><code>cal</code>: 日历</li>
<li><code>df</code> :磁盘剩余空间</li>
<li><code>free</code>: 空闲内存</li>
<li><code> file</code>  :确定文件类型</li>
<li><code>which</code>: 确定命令的位置, <code>where</code>: <code>zsh</code>内置命令, <code>which</code>:内置命令, 也有二进制, <code>whereis</code>: 二进制程序.</li>
<li><code>type</code>: 用来查看命令的类型</li>
<li><code>cd -</code> :更改工作目录到先前的工作目录</li>
<li><code>cd ~user_name</code> :切换到用户家目录</li>
<li><code>cp -u *.html destination</code> :更新文件到destination</li>
<li><code>ln file link</code> :创建硬链接</li>
<li><code>ln -s item link</code> :创建符号链接, <code>item</code>可以是一个文件或目录,<code>gnome</code>中,按住<code>ctrl+shift</code>拖动会创建链接.</li>
<li><code>df -hT</code>: <code>h</code>让你以 <code>MB</code> 或 <code>G</code> 为单位查看磁盘的空间, <code>T</code>打印设备类型</li>
</ul>
<hr />
<p>查看系统版本信息</p>
<p><a href="https://blog.csdn.net/whbing1471/article/details/52074390">ubuntu: 查看ubuntu系统的版本信息</a></p>
<pre><code class="language-bash">cat /proc/version
uname -a
sb_release -a
</code></pre>
<hr />
<p>查看主要存储设备的使用情况</p>
<pre><code class="language-bash">df -h | sort -hr --key=2
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p><a href="https://blog.csdn.net/lijingshan34/article/details/86568596">/etc/environment 与 /etc/profile区别</a></p>
<p><code>/etc/environment</code>是设置整个系统的环境, 而<code>/etc/profile</code>是设置所有用户的环境, 前者与登录用户无关, 后者与登录用户有关.</p>
<p>跟环境变量相关的参数:</p>
<p><code>/etc/profile</code> -&gt;<code>/etc/enviroment</code> --&gt;<code>$HOME/.profile</code> --&gt;<code>$HOME/.env</code></p>
<p>如果你把文本放在双引号中, <code>shell</code> 使用的特殊字符, 除了<code>\</code>(反斜杠),<code>$</code> ,和 <code>`</code>(倒引号)之外, 则失去它们的特殊含义,被当作普通字符来看待.</p>
<p>这意味着</p>
<ul>
<li>单词分割, (<code>空格</code>)</li>
<li>路径名展开, (<code>*``?</code>)</li>
<li>波浪线展开,(<code>~</code>)</li>
<li>和花括号展开(<code>{}</code>)</li>
</ul>
<p>都被禁止,然而</p>
<ul>
<li>参数展开(<code>$USER</code>)</li>
<li>算术展开(<code>$(())</code>)</li>
<li>命令替换<code>$()</code></li>
</ul>
<p>仍被执行, 所以在<code>.zshrc</code> or <code>.bashrc</code> 中设置环境变量的时候, 如果需要用到<code>~</code>, 那么就不用加<code>&quot;</code> or <code>'</code>,(不要加任何引号)</p>
<pre><code class="language-bash">export PATH=/usr/local/opt/coreutils/libexec/gnubin:~/bin:$PATH
</code></pre>
<p><code>$HOME</code>:用户目录</p>
<h2 id="shell-模式切换"><a class="header" href="#shell-模式切换">shell 模式切换</a></h2>
<ol>
<li>查看系统支持的shell模式及位置</li>
</ol>
<p><code>echo &amp;SHELL</code>
<code>cat /etc/shells</code></p>
<ol start="2">
<li>切换shell为/bin/sh</li>
</ol>
<p><code># chsh -s /bin/sh</code></p>
<h2 id="重启x-org"><a class="header" href="#重启x-org">重启x-org</a></h2>
<p><a href="https://www.kaifa99.com/ubuntu/article_156280">xorg 重新启动X窗口服务器</a></p>
<p>在<code>systemd</code>系统上(<code>Ubuntu 15.04</code>和更新版本)</p>
<pre><code class="language-bash">sudo systemctl restart display-manager
</code></pre>
<p>注: 这将强制退出所有图形程序, 将丢失未保存的工作, 强制被注销. 非图形程序不会受到影响.</p>
<p>对于其他<code>Ubuntu</code>版本, 首先使用以下命令找到<code>Ubuntu</code>的显示管理器:</p>
<pre><code class="language-bash">cat /etc/X11/default-display-manager
</code></pre>
<p>根据显示管理器的不同, 可以使用以下命令之一:</p>
<pre><code class="language-bash">sudo restart lightdm # 使用LightDM
sudo restart gdm # Gnome (带GDM )
sudo restart kdm # KDE (带KDM )
sudo restart mdm # 对于MDM (例如对于Mint Cinnamon )
</code></pre>
<p><a href="https://wiki.archlinux.org/title/Display_manager">Display manager</a></p>
<p><code>显示管理器</code>(display manager), 或称<code>登录管理器</code>(login manager), 通常是一个图形用户界面, 在 boot 过程结束时显示, 以取代默认的shell.
显示管理器有多种实现方式, 就像有各种类型的 window managers 和 desktop environments 一样. 通常每一种都有一定程度的定制和主题性可供选择.</p>
<h2 id="ls-选项"><a class="header" href="#ls-选项">ls 选项</a></h2>
<p><code>ls -d */</code></p>
<ul>
<li><code>-d</code>; 选项指定只列出目录,<code>glob</code>模式当前目录下<code>*/</code>表示所有的子目录</li>
<li><code>-S</code> ;  按文件大小排序,大的优先</li>
<li><code>--sort=WORD</code> ;  按<code>WORD</code>排序,而不是<code>name</code>: none (-U), size (-S), time (-t), version (-v), extension (-X)</li>
<li><code>--time=WORD</code>; 和 <code>-l</code>一起使用, 显示<code>WORD</code>时间, 而不是默认的修改时间, 可使用字段:
<code>atime</code> or <code>access</code> or <code>use</code> (<code>-u</code>); <code>ctime</code> or <code>status</code> (<code>-c</code>); 同时使用指定的 <code>time</code> 作为排序键, 如果使用了<code>--sort=time</code> (新的在前)</li>
<li><code>-X</code> ; 按拓展名的字母顺序排列</li>
<li><code>-m</code>; 用逗号分隔的条目列表填充宽度</li>
<li><code>-x</code> ;    按行而不是按列输出条目</li>
<li><code>-b, --escape</code>;    对非图形字符, 打印<code>C</code>式转义符</li>
<li><code>-q, --hide-control-chars</code>;    对非图形字符, 打印<code>?</code></li>
<li><code>-1</code> ;    每行打印一个文件. 可以使用<code>-q</code>或者<code>-b</code>避免<code>\n</code></li>
<li><code>--format=WORD</code> ;  横跨<code>-x</code>,逗号<code>-m</code>,水平<code>-x</code>,长<code>-l</code>,单列<code>-1</code>,verbose<code>-l</code>,垂直<code>-C</code></li>
</ul>
<h2 id="别名alias"><a class="header" href="#别名alias">别名(alias)</a></h2>
<p><a href="https://www.cnblogs.com/chenjo/p/11145021.html">Linux shell 脚本中使用 alias 定义的别名</a></p>
<p>可以把多个命令放在同一行上,命令之间 用<code>;</code>分开</p>
<pre><code class="language-bash">command1; command2; command3...
</code></pre>
<p>我们会用到下面的例子:</p>
<pre><code class="language-bash">$ cd /usr; ls; cd -
bin games
kerberos lib64
local
</code></pre>
<p>正如我们看到的,我们在一行上联合了三个命令.
首先更改目录到<code>/usr</code>,然后列出目录 内容,最后回到原始目录(用命令<code>cd -</code>),结束在开始的地方.
现在,通过 <code>alia</code> 命令 把这一串命令转变为一个命令.</p>
<p>为了查清此事,可以使用 type 命令:</p>
<pre><code class="language-bash">$ type test
test is a shell builtin
</code></pre>
<p>哦!<code>test</code>名字已经被使用了.试一下<code>foo</code>:</p>
<pre><code class="language-bash">$ type foo
bash: type: foo: not found
</code></pre>
<p>创建命令别名:</p>
<pre><code class="language-bash">$ alias foo='cd /usr; ls; cd -'
</code></pre>
<p>注意命令结构:</p>
<pre><code class="language-bash">alias name='string'
</code></pre>
<p>在命令<code>alias</code>之后,输入<code>name</code>,紧接着(没有空格)是一个等号,等号之后是 一串用引号引起的字符串,字符串的内容要赋值给 <code>name</code>.</p>
<p>删除别名,使用 unalias 命令,像这样:</p>
<pre><code class="language-bash">$ unalias foo
$ type foo
bash: type: foo: not found
</code></pre>
<p>如果想要永久保存定义的<code>alias</code>,可以将其写入到 <code>/etc/profile</code> 或者 <code>~/.bash_rc</code> 中去,
两个的区别是影响的范围不一样而已</p>
<h2 id="zsh-别名"><a class="header" href="#zsh-别名">zsh 别名</a></h2>
<ul>
<li><code>grep</code>='grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}'</li>
</ul>
<h2 id="文件管理-cp-rm-mv"><a class="header" href="#文件管理-cp-rm-mv">文件管理 cp rm mv</a></h2>
<p>复制移动的时候,可以加上 <code>-i</code> 参数,防止覆盖</p>
<p><code>cp [OPTION]... SOURCE... DIRECTORY</code></p>
<p><code>...</code> 表示可以重复</p>
<p><code>cp -i  ... ... </code></p>
<p><code>cp -irf  ... ... </code></p>
<p>短命令可以堆叠, <code>-i -r -f</code>=<code>-irf</code>=<code>--interactive --force --recursive</code></p>
<p><code>-R</code> 如果<code>source_file</code>是目录, 则<code>cp</code>复制目录和整个子目录.  如果<code>source_file</code>以<code>/</code>结尾, 则复制目录内容, 而不是此目录本身.
此选项还会导致复制符号链接, 而不是复制链接对应的文件, 并让<code>cp</code>创建特殊文件, 而不是普通文件. 创建的目录与相应的源目录具有相同的<code>mode</code>, 不会被<code>umask</code>修改.
在<code>-R</code>模式下, 即使检测到错误, <code>cp</code>仍将继续复制.
请注意, <code>cp</code>将硬链接的文件单独复制一份.  如果你需要保持硬链接, 考虑改用<code>tar(1)</code>, <code>cpio(1)</code>, or <code>pax(1)</code>.</p>
<p><code>-a</code>与<code>-pPR</code>选项相同.  保留文件的结构和属性, 但不保留目录结构.</p>
<hr />
<p>要删除名称以<code>-</code>开头的文件,例如<code> -foo</code>,请使用以下命令之一:</p>
<ul>
<li><code>rm -- -foo</code></li>
<li><code>rm ./-foo</code></li>
</ul>
<p>删除本层目录下除了源文件的<code>latex</code>辅助文件</p>
<pre><code>temp_a=$(find . -mindepth 1 -maxdepth 1 -type f   \( -not -name  &quot;*.pdf&quot; \)  \( -not -name  &quot;*.tex&quot; \) \( -not -name  &quot;*.bib&quot; \) -print0); if [[ ${temp_a} != '' ]]; then  echo -n ${temp_a} |  xargs --null rm; fi
</code></pre>
<p>可以多用花括号展开,指定多个文件名,例如:</p>
<pre><code class="language-bash">ls ~/draft/draft.2008{03,04,05}.nb
/home/tom/draft/draft.200803.nb  /home/tom/draft/draft.200804.nb  /home/tom/draft/draft.200805.nb
</code></pre>
<p>删除本目录下的子目录, 只保留文件:</p>
<pre><code class="language-bash">find . -mindepth 1 -maxdepth 0 -type d # 先查看输出
find . -mindepth 1 -maxdepth 1 -type d -exec rm -rf '{}' + #使用 + 号将输出合并到 rm -rf 后面
</code></pre>
<p>其中<code>{}</code>是当前路径名的符号表示,<code>;</code>界定符表示命令结束, <code>+</code>界定符表示合并结果一起执行命令.</p>
<h2 id="重命名-rename"><a class="header" href="#重命名-rename">重命名 rename</a></h2>
<p>重命名除了使用<code>mv</code>,也可以使用<code>rename</code>.  在<code>ubuntu</code>上, 有两个版本的<code>rename</code>程序.
<code>perl</code>版的<code>rename</code>程序就叫做<code>rename</code>, <code>util-linux</code>包中的版本叫做<code>rename.ul</code>.</p>
<p>以下是简单的说明:</p>
<hr />
<p>rename - renames multiple files</p>
<p>SYNOPSIS</p>
<pre><code class="language-bash">rename [ -h|-m|-V ] [ -v ] [ -n ] [ -f ] [ -e|-E perlexpr]*|perlexpr [ files ]
</code></pre>
<p>DESCRIPTION</p>
<p><code>rename</code>根据指定为第一个参数的规则重命名提供的文件名.
<code>perlexpr</code>参数是一个<code>Perl</code>表达式,它修改<code>Perl</code>中的<code>$ _</code>字符串.
如果给定的文件名未被表达式修改,则不会重命名.
如果命令行中未提供文件名,则将通过标准输入读取文件名.</p>
<p><code>perlepxr</code>三种模式,分别是:</p>
<ul>
<li>匹配; <code>m</code></li>
<li>替换; <code>s</code></li>
<li>转化; <code>tr</code> or <code>y</code> :  相当于一个映射表格, 进行批量替换</li>
</ul>
<p><code>perlepxr</code>的后向引用</p>
<pre><code class="language-perl">$` : 匹配部分的前一部分字符串
$&amp; : 匹配的字符串
$'  : 还没有匹配的剩余字符串
$1 : 反向引用的第一个字符串
</code></pre>
<p><code>/expr/sub/mod</code>中<code>mod</code>表示模式修饰符, 可以是</p>
<ul>
<li><code>i</code>    如果在修饰符中加上<code>$1</code>, 则正则将会取消大小写敏感性, 即<code>$1</code>和<code>$1</code> 是一样的.</li>
<li><code>m</code>    默认的正则开始<code>^</code>和结束<code>$</code>只是对于正则字符串.
如果在修饰符中加上<code>m</code>, 那么开始和结束将会指字符串的每一行: 每一行的开头就是<code>^</code>, 结尾就是<code>$</code>.</li>
<li><code>o</code>    表达式只执行一次.</li>
<li><code>s</code>    如果在修饰符中加入<code>s</code>, 那么默认的<code>.</code>代表除了换行符以外的任何字符将会变成任意字符, 也就是包括换行符!</li>
<li><code>x</code>    如果加上该修饰符, 表达式中的空白字符将会被忽略, 除非它已经被转义.</li>
<li><code>g</code>    替换所有匹配的字符串.</li>
<li><code>e</code>    替换字符串作为表达式</li>
</ul>
<p>例如,要重命名所有匹配<code>* .bak</code>的文件,以去除扩展名,可以用</p>
<pre><code class="language-bash">rename 's/\w.bak$//' *.bak
</code></pre>
<p>要将大写名称转换为小写,可以使用</p>
<pre><code class="language-bash">rename 'y/A-Z/a-z/' *
</code></pre>
<p>把文件名中的 中划线 改称 下划线</p>
<pre><code class="language-bash">rename -n 'y/-/_/' */* # 先使用 -n 查看将被改名的文件, 但不执行操作
rename -v 'y/-/_/' */* # 去掉 -n 选项, 执行操作
</code></pre>
<hr />
<p>参数</p>
<ul>
<li><code> -v, --verbose</code>;  打印出重命名成功的文件.</li>
<li><code>-0, --null</code>; 当从<code>STDIN</code>读取时, 使用<code>\0</code>作为分隔符.</li>
<li><code>--path, --fullpath</code>; Rename full path: 重命名任何路径元素, 默认行为</li>
<li><code>-d, --filename, --nopath, --nofullpath</code>; 不重命名文件夹, 只重命名文件部分.</li>
<li><code>-n, --nono</code>;No action: 打印出要重命名的文件, 但不执行操作</li>
<li><code>-e  Expression</code>; 作用到文件名上的代码. 可以重复使用<code>-e expr1 -e expr2 ...</code>来构建代码, (like <code>perl -e</code>). 如果没有<code>-e</code>, 第一个参数被当成<code>code</code></li>
<li><code>-E Statement</code>; 类似于<code>-e</code>, 但需要<code>;</code>结束</li>
</ul>
<h2 id="获取绝对路径-realpath"><a class="header" href="#获取绝对路径-realpath">获取绝对路径 realpath</a></h2>
<p><code>realpath</code> - <code>print the resolved path</code>(打印已解析的路径)</p>
<p>SYNOPSIS
<code>realpath [OPTION]... FILE...</code></p>
<p>DESCRIPTION
打印解析的绝对文件名;  除最后一个组件外的所有组件都必须存在</p>
<p><code>-e</code>, <code>--canonicalize-existing</code>: 路径的所有组成部分必须存在
<code>-m</code>,<code>--canonicalize-missing</code>:路径组件不需要存在,也不必是目录
<code>-L</code>, <code>--logical</code>:解析符号链接前的<code>..</code>组件
<code>-P</code>, <code>--physical</code>:解析遇到的符号链接(默认)
<code>-q</code>, <code>--quiet</code>:禁止显示大多数错误消息
<code>--relative-to=DIR</code>:打印相对于<code>DIR</code>的解析路径
<code>--relative-base=DIR</code>:只打印<code>DIR</code>后面的绝对路径路径
<code>-s</code>, <code>--strip, --no-symlinks</code>:不扩展符号链接
<code>-z</code>,<code> --zero</code>:用NUL而不是换行符结束每个输出行</p>
<p>canonical order: 在排序中,指一种标准的顺序,比如字母顺序.</p>
<h2 id="tar-unzip"><a class="header" href="#tar-unzip">tar unzip</a></h2>
<hr />
<p>创建压缩文件</p>
<ul>
<li><code>tar -cvf a.tar /etc</code></li>
<li><code>gzip foo.txt</code></li>
<li><code>gzip -fvr foo.txt </code>: force,verbose,recursive</li>
<li><code>zip -r foo.zip a b c ...</code></li>
</ul>
<p>创建存档的同时用<code>gunzip</code>压缩: <code>tar -czvf a.tar.gz /etc</code>.
<code>tar</code>默认把路径当成相对路径, 如果提供的路径为<code>/home/user/file</code>, <code>tar</code>在创建存档时依次创建这些目录层次, 并且去掉开头的<code>/</code>, 使用<code>-P</code>选项改变默认设置.
下面讨论一些<code>tar</code>的选项:</p>
<ul>
<li><code>-P, --absolute-names</code>:在创建存档时, 不去掉领头的<code>/</code>.</li>
<li><code>--no-recursion</code>:避免自动递归子目录.</li>
<li><code>--recursion</code>:递归子目录, 默认.</li>
<li><code>-f, --file=ARCHIVE</code>: 设置存档用的文件或设备为<code>ARCHIVE</code>.</li>
</ul>
<p>如果未提供<code>--file=ARCHIVE</code>, 则<code>tar</code>将首先检查环境变量<code>TAPE</code>. 如果<code>TAPE</code>不为<code>null</code>, 其值将用作存档名称.
否则, <code>tar</code>将采用编译的默认值. 默认值可以使用<code>--show-defaults</code>选项, 或在<code>tar --help</code>输出的末尾查看.
用带有<code>:</code>的存档名称表示远程计算机上的文件或设备. 冒号之前的部分作为机器名称或<code>IP</code>地址, 其后的部分为文件或设备路径名, 例如: <code>--file=remotehost:/dev/sr0</code>.
也可以使用<code>user@host</code>, 即<code>用户名@主机名</code>的形式. 默认情况下, 通过<code>rsh(1)</code>命令访问远程主机. 如今通常使用<code>ssh(1)</code>代替, 可以通过以下选项指定: <code>--rsh-command=/usr/bin/ssh</code>.
远程计算机应安装了<code>rmt(8)</code>命令. 如果远程机器上<code>rmt</code>的路径名与<code>tar</code>的默认不匹配, 可以通过<code>--rmt-command</code>选项来指定正确的路径.
使用<code>--force-local</code>选项: 即使带有<code>:</code>号, 也认为文件存在于本地.</p>
<hr />
<p>解压缩<code>xxx.tar.gz</code></p>
<ul>
<li><code>tar -xzvf  xxx.tar.gz</code></li>
<li><code>gzip foo.txt</code></li>
<li><code>gzip -tv foo.txt.gz</code> : test,检验压缩文件完整性</li>
<li><code>unzip file[.zip] [file(s) ...]  [-x xfile(s) ...] [-d exdir]</code>  文件名中可以使用通配符,但要<code>quote</code>起来</li>
</ul>
<p>查看压缩文件内容,以下命令都可以</p>
<ul>
<li><code>tar -tf  xxx.tar.gz</code></li>
<li><code>tar -tzf  xxx.tar.gz</code></li>
<li><code>gunzip -c foo.txt | less</code></li>
<li><code>zcat foo.txt.gz | less</code></li>
<li><code>unzip -l file[.zip] [file(s) ...]</code></li>
</ul>
<p>支持的解压过滤器如下</p>
<ul>
<li><code>-a, --auto-compress</code>  使用存档后缀来确定压缩程序.</li>
<li><code>-I, --use-compress-program=COMMAND</code>: 通过COMMAND过滤数据.  它必须接受<code>-d</code>选项以进行解压缩.  该参数可以包含命令行选项.</li>
<li><code>-j, --bzip2</code>: 通过<code>bzip2(1)</code>过滤存档.</li>
<li><code>-J, --xz</code>: 通过<code>xz(1)</code>过滤存档.</li>
<li><code>--lzip</code> :通过<code>lzip(1)</code>过滤存档.</li>
<li><code>--lzma</code> :通过<code>lzma(1)</code>过滤存档.</li>
<li><code>--lzop</code>:通过lzop(1)过滤存档.</li>
<li><code>--no-auto-compress</code>: 不要使用存档后缀来确定压缩程序.</li>
<li><code>-z, --gzip, --gunzip, --ungzip</code>: 通过<code>gzip(1)</code>过滤存档.</li>
<li><code>-Z, --compress, --uncompress</code>通过<code>compress(1)</code>过滤存档.</li>
<li><code>--zstd</code>: 通过<code>zstd(1)</code>过滤存档.</li>
</ul>
<p><code>unzip</code> 解压特定文件合并到当前目录: 使用<code>unzip -j</code>选项: junk paths, 不会重新创建档案的目录结构;  所有文件都存放在提取目录中(默认为当前目录), 结合通配符.</p>
<pre><code class="language-bash">unzip -j '*.zip'  '*.otf'
</code></pre>
<h2 id="7z"><a class="header" href="#7z">7z</a></h2>
<p>支持的格式</p>
<p><code>LZMA2</code>, <code>XZ</code>, <code>ZIP</code>, <code>Zip64</code>, <code>CAB</code>, <code>RAR</code> (如果安装了 non-free <code>p7zip-rar</code>包),
<code>ARJ</code>,  <code>GZIP</code>, <code>BZIP2</code>, <code>TAR</code>, <code>CPIO</code>, <code>RPM</code>, <code>ISO</code></p>
<p>用法: <code>7z &lt;command&gt; [&lt;switches&gt;...] &lt;archive_name&gt; [&lt;file_names&gt;...] [&lt;@listfiles...&gt;]</code></p>
<ul>
<li>解压缩,输入密码, <code>x</code>动作保持压缩档案的目录结构:</li>
</ul>
<pre><code class="language-bash">7z x -p1234 filename
</code></pre>
<ul>
<li>压缩单个文件, <code>a</code>动作即添加压缩档案</li>
</ul>
<pre><code class="language-bash">7z a -t7z archive_name filename
</code></pre>
<ul>
<li>压缩<code>txt</code>中的文件</li>
</ul>
<pre><code class="language-bash">7z a -t7z configrc.win.7z @tom.rc_list.win
7z a -t7z configrc.linux.7z @tom.rc_list.linux
</code></pre>
<ul>
<li>
<p>各种动作</p>
</li>
<li>
<p><code>a</code> : 添加文件到归档中</p>
</li>
<li>
<p><code>b</code> : Benchmark</p>
</li>
<li>
<p><code>d</code> : 从归档中删除</p>
</li>
<li>
<p><code>e</code> : 从归档中提取(不使用目录名)</p>
</li>
<li>
<p><code>h</code> : 计算文件的 hash 值</p>
</li>
<li>
<p><code>i</code> : 展示支持的格式</p>
</li>
<li>
<p><code>l</code> : 列出归档的内容</p>
</li>
<li>
<p><code>rn</code> : 重命名归档中的文件</p>
</li>
<li>
<p><code>t</code> : 检查归档的完整性</p>
</li>
<li>
<p><code>u</code> : 把文件更新到归档</p>
</li>
<li>
<p><code>x</code> : 提取文件, 使用全路径(也就是保持文件结构)</p>
</li>
<li>
<p>可以使用的开关. 开关后面跟的具体参数不需要空格隔开.</p>
</li>
<li>
<p><code>--</code> : 停止解析开关</p>
</li>
<li>
<p><code>-o{Directory}</code> : 设置输出目录</p>
</li>
<li>
<p><code>-p{Password}</code> : 设置密码</p>
</li>
<li>
<p><code>-r[-|0]</code> : 递归子目录,作者不推荐使用</p>
</li>
<li>
<p><code>-y</code> : 对所有询问回答 yes</p>
</li>
<li>
<p><code>-t{Type}</code>:设置归档的类型</p>
</li>
<li>
<p><code>-ai[r[-|0]]@{listfile} | !{wildcard}</code>: 包括额外的压缩文件, 以及通配符. 支持使用多次.</p>
</li>
<li>
<p><code>-an</code>: 禁止命令行自动解析压缩文档的名字,需要与<code>-ai</code> (Include archives)开关一起使用</p>
</li>
<li>
<p><code>-m</code>: 设置压缩方法开关</p>
</li>
<li>
<p><code>-v{Size}[b | k | m | g]</code>: 创建 Volumes, 指定分卷体积.</p>
</li>
</ul>
<p><code>-an</code>禁止解析命令行中的压缩文档名称. 此开关必须与 <code>-ai</code> (Include archives) 开关一起使用.
如果你的压缩文档在列表文件中给出, 你要用<code>-ai</code>开关指定它, 所以在命令行中你需要禁止解析<code>存档_名称</code>字段.</p>
<hr />
<ul>
<li>
<p><code>-m</code>: 设置压缩方法开关. 语法:  <code>-m&lt;method_parameters&gt;</code>(压缩方法).
例如<code>7z a -pa.7z-mx=0 a.txt</code> 创建加密文档<code>a.7z</code>, 只是简单复制.</p>
<p>开关描述中的 &quot;默认值 &quot;是指如果没有指定开关, 将使用的值.
允许使用布尔型开关的简化形式: <code>sw+</code>或<code>sw</code>代替<code>sw=on</code>, <code>sw-</code>代替<code>sw=off</code>.
此开关的格式取决于存档类型: <code>Zip </code>, <code>GZip </code>, <code>BZip2 </code>, <code>7z </code>, <code>XZ </code>, <code>WIM </code>. <code>-m</code>开关还可以为<code>h</code>(Hash)命令指定散列方法.</p>
<p>对于<code>7z</code>格式,
Parameter  Default  Description</p>
<ul>
<li><code>x=[0 | 1 | 3 | 5 | 7 | 9 ]</code>; <code>5</code>;  例如: <code>x=9</code>.定压缩级别. 将选择不同的<code>Dictionary</code>, <code>FastBytes</code>,  <code>MatchFinder</code>, <code>Filter</code> .</li>
<li><code>yx=[0 | 1 | 3 | 5 | 7 | 9 ]</code>; <code>5</code>; 文件分析的级别.</li>
<li><code>s=[off | on | [e] [{N}f] [{N}b | {N}k | {N}m | {N}g | {N}t]</code>; <code>on</code>;  默认模式是<code>s=on</code>. 在<code>solid</code>模式下, 文件被分组在一起, 通常可以提高压缩率.</li>
<li><code>qs=[off | on]</code>; <code>off</code>;  在固实档案中按类型对文件进行分类.</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><code>-v{Size}[b | k | m | g]</code>: 创建 Volumes, 指定分卷体积.</li>
</ul>
<p>以 <code>Bytes</code>,<code> Kilobytes</code> (1 <code>Kilobyte</code> = 1024 <code>bytes</code>), <code>Megabytes</code> (1 <code>Megabyte</code> = 1024 <code>Kilobytes</code>) 或 <code>Gigabytes</code> (1 <code>Gigabyte</code> = 1024 <code>Megabytes</code>) 为单位指定卷的大小.
如果你只指定 <code>{Size}</code>, <code>7-zip</code> 会把它当作字节来处理. 可以指定多个 <code>-v</code> 开关.
注意: 在完成归档之前, 请不要使用卷(也不要复制卷). <code>7-Zip</code> 可能在归档操作结束时改变任何卷, 包括第一个卷.</p>
<p>例子, 创建多卷<code>a.7z</code>档案. 第一个卷是<code>10KB</code>, 第二个是<code>15KB</code>, 其他都是<code>2MB</code>. :</p>
<pre><code class="language-bash">7z a a.7z *.txt -v10k -v15k -v2m
</code></pre>
<ul>
<li>
<p><code>7z</code>解压多个<code>.zip</code>文件; 使用下列形式:</p>
<pre><code>7z -an -ai[r[-|0]]@{listfile} | !{wildcard}
</code></pre>
</li>
</ul>
<p><code>-an</code>表示禁止<code>bash</code>解析压缩文档名, <code>-ai</code>表示要包括的压缩文件名. 由于<code>!</code>在<code>bash</code>中是特殊符号, 需要转义或者用引号<code>'</code>裹起来:</p>
<pre><code class="language-bash">7z x -an -'air!*.zip'
7z t -an -ai!*.7z -ax!a*.7z # 测试所有*.7z 归档, 但排除 a*.7z 归档
find . -mindepth 1 -maxdepth 1 -type f -iname *.zip -exec 7z x -o'{}' '{}' + #使用 + 号将输出合并到 rm -rf 后面
</code></pre>
<p>类似的, <code>-i</code> 开关表示添加文件, 在创建压缩文档时使用.</p>
<pre><code class="language-bash">7z a -tzip src.zip *.txt -ir!DIR1\*.cpp
</code></pre>
<p>将当前目录下的所有<code>*.txt</code>文件, 以及<code>DIR1</code>目录和所有它的子目录中的<code>*.cpp</code>文件添加到<code>src.zip</code> 中.</p>
<ul>
<li>解压<code>zip</code>文件同时, 创建外层的同名文件夹. 处理带有空格的文件名参考<a href="https://www.cyberciti.biz/tips/handling-filenames-with-spaces-in-bash.html">For Loop File Names With Spaces</a></li>
</ul>
<pre><code class="language-bash">SAVEIFS=$IFS;IFS=$(echo -en &quot;\n\b&quot;); #定义分词关键字为 \n\b newline, backspace
for f in *;do  echo &quot;$f&quot;;done
IFS=$SAVEIFS;
</code></pre>
<p>所以, 可处理含有空格文件的, 批量解压缩的脚本为:</p>
<pre><code class="language-bash">SAVEIFS=$IFS;IFS=$(echo -en &quot;\n\b&quot;);
declare -a archs=( $(find . -mindepth 1 -maxdepth 1 -type f -iname '*.zip' -print0 | xargs --null  basename -s '.zip' ) );declare -p archs;
for i in ${archs}; do  unzip $i -d $i; done;
IFS=$SAVEIFS
</code></pre>
<h3 id="7z-的通配符"><a class="header" href="#7z-的通配符">7z 的通配符</a></h3>
<p>通配符或带空格的文件名必须加引号.</p>
<pre><code>&quot;Dir\Program files\*&quot;
Dir\&quot;Program files&quot;\*
</code></pre>
<p><code>开关选项</code>可以组合起来以节省命令行长度.
然而, 一些开关选项具有<code>可选参数</code>, 因此, 这种选项必须在<code>开关组合</code>的末尾, 因为<code>7-Zip</code>把<code>开关组合</code>后面的参数看作开关选项的<code>可选参数</code>.</p>
<p><code>7-Zip</code>使用类似于<code>Windows 95</code>的通配符.</p>
<ul>
<li><code>*</code>表示一个任意字符的序列.</li>
<li><code>?</code>意味着任何字符.</li>
</ul>
<blockquote>
<p><code>7-Zip</code>不使用系统的通配符解析器.
<code>7-Zip</code>不遵循古老的规则, 也就是<code>*.*</code>表示任何文件. <code>7-Zip</code>将<code>*.*</code>视为任何有扩展名的文件名. 要处理所有的文件, 你必须使用单个<code>*</code>通配符.
举例来说:</p>
</blockquote>
<p><code>*.txt</code>表示所有扩展名为<code>.txt</code>的文件.
<code>?a*</code>表示所有第二个字符为<code>a</code>的文件
<code>*1*</code>表示所有包含字符<code>1</code>的名字
<code>*.*.*</code>表示所有包含两个至少<code>.</code>字符的名称.</p>
<p>如果命令行中没有<code>文件名</code>/<code>通配符</code>, 将使用默认通配符<code>*</code>.
路径末尾的斜杠<code>\</code>表示一个目录. 如果路径末尾没有斜杠<code>\</code>, 路径可以指一个文件或一个目录.</p>
<ul>
<li>列出文件</li>
</ul>
<p>你可以为特殊的列表文件(包含文件列表的文件)提供一个或多个文件名或通配符. 这种列表文件中的文件名必须用换行符号分开.
对于列表文件, <code>7-Zip</code>默认使用<code>UTF-8</code>编码. 你可以使用 <code>-scs</code> 开关改变编码. 支持多个列表文件.
例如, 如果文件 <code>listfile.txt</code> 包含以下内容.</p>
<pre><code>My programs\*.cpp
Src\*.cpp
</code></pre>
<p>那么命令</p>
<pre><code class="language-bash">7z a -tzip archive.zip @listfile.txt
</code></pre>
<p>将 <code>My programs</code> 和 <code>Src</code> 目录下的所有 <code>*.cpp</code> 文件添加到<code>archive.zip</code>中.</p>
<ul>
<li>短和长的文件名; <code>7-Zip</code>在某些情况下支持短文件名(如<code>FILENA~1.TXT</code>). 然而, 我们强烈建议只使用真正的(长)文件名.</li>
</ul>
<h2 id="查看和安装字体"><a class="header" href="#查看和安装字体">查看和安装字体</a></h2>
<p><code>fc-list</code>: 列出系统中可用的字体</p>
<pre><code class="language-bash"># 语法
fc-list [ -vVh ]  [ pattern  [ element... ]   ]
# 例如列出所有中文字体, :lang=zh  代表匹配模式
fc-list :lang=zh
</code></pre>
<h3 id="安装字体"><a class="header" href="#安装字体">安装字体</a></h3>
<p><a href="https://www.jianshu.com/p/e7f12b8c8602">x-org 系统字体命令和字体的安装</a></p>
<p>字体有<code>.ttf格</code>式(truetype font)和<code>.otf</code>格式(opentype font)字体</p>
<p>如果系统中没有中文字体,需要先行安装中文字体,在<code>Ubuntu</code>和<code>Cent OS</code>中的安装步骤如下:</p>
<ul>
<li>从网络上下载字体或者直接从其他计算机(windows)上拷贝</li>
<li>建立<code>/usr/share/fonts/myfonts</code> 目录</li>
<li><code>cd /usr/share/fonts/</code></li>
</ul>
<p>在<code>/etc/fonts/conf.d</code>目录下,有字体配置文件的符号链接</p>
<p>如果<code>fonts/</code>目录不存在,则创建</p>
<pre><code class="language-bash">mkdir fonts
mkdir myfonts
</code></pre>
<p>把下载好的字体拷贝到<code>/usr/share/fonts/myfonts</code>目录下:</p>
<pre><code class="language-bash">sudo cp ~/myfonts/* /usr/share/fonts/myfonts/
# ~/myfonts/ 是保存字体的目录
</code></pre>
<ul>
<li>修改字体文件的权限,使root用户以外的用户也可以使用</li>
</ul>
<pre><code class="language-bash">cd /usr/share/fonts/
sudo chmod -R  755 myfonts/
</code></pre>
<p>(5) 建立字体缓存</p>
<pre><code class="language-bash">cd /usr/share/fonts/myfonts
sudo mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache -fv
</code></pre>
<pre><code class="language-bash">sudo mkfontscale
# 如果提示 mkfontscale: command not found
# 在Ubuntu下运行如下命令
# sudo apt-get install ttf-mscorefonts-installer
# 在cent os下运行如下命令
# yum install mkfontscale
sudo mkfontdir
sudo fc-cache -fv
# fc-cache - build font information cache files
# 如果提示 fc-cache: command not found
# 在Ubuntu下运行如下命令
# sudo apt-get install fontconfig
# 在cent os下运行如下命令
# yum install fontconfig
</code></pre>
<p>至此字体就安装成功了,如果需要安装其他字体,只需将字体拷贝到字体目录下,重新运行以上的命令即可.</p>
<h2 id="grep-过滤输出"><a class="header" href="#grep-过滤输出">grep 过滤输出</a></h2>
<ul>
<li><code>-n</code> 行号</li>
<li><code>-v</code>,<code>--invert-match</code> 匹配不符合</li>
<li><code>--color</code> 染色</li>
<li><code>-P</code> perl 拓展</li>
<li><code>-B</code> before 前输出</li>
<li><code>-A</code> after 后输出</li>
<li><code>-o</code> only 仅输出匹配字符</li>
<li><code>-i</code> <code>--ignore-case</code> 忽略大小写</li>
</ul>
<hr />
<p><code>-m NUM</code>, <code>--max-count=NUM</code> 输出的最大行: 在<code>NUM</code>行匹配的行之后停止读取文件.</p>
<p>如果输入来自于普通文件, 就输出<code>NUM</code>行匹配的结果. 之后<code>grep</code>将标准输入定位到最后一个匹配行后面, 不再处理后面的内容.
这使调用<code>grep</code>的程序可以继续搜索, 当<code>grep</code>停止之后, 它可以继续输出后面的文本.
当同时使用<code>-c</code>或<code>--count</code>选项时, <code>grep</code>不会输出大于<code>NUM</code>的计数.
当同时使用<code>-v</code>或<code>--invert-match</code>选项时, <code>grep</code>在输出<code>NUM</code>不匹配的行后停止.</p>
<p>example:</p>
<pre><code class="language-bash">grep -n --color -P -B 1 -A 6 &quot;(?:tex:\d+:|warning:)&quot; ./temp $tex_file&quot;.log&quot;
</code></pre>
<p><code>-e PATTERNS</code>, <code>--regexp=PATTERNS</code>: 使用<code>PATTERNS</code>作为模式.
此选项可以多次使用或与<code>-f</code>(<code>--file</code>)选项结合使用,搜索给定的所有模式. 此选项可用于保护以<code>-</code>开头的模式.</p>
<p><code>f FILE</code>, <code>--file=FILE</code>:从<code>FILE</code>中获取模式,每行一个.
如果此选项多次使用或与<code>-e</code>(<code>--regexp</code>)选项结合使用,则搜索给定的所有模式. 空文件包含零个模式,因此不匹配.</p>
<h2 id="文档格式转换"><a class="header" href="#文档格式转换">文档格式转换</a></h2>
<p>用 <code>pandoc</code></p>
<p><code>pandoc [options] [input-file]...</code></p>
<p><code>-f --from -t --to</code></p>
<p><code>--latex-engine=pdflatex|lualatex|xelatex</code></p>
<p>把markdown转换成<code>pdf</code></p>
<pre><code class="language-bash">pandoc -f markdown --latex-engine=xelatex -o output.pdf input.md
</code></pre>
<h2 id="挂载命令-mount"><a class="header" href="#挂载命令-mount">挂载命令 mount</a></h2>
<p><a href="https://www.cnblogs.com/sunshine-cat/p/7922193.html">linux挂载命令mount及U盘,移动硬盘的挂载</a>
<a href="https://blog.csdn.net/zhang_can/article/details/79714012">gpt格式的移动硬盘在Linux系统下挂载方法</a></p>
<ul>
<li>
<p><code>mount -l -t type</code> : <code>-l</code> 选项可以显示<code>label</code></p>
</li>
<li>
<p><code>findmnt [options] device|mountpoint</code>: 可以更清晰的显示文件系统</p>
</li>
<li>
<p><code>umount [-dflnrv] {directory|device}</code> : 卸载文件系统,应该通过给出文件目录来使用,<code>-l, --lazy</code>Lazy  unmount</p>
</li>
<li>
<p><code>fdisk</code> 查看磁盘列表</p>
</li>
</ul>
<pre><code class="language-bash">sudo fdisk -l
</code></pre>
<p>显示某个特定设备</p>
<pre><code class="language-bash">sudo fdisk -l /dev/sdb
</code></pre>
<p>首先查看所有已经 mount 的设备:</p>
<pre><code class="language-bash">mount [-l] [-t type]
</code></pre>
<p>显示如下信息</p>
<pre><code class="language-bash">root@kali:~# fdisk -l
...
Device     Boot     Start       End   Sectors   Size Id Type
/dev/sda1  *  2048 209719295 209717248   100G  7 HPFS/NTFS/exFAT
/dev/sda2       209719296 976773119 767053824 365.8G  f W95 Ext'd (LBA)
/dev/sda5       209721344 465575935 255854592   122G  7 HPFS/NTFS/exFAT
/dev/sda6       465577984 721432575 255854592   122G  7 HPFS/NTFS/exFAT
/dev/sda7       721434624 976773119 255338496 121.8G  7 HPFS/NTFS/exFAT
...
</code></pre>
<p><code>parted /dev/sdb print</code>  显示 sdb 的分区表</p>
<p>可以知道sdb2(135M to 6001G)为基本数据分区,格式为<code>NTFS</code></p>
<p>mount 命令的标准格式:</p>
<pre><code class="language-bash">mount -t type device dir
</code></pre>
<p>告诉 kernel attach the filesystem found on <code>device</code> (which is of type <code>type</code>) at the directory <code>dir</code>.  The option <code>-t type</code> is optional.</p>
<p>挂载到指定目录即可:</p>
<pre><code class="language-bash">sudo mount -t ntfs /dev/sda1 /home/6T
</code></pre>
<p>The option <code>-l</code> adds labels to this listing.</p>
<hr />
<p>弹出设备</p>
<pre><code class="language-bash">umount /dev/sda5
</code></pre>
<p>通过<code>df</code>可以查看设备挂载点</p>
<h2 id="u盘格式化-exfat"><a class="header" href="#u盘格式化-exfat">U盘格式化 exFAT</a></h2>
<p><a href="https://linux.cn/article-12294-1.html">将 USB 盘格式化为 exFAT</a></p>
<p>从 <code>Linux kernel 5.4</code>开始, <code>Linux</code> 内核本身中启用了 <code>exFAT</code> 文件系统支持.
检查正在运行的 <code>Linux</code> 内核版本: <code>uname -r</code>. 如果是内核 <code>5.4</code> 或更高版本, 那么应该没问题.
不然, 你必须启用<code>exFAT</code>支持. 在基于 <code>Ubuntu</code> 的发行版中, 你可以安装以下软件包:</p>
<pre><code class="language-bash">sudo apt install exfat-fuse exfat-utils
</code></pre>
<hr />
<p>方法 1: 使用 <code>GNOME 磁盘工具</code>将磁盘格式化为 <code>exFAT</code>.</p>
<p>使用<code>GNOME 磁盘</code> 格式化驱动器是一项简单的工作. 它预装在许多 Linux 发行版中.
插入外部 <code>USB</code> 盘. 在菜单中查找 <code>Disk</code>, 然后打开<code>GNOME 磁盘</code> 应用. 第一步, 选择要格式化的驱动器, 要使用 <code>exFAT</code>, 请选择 <code>其它</code>, 然后单击<code>下一步</code>.</p>
<hr />
<p>方法 2: 在 <code>Linux</code> 命令行中将磁盘格式化为 <code>exFAT</code>.</p>
<p>插入外部硬盘, 然后在终端中输入以下命令<code>sudo fdisk -l</code>.通过列出的磁盘大小信息找出<code>USB</code>的标记, 假设<code>/dev/sdc1</code>.
如果磁盘有多个分区, 想要管理, 可以使用<code>sudo fdisk /dev/sdc</code>进行分区的管理工作. 这里要输入<code>/dev/sdc</code>也就是整个<code>U</code>盘, 而不是<code>/dev/sdc1</code>.
进入交互式分区工具:</p>
<p><code>m</code>提示可用的命令列表.
<code>o</code>:创建新的<code>dos</code>分区表, <code>n</code>添加一个新的分区.
<code>t</code>:更改分区类型, <code>dos</code> 类型的分区表, 如果要和<code>windows</code>格式化一致, 为<code>HPFS/NTFS/exFAT</code>, 就输入<code>7</code>.
<code>w</code>:保存更改, <code>q</code>退出不保存更改.</p>
<p>在这里更改分区表保存后, 磁盘已经可用了. 如果保存原来的分区直接格式, 可以使用<code>mkfs.exfat</code>:</p>
<ul>
<li><code>mkfs.exfat</code>:格式化成<code>exfat</code>.</li>
<li><code>mkfs.fat</code>:格式化成<code>fat32</code>.</li>
</ul>
<p><code>man mkfs.exfat</code>会发现, <code>mkfs.exfat</code>的同义词<code>mkexfatfs</code>. 如果分区表是<code>MBR</code>类型的, 需要将文件系统类型设置为<code>0X07</code>(<code>NTFS/exFAT</code>), 否则其他操作系统可能会拒绝挂载.
仍然假设U盘分区为<code>/dev/sdc1</code>, 使用以下命令将它格式化为 <code>exfat</code>.</p>
<pre><code class="language-bash">sudo mkfs.exfat -i 0x07 -n udisk /dev/sdc1
</code></pre>
<p>将<code>/dev/sdc1</code> 替换为你的磁盘 <code>ID</code>. <code>udisk</code> 是你要为磁盘命名的名称. 可选地, 运行 <code>fsck</code> 检查<code>sudo fsck.exfat /dev/sdc1</code>, 以确保格式化正确, 享受 <code>exFAT</code> 盘吧.</p>
<h2 id="查看文档首行末行"><a class="header" href="#查看文档首行末行">查看文档首行末行</a></h2>
<p>文档尾巴, <code>tail -n, --lines=[+]NUM</code>, 从第<code>num</code>行开始.
文档开头, <code>head -n, --lines=[-]NUM</code>, 减去最后<code>num</code>行.</p>
<h2 id="查看使用的桌面环境-x11-wayland"><a class="header" href="#查看使用的桌面环境-x11-wayland">查看使用的桌面环境 x11 wayland</a></h2>
<p><a href="https://linux.cn/article-12124-1.html">如何找出你所使用的桌面环境 </a></p>
<hr />
<p>检查你使用的是哪个桌面环境</p>
<p>你可以在<code>Linux</code>中使用 <code>echo</code> 命令在终端中显示 <code>XDG_CURRENT_DESKTOP</code> 变量的值.</p>
<pre><code class="language-bash">echo $XDG_CURRENT_DESKTOP
echo $XDG_SESSION_TYPE
</code></pre>
<p>或者使用<code>loginctl</code>得到<code>&lt;SESSION_ID&gt;</code>, 然后使用下列命令查看会话的类型:</p>
<pre><code class="language-bash">loginctl show-session &lt;SESSION_ID&gt; -p Type
</code></pre>
<hr />
<p>如何获取桌面环境版本</p>
<p>与获取桌面环境的名称不同.获取其版本号的方法并不直接,因为它没有标准的命令或环境变量可以提供此信息.
在 <code>Linux</code> 中获取桌面环境信息的一种方法是使用 <code>screenfetch</code>,<code>neofetch</code>之类的工具.
此命令行工具以 <code>ascii</code> 格式显示 <code>Linux</code> 发行版的 logo 以及一些基本的系统信息.桌面环境版本就是其中之一.
安装:<code>sudo apt install screenfetch</code>.</p>
<p>对于其他 Linux 发行版,请使用系统的软件包管理器来安装此程序.
安装后,只需在终端中输入 <code>screenfetch</code> 即可,它应该显示桌面环境版本以及其他系统信息.</p>
<h2 id="查看-linux-系统信息"><a class="header" href="#查看-linux-系统信息">查看 linux 系统信息</a></h2>
<p>ref: <a href="https://itsfoss.com/find-which-kernel-version-is-running-in-ubuntu/">3 Ways to Check Linux Kernel Version in Command Line</a></p>
<hr />
<p>uname</p>
<p><code>inxi -S</code>: 命令行系统信息脚本 for 终端和 IRC(InternetRelayChat)
<code>uname</code> -打印系统信息
<code>uname -r</code>命令的输出为:<code>5.4.0-48-generic</code></p>
<p>这意味着您正在运行Linux内核<code>5.4.0-48</code>,或更笼统地说,您正在运行Linux内核版本<code>5.4</code>.</p>
<p>但是其他数字在这里意味着什么?</p>
<ul>
<li><code>5</code> – 内核版本</li>
<li><code>4</code> – 重大修订</li>
<li><code>0</code> – 次要修订</li>
<li><code>48</code>– Bug fix</li>
<li><code>generic</code>–特定于发行版的字符串.对于Ubuntu,这表示我使用的是<code>desktop</code>版本.
对于Ubuntu服务器版本,它将是<code>server</code></li>
</ul>
<p>使用<code>-a</code>选项可以输出更多信息
<code>uname -a</code></p>
<p>命令的输出应如下所示:
<code>Linux OP7050 5.4.0-48-generic #52-Ubuntu SMP Thu Sep 10 10:58:49 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</code></p>
<p>让我解释一下输出及其含义:</p>
<ul>
<li><code>Linux</code> –内核名称. 如果在BSD或macOS上运行相同的命令,结果将有所不同.</li>
<li><code>OP7050</code> –主机名.</li>
<li><code>5.4.0-48-generic</code> –内核版本(如我们在上面看到的).</li>
<li><code>52-Ubuntu SMP Thu Sep 10 10:58:49 UTC 2020</code> –这意味着Ubuntu已编译<code>5.4.0-48-generic</code> <code>52</code>次. 最后一次编译的时间戳也在那里.</li>
<li><code>x86_64</code> –机器架构.</li>
<li><code>x86_64</code> –处理器架构.</li>
<li><code>x86_64</code> –操作系统体系结构(您可以在64位处理器上运行32位OS).</li>
<li><code>GNU / Linux</code> –操作系统(它不会显示发行版名称).</li>
</ul>
<p>让我们看看其他一些命令来查找您的Linux内核版本.</p>
<hr />
<p>使用<code>/proc/version file</code></p>
<p>在Linux中,您还可以在文件<code>/proc/version</code>中找到内核信息. 只需查看此文件的内容即可:</p>
<p><code>cat /proc/version</code></p>
<p>在命令行中检查Linux内核版本, 您会看到类似于uname的输出.</p>
<p><code>Linux version 5.4.0-48-generic (buildd@lcy01-amd64-010) (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)) #52-Ubuntu SMP Thu Sep 10 10:58:49 UTC 2020</code></p>
<p>您可以在此处看到内核版本<code>5.4.0-48-generic</code>.</p>
<hr />
<p>使用<code>dmesg</code></p>
<p><a href="https://www.runoob.com/linux/linux-comm-dmesg.html">Linux dmesg命令</a></p>
<p>dmesg是用于编写内核消息的强大命令.这对于获取系统信息也非常有用.<code>dmesg</code>命令用于显示开机信息.
<code>kernel</code>会将开机信息存储在<code>ring buffer</code>中.您若是开机时来不及查看信息,可利用dmesg来查看.开机信息亦保存在<code>/var/log</code>目录中,名称为<code>dmesg</code>的文件里.</p>
<p>由于<code>dmesg</code>提供了很多信息,使用<code>grep</code>挑选.</p>
<pre><code class="language-bash">dmesg | grep Linux
</code></pre>
<p>输出将包含几行,但是您应该能够在其中轻松识别Linux内核版本.</p>
<pre><code class="language-bash">[    0.000000] Linux version 5.4.0-48-generic (buildd@lcy01-amd64-010) (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)) #52-Ubuntu SMP Thu Sep 10 10:58:49 UTC 2020 (Ubuntu 5.4.0-48.52-generic 5.4.60)
...
[   12.936690] Intel(R) Wireless WiFi driver for Linux
</code></pre>
<h2 id="curl-wget"><a class="header" href="#curl-wget">curl wget</a></h2>
<p>curl -fsSL https://www.preining.info/rsa.asc | tlmgr key add -</p>
<p><code>-f, --fail</code>
(HTTP)服务器错误时<code>静默失败</code>(没有输出).  这样做主要是为了, 使脚本等更好地处理失败的尝试.
在正常情况下, 当<code>HTTP</code>服务器无法交付文档时, 它将返回<code>HTML文档</code>, 说明(通常还会描述原因及更多).
该<code>flag</code>将阻止<code>curl</code>输出该错误并返回<code>error 22</code>.</p>
<p>此方法不是<code>fail-safe</code>的, 并且有时会漏入不成功的响应代码, 尤其是在涉及验证时(response codes 401 and 407).</p>
<p><code>-s, --silent</code></p>
<p>静音或安静模式.  不显示进度表或错误消息.  使<code>Curl</code>静音.  仍会输出您要求的数据, 甚至到终端/标准输出, 除非您将其重定向.
除此选项外, 还可以使用<code>-S</code>, <code>--show-error</code>禁用进度表, 但仍显示错误消息.
另请参见<code>-v</code>, <code>--verbose</code> and <code>--stderr</code>.</p>
<p><code>-S, --show-error</code>
与<code>-s</code>, <code>--silent</code>一起使用时, 如果<code>curl</code>失败, 它将使<code>curl</code>显示一条错误消息.</p>
<p><code>-L, --location</code></p>
<p>(HTTP)如果服务器报告请求的页面已移动到其他位置(由<code>Location:  header</code>  and  a <code>3XX</code>响应代码), 此选项将使<code>curl</code>在新位置上重做请求.
如果与<code>-i</code>, <code>--include</code>或<code>-l</code>,<code>--head</code>一起使用, 将显示所有请求页面的<code>headers</code>. 使用身份验证时, curl仅将其凭据发送到初始主机.
如果重定向将curl转移到其他主机, 它无法截获<code>user+password</code>.
另请参阅<code>--location-trusted</code>查看如何修改这项设置.
您可以使用<code>--max-redirs</code>选项来限制要遵循的重定向数量.</p>
<p>当curl跟随重定向并且请求不是简单的<code>GET</code>(例如<code>POST</code>或<code>PUT</code>)时, it will do the following request with a GET:
如果<code>HTTP</code>响应是<code>301</code>, <code>302</code>或<code>303</code>. 如果响应代码是任何其他<code>3xx</code>代码, curl will resend the following request using the same unmodified method.</p>
<p>您可以通过使用专用的选项<code>--post301,</code> <code>--post302</code> and <code>--post303</code>, 来告诉curl 对于<code>30x</code>response, 不要将 <code>non-GET</code> request method 更改为<code>GET</code>.</p>
<h2 id="查看ip地址"><a class="header" href="#查看ip地址">查看ip地址</a></h2>
<p>使用<code>ip</code>命令</p>
<pre><code class="language-bash">ip addr show
ip link show #查看 MAC 地址
</code></pre>
<h2 id="安装额外解码器"><a class="header" href="#安装额外解码器">安装额外解码器</a></h2>
<p>如果你刚刚安装了 Ubuntu 或其他 Ubuntu 特色版本 如 Kubuntu,Lubuntu 等,你会注意到系统无法播放某些音频或视频文件.</p>
<p>对于视频文件,你可以在 Ubuntu 上安装 <code>VLC</code>.<code>VLC</code> 是 Linux 上的最佳视频播放器之一,它几乎可以播放任何视频文件格式.但你仍然会遇到无法播放音频和 <code>flash</code> 的麻烦.</p>
<p>好消息是 Ubuntu 提供了一个软件包来安装所有基本的媒体编解码器:<code>ubuntu-restricted-extras</code>.</p>
<p>ubuntu-restricted-extras 是一个包含各种基本软件,如 <code>Flash</code> 插件,<code>unrar</code> ,<code>gstreamer</code>,<code>mp4</code>,<code>Ubuntu</code> 中的 <code>Chromium</code> 浏览器的编解码器等的软件包.</p>
<p>由于这些软件不是开源软件,并且其中一些涉及软件专利,因此 Ubuntu 默认情况下不会安装它们.你必须使用 <code>multiverse</code> 仓库,它是 Ubuntu 专门为用户提供非开源软件而创建的仓库.</p>
<p>由于 <code>ubuntu-restrcited-extras</code> 软件包在 <code>multiverse</code> 仓库中,因此你应验证系统上已启用 <code>multiverse</code> 仓库:</p>
<pre><code class="language-bash">sudo add-apt-repository multiverse
</code></pre>
<p>然后你可以使用以下命令安装:</p>
<pre><code class="language-bash">sudo apt install ubuntu-restricted-extras
</code></pre>
<p><a href="https://itsfoss.com/ubuntu-repositories/">What are Ubuntu Repositories</a>
<a href="https://linux.cn/article-11906-1.html">一条命令在 Ubuntu 中安装所有基本的媒体编解码器 </a></p>
<h2 id="source-命令"><a class="header" href="#source-命令">source 命令</a></h2>
<p><a href="http://www.xitongzhijia.net/xtjc/20150714/52870.html">Ubuntu如何使用source命令执行文件</a></p>
<p><code>Ubuntu source</code> 命令的作用就是将设置在文件中的配置信息马上生效,而不需要经过重启.</p>
<p>Ubuntu如何使用<code>source</code>命令执行文件</p>
<p>source命令用法:
<code>source filename</code> 或 <code>. filename</code></p>
<p>在对编译系统核心时常常需要输入一长串的命令,如:</p>
<pre><code class="language-bash">make mrproper
make menuconfig
make dep
make clean
make bzImage
......
</code></pre>
<p>如果把这些命令做成一个文件,让它自动顺序执行,对于需要多次反复编译系统核心的用户来说会很方便,
而用source命令就可以做到这一点,
它的作用就是把一个文件的内容当成shell来执行,先在linux的源代码目录下(如<code>/usr/src/linux-2.4.20</code>)建立一个文件,如<code>make_command</code>,在其中输入一下内容:</p>
<pre><code class="language-bash">make mrproper &amp;&amp;
make menuconfig &amp;&amp;
make dep &amp;&amp;
make clean &amp;&amp;
...
</code></pre>
<p>文件建立好之后,每次编译核心的时候,只需要在<code>/usr/src/linux-2.4.20</code>下输入:<code>source make_command</code>即可</p>
<p>顺便补充一点,<code>&amp;&amp;</code>命令表示顺序执行由它连接的命令,但是只有它之前的命令成功执行完成了之后才可以继续执行它后面的命令.</p>
<p>另外执行source命令时如果提示command not found,是因为环境变量没配置好的原因,在终端运行如下命令即可修复:</p>
<p><code>export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</code></p>
<h2 id="查看磁盘空间"><a class="header" href="#查看磁盘空间">查看磁盘空间</a></h2>
<p><code>df</code>命令是linux系统以磁盘分区为单位查看文件系统,可以加上参数查看磁盘剩余空间信息,命令格式:</p>
<p><code>df - report file system disk space usage</code></p>
<hr />
<p>SYNOPSIS</p>
<p><code>df [OPTION]... [FILE]...</code></p>
<ul>
<li><code>-a</code>, <code>--all</code> include pseudo, duplicate, inaccessible file systems</li>
<li><code>-l</code>, <code>--local</code> limit listing to local file systems</li>
<li><code>-h</code>, <code>--human-readable</code> print sizes in powers of 1024 (e.g., 1023M)</li>
<li><code>-T</code>, <code>--print-type</code> print file system type</li>
</ul>
<h2 id="find-过滤文件"><a class="header" href="#find-过滤文件">find 过滤文件</a></h2>
<p>删除日志文件</p>
<pre><code class="language-bash">sudo /dev/null &gt; /var/log/**.log
</code></pre>
<p>下面这个推荐使用,删除30天之前的旧文件</p>
<pre><code class="language-bash">sudo find /var/log/ -type f -mtime +30 -exec rm -f {} \;
</code></pre>
<hr />
<p><code>find</code> - search for files in a directory hierarchy</p>
<p><code>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]</code></p>
<hr />
<p><code>expression</code></p>
<p><code>starting points</code>列表之后的部分是<code>表达式</code>.  这是一种查询规范, 描述了我们如何匹配文件以及如何处理匹配的文件.
表达式由一系列事物组成:<code>Test</code>, <code>Actions</code>,...</p>
<hr />
<p><code>-exec command ;</code></p>
<p>执行命令;  如果返回<code>0</code>状态, 则为<code>true</code>.  之后传递给<code>find</code>的参数都将作为命令的参数, 直到遇到<code>;</code>为止.
字符<code> {}</code>被替换为当前文件名命令参数中出现的任何地方的当前文件名, 而不仅仅是在单独存在的参数中.
这两种构造都可能需要转义(以<code>\</code>表示)或加引号以保护它们, 避免 shell 展开.
有关使用<code>-exec</code>选项的示例, 请参见示例部分. 对每个匹配的文件运行一次指定的命令.
该命令在起始目录中执行.  与<code>-exec</code>有关的操作具有不可避免的安全问题;  你应该使用<code>-execdir</code>选项代替.</p>
<hr />
<p><code>-exec command {} +</code></p>
<p>在选定的文件上运行指定的命令, <code>-exec</code> action的变体. 但是通过在命令结尾附加上每个选中的文件名;
该命令的调用总数将远远少于匹配文件的数目.  命令行的构建方式与<code>xargs</code>几乎相同.
命令中仅允许使用一个<code>{}</code>实例, 并且当从<code>shell</code>调用<code>find</code>时,应该用引号保护起来, 例如<code>'{}'</code>, 以防止其被<code>shell</code>解释.
该命令在起始目录中执行.  如果有任何调用返回一个非零值作为退出状态, 则<code>find</code>返回一个非零退出状态.
如果<code>find</code>遇到错误, 有时可能会导致立即退出, 因此一些待处理的命令可能根本不会运行. This variant of <code>-exec</code> always returns <code>true</code>.</p>
<hr />
<p><code>-mtime n</code>
文件数据的最后修改时间为 <code>n*24</code> 小时. 请参阅<code>-atime</code>的注释, 以了解舍入如何影响文件修改时间的解释</p>
<p><code>-type c</code>
File is of type c:</p>
<ul>
<li><code>b</code>  block (buffered) special</li>
<li><code>c</code>  character (unbuffered) special</li>
<li><code>d</code>  directory</li>
<li><code>p</code>  named pipe (FIFO)</li>
<li><code>f</code>  regular file</li>
</ul>
<h2 id="查看文件大小"><a class="header" href="#查看文件大小">查看文件大小</a></h2>
<p><a href="https://blog.csdn.net/BigData_Mining/java/article/details/88998472">Ubuntu下查看文件, 文件夹和磁盘空间的大小</a></p>
<p>在实际使用<code>ubuntu</code>时候,经常要碰到需要查看文件以及文件夹大小的情况.
有时候,自己创建压缩文件,可以使用 <code>ls -hl</code>查看文件大小.参数<code>-h</code> 表示<code>Human-Readable</code>,使用<code>GB</code>,<code>MB</code>等易读的格式方式显示.对于文件夹的大小,<code>ll -h</code> 显示只有<code>4k</code>.</p>
<hr />
<p>那么如何来查看文件夹的大小呢?</p>
<p>使用<code>du</code>命令查看文件或文件夹的磁盘使用空间,<code>–max-depth</code> 用于指定深入目录的层数.</p>
<p>如要查看当前目录已经使用总大小及当前目录下一级文件或文件夹各自使用的总空间大小,
输入<code>du -h --max-depth=1</code>即可.</p>
<p>如要查看当前目录已使用总大小可输入:<code>du -h --max-depth=0</code></p>
<hr />
<pre><code class="language-bash">du [OPTION]... [FILE]...
du [OPTION]... --files0-from=F
</code></pre>
<ul>
<li><code>-s,</code> <code>--summarize</code>: 对每个参数仅显示总计</li>
<li><code> -h</code>, <code>--human-readable</code>: 以人类可读的格式显示大小(例如<code>1K</code> <code>234M</code> <code>2G</code>)</li>
<li><code>-d,</code> <code>--max-depth=N</code>: 指定目录递归的层数;  <code>--max-depth = 0</code>与<code>--summaryize</code>相同</li>
<li><code>--si</code>   like <code>-h</code>, 但是使用<code>1000</code>的幂而不是<code>1024</code>的幂</li>
<li><code>-a,</code> <code>--all</code> :给出所有文件的统计, 而不仅仅是目录</li>
</ul>
<h2 id="创建链接"><a class="header" href="#创建链接">创建链接</a></h2>
<p><code>ln</code> — 创建链接</p>
<p><code>ln</code> 命令即可创建硬链接,也可以创建符号链接.</p>
<p>可以用其中一种方法来使用它:</p>
<ul>
<li><code>ln file link</code> 创建硬链接</li>
<li><code>ln -s item link</code> 创建符号链接,<code>item</code> 可以是一个文件或是一个目录.</li>
</ul>
<h3 id="硬链接"><a class="header" href="#硬链接">硬链接</a></h3>
<p>硬链接和符号链接比起来,硬链接是最初 <code>Unix</code> 创建链接的方式,而符号链接更加现代. 在默认情况下,每个文
件有一个硬链接,这个硬链接给文件起名字.
当我们创建一个 硬链接以后,就为文件创建了一个额外的目录条目.硬链接有两个重要局限性:</p>
<ol>
<li>一个硬链接不能关联它所在文件系统之外的文件.这是说一个链接不能关联 与链接本身不在同一个磁盘分区
上的文件.</li>
<li>一个硬链接不能关联一个目录.</li>
</ol>
<p>一个硬链接和文件本身没有什么区别.不像符号链接,当你列出一个包含硬链接的目录 内容时,你会看到没有特
殊的链接指示说明.当一个硬链接被删除时,这个链接 被删除,但是文件本身的内容仍然存在(这是说,它所占
的磁盘空间不会被重新分配), 直到所有关联这个文件的链接都删除掉.知道硬链接很重要,因为你可能有时
会遇到它们,但现在实际中更喜欢使用符号链接,下一步我们会讨论符号链接.</p>
<h3 id="符号链接"><a class="header" href="#符号链接">符号链接</a></h3>
<p>创建符号链接是为了克服硬链接的局限性.
符号链接生效,是通过创建一个特殊类型的文件,这个文件包含一个关联文件或目录的文本指针.
在这一方面, 它们和 Windows 的快捷方式差不多,当然,符号链接早于Windows 的快捷方式 很多年;-)</p>
<p>一个符号链接指向一个文件,而且这个符号链接本身与其它的符号链接几乎没有区别.
例如,如果你往一个符号链接里面写入东西,那么相关联的文件也被写入.</p>
<p>然而, 当你删除一个符号链接时,只有这个链接被删除,而不是文件自身.
如果先于符号链接删除文件,这个链接仍然存在,但是不指向任何东西.
在这种情况下,这个链接被称为坏链接.
在许多实现中,<code>ls</code> 命令会以不同的颜色展示坏链接,比如说红色,来显示它们的存在.</p>
<hr />
<p>创建硬链接</p>
<p>现在,我们试着创建链接.首先是硬链接.我们创建一些关联我们 数据文件的链接:</p>
<pre><code class="language-bash">[me@linuxbox playground]$ ln fun fun-hard
[me@linuxbox playground]$ ln fun dir1/fun-hard
[me@linuxbox playground]$ ln fun dir2/fun-hard
</code></pre>
<p><code>ls</code> 命令有一种方法,来展示(文件索引节点)的信息.在命令中加上<code>-i</code>选项:</p>
<hr />
<p>创建符号链接</p>
<p>建立符号链接的目的是为了克服硬链接的两个缺点:硬链接不能跨越物理设备, 硬链接不能关联目录,只能是文
件.符号链接是文件的特殊类型,它包含一个指向 目标文件或目录的文本指针.</p>
<p>符号链接的建立过程相似于创建硬链接:</p>
<pre><code class="language-bash">[me@linuxbox playground]$ ln -s fun fun-sym
[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym
</code></pre>
<p>第一个实例相当直接,在 ln 命令中,简单地加上<code>-s</code>选项就可以创建一个符号链接, 而不是一个硬链接.</p>
<p><code>fun-sym</code> 的列表说明了它是一个符号链接,通过在第一字段中的首字符<code>l</code> 可知,并且它还指向<code>../fun</code>,也是正确的.</p>
<p>当建立符号链接时,你即可以使用绝对路径名:</p>
<pre><code class="language-bash">ln -s /home/me/playground/fun dir1/fun-sym
</code></pre>
<p>也可用相对路径名,正如前面例题所展示的.使用相对路径名更令人满意, 因为它允许一个包含符号链接的目录重命名或移动,而不会破坏链接.</p>
<h2 id="basename"><a class="header" href="#basename">basename</a></h2>
<hr />
<p>截取文件名和后缀</p>
<p>编写Shell脚本的过程中,经常会和文件名和文件路径打交道.
如果用户输入了一个文件的全名(可能包含绝对路径和文件后缀),如何得到文件的路径名,文件名,文件后缀这些信息呢.
Shell脚本拥有强大的字符串处理能力,如果把文件名当做字符串,我们不难使用<code>cut</code>或<code>sed</code>这样的工具得到我们想要的结果.</p>
<pre><code class="language-bash">$fullfile=/the/path/foo.txt
$fullname=$(basename $fullfile)
$dir=$(dirname $fullfile)
$filename=$(echo $fullname | cut -d . -f1)
$extension=$(echo $fullname | cut -d . -f2)
$ echo $dir , $fullname , $filename , $extension
/the/path , foo.txt , foo , txt
</code></pre>
<p>这里使用<code>basename</code>命令可以直接得到包含后缀的文件名,而<code>dirname</code>命令可以得到路径名,
然后就能简单的用<code>cut</code>截取文件名和后缀名.</p>
<hr />
<p>更复杂的情况</p>
<p>如果对付简单应用场景,到这里已经可以打完收工了,但是有时候文件可能不止有一个后缀,比如<code>*.tar.gz</code>,怎样得到最后一个后缀呢?
再<code>cut</code>一回? 当然可以,但是如果文件名是<code>mylib.1.0.1a.zip</code>这样的呢? 呃......正则表达式肯定可以.</p>
<pre><code class="language-bash">$ fullname=mylib.1.0.1a.zip
$ filename=$(echo $fullname | sed 's/\.[^.]*$//')
$ extension=$(echo $fullname | sed 's/^.*\.//')
$ echo $filename, $extension
mylib.1.0.1a, zip
</code></pre>
<p>这里面的逻辑是这样的:</p>
<p>文件名:把以<code>.</code>字符开头以后一直到行尾都是非<code>.</code>字符的子串替换为空.
后缀名:把从行首开始以<code>.</code>字符结尾的子串替换为空.</p>
<p>光用语言把这两个正则表达式描述出来脑细胞也要死不少.有没有像上面<code>cut</code>版本一样简单容易理解的方法呢?
由于<code>.</code>分隔符的个数不确定,正常使用<code>cut</code>来分割最后一个<code>.</code>字符是不太可能的.
但是我们可使用<code>rev</code>命令将字符串反转一下,区分后缀和文件名的<code>.</code>字符位置就确定了.
截取了想要的部分之后,再次反转就得到了我们想要的内容.</p>
<pre><code class="language-bash">$ fullname=mylib.1.0.1a.zip
$ filename=$(rev &lt;&lt;&lt; $fullname | cut -d . -f2- | rev)
$ extension=$(rev &lt;&lt;&lt; $fullname | cut -d . -f1 | rev)
$ echo $filename, $extension
mylib.1.0.1a, zip
</code></pre>
<hr />
<p>使用参数扩展</p>
<p>其实不借助复杂的正则表达式,甚至不调用<code>basename</code>, <code>dirname</code>, <code>cut</code>, <code>sed</code>命令,<code>shel</code>l脚本一样可以做到所有的操作.
看下面的实现:</p>
<pre><code class="language-bash">$ fullfile=/the/path/mylib.1.0.1a.zip
$ fullname=&quot;${fullfile##*/}&quot;
$ dir=&quot;${fullfile%/*}&quot;
$ extension=&quot;${fullname##*.}&quot;
$ filename=&quot;${fullname%.*}&quot;
$ echo $dir , $fullname , $filename , $extension
/the/path , mylib.1.0.1a.zip , mylib.1.0.1a , zip
</code></pre>
<p>真是不能再简洁了,大括号之内变量名配合几个神奇的字符,就是Shell的参数扩展(Parameter Extension)功能.</p>
<ul>
<li><code>${fullfile##*/}</code>:从前面开始删除<code>fullfile</code>中最大匹配(longest matching pattern) <code>*/</code> 的字符串</li>
<li><code>${fullfile%/*}</code>:从后面开始删除<code>fullfile</code>中最小匹配(shortest matching pattern) <code>/*</code> 的字符串</li>
<li><code>${fullname##*.}</code>:从前面开始删除<code>fullname</code>中最大匹配(longest matching pattern) <code>*.</code> 的字符串</li>
<li><code>${fullname%.*}</code>:从后面开始删除<code>fullname</code>中最小匹配(shortest matching pattern) <code>.*</code> 的字符串</li>
</ul>
<p>参数扩展有多种形式,在shell编程中可以用作参数的拼接,字符串的替换,参数列表截取,变量初值等操作,
这里不再详述,请参考后面的功能列表和官方文档</p>
<hr />
<p>使用<code>basename</code>命令输出所有<code>*.tex</code>的名字</p>
<pre><code class="language-bash">basename -s '.tex' $(ls *.tex) | xargs echo
</code></pre>
<h2 id="inode"><a class="header" href="#inode">inode</a></h2>
<p><a href="https://www.cnblogs.com/itech/archive/2012/05/15/2502284.html">Linux的inode的理解</a></p>
<hr />
<p>inode是什么</p>
<p>理解<code>inode</code>,要从文件储存说起.
文件储存在硬盘上,硬盘的最小存储单位叫做<code>扇区</code>(Sector).每个扇区储存<code>512</code>Byte(相当于<code>0.5KB</code>).
操作系统读取硬盘的时候,不会一个个扇区地读取,这样效率太低,而是一次性连续读取多个扇区,即一次性读取一个&quot;块&quot;(<code>block</code>).
这种由多个扇区组成的<code>块</code>,是文件存取的最小单位.<code>块</code>的大小,最常见的是<code>4KB</code>,即连续八个 <code>sector</code>组成一个 <code>block</code>.</p>
<p>文件数据都储存在<code>块</code>中,那么很显然,我们还必须找到一个地方储存文件的元信息,比如文件的创建者, 文件的创建日期, 文件的大小等等.
这种储存文件元信息的区域就叫做<code>inode</code>,中文译名为<code>索引节点</code>, <code>index node</code>.</p>
<hr />
<p>inode的内容</p>
<p><code>inode</code>包含文件的元信息,具体来说有以下内容:</p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的User ID</li>
<li>文件的Group ID</li>
<li>文件的读, 写, 执行权限</li>
<li>文件的时间戳,共有三个:<code>ctime</code> 指 <code>inode</code> 上一次变动的时间, <code>mtime</code> 指文件内容上一次变动的时间, <code>atime</code> 指文件上一次打开的时间.</li>
<li>链接数,即有多少文件名指向这个 <code>inode</code></li>
<li>文件数据<code>block</code>的位置</li>
</ul>
<p>可以用<code>stat</code>命令,查看某个文件的<code>inode</code>信息:</p>
<pre><code class="language-bash">stat example.txt
</code></pre>
<p>总之,除了文件名以外的所有文件信息,都存在<code>inode</code>之中.至于为什么没有文件名,下文会有详细解释.</p>
<hr />
<p>inode的大小</p>
<p><code>inode</code>也会消耗硬盘空间,所以硬盘格式化的时候,操作系统自动将硬盘分成两个区域.一个是数据区,存放文件数据; 另一个是<code>inode</code>区(<code>inode table</code>),存放<code>inode</code>所包含的信息.
每个<code>inode</code>节点的大小,一般是<code>128</code>字节或<code>256</code>字节.
<code>inode</code>节点的总数,在格式化时就给定,一般是每1KB或每2KB就设置一个<code>inode</code>.
假定在一块1GB的硬盘中,每个<code>inode</code>节点的大小为128字节,每<code>1KB</code>就设置一个<code>inode</code>,那么<code>inode table</code>的大小就会达到<code>128MB</code>,占整块硬盘的<code>12.8%</code>.</p>
<p>查看每个硬盘分区的<code>inode</code>总数和已经使用的数量,可以使用<code>df</code>命令.</p>
<pre><code class="language-bash">df -i
</code></pre>
<p>查看每个<code>inode</code>节点的大小,可以用如下命令:</p>
<pre><code class="language-bash">sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;
</code></pre>
<p>由于每个文件都必须有一个<code>inode</code>,因此有可能发生<code>inode</code>已经用光,但是硬盘还未存满的情况.这时,就无法在硬盘上创建新文件.</p>
<hr />
<p>inode号码</p>
<p>每个<code>inode</code>都有一个号码,操作系统用<code>inode</code>号码来识别不同的文件.</p>
<p>这里值得重复一遍,<code>Unix/Linux</code>系统内部不使用文件名,而使用<code>inode</code>号码来识别文件.对于系统来说,文件名只是<code>inode</code>号码便于识别的别称或者绰号.
表面上,用户通过文件名,打开文件.实际上,系统内部这个过程分成三步:首先,系统找到这个文件名对应的<code>inode</code>号码; 其次,通过<code>inode</code>号码,获取<code>inode</code>信息;
最后,根据<code>inode</code>信息,找到文件数据所在的<code>block</code>,读出数据.</p>
<p>使用<code>ls -i</code>命令,可以看到文件名对应的<code>inode</code>号码:</p>
<pre><code class="language-bash">ls -i example.txt
</code></pre>
<hr />
<p>目录文件</p>
<p><code>Unix/Linux</code>系统中,目录(directory)也是一种文件.打开目录,实际上就是打开目录文件.</p>
<p>目录文件的结构非常简单,就是一系列目录项(<code>dirent</code>)的列表.每个目录项,由两部分组成: 所包含文件的文件名,以及该文件名对应的 <code>inode</code> 号码.</p>
<p><code>ls</code>命令只列出目录文件中的所有文件名:</p>
<pre><code class="language-bash">ls /etc
</code></pre>
<p>ls -i命令列出整个目录文件,即文件名和<code>inode</code>号码:</p>
<pre><code class="language-bash">ls -i /etc
</code></pre>
<p>如果要查看文件的详细信息,就必须根据<code>inode</code>号码,访问<code>inode</code>节点,读取信息.<code>ls -l</code>命令列出文件的详细信息.</p>
<pre><code class="language-bash">ls -l /etc
</code></pre>
<hr />
<p>硬链接</p>
<p>一般情况下,文件名和<code>inode</code>号码是&quot;一一对应&quot;关系,每个<code>inode</code>号码对应一个文件名.但是,Unix/Linux系统允许,多个文件名指向同一个<code>inode</code>号码.
这意味着,可以用不同的文件名访问同样的内容; 对文件内容进行修改,会影响到所有文件名; 但是,删除一个文件名,不影响另一个文件名的访问.这种情况就被称为&quot;硬链接&quot;(<code>hard link</code>).</p>
<p><code>ln</code>命令可以创建硬链接:</p>
<pre><code class="language-bash">ln 源文件 目标文件
</code></pre>
<p>运行上面这条命令以后,源文件与目标文件的inode号码相同,都指向同一个<code>inode</code>.<code>inode</code>信息中有一项叫做&quot;链接数&quot;,记录指向该<code>inode</code>的文件名总数,这时就会增加1.反过来,删除一个文件名,就会使得<code>inode</code>节点中的&quot;链接数&quot;减1.当这个值减到0,表明没有文件名指向这个<code>inode</code>,系统就会回收这个<code>inode</code>号码,以及其所对应<code>block</code>区域.</p>
<p>这里顺便说一下目录文件的&quot;链接数&quot;.创建目录时,默认会生成两个目录项:&quot;.&quot;和&quot;..&quot;.前者的<code>inode</code>号码就是当前目录的<code>inode</code>号码,等同于当前目录的&quot;硬链接&quot;; 后者的<code>inode</code>号码就是当前目录的父目录的<code>inode</code>号码,等同于父目录的&quot;硬链接&quot;.所以,任何一个目录的&quot;硬链接&quot;总数,总是等于<code>2</code>加上它的子目录总数(含隐藏目录),这里的<code>2</code>是父目录对其的&quot;硬链接&quot;和当前目录下的&quot;.硬链接&quot;.</p>
<hr />
<p>软链接</p>
<p>除了硬链接以外,还有一种特殊情况.文件<code>A</code>和文件<code>B</code>的<code>inode</code>号码虽然不一样,但是文件<code>A</code>的内容是文件<code>B</code>的路径.
读取文件<code>A</code>时,系统会自动将访问者导向文件<code>B</code>.因此,无论打开哪一个文件,最终读取的都是文件<code>B</code>.这时,文件<code>A</code>就称为文件<code>B</code>的&quot;软链接&quot;(soft link)或者&quot;符号链接(symbolic link).</p>
<p>这意味着,文件<code>A</code>依赖于文件<code>B</code>而存在,如果删除了文件<code>B</code>,打开文件<code>A</code>就会报错:&quot;No such file or directory&quot;.
这是软链接与硬链接最大的不同:文件<code>A</code>指向文件<code>B</code>的文件名,而不是文件<code>B</code>的<code>inode</code>号码,文件<code>B</code>的<code>inode</code>&quot;链接数&quot;不会因此发生变化.</p>
<p><code>ln -s</code>命令可以创建软链接.</p>
<pre><code class="language-bash">ln -s 源文文件或目录 目标文件或目录
</code></pre>
<hr />
<p>inode的特殊作用</p>
<p>由于<code>inode</code>号码与文件名分离,这种机制导致了一些<code>Unix/Linux</code>系统特有的现象.</p>
<ul>
<li>有时,文件名包含特殊字符,无法正常删除. 这时,直接删除<code>inode</code>节点,就能起到删除文件的作用.</li>
<li>移动文件或重命名文件,只是改变文件名,不影响<code>inode</code>号码.</li>
<li>打开一个文件以后,系统就以<code>inode</code>号码来识别这个文件,不再考虑文件名.因此,通常来说,系统无法从<code>inode</code>号码得知文件名.</li>
</ul>
<p>第<code>3</code>点使得软件更新变得简单,可以在不关闭软件的情况下进行更新,不需要重启.
因为系统通过<code>inode</code>号码,识别运行中的文件,不通过文件名.更新的时候,新版文件以同样的文件名,生成一个新的<code>inode</code>,不会影响到运行中的文件.
等到下一次运行这个软件的时候,文件名就自动指向新版文件,旧版文件的<code>inode</code>则被回收.</p>
<h2 id="shebang-脚本开头"><a class="header" href="#shebang-脚本开头">shebang 脚本开头</a></h2>
<p><a href="https://bash.cyberciti.biz/guide/Shebang">Shebang</a></p>
<p>大多数<code>Linux shell</code>和<code>perl</code>/<code>python</code>脚本以以下行开头:</p>
<pre><code class="language-bash">#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/python
#!/usr/bin/python3
#!/usr/bin/env bash
</code></pre>
<p>这称为<code>shebang</code>或<code>bang</code>行.</p>
<p><code>shebang</code>(意思为这一切)其实就是<code>Bash</code>解释器的绝对路径. 几乎所有的<code>bash</code>脚本通常都以<code>#!/bin/bash</code>开头(假设<code>Bash</code>已安装在<code>/bin</code>中).
这样可以确保即使在另一个<code>shell</code>下执行脚本, 也可以使用<code>Bash</code>来解释该脚本.
<code>Shebang</code>是由Dennis Ritchie在第7版和8版<code>Unix</code>之间在<code>Bell</code>实验室推出的.  然后, 它也被添加到Berkeley的<code>BSD</code>中.</p>
<p><code>/usr/bin/env</code>在修改后的环境中运行<code>bash</code>之类的程序.  它使您的<code>bash</code>脚本具有可移植性.
<code>#!/usr/bin/env bash</code>的优点是, 它将使用运行用户的<code>$PATH</code>变量中最先出现的<code>bash</code>可执行文件.</p>
<h2 id="日志文件"><a class="header" href="#日志文件">日志文件</a></h2>
<p><a href="https://www.php.cn/linux-435716.html">linux系统日志在哪? </a>
<a href="https://zhuanlan.zhihu.com/p/26428150">linux日志介绍</a></p>
<pre><code class="language-bash">sudo tail -f /var/log/messages
# or in ubuantu
sudo tail -f /var/log/kern.log
</code></pre>
<p><code>linux</code>日志大多是以明文存储, 一般存储在<code>/var/log</code>目录中, linux系统中主要有三个日志子系统: 连接时间日志, 进程统计日志, 错误日志.</p>
<ul>
<li><code>assess-log</code> 记录和<code>HTTP/web</code>的传输</li>
<li><code>secure</code> 记录登录系统存取资料的消息</li>
<li><code>btmp</code> 记录失败的消息</li>
<li><code>lastlog</code> 记录最近几次成功登录的事件和最后一次不成功的登录</li>
<li><code>messages</code>: 包括整体系统信息, 其中也包含系统启动期间的日志. 此外, 还包括<code>mail</code>, <code>cron</code>, <code>daemon</code>, <code>kern</code>和<code>auth</code>等内容</li>
<li><code>sudolog</code> 记录<code>sudo</code>发出的命令</li>
<li><code>sulog</code> 记录使用<code>su</code>命令的使用</li>
<li><code>utmp</code> 记录当前登录的每个用户</li>
<li><code>wtmp</code> 一个用户每次登录进入和退出的的永久记录</li>
<li><code>syslog</code>: 它和<code>/etc/log/messages</code>日志文件不同, 它只记录警告信息, 常常是系统出问题的信息.</li>
<li><code>xferlog</code> 记录了FTP会话</li>
<li><code>user.log</code>: 记录所有等级用户信息的日志.</li>
<li><code>auth.log</code>: 包含系统授权信息, 包括用户登录和使用的权限机制等.</li>
<li><code>daemon.log</code>: 包含各种系统后台守护进程日志信息.</li>
<li><code>kern.log</code>: 包含内核产生的日志, 有助于在定制内核时解决问题.</li>
</ul>
<p>连接时间日志是有多个程序执行的, 把日志记录到<code>/var/log/wtmp</code>, <code>/var/run/utmp</code>,<code>/var/log/lastlog</code> 三个文件中, 这三个文件记录了用户登录系统和退出的有关信息,
<code>utmp</code>保存了当前用户的每个用户的信息, <code>wtmp</code>记录了每个用户登录注销和系统的启动, 关机的事件, <code>lastlog</code>记录了每个用户最后登录的信息记录.</p>
<p><code>wtmp</code>和<code>utmp</code>文件都是二进制, 不能使用<code>cat</code>和<code>tail</code>命令查看, 但是可以使用<code>who</code>, <code>w</code>,<code>users</code>,<code>last</code> 等命令查看着两个文件的信息</p>
<hr />
<p><code>who [参数]</code></p>
<ul>
<li><code>-a</code> 显示全部信息</li>
<li><code>-m</code> 只显示当前终端的登录用户信息</li>
<li><code>-q</code> 只显示当前登录到系统中的用户名称和数量, 和其他参数共同使用的时候, 其他参数将被忽略</li>
</ul>
<hr />
<p><code>Systemd</code>统一管理所有 <code>Unit</code> 的启动日志. 带来的好处就是可以只用<code>journalctl</code>一个命令, 查看所有日志(内核日志和 应用日志).</p>
<p>语法格式:  <code>journalctl [参数]</code></p>
<ul>
<li><code>-k,--dmesg</code>: 查看内核日志</li>
<li><code>-b</code>:  查看系统本次启动的日志</li>
<li><code>-u</code>:  查看指定服务的日志</li>
<li><code>-n</code>:  指定日志条数</li>
<li><code>-f</code>:  追踪日志</li>
<li><code>--disk-usage</code>:  查看当前日志占用磁盘的空间的总大小</li>
</ul>
<p><code>-S, -since =, -U, -until =</code>
显示比指定日期更早或更晚的日志. 日期格式为<code>&quot;2012-10-30 18:17:16&quot;</code>.如果省略时间部分, 则假定为<code>00:00:00</code>.如果只有秒部分是省略, 则假定为<code>:00</code>.
如果省略日期部分, 则假定为当前日期.  也可以使用字符串<code>yesterday</code>, <code>&quot;today&quot;</code>, <code>&quot;tomorrow&quot;</code>.<code>now</code>是指当前时间.
是指当日, 当日或当日后一天的00:00:00. 最后, 可以用<code>-</code>或<code>+</code>为前缀指定相对时间. 有关完整的时间和日期规范, 请参见<code>systemd.time(7).</code>.
<code>--output=short-full</code>将完全按照此格式打印时间戳.</p>
<p><code>x, --catalog</code>:
用信息目录中的解释文本来增加日志行. 这将为输出中的日志信息添加解释性的帮助文本, 如果这是可用的.
这些简短的帮助文本将解释错误或日志事件的背景, 可能的解决方案, 以及指向支持论坛, 开发人员文档和任何其他相关手册的指针.
请注意, 帮助文本不是对所有的信息都可用, 而只是对选定的 的帮助文本. 关于消息目录的更多信息, 请参考消息目录开发者文档[5].</p>
<p>注意: 当把 <code>journalctl</code> 输出附加到错误报告时, 请不要使用 <code>-x</code>.</p>
<p><code>-e, --pager-end</code>:</p>
<p>立即跳到默认的分页工具的日志末尾. 这意味着<code>-n1000</code>, 以保证<code>pager</code>不会缓冲无限制大小的日志.
可以用一个明确的<code>-n数值</code>来覆盖, 而<code>-nall</code>将禁用这个上限. 注意, 这个选项只支持<code>less(1)</code>pager.</p>
<p>参考实例</p>
<ul>
<li>查看所有日志:  <code>journalctl</code></li>
<li>查看httpd的日志:  <code>journalctl -u httpd</code></li>
<li>查看最近发生的20条日志:  <code>journalctl -n 20</code></li>
<li>追踪日志:  <code>journalctl -f</code></li>
</ul>
<h2 id="linux-安装时的分区"><a class="header" href="#linux-安装时的分区">Linux 安装时的分区</a></h2>
<p><a href="https://wiki.archlinux.org/title/Parted_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#UEFI/GPT_%E7%A4%BA%E4%BE%8B">UEFI/GPT 示例</a>
<a href="https://manjaro.org/support/userguide/">manjaro_user_guide 也有分区的例子</a>
<a href="https://wiki.archlinux.org/title/Arch_boot_process_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8">Arch boot process</a></p>
<p>以<code>UEFI</code>主板为例, 参考<code>manjaro_user_guide</code>. 主要设置三个分区:</p>
<p>文件系统格式, 挂载点, 建议大小, <code>flags</code></p>
<ul>
<li><code>fat32</code>,<code>/boot/efi</code>,<code>512MiB</code>, <code>boot,esp</code>, <code>esp</code>即 <code>UEFI System Partition</code>, GPT 中它是<code>boot</code>的别名.</li>
<li><code>linuxswap</code>,不需要挂载, $\sqrt{\text{内存大小}} \sim 2* \text{内存大小}$</li>
<li><code>ext4</code>,<code>/</code>,最简单的, 可以把剩下空间全部分配给<code>/</code>,文件系统也可以选别的, 比如<code>Btrfs</code></li>
</ul>
<p>强迫症可以把分区调整成<code>EFI</code>,<code>root</code>,<code>swap</code>的顺序, 可能有玄学加成.</p>
<h2 id="交换分区-swap"><a class="header" href="#交换分区-swap">交换分区 swap</a></h2>
<p><a href="https://help.ubuntu.com/community/SwapFaq">ubnuntu SwapFaq</a></p>
<p>**
如果想要确认是否有<code>swap</code>分区, 使用<code>parted</code>查看所有分区</p>
<pre><code class="language-bash">sudo parted --list
</code></pre>
<p>如果有<code>swap</code>, 在输出中可以看到类似下面的内容</p>
<pre><code>5      236GB   256GB   20.0GB  linux-swap(v1)
</code></pre>
<hr />
<p>增加交换分区大小并将其用于休眠</p>
<ul>
<li>创建交换分区</li>
<li>激活交换分区</li>
<li>使新的交换分区适用于休眠状态(可选)</li>
</ul>
<hr />
<p>创建交换分区</p>
<p>使用<code>Ubuntu</code>安装介质如U盘开机, 选择<code>立即运行Ubuntu</code>.
打开<code>GParted</code>分区编辑器: 删除原先的<code>swap</code>, <code>resize</code>主分区大小, 留出合适的空白空间用作<code>swap</code>.可以直接在<code>&quot;free space following&quot;</code>一项中设置想要的<code>swap</code>分区大小.
在新的空白空间中, 选择<code>new</code>, 输入<code>linux-swap</code>, 如果喜欢,可以起个名<code>swap</code>到<code>Partition name</code>中, 然后点击<code>Apply</code>应用.  完成后, 重新启动原先硬盘上的<code>Ubuntu</code>系统.</p>
<hr />
<p>激活交换分区</p>
<p>如果交换位于主硬盘驱动器上, 则无需在此处做任何事情.
现在, 您需要查找<code>swap</code>所在的<code>分区</code>及其<code>UUID</code>, Universally Unique IDentifier, 它是该分区的通用唯一身份, 即使由于添加磁盘, 重启之后分区挂载点改变, <code>UUID</code>也不会改变.</p>
<p>切换到<code>root</code>用户, 运行<code>gparted</code> . 右键单击交换分区, 然后选择<code>Information</code>.
应该可以看到<code>Path</code>和<code>UUID</code>. 保持打开状态以供进一步参考.
运行 <code>gedit /etc/fstab</code>, 查找其中带有<code>swap</code>的行. 它应该在第三列, 用空格或制表符分隔. 您可以使用路径或<code>UUID</code>来告诉<code>Linux</code>在哪里找到交换分区. 建议使用<code>UUID</code>, 因为即使您移动分区或磁盘之后, <code>sdb</code>变成<code>sda</code>, <code>UUID</code>也将保持不变.
如果您使用的是UUID, 则您的代码行应如下所示:</p>
<pre><code>UUID=41e86209-3802-424b-9a9d-d7683142dab7 none swap sw 0 0
</code></pre>
<p>或使用路径:</p>
<pre><code>/dev/sda2 none swap sw 0 0
</code></pre>
<p>保存更改.</p>
<p>使用此命令启用新的交换分区.</p>
<pre><code class="language-bash">sudo swapon --all # 或者 sudo swapon --all --verbose
</code></pre>
<p>确认交换分区存在.</p>
<pre><code class="language-bash">$ cat /proc/swaps
Filename                                Type            Size  Used    Priority
/dev/sda2                               partition      20971480       -1
</code></pre>
<p>接着可以重启查看交换分区能否被正确激活.</p>
<hr />
<p>使交换分区用于休眠(可选)</p>
<p>运行<code>cat /proc/swaps</code>, 可以看到<code>swap</code>分区的路径. 找到它的<code>UUID</code>. 使用</p>
<pre><code>sudo gedit /etc/default/grub
</code></pre>
<p>修改<code>grub</code>(启动引导加载程序)的配置. 如果怕出问题可以先备份</p>
<pre><code>sudo cp -a /etc/default/grub /etc/default/grub.bak
</code></pre>
<p>查找<code>GRUB_CMDLINE_LINUX=&quot;xx&quot;</code>行, 在后面添加上:</p>
<pre><code>GRUB_CMDLINE_LINUX=&quot;XXX resume=UUID=41e86209-3802-424b-9a9d-d7683142dab7&quot;
</code></pre>
<p>并保存文件.<code>sudo update-grub</code>并等待其完成.</p>
<p>然后<code>sudo gedit /etc/initramfs-tools/conf.d/resume</code>, 确保内容类似下面这样:</p>
<pre><code>resume=UUID=41e86209-3802-424b-9a9d-d7683142dab7
</code></pre>
<p>如果不使用<code>swap</code>, 这里的设置应该是<code>resume=none</code>,保存文件.
然后运行<code>sudo update-initramfs -u</code>. 重启. 现在应该可以休眠了.</p>
<hr />
<p>启用未生效的交换分区: 如果你已经有交换分区, 则有几种启用它的方法. 首先查看<code>fstab</code></p>
<pre><code>cat /etc/fstab
</code></pre>
<p>确保下面有<code>swap</code>的记录, 这样可以在启动时启用<code>swap</code>.</p>
<pre><code>/dev/sdb5       none            swap    sw              0       0
</code></pre>
<p>然后禁用所有<code>swap</code>, 再重新创建它, 然后使用以下命令重新启用</p>
<pre><code class="language-bash">sudo swapoff -a
sudo /sbin/mkswap /dev/sdb5
sudo swapon -a
</code></pre>
<hr />
<p>什么是<code>swappiness</code>, 我该如何更改?</p>
<p><code>swappiness</code>参数控制内核使用<code>swap</code>的倾向. 因为磁盘要比<code>RAM</code>慢得多, 所以如果进程经常主动地移出内存, 可能导致系统和应用程序的响应时间变慢.</p>
<ul>
<li><code>swappiness</code> 的值可以在<code>0</code>到<code>100</code>之间</li>
<li><code>swappiness=0</code>告诉内核尽可能避免将进程从物理内存中交换出来</li>
<li><code>swappiness=100</code> 告诉内核积极地把进程从物理内存移动到<code>swap</code>缓存</li>
</ul>
<p><code>Ubuntu</code> 中的默认设置为<code>swappiness=60</code>. 降低 <code>swappiness</code> 的默认值可能会提高典型的<code>Ubuntu</code>桌面安装的整体性能.
建议将 <code>swappiness</code> 的值设置为<code>10</code>, 你也可以自己尝试. <code>Ubuntu</code>服务器对桌面系统的性能要求不同, 默认值<code>60</code>可能更合适.</p>
<p>检查<code>swappiness</code>值</p>
<pre><code>cat /proc/sys/vm/swappiness
</code></pre>
<p>临时更改 <code>swappiness</code> 值(重启之后丢失):</p>
<pre><code>sudo sysctl vm.swappiness=10
</code></pre>
<p>永久更改:</p>
<pre><code>sudo gedit /etc/sysctl.conf
</code></pre>
<p>搜索<code>vm.swappiness</code>根据需要更改其值. 如果<code>vm.swappiness</code>不存在则自己添加:</p>
<pre><code>vm.swappiness=10
</code></pre>
<p>保存文件并重新启动.</p>
<h2 id="编码字符集"><a class="header" href="#编码字符集">编码,字符集</a></h2>
<p><a href="https://wiki.archlinux.org/title/Localization/Simplified_Chinese">File name is garbled</a></p>
<p>避免乱码基本原则: 使用 <code>utf-8</code> 代替 <code>gbk/gb2312</code>.</p>
<p><code>convmv</code>: 将文件名从一种编码转换到另一种编码, 例如:</p>
<pre><code class="language-bash">convmv -f GBK -t UTF-8 --notest --nosmart file
</code></pre>
<p><code>-f</code>指定原始编码, <code>-t</code>指定输出编码. 使用 <code>convmv --list</code> 可查询所有支持的编码.
<code>--notest</code> 表示进行实际操作, 而非测试, 如果不使用该参数只会打印出转换结果而不会实际转码. <code>--smart</code>表示如果已经是<code>UTF-8</code> 则忽略.</p>
<h3 id="文件内容乱码"><a class="header" href="#文件内容乱码">文件内容乱码</a></h3>
<p>使用 <code>iconv</code> 命令转换格式. 示例:</p>
<pre><code class="language-bash">iconv -f GBK -t UTF-8 -o new-file origin-file
</code></pre>
<p><code>-f</code> 指定原始编码, <code>-t</code> 指定输出编码. 使用 <code>iconv -l</code> 可查询所有支持的编码. <code>-o</code> 指定输出文件.</p>
<h3 id="zip-压缩包乱码"><a class="header" href="#zip-压缩包乱码">zip 压缩包乱码</a></h3>
<p>避免方法: 非 <code>utf8</code> 编码环境下(一般 <code>windows</code> 下的中文环境即是)不使用 <code>zip</code> 进行压缩(建议使用 <code>7z</code>).
解决方案: 安装使用 <code>unzip-iconv</code> 或者 <code>unzip-natspec</code>取代原版的 <code>unzip</code> 来解压缩, 示例:</p>
<pre><code class="language-bash">unzip -O gbk file.zip
</code></pre>
<p><code>file.zip</code> 是压缩文件, <code>gbk</code> 是该文件的编码格式, 以 <code>-O</code> 指定(原版 <code>unzip</code> 无 <code>-O</code> 选项).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-1-exception"><a class="header" href="#linux-1-exception">linux-1-exception</a></h1>
<h2 id="常用软件"><a class="header" href="#常用软件">常用软件</a></h2>
<h3 id="ubuntu-dock"><a class="header" href="#ubuntu-dock">Ubuntu Dock</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/48078003">如何移除或禁用 Ubuntu Dock</a></p>
<p>使用 <code>Dash to Panel</code> 扩展:</p>
<p><code>Dash to Panel</code> 是 Gnome Shell 的一个高度可配置面板,是 Ubuntu Dock 或 Dash to Dock 的一个很好的替代品(Ubuntu Dock 是从 Dash to Dock 分叉而来的).
安装和启动 <code>Dash to Panel</code> 扩展会禁用 Ubuntu Dock,因此你无需执行其它任何操作.
你可以从 extensions.gnome.org 来安装 <a href="https://extensions.gnome.org/extension/1160/dash-to-panel/">Dash to Panel</a>.</p>
<p>如果你改变主意并希望重新使用 Ubuntu Dock,那么你可以使用 Gnome Tweaks 应用程序禁用 Dash to Panel,或者通过单击以下网址旁边的 X 按钮完全移除 <code>Dash to Panel</code>: https://extensions.gnome.org/local/ .</p>
<h3 id="oh-my-zsh"><a class="header" href="#oh-my-zsh">oh-my-zsh</a></h3>
<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Oh My Zsh 插件</a>
<a href="https://www.jianshu.com/p/fa6aa9329be6">Mac/Linux使用ZSH (oh-my-zsh)</a>
<a href="https://www.jianshu.com/p/6b47198fd430">oh-my-zsh国内镜像安装和更新方法</a>
<a href="https://gitee.com/mirrors"> Gitee 极速下载</a>:<code>Gitee 极速下载</code> 是为了提升国内下载速度的镜像仓库, 每日同步一次.</p>
<p><code>oh-my-zsh</code>的 github 地址在国内可能用不了, 可以考虑使用<code>gitee</code>的镜像.</p>
<p>首先需要安装<code>zsh</code>, 可以直接用<code>sudo apt install zsh</code>.  然后安装<code>oh-my-zsh</code>, 下载<a href="https://gitee.com/mirrors/oh-my-zsh">码云安装脚本install.sh</a></p>
<pre><code class="language-bash">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh
</code></pre>
<p>编辑<code>install.sh</code>, 找到以下部分</p>
<pre><code class="language-bash"># Default settings
ZSH=${ZSH:-~/.oh-my-zsh}
REPO=${REPO:-ohmyzsh/ohmyzsh}
REMOTE=${REMOTE:-https://github.com/${REPO}.git}
BRANCH=${BRANCH:-master}
</code></pre>
<p>把其中的</p>
<pre><code class="language-bash">REPO=${REPO:-ohmyzsh/ohmyzsh}
REMOTE=${REMOTE:-https://github.com/${REPO}.git}
</code></pre>
<p>替换为</p>
<pre><code class="language-bash">REPO=${REPO:-mirrors/oh-my-zsh}
REMOTE=${REMOTE:-https://gitee.com/${REPO}.git}
</code></pre>
<p>编辑后保存, 运行安装即可. (运行前先给<code>install.sh</code>权限, <code>chmod +x install.sh</code>).
安装完成后修改同步的<code>仓库地址</code></p>
<pre><code class="language-bash">cd ~/.oh-my-zsh
git remote set-url origin https://gitee.com/mirrors/oh-my-zsh.git
git pull
</code></pre>
<h3 id="powerline-状态条"><a class="header" href="#powerline-状态条">Powerline 状态条</a></h3>
<p><code>Powerline</code> 是一个极棒的 <code>Vim</code> 编辑器的状态行插件,这个插件是使用 Python 开发的,主要用于显示状态行和提示信息,适用于很多软件,比如 <code>bash</code>, <code>zsh</code>, <code>tmux</code> 等等.
<a href="https://linux.cn/article-8118-1.html">使用Powerline为VIM和Bash注入强劲动力</a></p>
<p>首次安装<code>pip</code>,即python包管理器,在 Debian, Ubuntu 和 Linux Mint 中安装 <code>pip</code></p>
<pre><code class="language-bash">apt-get install python3-pip
</code></pre>
<p>然后你可以通过 pip 命令安装 <code>Powerline</code>.</p>
<pre><code class="language-bash">pip3 install git+git://github.com/powerline/powerline
</code></pre>
<h4 id="安装-powerline-的字体"><a class="header" href="#安装-powerline-的字体">安装 Powerline 的字体</a></h4>
<p><code>Powerline</code> 使用特殊的符号来为开发者显示特殊的箭头效果和符号内容.因此你的系统中必须要有符号字体或者补丁过的字体.
通过下面的 <code>wget</code> 命令下载最新的系统字体及字体配置文件.</p>
<pre><code class="language-bash">wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf
wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf
</code></pre>
<p>然后你将下载的字体放到字体目录下 <code>/usr/share/fonts</code> 或者 <code>/usr/local/share/fonts</code>,或者你可以通过 <code>xset q</code> 命令找到一个有效的字体目录.</p>
<pre><code class="language-bash">mv PowerlineSymbols.otf /usr/share/fonts/
</code></pre>
<p>接下来你需要通过如下命令更新你系统的字体缓存.</p>
<pre><code class="language-bash">fc-cache -vf /usr/share/fonts/
</code></pre>
<p>其次安装字体配置文件.</p>
<pre><code class="language-bash">mv 10-powerline-symbols.conf /etc/fonts/conf.d/
</code></pre>
<h4 id="bash-中的-powerline"><a class="header" href="#bash-中的-powerline">bash 中的 Powerline</a></h4>
<p>如果希望在 <code>bash shell</code> 中默认打开 <code>Powerline</code>,可以在 <code>~/.bashrc</code> 中添加如下内容.</p>
<p>首先通过如下命令获取 powerline 的安装位置.</p>
<pre><code class="language-bash">pip3 show powerline-status
...
Location: XXXXX
...
</code></pre>
<p>一旦找到 <code>powerline</code> 的具体位置后,根据你系统的情况替换到下列行中的 <code>XXXXX</code> 对应的位置.</p>
<pre><code class="language-bash">powerline-daemon -q
POWERLINE_BASH_CONTINUATION=1
POWERLINE_BASH_SELECT=1
source XXXXX/powerline/bindings/bash/powerline.sh
</code></pre>
<p>然后退出后重新登录,现在 <code>powerline</code> 的状态行应该如下显示了.</p>
<h4 id="vim-中的-powerline"><a class="header" href="#vim-中的-powerline">Vim 中的 Powerline</a></h4>
<p>首先通过如下命令获取 <code>powerline</code> 的安装位置.</p>
<pre><code class="language-bash">pip3 show powerline-status
</code></pre>
<p>在 <code>~/.vimrc</code> 中添加如下内容打开该插件(译注: 注意同样需要根据你的系统情况修改路径).</p>
<pre><code class="language-bash">set rtp+=/home/tom/.local/lib/python3.6/site-packages/powerline/bindings/vim/
set laststatus=2
set t_Co=256
</code></pre>
<p>然后你打开 <code>vim</code> 后会看到一个新的状态行</p>
<h3 id="tldr"><a class="header" href="#tldr">tldr</a></h3>
<p><code>tldr</code>(Too Long; Don't Read): 帮你更加高效地学习<code>linux</code>命令</p>
<pre><code class="language-bash">pip3 install --user tldr
</code></pre>
<h2 id="x窗口系统"><a class="header" href="#x窗口系统">X窗口系统</a></h2>
<p><code>X</code>窗口系统(使GUI工作的底层引擎)内建了一种机制,支持快速拷贝和粘贴技巧.</p>
<p>按下鼠标左键,沿着文本拖动鼠标(或者双击一个单词)高亮了一些文本,
那么这些高亮的文本就被拷贝到了一个由X管理的缓冲区里面.然后按下鼠标中键,这些文本就被粘贴到光标所在的位置.</p>
<blockquote>
<p><code>ctrl-c</code> and <code>ctrl-v</code>,这两个控制代码对于Shell 有不同的含义,它们在早于Microsoft Windows许多年之前就赋予了不同的意义.</p>
</blockquote>
<p>可以把聚焦策略设置为&quot;跟随鼠标&quot;,这样鼠标移动到的窗口,就可以接受输入</p>
<h3 id="图形界面"><a class="header" href="#图形界面">图形界面</a></h3>
<p><a href="https://blog.csdn.net/qq_16093937/article/details/83269106">Linux图形界面知识</a></p>
<p><code>X</code>是协议, 不是具体的某个软件. <code>XFree86</code>只是实现<code>X</code>协议的一个免费X服务器软件
<code>X11R6</code> 是 X Protocol version 11 Release 6,(<code>X</code>协议第<code>11</code>版第<code>6</code>次发行)的意思
窗口管理器的作用是最大化, 最小化, 移动, 关闭窗口等.而这些不是<code>X</code>服务器来负责完成的.</p>
<p><code>KDE</code> 和<code>GNOME</code>是<code>Linux</code>里最常用的图形界面操作环境, 他们不仅仅是一个窗口管理器那么简单,  <code>KDE</code>是<code>K Desktop Environment</code> 的缩写.
他不仅是一个窗口管理器, 还有很多配套的应用软件和方便使用的桌面环境, 比如任务栏, 开始菜单, 桌面图标等等.
<code>GNOME</code>是<code>GNU Network Object Model Environment</code> 的缩写.和<code>KDE</code>一样, 也是一个功能强大的综合环境.</p>
<p>办公室的电脑在4K分辨率下会卡顿, 2K则正常.</p>
<h3 id="幕后控制台"><a class="header" href="#幕后控制台">幕后控制台</a></h3>
<p>即使仿真终端没有运行,后台仍然有几个终端会话运行.他们叫做虚拟终端或者虚拟控制台.</p>
<p>在大多数Linux发行版中,可以通过按下 <code>Ctrl+Alt+F1</code> 到 <code>Ctrl+Alt+F6</code> 访问.</p>
<p>切换可以直接按<code>Alt+F1..F6</code>.返回图形桌面,按下<code>Alt+F7</code></p>
<h3 id="将标准输出重定向到剪贴板"><a class="header" href="#将标准输出重定向到剪贴板">将标准输出重定向到剪贴板</a></h3>
<p><a href="https://blog.csdn.net/tcliuwenwen/article/details/103752486">将标准输出重定向到剪贴板</a></p>
<p>作为一名优秀的程序员,终端和复制粘贴必将是必不可少的,手动将输出复制粘贴不应该是一名优秀程序员的作风.
那么如何将标准输出重定向到剪贴板方便我们粘贴呢?</p>
<p>安装<code>xsel</code>或者<code>xclip</code></p>
<pre><code class="language-bash">sudo apt install xsel
sudo apt install xclip
</code></pre>
<hr />
<p>将输出通过管道重定向到剪贴板</p>
<pre><code class="language-bash">ls | xsel -ib  # 使用xsel
ls | xclip -select clip  # 使用xclip
</code></pre>
<hr />
<p>可以考虑使用别名来简短命令这里不再赘述</p>
<h3 id="剪贴板管理程序"><a class="header" href="#剪贴板管理程序">剪贴板管理程序</a></h3>
<p><a href="https://www.linuxprobe.com/10-best-linux-clipboard.html">10 款最佳剪贴板管理器</a></p>
<ul>
<li>CopyQ</li>
<li>GPaste</li>
<li>Klipper</li>
<li>Clipman</li>
<li>Diodon</li>
</ul>
<p>etc</p>
<h3 id="linux-录屏软件"><a class="header" href="#linux-录屏软件">Linux 录屏软件</a></h3>
<p><a href="https://www.zhihu.com/question/51920876">Linux 录屏软件有哪些</a></p>
<p>如果是<code>Gnome3</code>系用户,可以按<code>ctrl + shift + alt + r</code>,屏幕右下角有红点出现,则开始录屏,
要结束的话再按一次<code>ctrl + shift + alt + r</code>,录好的视频在<code>~/video</code>下</p>
<hr />
<p>修改默认30秒的问题, 改成1小时</p>
<pre><code class="language-bash">gsettings set org.gnome.settings-daemon.plugins.media-keys max-screencast-length 3600
</code></pre>
<h3 id="美化"><a class="header" href="#美化">美化</a></h3>
<p>shell: <a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a>
themes: <a href="https://github.com/vinceliuice/vimix-gtk-themes">vimix-gtk-themes</a>
icon: <a href="https://github.com/vinceliuice/vimix-icon-theme/">vimix-icon-theme/</a></p>
<p><code>sudo apt install gnome-shell-extensions</code></p>
<p>extensions: <code>Blyr </code>,<code>Dash to panel</code>,<code>User themes</code>,<code>openweather</code></p>
<hr />
<p>Plymouth</p>
<p><a href="https://blog.csdn.net/mutilcam_prince/article/details/78299628">Ubuntu 16.04美化 -- Plymouth(splash screen/开机画面)主题安装</a></p>
<p><a href="www.gnome-look.org">www.gnome-look.org</a>上有大量的<code>Ubuntu Plymouth</code>主题,也就是通常所说的开机画面主题,
但是几乎所有的主题在<code>16.04</code>之后变的不可用了,那是因为从<code>16.04</code>开始, <code>plymouth</code>主题存放路径已经变了,
而网络上的主题还是对应的老版路径,那就是<code>/lib/plymouth/themes/</code>,<code>16.04</code>之后已改为: <code>/usr/share/plymouth/themes/</code>.
这导致老版的主题不光用作者写的脚本安装不上,即便是自己手动复制到主题目录里,也不能正常使用.</p>
<p>本篇文章重点介绍一下老版<code>plymouth</code>主题如何安装到<code>16.04</code>上.</p>
<p>首先正常的话,<code>16.04</code>已经默认安装了一个<code>plymouth</code>主题,
如果不知道何种原因,你的<code>16.04</code>没有默认安装<code>plymouth</code>的默认主题,那么可以通过下面这个命令安装:</p>
<p><code> sudo apt-get install plymouth-themes</code></p>
<p>这条命令会自动创建<code>/usr/share/plymouth/themes/</code>并且附带几个简单默认的主题.</p>
<p>那么下面我们来开始安装自定义主题.以[<code>NSA Splash Screen</code>] (https://www.gnome-look.org/p/1173975/)为例.</p>
<hr />
<p>下载主题,然后解压后得到一个目录.(本文以解压到<code>~/Downloads</code>为例)解压完成后,
重点是<code>images</code>目录, <code>nsa.plymouth</code>, <code>nsa.script</code>
那么我们可以得知,这个主题叫<code>nsa</code>
<code>Plymouth</code>的主题名称和主题文件名以及主题目录名,必须完全一致,不然会报错.
所以我们首先需要把这个<code>skd1993-nsa-plymouth-50df7fd</code>目录名改成<code>nsa</code></p>
<hr />
<p>查看并修改主题文件</p>
<p><code>nsa</code>是个老版本的主题,这个是怎么看出来的呢,用文本编辑器打开<code>nsa.plymouth</code>:</p>
<p>[Plymouth Theme]
Name=nsa
Description=An NSA style cool bootsplash
ModuleName=script</p>
<p>[script]
ImageDir=/lib/plymouth/themes/nsa-plymouth
ScriptFile=/lib/plymouth/themes/nsa-plymouth/nsa.script</p>
<p>正如之前所说,<code>ImageDir</code>和<code>ScriptFile</code>对应的路径已经不存在了.因此我们需要对其进行修改.
对于我们这个主题来说,具体是这样的:</p>
<pre><code class="language-bash">ImageDir=/usr/share/plymouth/themes/nsa
ScriptFile=/usr/share/plymouth/themes/nsa/nsa.script
</code></pre>
<p>保存退出.</p>
<hr />
<p>安装主题</p>
<p>把主题文件夹复制到<code>plymouth</code>的<code>theme</code>目录</p>
<p><code>sudo cp -r  ~/Downloads/nsa   /usr/share/plymouth/themes/</code></p>
<p>然后安装这个主题.</p>
<p><code>sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth       default.plymouth        /usr/share/plymouth/themes/nsa/nsa.plymouth  100</code></p>
<p>更新一下<code>plymouth</code>,根据提示手动输入序号选择我们刚刚安装的主题.</p>
<p><code>sudo update-alternatives --config default.plymouth</code></p>
<p>最后更新一下<code>initramfs</code></p>
<p><code>sudo update-initramfs -u</code></p>
<p>完成
重启即可看到效果.</p>
<hr />
<p>如果在<code>sudo update-alternatives –config default.plymouth</code>这一步出现错误提示:</p>
<pre><code class="language-bash">W: plymouth module &quot;(/usr/lib/i386-linux-gnu/plymouth//.so)&quot; missing, skipping that theme.
</code></pre>
<p>这是个内核级的错误,此时不要重启,不然可能卡在开机界面.绝大多数可能是某个步骤中的路径搞错了.
仔细检查所有步骤的路径,然后重来一遍.</p>
<p>本文中的三四步骤, 可以通过一个shell脚本完成.
下面贴上脚本内容(仅限本主题, 其他主题可以简单将文中的<code>nsa</code>更换为相应主题的名称, 前提是修改完<code>nsa.script</code>)</p>
<pre><code class="language-bash">#!/bin/bash
# 打印提示信息, 选择颜色使其更醒目
echo  -e &quot;\033[36m Copying new files...  \033[0m&quot;
# 在/usr/share/plymouth/themes文件夹下, 创建目录存放主题文件
sudo mkdir /usr/share/plymouth/themes/nsa
# 复制主题内容, 其中使用了花括号展开, 这里相当于直接给出
sudo cp --recursive {images,nsa.plymouth,nsa.script,README.md} /usr/share/plymouth/themes/nsa
# 安装主题, 语法是: update-alternatives --install link name path priority ... 分别是2级链接, 一级连接, 实际路径
echo -e &quot;\033[31m Installing the theme...  \033[0m&quot;
sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/nsa/nsa.plymouth  100
# 使用 update-alternatives 设置为默认主题, 依照提示选择
echo -e &quot;\033[32m Please Select your theme and set it default...  \033[0m&quot;
sudo update-alternatives --config default.plymouth
# 更新
sudo update-initramfs -u
echo -e &quot;\033[36m Installation Complete!  \033[0m&quot;
</code></pre>
<p>将上述代码保存到主题目录下, 文件名比如为<code>xxx.sh</code></p>
<pre><code class="language-bash">chmod +x xxx.sh
./xxx.sh
</code></pre>
<p>即可完成安装</p>
<hr />
<p>其他主题安装</p>
<p>有的主题也可能自带安装脚本, 比如</p>
<p><a href="http://gnome-look.org/content/show.php/colours%3A+Ubuntu+rainbow+plymouth+theme?content=163234">ubuntu-touch: A Plymouth startup and shutdown animated splash</a></p>
<ol>
<li>下载解压缩, 进入<code>ubuntu-touch-splash</code></li>
<li><code>./install-ubuntu-touch [ENTER]</code>.将安装<code>plymouth-x11</code>软件包以提供测试主题的功能, 而无需重新启动.
之后, 将显示新主题的启动和关闭的10秒测试.</li>
</ol>
<p>如果修改不小心导致启动屏幕黑屏, 则恢复的最快方法是重新提取下载文件, 然后重新安装它.
如果尚未对<code>ubuntu-touch-splash</code>文件夹中的文件进行任何更改, 则可以使用以下方法重复测试:
<code>  ./test-plymouth [输入]</code></p>
<p>在启动动画的持续时间非常非常短的情况下, 可以通过在<code>ubuntu-touch-splash</code>文件夹中执行来获得改进的效果:
<code> ./assert-framebuffer</code>
如果您最终对该主题不满意, 还原可以在主题目录下执行:</p>
<pre><code class="language-bash">./update-plymouth [ENTER]
</code></pre>
<p>根据要求选择<code>ubuntu-logo</code>或者其他之前使用的主题.</p>
<h3 id="kde-桌面环境"><a class="header" href="#kde-桌面环境">KDE 桌面环境</a></h3>
<p>现在, 如果您不喜欢KDE或出于任何原因想要删除此环境, 请按照以下步骤在Ubuntu上卸载KDE:</p>
<pre><code class="language-bash">sudo apt --purge remove kde-standard
sudo apt autoremove
reboot
</code></pre>
<p>注意: 在安装KDE软件包时安装的某些应用程序必须手动删除.  像(Konsole, Konqueror等)之类的应用
重新启动后, 如果遇到CLI登录屏幕, 请不要慌张.
这是因为您已将SDDM设置为默认显示管理器, 现在已将其删除.  因此, 我们将<code>gdm3</code>设置为默认值.</p>
<pre><code class="language-bash">sudo systemctl restart gdm3
sudo dpkg-reconfigure gdm3
reboot
</code></pre>
<p>重新启动系统, 然后检查是否一切正常.</p>
<h2 id="ubuntu-备份和恢复"><a class="header" href="#ubuntu-备份和恢复">ubuntu 备份和恢复</a></h2>
<p>教程中排除的目录</p>
<pre><code class="language-bash">--exclude=/proc
--exclude=/tmp
# --exclude=/home
--exclude=/lost+found
--exclude=/media
--exclude=/mnt
--exclude=/run
--exclude=/sys
</code></pre>
<h3 id="备份方法1"><a class="header" href="#备份方法1">备份方法1</a></h3>
<hr />
<p>分区 id 记录</p>
<p>设备 挂载点 原始uuid 分区格式 新uuid new设备</p>
<p><code>/boot/efi</code> 2EEE-149A <code>FAT (32-bit version)</code>
<code>none</code> 3278e9ef-8c04-4eaa-bfde-af2313f36545 <code>Swap</code>
<code>/</code>  7aba3e2f-f94d-454c-9ad6-9098d658401a <code>Ext4</code></p>
<hr />
<p>可以用ubuntu18.04自带软件<code>gnome-disks</code>查看自己系统分区情况:
在新电脑上, 可以用<code>GParted</code>对硬盘进行分区</p>
<hr />
<p>首先启动live CD, 选择<code>try Ubuntu</code>;</p>
<p>开始对需要用live CD备份的分区进行挂载, 所以挂载除了<code>swap</code>之外的分区, 对比我们之前创建的表来看下面的挂载命令会更容易理解:</p>
<pre><code class="language-bash">#获取最高权限
sudo su
#-- 在mnt下创建root目录和efi目录, 分别用来挂载原系统的root分区和efi分区
mkdir /mnt/root   /mnt/efi  /mnt/home
#-- 将原系统根分区挂载到/mnt目录
mount /dev/sdb5   /mnt/root
#将原系统的boot/efi分区挂载到/mnt/efi目录
mount /dev/sda2   /mnt/efi
#-- 将原系统的home分区挂载到/mnt/home
mount /dev/sdb6   /mnt/home
</code></pre>
<hr />
<p>插入U盘或硬盘开始备份:</p>
<pre><code class="language-bash">#-- 将root, home和efi分区备份到硬盘中
mksquashfs /mnt/root /media/ubuntu/你的移动硬盘/备份的目录/root.sfs
mksquashfs /mnt/efi /media/ubuntu/你的移动硬盘/备份目录/efi.sfs
mksquashfs /mnt/home /media/ubuntu/你的移动硬盘/备份目录/home.sfs
sync
#-- 卸载刚刚挂载的分区和硬盘
umount /media/ubuntu/* /mnt/*
</code></pre>
<p><code>root</code>, <code>home</code>和<code>efi</code>分区备份完成.</p>
<hr />
<p>对新硬盘进行分区</p>
<p>在新电脑上启动live CD, 选择试用, 打开live CD中自带分区工具<code>GParted</code>, 对新电脑进行分区, 分区大小根据个人情况而定, 参照之前填的表:</p>
<pre><code class="language-bash">efi分区
swap分区,如果不需要休眠, 其实不用分这个, 而且固态硬盘不分这个比较好
root分区(主分区或逻辑分区无所谓)
home分区(主分区或逻辑分区无所谓)
</code></pre>
<hr />
<p>将备份文件恢复到各个分区</p>
<p>使用<code>live CD</code>自带软件<code>gnome-disks</code>查看新分区的信息, 完善之前的表, 我的情况如下:</p>
<p>插入存有备份文件的移动硬盘开始恢复备份:</p>
<pre><code class="language-bash">sudo su
#-- 在mnt下创建root, home和efi目录, 分别用来挂载新电脑的root, home和efi分区
mkdir /mnt/root /mnt/efi  /mnt/home
#-- 挂载新电脑的根分区到/mnt/root目录
mount /dev/sdc5 /mnt/root
#-- 挂载新电脑的efi分区到/mnt/efi
mount /dev/sdc1 /mnt/efi
#-- 挂载新电脑home分区到/mnt/home
mount /dev/sdc6 /mnt/home
#-- 新建/backup/root/, /backup/home和/backup/efi目录,使用loop模式将之前准备好的sfs文件挂载到对应的目录下
mkdir /backup
cd /backup
mkdir root efi home
mount -o loop /media/ubuntu/存放备份文件的路径/root.sfs /backup/root
mount -o loop /media/ubuntu/存放备份文件的路径/efi.sfs  /backup/efi
mount -o loop /media/ubuntu/存放备份文件的路径/home.sfs  /backup/home
#-- 开始恢复
cp -a /backup/root/* /mnt/root
cp -a /backup/efi/* /mnt/efi
cp -a /backup/home/* /mnt/home
# -- 同步数据并取消挂载
sync
umount /backup/*
umount /mnt/*
umount /media/ubuntu/*
</code></pre>
<hr />
<p>启动引导修复</p>
<p>恢复完成之后, 开始来修改引导文件,首先使用<code>/mnt</code>目录来挂载新电脑完整的文件系统, 再次掏出我们之前填好的表:</p>
<pre><code class="language-bash">sudo su
# -- 移除之前创建的临时文件夹
rm -r /mnt/root /mnt/efi /mnt/home
# -- 首先挂载新电脑的根目录
mount /dev/sdc5 /mnt
#-- 挂载efi
mount /dev/sdc1 /mnt/boot/efi
# -- 挂载home
mount /dev/sdc6 /mnt/home
# 接下来挂载虚拟文件系统, 为后面的修复做准备
mount --o bind /dev   /mnt/dev
mount --o bind /proc   /mnt/proc
mount --o bind /sys   /mnt/sys
# 将liveCD的根目录改为新电脑的根目录确保之后的操作安全. (这里也请大佬指点, 是否只是安全? )
# chroot /mnt
</code></pre>
<p>接下来修改两个文件分别位于新电脑的<code>/etc/fstab</code>和<code>/boot/grub/grub.cfg</code>(不用手动修改), 接下来我们再次掏出我们的表:</p>
<pre><code class="language-bash"># -- 用nano编辑器打开/etc/fstab
nano /etc/fstab
</code></pre>
<p>按照提示, 和<code>uuid</code>变化的对照表, 修改<code>root</code>,<code>/boot/efi</code>,<code>/home</code>等的<code>uuid</code></p>
<p><code>/boot/grub/grub.cfg</code>这个文件是用<code>grub-mkconfig</code>自动生成的, 所以不需要手动修改.</p>
<blockquote>
<p>It is automatically generated by grub-mkconfig using templates  from /etc/grub.d and settings from /etc/default/grub</p>
</blockquote>
<p>然后一定要更新<code>grub</code>引导:</p>
<pre><code class="language-bash"># -- grub安装到efi分区
grub-install /dev/sdc1
update-grub
sync #确保数据写入硬盘
#-- 退出chroot
exit
umount /mnt/*/media/ubuntu/*
exit
reboot
</code></pre>
<p>系统重启, 拔出你的<code>live CD</code>, 不出意外电脑开机将会进入你备份恢复完成的新电脑.</p>
<h3 id="问题排查"><a class="header" href="#问题排查">问题排查</a></h3>
<p>如果无法开机/开机时间过长, 首先(使用 liveCD进入系统查看)确保<code>/etc/fstab</code>中的硬盘<code>uuid</code>没有写错.</p>
<p>使用下面命令查看问题</p>
<pre><code class="language-bash">systemd-analyze
systemd-analyze blame
systemd-analyze critical-chain
## 以及
sudo cat /var/log/boot.log | less
</code></pre>
<p>如果之前有<code>swap</code>分区, 还原的时候没有<code>swap</code>分区, 修改<code>initramfs</code>配置:</p>
<pre><code class="language-bash">sudo vim /etc/initramfs-tools/conf.d/resume
#在文件中添加一行
RESUME=none
sudo update-grub
sudo update-initramfs -u
</code></pre>
<p>以下命令在排除错误时可能用到</p>
<pre><code class="language-bash">sudo blkid
sudo fdisk -l
sudo dmesg
</code></pre>
<p><a href="https://www.sysgeek.cn/ubuntu-18-04-swap/">Ubuntu 18.04 如何添加或删除 SWAP 交换分区</a>
<a href="https://blog.csdn.net/xiaoma_2018/article/details/85059930">Linux系统制作Ubuntu18.04启动盘</a></p>
<pre><code class="language-bash"># 插入U盘, 在Linux系统中打开终端, 查看 U 盘信息:
sudo fdisk -l
# 然后卸载掉 U 盘:
sudo umount /dev/sdb*
# U 盘格式化:
sudo mkfs.vfat /dev/sdb -I # 使用 -I 选项创建
#完成格式化后查看磁盘信息:
# 最后使用 dd 命令制作启动盘:
sudo dd if=ubuntu-18.04.1-desktop-amd64.iso of=/dev/sdb bs=10M
</code></pre>
<h3 id="ubuntu系统备份2"><a class="header" href="#ubuntu系统备份2">Ubuntu系统备份2</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/51827233">Ubuntu系统备份</a></p>
<p>备份前可以先清理一下缓存</p>
<pre><code class="language-bash"># 清理旧版本的软件缓存
sudo apt-get autoclean
# 清理所有软件缓存
sudo apt-get clean
# 删除系统不再使用的孤立软件
sudo apt-get autoremove
</code></pre>
<p>ubuntu 秉承一切皆文件的思想, 系统备份就相当于把整个<code>/</code>(根目录)所有文件打包压缩保存</p>
<p>主要有两种方式备份还原:</p>
<ul>
<li><code>tar</code> 命令</li>
<li><code>livecd</code> 模式</li>
</ul>
<p>首先介绍下 <code>tar</code> 命令备份</p>
<pre><code class="language-bash"># 备份前先切换到root用户, 避免权限问题
sudo su
# 再切换到 /(根目录)
cd /
# 备份系统
tar -cvpzf /media/Disk/myDisk/ubuntu_backup@ $(date +%Y-%m+%d).tar.gz --exclude=/proc --exclude=/tmp --exclude=/home --exclude=/lost+found --exclude=/media --exclude=/mnt --exclude=/run /
</code></pre>
<hr />
<p>tar命令参数:</p>
<ul>
<li><code>-c</code>:  新建一个备份文档</li>
<li><code>-v</code>:  显示详细信息</li>
<li><code>-p</code>:  保存权限, 并应用到所有文件</li>
<li><code>-z</code>:  用 <code>gzip</code> 压缩备份文档, 减小空间</li>
<li><code>-f</code>:  指定压缩包名称(带路径), 只能做最后一个参数</li>
<li><code>–exclude</code>:  排除指定目录, 不进行备份</li>
</ul>
<p>注意, 如果没有把<code>/home</code>或者<code>/boot</code>目录单独分一个区, 一定不要加<code>–exclude=/home</code>或<code>–exclude=/boot</code>参数!</p>
<p>文件目录介绍</p>
<p><code>/proc</code>: 一个虚拟文件系统, 系统运行的每一个进程都会自动在这个目录下面创建一个进程目录. 既然是系统自动创建, 也就没必要备份的必要了.
<code>/tmp</code>: 一个临时文件夹, 系统的一些临时文件会放在这里.
<code>/lost+found</code>: 系统发生错误时(比如非法关机), 可以在这里找回一些丢失文件.
<code>/media</code>: 多媒体挂载点, 像u盘, 移动硬盘, windons分区等都会自动挂载到这个目录下.
<code>/mnt</code>: 临时挂载点, 你可以自己挂载一些文件系统到这里.
<code>/run</code>: 系统从启动以来产生的一些信息文件.
<code>/home</code>: 用户家目录, 存放用户个人文件和应用程序.
<code>/boot</code>: 和系统启动相关的文件, 像grub相关文件都放在这里, 这个目录很重要!</p>
<p>为了保险起见, 也可以对<code>/home</code>和<code>/boot</code>备份, 但是备份频率完全没必要和/分区一样高.
比如<code>/</code>分区每周备份一次, 那<code>/home</code>和<code>/boot</code>完全可以一个月备份一次, 因为这两个分区出问题的概率真的很小, 而且变动也不会太频繁.</p>
<pre><code class="language-bash">tar -cvpzf /media/Disk/my_Disk/ubuntu_home_backup@`date +%Y-%m-%d`.tar.gz /home
tar -cvpzf /media/Disk/myDisk/ubuntu_boot_backup@`date +%Y-%m-%d`.tar.gz /boot
</code></pre>
<hr />
<p>打包过程中会遇到如下错误或警告信息</p>
<pre><code class="language-bash">tar: Exiting with failure status due to previous errors
</code></pre>
<p>这个问题其实不是真正的错误信息,  真正的错误信息混杂在标准输出(stout)中, 重新执行命令并把<code>v</code>参数去掉即可看到真正问题所在.</p>
<pre><code class="language-bash">tar: Removing leading '/' from member names
#或
tar: Removing leading '/' from hard link targets
</code></pre>
<p>这个问题其实不影响程序的执行, 产生的原因是<code>tar</code>在压缩的过程中自动帮我们去掉了路径前的<code>/</code>, 也就是tar压缩后的包是按照相对路径压缩的.
当我们恢复时,  就需要通过 <code>-C</code> 参数手动指定解压到 <code>/</code> 目录,  如:</p>
<pre><code class="language-bash">tar zxvpf ubuntu_20170120_11.tar.bz2 -C /
</code></pre>
<p>可以使用<code>-P</code>参数来指定按照绝对路径打包:</p>
<pre><code class="language-bash">tar -cvpzf /media/Disk/myDisk/ubuntu_backup@`date +%Y-%m+%d`.tar.gz --exclude=/proc --exclude=/tmp --exclude=/home --exclude=/lost+found --exclude=/media --exclude=/mnt --exclude=/run -P /
</code></pre>
<p>另外, 如果出现</p>
<pre><code class="language-bash">tar: /dev/shm: file changed as we read it
或
tar: /run/udev/control: socket ignored
</code></pre>
<p>这个 <code>socket ignored</code> 产生的原因是压缩的过程中文件正在使用, 无需理会, 不影响压缩.</p>
<pre><code class="language-bash">tar: /run/user/1000/gvfs: Cannot stat: Permission denied
</code></pre>
<p>这个问题不用理会, 与虚拟文件系统有关, 不影响压缩.</p>
<p>Ubuntu系统U盘(livecd)方式备份</p>
<p>启动过程中从U盘启动, 采用试用Ubuntu系统的方式, 进入<code>livecd</code>模式(试用ubuntu)</p>
<pre><code class="language-bash">sudo su
fdisk -l
</code></pre>
<p>其中<code>boot</code>分区为<code>/dev/sda5</code>,<code>home</code>分区为<code>/dev/sda7</code>,主分区<code>/</code>为<code>/dev/sda8</code>.</p>
<p>分别进行挂载:</p>
<pre><code class="language-bash">mount /dev/sda5 /boot
mount /dev/sda7 /home
mount /dev/sda8 /mnt
</code></pre>
<p>再对移动硬盘进行挂载:</p>
<pre><code class="language-bash">mount /media/ubuntu/移动硬盘对应盘符 /data
</code></pre>
<p>进行备份:</p>
<pre><code class="language-bash">mksquashfs /mnt /data/ubuntu_main.sfs(文件名任意)
mksquashfs /home /data/ubuntu_home.sfs(文件名任意)
mksquashfs /boot /data/ubuntu_boot.sfs(文件名任意)
sync(让系统保存一下数据)
</code></pre>
<p>卸载硬盘:</p>
<pre><code class="language-bash">umount /data
umount /mnt
umount /home
umount /boot
</code></pre>
<p>到此备份成功.</p>
<h3 id="系统还原"><a class="header" href="#系统还原">系统还原</a></h3>
<p>系统备份的意义就在于系统哪天发生意外时可以系统还原拯救回来</p>
<p>这里有两种还原方式, 如果你系统出问题了, 但是还可以进入终端, 那就可以直接解压备份文件进行还原.
但是如果你连系统都不能登录了, 就要使用<code>LiveCD</code>(U盘启动盘)进行还原了.</p>
<h4 id="tar命令还原系统"><a class="header" href="#tar命令还原系统">tar命令还原系统</a></h4>
<pre><code class="language-bash"># 备份前先切换到`root`用户, 避免权限问题
sudo su
# 再切换到/(根目录)
cd /
# 还原
tar -xvpzf /media/Disk/myDisk/ubuntu_backup@2016-6-6.tar.gz -C /
</code></pre>
<p>注意先创建一个临时目录用于挂载你的<code>/</code>根目录分区, <code>sdaX</code>代表你的<code>/</code>根目录分区,
如果不知道就用<code>fdisk -l</code>查看一下, 另外如果你的移动硬盘没有被自动挂载, 你也需要手动创建一个临时目录进行挂载.</p>
<p>Note:
因为 tar还原是只会覆盖相同的文件, 但是这种方法只是恢复备份时的文件, 就是说如果某些文件丢失或损坏了, 这样可以恢复修复这些文件, 但不能删除自备份到恢复前这期间所生成的其它文件.
假如你备份系统时有<code>1234</code>这四个文件, 如果三天后, 由于某些原因变成了<code>1234'5</code>(<code>4</code>改变了), 你恢复后, 就会变成<code>12345</code>, 其中<code>4'</code>恢复成备份时的文件, <code>5</code>保留.
所以大家要是想彻底还原成备份时候的样子最好彻底删除根目录下的所有文件, 然后再还原, 这样就可以还原成备份时的样子了.
删除整个文件系统, 比如运行命令<code>rm -fr /*</code>, 那么你还原系统后一定要把你之前没有备份的目录手动创建, 不然重启系统是有问题的.</p>
<pre><code class="language-bash">mkdir proc tmp lost+found media mnt run
</code></pre>
<hr />
<p>进入 LiveCD 之后 还原系统</p>
<pre><code class="language-bash">#切换到root用户
sudo su
#进入到 / 目录
cd /
mkdir /mnt/sys
mount /dev/sdaX /mnt/sys
tar -xvpzf /media/myDisk/ubuntu_boot_backup@2016-6-6.tar.gz -C /mnt/sys
</code></pre>
<p>执行恢复命令之前请再确认一下你所键入的命令是不是你想要的, 执行恢复命令可能需要一段不短的时间.</p>
<p>恢复命令结束时, 你的工作还没完成, 别忘了重新创建那些在备份时被排除在外的目录:</p>
<pre><code class="language-bash">mkdir proc
mkdir lost+found
mkdir mnt
mkdir sys
</code></pre>
<p>等等</p>
<p>当你重启电脑, 你会发现一切东西恢复到你创建备份时的样子了!</p>
<h4 id="livecd-还原"><a class="header" href="#livecd-还原">livecd 还原</a></h4>
<p>还有一个稍微复杂点的<code>livecd</code>方式还原, 如下:</p>
<p>先要对之前的启动文件和分区文件做一个备份, 分别为<code>/etc/fstab</code>,<code>/etc/fstab.d</code>(可能没有),<code>/boot/grub/grub.cfg</code>:</p>
<pre><code class="language-bash">cp /etc/fstab /media/用户名/移动硬盘对应盘符/
cp /boot/grub/grub.cfg /media/用户名/移动硬盘对应盘符/
</code></pre>
<p>接下来进行恢复系统, 同样利用系统<code>u</code>盘进入<code>livecd</code>模式. 同样进入<code>root</code>模式, 查看分区情况</p>
<p>假设分区情况如上: <code>/dev/sda1</code>为<code>boot</code>分区, <code>/dev/sda2</code>为主分区, <code>/dev/sda3</code>为<code>home</code>分区. 对<code>home</code>分区和主分区进行格式化:</p>
<pre><code class="language-bash">sudo su
mkfs.ext4 /dev/sda2 # root
mkfs.ext4 /dev/sda3 # home
</code></pre>
<p>然后分别进行挂载:</p>
<pre><code class="language-bash">mount /dev/sda2 /mnt #挂载 root
# 新建home和boot文件:
mkdir /mnt/home
mkdir /mnt/boot
#挂载其他两个盘:
mount /dev/sda1 /mnt/boot #挂载 boot
mount /dev/sda3 /mnt/home # 挂载 home
# 挂载数据盘:
mkdir /rescovery/mnt
mkdir /rescovery/home
mkdir /rescovery/boot
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_main.sfs /rescovery/mnt  # 这里使用了 loop mount, 循环挂载
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_home.sfs /rescovery/home
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_boot.sfs /rescovery/boot
</code></pre>
<pre><code class="language-bash">cp -a /recovery/mnt/* /mnt
cp -a /recovery/home/* /mnt/home
cp -a /recovery/boot/* /mnt/boot
# 然后拷贝之前的fstab和grub.cfg文件到硬盘:
cp /media/ubuntu/移动硬盘盘符/fstab /mnt/etc/
cp /media/ubuntu/移动硬盘盘符/grub.cfg /mnt/boot/grub/
# 挂载虚拟文件系统, 这是为了后面修复引导做准备.
mount --bind /dev /mnt/dev
mount --bind /proc /mnt/proc
mount --bind /sys /mnt/sys
# chroot进入已经还原的操作系统.
chroot /mnt
</code></pre>
<h3 id="查看当前uuid"><a class="header" href="#查看当前uuid">查看当前UUID</a></h3>
<p>由于我们格式化了分区, 所以<code>UUID</code>发生了变化, 若不修改, 系统将无法正常挂载分区, 导致启动异常.
故需要修改本机系统的<code>UUID</code>设置,当前终端不要关闭, 新建一个终端, 输入<code>blkid</code>:</p>
<p>在<code>fstab</code>文件中更新上面两个新硬盘的<code>UUID</code>,在<code>chroot</code>过的端口输入:</p>
<pre><code class="language-bash">nano /etc/fstab
# 更改两个UUID, ctrl+x退出, Y保存. 进行grub的更新:
grub-install /dev/sda
update-grub
退出并卸载盘:
exit
umount /mnt/dev
umount /mnt/sys
umount /proc
sync
</code></pre>
<p>重启即可</p>
<h3 id="mount-简介"><a class="header" href="#mount-简介">mount 简介</a></h3>
<p><code>-o --options opts</code>:使用指定的安装选项.  <code>opts</code>参数是用逗号分隔的列表.  例如:</p>
<pre><code class="language-bash">mount LABEL=mydisk -o noatime,nodev,nosuid
</code></pre>
<p>复制文件:</p>
<p>在其他位置重新挂载文件结构的一部分.  语法是:</p>
<pre><code class="language-bash">mount --bind olddir newdir
</code></pre>
<p>或使用以下<code>fstab</code>条目:</p>
<pre><code class="language-bash">/olddir /newdir none bind
</code></pre>
<p>调用之后, 可以在两个位置访问相同的内容.</p>
<p>重要的是要理解<code>bind</code>不会在<code>kernel VFS</code>中创建任何<code>second-class </code>或<code>special node</code>.
<code>bind</code>只是<code>attach</code>文件系统的另一种操作. 没有一个特定的地方去记录哪些文件系统是通过<code>bind</code>附加到系统上的.
<code>olddir</code> 和 <code>newdir</code> 是独立的, 并且可以卸载<code>olddir</code>.</p>
<p>也可以将单个文件重新挂载(在单个文件上).  也可以使用<code>bind</code>从常规目录创建<code>mountpoint</code>, 例如:</p>
<pre><code class="language-bash">mount --bind foo foo
</code></pre>
<h2 id="texlive-lyx-相关"><a class="header" href="#texlive-lyx-相关">texlive lyx 相关</a></h2>
<h3 id="xelatex-脚本"><a class="header" href="#xelatex-脚本">xelatex 脚本</a></h3>
<p><a href="https://blog.csdn.net/donaldsy/article/details/99938408">shell 参数换行 &amp; shell 输出换行的方法</a></p>
<p>首先测试一下括号的用法:</p>
<pre><code class="language-bash">tex_list=1; echo $tex_list; tex_list=$( { ls -x *.tex } ); echo $tex_list;
tex_list=1; echo $tex_list; tex_list=$( ( ls -x *.tex ) ); echo $tex_list;
tex_list=$(ls -x *.tex; ls -x *.log); echo $tex_list;
tex_list=$( (ls -x *.tex; ls -x *.log) ); echo $tex_list;
</code></pre>
<pre><code class="language-bash">#!/bin/bash

# 设置格式化相关的部分
delimiter=&quot;echo -e \\\n+++++++++++++&quot;
nameis=&quot;name is :&quot;
eval  $delimiter

# 默认文件名是 main,否则使用文件夹中的tex文件名
tex_usual=&quot;main&quot;
echo &quot;tex_usual $nameis $tex_usual&quot;
eval  $delimiter

# 当前tex文件列表,去掉后缀

tex_list=$(ls -x *.tex)
echo &quot;tex_list $nameis $tex_list&quot;

tex_here=${tex_list//&quot;.tex&quot;/}
echo &quot;tex_here $nameis $tex_here&quot;
eval  $delimiter

# 判断当前tex文件列表中是否包含 main.tex
# 若有 main.tex,使用之,若没有,则使用 列表中的tex
# tex_file=${${tex_here}%% *}

if [[ $tex_usual =~ $tex_here ]]
then
    tex_file=$tex_usual
else
    tex_file=${tex_here}
fi

echo &quot;tex_file $nameis $tex_file&quot;
eval  $delimiter

# 可增加输出文件夹选项 -auxdir=temp -outdir=temp
# 还有 -shell-escape 选项

# 把下面这行加入到 ~/.latexmkrc,指定 pdf 查看程序
# $pdf_previewer = 'evince %O %S';
# -silent 可以抑制输出

latexmk -xelatex  -silent -pv  -view=pdf -bibtex -cd -recorder -file-line-error -halt-on-error -interaction=nonstopmode -synctex=1 -view=pdf ${tex_file}

## 输出错误记录
eval  $delimiter
echo 'error message'
eval  $delimiter
## 用 tail 减少输出数量
## grep -m 100 -i -n --color -P -B 0 -A 8 &quot;\[\d+\]&quot; ./$tex_file&quot;.log&quot; | tail -n 50
grep -m 10 -i -n --color -P -B 0 -A 8 &quot;\[\d+\]&quot; ./$tex_file&quot;.log&quot;
</code></pre>
<hr />
<p>默认情况下,<code>echo</code>关闭了对转义字符的解释,添加 <code>-e </code>参数可打开<code>echo</code>对转义字符的解释功能.<code>-E</code>关闭转义字符,是默认值.</p>
<pre><code class="language-bash">echo -e &quot;hello\n wrold&quot; #换行输出 hello world
echo -E &quot;hello\n wrold&quot; #输出 hello\n world, 默认情况
</code></pre>
<h3 id="texlive安装与卸载"><a class="header" href="#texlive安装与卸载">texlive安装与卸载</a></h3>
<hr />
<p><a href="https://blog.csdn.net/l2563898960/article/details/86774599">Linux环境下LaTex的安装与卸载</a>
<a href="https://blog.csdn.net/williamyi96/java/article/details/90732304">Ubuntu Texlive 2019 安装与环境配置</a>
<a href="https://zhuanlan.zhihu.com/p/64530166">TexLive 2019 安装指南</a>
<a href="https://tug.org/texlive/quickinstall.html">TeX Live - Quick install</a></p>
<hr />
<p>准备工作:下载,清除</p>
<p>注意:安装 <code>lyx</code>, <code>apt</code> 会默认安装 <code>tex2017</code>版本,覆盖掉新版的<code>texlive2020</code></p>
<p>注意:如果重新安装,请务必完全删除之前的失败安装,默认情况下,这将在这两个目录中:</p>
<pre><code class="language-bash">rm -rf /usr/local/texlive/2020
rm -rf ~/.texlive2020
</code></pre>
<p>或者参考下面的命令</p>
<pre><code class="language-bash">sudo rm -rf /usr/local/texlive/2020
rm -rf ~/.texlive2020
sudo rm -rf /usr/local/texlive
sudo rm -rf /usr/local/share/texmf
sudo rm -rf /var/lib/texmf
sudo rm -rf /etc/texmf
sudo apt-get purge texlive*
sudo apt-get remove tex-common --purge
</code></pre>
<hr />
<p>进行安装</p>
<p>因为下载好的是一个<code>iso</code>镜像文件,所以下载好之后,还需要挂载到<code>/mnt</code>目录下</p>
<pre><code class="language-bash">sudo mount -o ro,loop,noauto texlive2020-20200406.iso /mnt
</code></pre>
<ul>
<li><code>ro</code> :     Mount the filesystem read-only.</li>
<li><code>loop</code> : loop 文件</li>
<li><code>auto</code> :   Can be mounted with the -a option.</li>
<li><code>noauto</code> : Can only be mounted explicitly (i.e., the  -a  option  will  not cause the filesystem to be mounted).</li>
</ul>
<hr />
<p>接着运行<code>install-tl</code>脚本进行安装.</p>
<p>若要更改安装目录或其他选项,请阅读提示和说明.
一般需要更改路径到自己有读写权限的文件夹下面,按<code>D</code>,然后按<code>1</code>,输入比如<code>~/texlive/2020</code></p>
<p>更改目录到</p>
<ul>
<li>
<p><code>TEXDIR:         /home/tome/texlive/2020</code></p>
</li>
<li>
<p><code>main tree:      /home/tome/texlive/2020/texmf-dist</code></p>
</li>
<li>
<p><code>TEXMFLOCAL:     /home/tome/texlive/texmf-local</code></p>
</li>
<li>
<p><code>TEXMFSYSVAR:    /home/tome/texlive/2020/texmf-var</code></p>
</li>
<li>
<p><code>TEXMFSYSCONFIG: /home/tome/texlive/2020/texmf-config</code></p>
</li>
<li>
<p><code>TEXMFVAR:       ~/.texlive2020/texmf-var</code></p>
</li>
<li>
<p><code>TEXMFCONFIG:    ~/.texlive2020/texmf-config</code></p>
</li>
<li>
<p><code>TEXMFHOME:      ~/texmf</code></p>
</li>
</ul>
<pre><code class="language-bash">cd /tex_iso_directory
sudo ./install-tl --profile installation.profile
[... messages omitted ...]
Enter command: i
[... when done, see below for post-install ...]
</code></pre>
<p>安装程序的接口:文本,GUI,批处理
安装程序支持:文本,图形,和批处理接口.(Linux系统下没有图像安装,在Windows下支持图形安装)</p>
<p><code>install-tl -gui text #</code>使用简单文本模式.也是输入<code>install-tl</code>默认选项.</p>
<p><code>install-tl --profile=profile #</code>进行一个批处理安装,需要一个 <code>profile</code> (配置文件),为了创建一个<code>profile</code>,最简单的方式是使用<code>tlpkg/texlive.profile</code>文件,这是安装器在安装成功后生成的文件.</p>
<hr />
<p>卸载镜像文件</p>
<pre><code class="language-bash">sudo umount /mnt
</code></pre>
<hr />
<p>字体配置</p>
<pre><code class="language-bash">sudo cp /home/tom/texlive/2020/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/20-texlive.conf
sudo fc-cache -fsv
</code></pre>
<hr />
<p>环境变量</p>
<p>安装完之后有提示:</p>
<pre><code class="language-bash">Add /home/tom/texlive/2020/texmf-dist/doc/man to MANPATH.
Add /home/tom/texlive/2020/texmf-dist/doc/info to INFOPATH.
Most importantly, add /home/tom/texlive/2020/bin/x86_64-linux
to your PATH for current and future sessions.
</code></pre>
<p>我用的是<code>zsh</code>,如果用的是<code>bash</code>则修改<code>~/.bashrc</code>,其中的<code>/home/tom/texlive/2020</code>改称你安装时的路径
直接把下面的语句添加到<code>.zshrc</code>文件末尾.</p>
<pre><code class="language-bash">export MANPATH=${MANPATH}:/home/tom/texlive/2020/texmf-dist/doc/man
export INFOPATH=${INFOPATH}:/home/tom/texlive/2020/texmf-dist/doc/info
export PATH=${PATH}:/home/tom/texlive/2020/bin/x86_64-linux
</code></pre>
<hr />
<p>验证安装是否成功</p>
<pre><code class="language-bash">tex -v
</code></pre>
<hr />
<p>设置默认纸张尺寸</p>
<p><code>tlmgr paper letter</code></p>
<hr />
<p>ubuntu 仓库的texlive</p>
<p>使用<code>apt</code>命令从<code>ubuntu</code>仓库安装的<code>texlive</code>可以使用<code>dpkg -L texlive-full</code>查询</p>
<p>安装在 <code>/usr/local/</code>目录下,
<code>texmf</code>(TDS的根目录)在<code>/usr/share/texmf</code> and <code>/usr/share/texlive/texmf-dist</code></p>
<h3 id="texlive常用命令"><a class="header" href="#texlive常用命令">texlive常用命令</a></h3>
<p>用<code>texlive**.iso</code>手动安装的 texlive 是可以正常使用下面这些命令的,而用 <code>debian</code>源<code>apt</code>安装的,可能会出问题.</p>
<p><code>tlmgr [option]... action [option]... [operand]...</code></p>
<p>安装好 <code>texlive</code> 后</p>
<p>如果使用<code>tlmgr option</code> 报错
<code>cannot setup TLPDB in /home/USER/texmf at /usr/bin/tlmgr line 5308.</code></p>
<p>原因如下:</p>
<p>未初始化<code>tlmgr</code>时会产生此错误. 在大多数情况下,以普通用户身份启动以下命令可以解决此问题:</p>
<p><code>$ tlmgr init-usertree</code></p>
<p>此命令将在您的家目录内创建几个文件夹. 请参见手册页以获取解释:</p>
<blockquote>
<p>在用户模式下使用<code>tlmgr</code>之前,您必须使用<code>init-usertree</code>操作设置用户树.
这将创建<code>usertree / web2c</code>和<code>usertree / tlpkg / tlpobj</code>,以及最小的<code>usertree / tlpkg / texlive.tlpdb</code>.
此时,您可以通过添加<code>--usermode</code>命令行选项来告诉<code>tlmgr</code>执行(支持的)动作.</p>
</blockquote>
<hr />
<p>下面这些是<code>tlmgr</code>的常用命令:</p>
<ul>
<li><code>tlmgr option repository ctan</code></li>
<li><code>tlmgr option repository http://mirror.ctan.org/systems/texlive/tlnet</code></li>
<li><code>tlmgr repository list</code></li>
<li><code>tlmgr update --self</code></li>
<li><code>tlmgr update  --all</code></li>
</ul>
<p>如果要使用清华的<code>mirror</code>:</p>
<p><code>tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</code></p>
<p><a href="https://tug.org/texlive/">texlive home page</a>
<a href="https://tug.org/texlive/pkginstall.html">texlive installation and updates</a> texlive 安装和更新
<a href="https://www.texlive.info/tlnet-archive/">archive of tlnet </a> : 各个年份的 tex 更新, 可以选择用来更新的 repository 的版本
<a href="https://texlive.info/">texlive.info</a> 查看各种关于 texlive 的信息</p>
<p>告诉<code>tlmgr</code>使用附近的CTAN镜像进行将来的更新;  如果您从DVD映像安装了TeX Live,并且想要持续更新,则很有用.
这两个命令是等效的. <code>ctan</code>只是给定URL的别名.
注意: <code>mirror.ctan.org</code>解析为许多不同的主机,它们并没有完全同步. 我们建议仅(最多)每天更新一次,而不要更频繁.</p>
<ul>
<li><code>tlmgr update --list</code> 报告将要更新的内容,而无需实际更新任何内容.</li>
<li><code>tlmgr update --all</code> 使本地TeX安装与软件包存储库中的安装相对应(从CTAN更新时通常很有用).</li>
<li><code>tlmgr info pkg</code> 显示有关软件包内容的详细信息,例如搜索所有软件包中内容的安装状态和描述.</li>
</ul>
<p>可能遇到的错误:</p>
<p><a href="https://tex.stackexchange.com/questions/528634/tlmgr-unexpected-return-value-from-verify-checksum-5">tlmgr: unexpected return value from verify_checksum: -5</a></p>
<p>出现这个错误是由于某个<code>repository</code>的<code>signing key</code>过期了,
首先可以使用<code>tlmgr repository list</code>列出所有的库, 使用<code>tlmgr key list</code>列出所有的<code>keys</code></p>
<p>首先把<code>repository</code>更换到对应<code>debian</code>发行版的仓库, 比如使用 <code>2019</code> 版本的 <code>repository</code> ,
<code>tlmgr option repository https://www.texlive.info/tlnet-archive/2019/12/31/tlnet/</code></p>
<p>然后把<a href="https://www.tug.org/texlive/">tug</a>的 <code>GPG</code> key 加入到 <code>tlmgr</code> 的key 列表中</p>
<pre><code class="language-bash">curl -fsSL https://www.tug.org/texlive/files/texlive.asc | tlmgr key add -
</code></pre>
<p>这样就不会出现<code>erify_checksum: -5</code>错误了.</p>
<p>总结:</p>
<ul>
<li><code>tlmgr key list</code>列出所有的<code>key</code></li>
<li><code>tlmgr repository list</code>列出使用的仓库</li>
<li><code>curl -fsSL https://www.preining.info/rsa.asc | tlmgr key add -</code>为<code>contrib</code>仓库添加新的gpg key</li>
<li><code>tlmgr install  --verify-repo=none pkg</code> 免去验证</li>
</ul>
<p>curl -fsSL https://www.preining.info/rsa.asc | tlmgr key add -</p>
<h3 id="tlmgr-命令"><a class="header" href="#tlmgr-命令">tlmgr 命令</a></h3>
<hr />
<p><code>install [option]... pkg...</code></p>
<p>如果尚未安装,请安装命令行上给出的每个<code>pkg</code>.
(它不涉及现有软件包; 有关如何获取软件包的最新版本,请参见<code>更新</code>操作.)</p>
<p>默认情况下,这还会安装给定pkg所依赖的所有软件包. 选项:</p>
<ul>
<li><code>--dry-run</code> : 实际没有安装任何东西. 而是将要执行的动作写入终端.</li>
<li><code>--file</code>: 不从安装库中获取软件包, 使用命令行上给出的软件包文件. 这些文件必须是标准的<code>TeX Live</code>软件包文件(包含<code>tlpobj</code>文件).</li>
<li><code>--force</code>:如果存在对<code>tlmgr</code>本身(或基本基础结构的其他部分)的更新,
则除非给出此选项,否则<code>tlmgr</code>将退出紧急状态并且不会执行安装. 不建议.</li>
<li><code>--no-depends</code>:不要安装依赖项. (默认情况下,安装软件包可确保满足该软件包的所有依赖关系.)</li>
<li><code>--no-depends-at-all</code>:通常,当您安装附带二进制文件的软件包时,还将安装相应的二进制软件包.
也就是说,对于软件包<code>foo</code>,软件包<code>foo.i386-linux</code>也将安装在<code>i386-linux</code>系统上.
此选项抑制了这种行为,并且还暗示了<code>--no-depends</code>.
除非您确定自己在做什么,否则不要使用它.</li>
<li><code>--reinstall</code>:即使似乎已经安装了软件包(即TLPDB中已存在),也要重新安装软件包(包括集合的依赖项).
这对于从意外删除层次结构中的文件中恢复非常有用.</li>
</ul>
<hr />
<ul>
<li><code>conf [texmf|tlmgr|updmap [--conffile file] [--delete] [key [value]]]</code></li>
<li><code>conf auxtrees [--conffile file] [show|add|delete] [value]</code></li>
</ul>
<p>仅使用<code>conf</code>,即可显示TeX Live的常规配置信息,包括活动配置文件,路径设置等.
这就像运行<code>texconfig conf</code>一样,但是可以在所有支持的平台上运行.</p>
<p>使用<code>conf texmf</code>,<code>conf tlmgr</code>或<code>conf updmap</code>之一显示<code>ROOT / texmf.cnf</code>(用户特定的<code>tlmgr</code>配置)中保存的所有键/值对(即所有设置) 文件(请参见下文)或第一个(通过<code>kpsewhich</code>找到的)<code>updmap.cfg</code>文件.</p>
<p><code>conf</code>显示的<code>PATH</code>值与<code>tlmgr</code>使用的值相同. 包含<code>tlmgr</code>可执行文件的目录会自动添加到从环境继承的PATH值之前.</p>
<p>这是更改配置值的实际示例. 如果在安装过程中启用了通过<code>\ write18</code>执行的(部分或全部)系统命令,则可以在以后将其禁用:</p>
<pre><code class="language-bash">tlmgr conf texmf shell_escape 0
</code></pre>
<p>子命令<code>auxtrees</code>允许完全在用户控制下添加和删除任意其他texmf树.
<code>auxtrees show</code>显示其他树的列表,<code>auxtrees add</code>树将树添加到列表中,<code>auxtrees remove</code>树从列表中删除树(如果存在).</p>
<p>树中不应包含<code>ls-R</code>文件(否则,如果<code>ls-R</code>过时,则可能找不到文件).
通过操作<code>ROOT / texmf.cnf</code>中的Kpathsea变量<code>TEXMFAUXTREES</code>来生效. 例:</p>
<pre><code class="language-bash">tlmgr conf auxtrees add /quick/test/tree
tlmgr conf auxtrees remove /quick/test/tree
</code></pre>
<p>在所有情况下,如果需要,都可以通过选项<code>--conffile</code>文件显式指定配置文件.</p>
<p>警告: 此处是用于更改配置值的一般工具,但是强烈建议不要以这种方式修改设置.
同样,不对键或值进行错误检查,因此可能发生任何破损.</p>
<h3 id="手动安装宏包"><a class="header" href="#手动安装宏包">手动安装宏包</a></h3>
<p>如果无法使用<code>tlmgr</code>自动安装宏包, 例如<code>ubuntu</code>自带的<code>texlive</code>, 默认的版本比远程仓库中的低, 无法自动升级.
可以直接从网上下载想要安装的宏包, 大部分宏包已经打包成标准格式, 例如<code>siunitx.tds.zip</code>, <a href="https://www.ctan.org/pkg/siunitx">siunitx</a>.
直接解压到<code>texlive</code>的安装目录即可.</p>
<p>如何定位安装目录呢? 可以参考<a href="http://www.tug.org/fonts/fontinstall.html">Installing TeX fonts</a>, 虽然这个文章主要是介绍安装字体的.
使用类似下面的命令找出<code>texlive</code>的安装目录.</p>
<pre><code class="language-bash">kpsewhich --var-value TEXMF
tlmgr conf # 这个会输出texlive大部分配置的信息
</code></pre>
<p>我电脑上<code>texlive</code>安装在<code>/usr/share/texmf </code>, 这是共享目录, 如果安装在这里, 所有账户都能使用.
此外在家目录下, 即<code>/home/tom/texmf</code>还有一个用户目录树, 建议把宏包解压到这里, 不会影响<code>ubuntu</code>自带的发行版.
如果你的<code>home</code>没有这个文件夹, 可以运行<code>tlmgr init-usertree</code>产生一个.
由于路径中<code>/home/tom/texmf</code>在前面, 把宏包装在这里, 就会被优先使用.</p>
<h3 id="jabref"><a class="header" href="#jabref">jabref</a></h3>
<p><a href="https://blog.csdn.net/zd0303/article/details/7676807">JabRef中文手册</a></p>
<p>entry 时间戳</p>
<p>本功能可以在<code>选项-&gt;偏好设置-&gt;通用设置</code>中关闭或配置. <code>JabRef</code>能自动的产生一个包含题录加入数据库的日期的域.</p>
<p>格式:</p>
<p>时间戳记的格式由包含指示词的字符串确定,指示词表示日期各部分的位置.
以下是一些可用的指示字母(示例在括号中给出,为:  2005年9月14日(星期三)下午5.45):</p>
<ul>
<li>yy: year (05)</li>
<li>yyyy: year (2005)</li>
<li>MM: month (09)</li>
<li>dd: day in month (14)</li>
<li>HH: hour in day (17)</li>
<li>mm: minute in hour (45)</li>
</ul>
<p>这些指示符可以与标点符号和空格一起使用. 几个例子:</p>
<ul>
<li><code>yyyy.MM.dd gives 2005.09.14</code></li>
<li><code>yy.MM.dd gives 05.09.14</code></li>
<li><code>yyyy.MM.dd HH:mm gives 2005.09.14 17:45</code></li>
</ul>
<h3 id="lyx-报错"><a class="header" href="#lyx-报错">lyx 报错</a></h3>
<hr />
<p>如果桌面环境使用<code>Gnome</code>默认, 也就是<code>Wayland</code>协议, 默认<code>ibus</code>输入法在<code>lyx</code>下无法使用. 报错为</p>
<pre><code class="language-bash">Warning: Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run on Wayland anyway.
</code></pre>
<p>按照<a href="https://zh.opensuse.org/SDB:%E5%9C%A8_Wayland_%E4%B8%AD%E5%90%AF%E7%94%A8%E8%BE%93%E5%85%A5%E6%B3%95">SDB:在 Wayland 中启用输入法</a>
操作仍然不行.</p>
<p>进入 <code>KDE</code> 或 <code>GNOME</code> 的 <code>Wayland</code> 会话之后, 您可能会发现输入法(Fcitx 或 iBus)无法使用.
最新的稳定版 <code>Fcitx</code> 和 <code>iBus</code> 都已经了基本的 <code>Wayland</code> 支持, 通过 X 的协议转接实现.
<code>Wayland</code> 读取的环境配置文件是<code>/etc/environment</code> 而不是 <code>X</code> 所读取的环境变量文件. 因此对 <code>X</code> 有效的输入法配置在 <code>Wayland</code> 上不起效果了. 以管理员权限编辑它:</p>
<pre><code class="language-bash">sudo vi /etc/environment
</code></pre>
<p>这个文件应该是空的, 只有几行注释. 添加下面几行, 以 <code>Fcitx</code> 为例:</p>
<pre><code class="language-bash">INPUT_METHOD=fcitx
GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
</code></pre>
<p>如果您使用 iBus 的话, 那么应该添加这几行:</p>
<pre><code class="language-bash">INPUT_METHOD=ibus
GTK_IM_MODULE=ibus
QT_IM_MODULE=ibus
XMODIFIERS=@im=ibus
</code></pre>
<p>之后请重启您的系统.</p>
<hr />
<p>有时安装好了texlive,也安装好了<code>lyx</code>,却仍然报错,这个时候一般是因为路径(<code>$PATH</code>)没有配置好,
lyx没有检测到texlive的各种文件.参考 <a href="https://wiki.lyx.org/uploads//LyX/Manuals/1.6.4//Manuals.pdf">LYX Manuals</a></p>
<p><code>LYX</code>的一些功能可以从<code>LYX</code>内部进行配置,而无需重新配置文件.
首先,<code>LYX</code>能够检查您的系统,以查看可以使用哪些程序,<code>LATEX</code>文档类和<code>LATEX</code>软件包.
它使用此知识为多个<code>Preferences</code>设置提供合理的默认值.
尽管在系统上安装<code>LYX</code>时已经完成了此配置,但是您可能需要在本地安装一些项目,
新的<code>LATEX</code>类,而<code>LYX</code>看不到这种变化.
要强制LYX重新检查系统,您应该使用<code>Tools,Reconfigure</code>. 然后,您应该重新启动<code>LYX</code>以确保考虑到更改.</p>
<p>添加<code>tex</code>文件的路径到<code>$PATH</code>中的时候,注意尽量把新的<code>tex</code>路径添加到<code>$PATH</code>前面,
以防止之前安装的残留掩盖新的路径.也就是,</p>
<pre><code class="language-bash">if [[ $SHELL == &quot;/bin/zsh&quot; ]] ;then
echo &quot;\n# add texlive paths&quot; &gt;&gt; ~/.zshrc
echo &quot;export MANPATH=your_texlive_path/texmf-dist/doc/man:${MANPATH}&quot; &gt;&gt; ~/.zshrc
echo &quot;export INFOPATH=your_texlive_path/texmf-dist/doc/info:${INFOPATH}&quot; &gt;&gt; ~/.zshrc
echo &quot;export PATH=your_texlive_path/bin/x86_64-linux:${PATH}&quot; &gt;&gt; ~/.zshrc
fi
</code></pre>
<p>直接使用<code>apt</code>仓库安装的<code>texlive</code>套装和<code>lyx</code>一般没有问题.</p>
<h3 id="lyx-默认pdf查看"><a class="header" href="#lyx-默认pdf查看">lyx 默认pdf查看</a></h3>
<p>在<code>tools-preferences-File Handling-File Formats</code></p>
<p>在 <code>Format</code> 一栏中选中<code>PDF(XeTex)</code>  或者其他想要更改的格式,然后在 <code>Viewer</code>中更改程序,或者自定义程序位置.</p>
<h3 id="latexmk-选项"><a class="header" href="#latexmk-选项">latexmk 选项</a></h3>
<p>一般来说, <code>latexmk</code> 的通用<code>cmd</code>命令形式为:</p>
<p><code>latexmk [options] [file]</code></p>
<p>所有的选项可以用单个<code>-</code>连字符,也可以用双连字符<code>--</code>引入,e.g., &quot;latexmk -help&quot; or &quot;latexmk --help&quot;.</p>
<hr />
<p>注意:</p>
<p>除了文档里列出的选项, <code>latexmk</code>认识几乎所有the options recognized by the latex, pdflatex programs (and their relatives),
在当前的 TexLive and MikTeX 发行版中.</p>
<p>这些程序的一些选项还会引起 latexmk 的特殊 action or behavior,在本文档中有解释.否则,它们被直接传递给latex or pdflatex.
run <code>latexmk -showextraoptions</code>给出选项列表,这些选项被直接传递给latex or pdflatex.</p>
<hr />
<p>注意:</p>
<p>&quot;Further processing&quot; 意味着需要运行其他程序,或者再次运行<code>latex</code>(etc),如果没有 <code>errors</code> 的话.
如果你不想让<code>latex</code>在遇到错误的时候停下,应该使用 latexmk's option <code>-interaction=nonstopmode</code></p>
<p><code>-xelatex</code>  使用<code>xelatex</code>编译
<code>-pv </code>   - preview document.  (Side effect turn off continuous preview)
<code> -pv-</code>   - turn off preview mode
<code>-pvc</code>   - preview document and continuously update.  (This also turns  on force mode, so errors do not cause latexmk to stop.)
(Side effect: turn off ordinary preview mode.)
<code>-pvc-</code>  - turn off -pvc</p>
<p><code>-view=default</code> - viewer is default (dvi, ps, pdf)
<code>-view=ps</code>      - viewer is for ps
<code>-view=pdf</code>     - viewer is for pdf</p>
<p><code>-bibtex</code>       - use bibtex when needed (default)
<code>-bibtex-</code>      - never use bibtex</p>
<p><code>-cd</code>    - Change to directory of source file when processing it</p>
<p><code>-recorder</code> - Use -recorder option for (pdf)latex (to give list of input and output files)
<code> -recorder-</code> - Do not use -recorder option for (pdf)latex</p>
<hr />
<p>简单传递的命令</p>
<p><code>-error-line=n</code> set the width of context lines on terminal error messages
<code>-half-error-line=n</code>      set the width of first lines of contexts in terminal error messages</p>
<p><code>-file-line-error </code>       enable <code>file:line:error</code> style messages
<code>-halt-on-error</code>          stop processing at the first error
<code>-interaction=STRING</code>     set interaction mode (STRING=batchmode/nonstopmode/scrollmode/errorstopmode)
<code>-synctex=NUMBER</code>         generate <code>SyncTeX</code> data for previewers if nonzero</p>
<h3 id="安装latex包"><a class="header" href="#安装latex包">安装latex包</a></h3>
<p><a href="https://blog.csdn.net/codeforces_sphinx/article/details/7315044">Ubuntu/Mint下LaTeX宏包安装及更新</a></p>
<p>一般使用texlive的包管理工具,否则需要手动安装:</p>
<ol>
<li>Get the package from <a href="http://www.ctan.org/CTAN">CTAN</a> or wherever.</li>
<li>如果其中有一个文件是<code>.ins</code> 结尾的,打开终端,执行命令<code>latex foiltex.ins</code>,就获得了安装需要的包.大多数 latex 包没有打包,所以可以跳过这一步.</li>
<li>现在你需要决定,这个包要安装给所有用户使用,还是only for you.</li>
<li>在*nix 系统上(OSX),给所有用户使用,安装到<code>local</code> TeX tree, 给自己使用,安装到<code>user</code>TeX tree.</li>
</ol>
<p>查看<code>texmf.cnf</code>文件,它通常在<code>$TEXMF/web2c</code>文件夹,但是可以用<code>kpsewhich texmf.cnf</code>定位.</p>
<p><code>local</code> Tree 的位置在 <code>TEXMFLOCAL</code> variable 中定义,通常像是<code>/usr/local/share/texmf</code>.
<code>user</code>  Tree 的位置在<code>TEXMFHOME</code>中定义,通常像是<code>$HOME/texmf</code> or <code>$HOME/.texliveXXXX</code></p>
<p>如果这些变量没有定义,你需要手工指定.修改<code>local</code> Tree 可能需要 root 权限.建议修改 user tree, 因为在升级的时候,不会被覆盖.这样在备份系统的时候,可以一起备份.</p>
<p>现在,你需要告诉 Latex 有新文件.这取决于 LaTex 发行版.</p>
<ol>
<li>
<p>对于 TeXLive,运行<code>texhash</code>,可能需要 root 权限</p>
</li>
<li>
<p>对于MikTeX,运行 <code>Settings (Admin)</code> and press the button marked <code>Refresh FNDB</code></p>
</li>
<li>
<p>最后,你需要告诉 LyX 有新的包可以使用.在LyX 中,运行 <code>Tools-&gt;Reconfigure</code> and then restart LyX</p>
</li>
</ol>
<p>现在,新的文档 class 可以选择了,<code>Document-&gt;Settings-&gt;Document Class</code>.</p>
<h3 id="latex包安装方式2"><a class="header" href="#latex包安装方式2">latex包安装方式2</a></h3>
<p>首先要找到默认宏包所在目录,一般是:</p>
<pre><code class="language-bash">/usr/share/texmf/tex/latex
/usr/share/texmf-texlive/tex/latex
</code></pre>
<ol>
<li>如果是安装一个新的宏包,就直接把宏包的压缩文件扔进第一个目录下,直接解压就行,注意解压后的文件里可能有安装说明,照着安装说明做就是了.
如果是更新一个宏包,一般都可以在第二个目录下找到,把原先的宏包重命名成<code>*-backup</code>,再解压新下载的宏包压缩文件,同时如果有安装说明的话,也照着做.</li>
<li>之后要对宏包重新标记下,终端下执行</li>
</ol>
<pre><code class="language-bash"># texhash
</code></pre>
<p><code>Log off/Log in</code>后,就完成了~</p>
<h3 id="latex-pdf-裁剪"><a class="header" href="#latex-pdf-裁剪">latex pdf 裁剪</a></h3>
<p><code>texlive</code> 自带了一个叫做 <code>pdfcrop</code> 的 <code>perl</code> 脚本</p>
<p>使用方法如下:</p>
<p><code>pdfcrop --margins 3 --clip input.pdf output.pdf; </code> 或者</p>
<pre><code class="language-bash">pdfcrop --clip --bbox '120 480 570 830' input.pdf output.pdf;
pdfcrop --clip --bbox '60 660 516 775' moban.pdf moban_crop.pdf &amp;&amp; evince moban_crop.pdf  # 国科大试卷的裁减参数
</code></pre>
<p>四个数字的含义是,以左下角为原点,给出<code>left bottom right top</code>的数值,单位是<code>point</code></p>
<p><code>1 point</code>=<code>0.3527 mm</code>=<code>1/72 inch</code>.
A4纸张(mm) <code>210</code> * <code>297</code>=<code>595.4 point</code>*<code>842.1 point</code>.</p>
<h2 id="loop-设备"><a class="header" href="#loop-设备">loop 设备</a></h2>
<p>loop 设备 (循环设备)</p>
<p><a href="https://blog.csdn.net/neiloid/article/details/8150629">loop 设备 (循环设备)</a></p>
<h3 id="loop-设备介绍"><a class="header" href="#loop-设备介绍">loop 设备介绍</a></h3>
<p>在类 UNIX 系统里,<code>loop</code> 设备是一种伪设备(pseudo-device),或者也可以说是仿真设备.它能使我们像块设备一样访问一个文件.</p>
<p>在使用之前,一个 <code>loop</code> 设备必须要和一个文件进行连接.这种结合方式给用户提供了一个替代块特殊文件的接口.因此,如果这个文件包含有一个完整的文件系统,那么这个文件就可以像一个磁盘设备一样被 <code>mount</code> 起来.</p>
<p>上面说的文件格式,我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 <code>*.img</code> 镜像文件.通过这种 <code>loop mount</code> (回环<code>mount</code>)的方式,这些镜像文件就可以被 <code>mount</code> 到当前文件系统的一个目录下.</p>
<p>至此,顺便可以再理解一下 <code>loop</code> 的含义:对于第一层文件系统,它直接安装在我们计算机的物理设备之上;
而对于这种被 <code>mount</code> 起来的镜像文件(它也包含有文件系统),它是建立在第一层文件系统之上,
这样看来,它就像是在第一层文件系统之上再绕了一圈的文件系统,所以称为 <code>loop</code>.</p>
<p>在 Linux 里,<code>loop</code> 设备的设备名形如:</p>
<pre><code class="language-bash">ls /dev/loop*
/dev/loop0  /dev/loop2  /dev/loop4  /dev/loop6
/dev/loop1  /dev/loop3  /dev/loop5  /dev/loop7
... ...
</code></pre>
<p>例如,要在一个目录下 mount 一个包含有磁盘镜像的文件,需要分 2 步走:</p>
<pre><code class="language-bash">losetup /dev/loop0 disk.img           #使磁盘镜像文件与循环设备连结起来
mount /dev/loop0 /home/groad/disk_test   #将循环设备 mount 到目录 disk_test 下
</code></pre>
<p>经过上面的两个命令后,镜像文件就如同一个文件系统挂载在 <code>disk_test</code> 目录下,当然我们也可以往镜像里面添加文件.</p>
<p>其实上面的两个步骤可以写成一个步骤:</p>
<pre><code class="language-bash">mount -t minix -o loop ./disk.img ./disk_test
</code></pre>
<h2 id="snap"><a class="header" href="#snap">snap</a></h2>
<p><a href="https://www.jianshu.com/p/4049b97151a1">Ubuntu使用snap安装常用软件</a></p>
<p>什么是<code>snap</code>, <code>snap</code>是一种全新的软件包管理方式, 它类似一个容器拥有一个应用程序所有的文件和库, 各个应用程序之间完全独立.
所以使用<code>snap</code>包的好处就是它解决了应用程序之间的依赖问题, 使应用程序之间更容易管理. 但是由此带来的问题就是它占用更多的磁盘空间.</p>
<p><code>Snap</code>的安装包扩展名是<code>.snap</code>, 类似于一个容器, 它包含一个应用程序需要用到的所有文件和库(<code>snap</code>包包含一个私有的<code>root</code>文件系统, 里面包含了依赖的软件包).
它们会被安装到单独的目录; 各个应用程序之间相互隔离. 使用<code>snap</code>有很多好处, 首先它解决了软件包的依赖问题; 其次, 也使应用程序更容易管理.</p>
<p>现在支持<code>snap</code>的应用并不多, <code>snap</code>软件包一般安装在<code>/snap</code>目录下.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-1-systemd"><a class="header" href="#linux-1-systemd">linux-1-systemd</a></h1>
<h2 id="bash-快捷键"><a class="header" href="#bash-快捷键">bash 快捷键</a></h2>
<p><a href="https://linux.cn/article-5660-1.html">Bash 快捷键大全 </a>
<a href="https://www.cnblogs.com/cocoliu/p/6369749.html">vim ,vi总是卡死,终于找到原因了.</a></p>
<ul>
<li><code>Alt+tab</code>:切换程序</li>
<li><code>Alt+`</code>:切换程序的不同窗口</li>
</ul>
<p>在<code>vim</code>下,有时候不小心按下了<code>CTRL-S</code>--<code>Suspend(XOFF)</code>,会冻结终端的输入,表现为按什么键都没有反应,这时候按下<code>CTRL-Q</code>即可恢复.</p>
<h3 id="常用的"><a class="header" href="#常用的">常用的</a></h3>
<table><thead><tr><th>快捷键</th><th>快捷键说明</th></tr></thead><tbody>
<tr><td><code>CTRL-/</code></td><td>撤消操作,Undo.</td></tr>
<tr><td><code>ALT-B</code></td><td>光标往回跳一个词,词以非字母为界(跳动到当前光标所在词的开头).</td></tr>
<tr><td><code>ALT-F</code></td><td>光标往前跳一个词(移动到光标所在词的末尾).</td></tr>
<tr><td><code>ALT-D</code></td><td>删除光标所在位置到光标所在词的结尾位置的所有内容</td></tr>
<tr><td><code>ALT-BASKSPACE</code></td><td>删除光标所在位置到词开头的所有内容.</td></tr>
<tr><td><code>ALT-数值</code></td><td>这个数值可以是正或者是负,这个键单独没有作用,必须后面再接其他内容,如果后面是字符,则表示重复次数.如:<code>[ALT-9,k]</code>则光标位置会插入<code>9</code>个<code>k</code>字符(负值在这种情况下无效); 如果后面接的是命令,则数字会影响后面命令的执行结果,如:<code>[ALT-9,CTRL-D]</code>则向<code>CTRL-D</code>默认方向相反(负数)的方向执行<code>9</code>次操作.</td></tr>
<tr><td><code>ALT-&lt;</code></td><td>移动到历史记录中的第一行命令.</td></tr>
<tr><td><code>ALT-&gt;</code></td><td>移动到历史的最后一行,即当前正在输入的行(没有输入的情况下为空).</td></tr>
<tr><td><code>ALT-P</code></td><td>从当前行开始向前搜索,有必要则向&quot;上&quot;移动,移动时,使用非增量搜索查找用户提供的字符串.</td></tr>
<tr><td><code>ALT-N</code></td><td>从当前行开始向后搜索,如果有必要向&quot;下&quot;移动,移动时,使用非增量搜索查找用户提供的字符串.</td></tr>
<tr><td><code>ALT-?</code></td><td>列出能够补全标志点前的条目.</td></tr>
<tr><td><code>ALT-C</code></td><td>将光标所在位置的字母转为大写</td></tr>
<tr><td><code>ALT-U</code></td><td>将光标所在位置到词尾的所有字母转为大写.</td></tr>
<tr><td><code>ALT-L</code></td><td>将光标位置到词尾的所有字母转为小写.</td></tr>
<tr><td><code>ALT-R</code></td><td>取消所有变更,并将当前行恢复到在历史记录中的原始状态</td></tr>
<tr><td><code>ALT-T</code></td><td>当光标两侧都存在词的时候,交换光标两侧词的位置.如:`abc <ALT-T>bcd -&gt; bcd abc</td></tr>
<tr><td><code>ALT-.</code></td><td>使用前一次命令的最后一个词(命令本身也是一个词,参见后一篇的Bang命令中的词指示符概念).</td></tr>
<tr><td><code>CTRL-A</code></td><td>将光标移到行首(在命令行下)</td></tr>
<tr><td><code>CTRL-C</code></td><td>中断,终结一个前台作业.</td></tr>
<tr><td><code>CTRL-E</code></td><td>将光标移动到行尾(在命令行下)</td></tr>
<tr><td><code>CTRL-K</code></td><td>在控制台或 xterm 窗口输入文本时,<code>CTRL-K</code>会删除从光标所在处到行尾的所有字符.</td></tr>
<tr><td><code>CTRL-U</code></td><td>擦除从光标位置开始到行首的所有字符内容.</td></tr>
<tr><td><code>CTRL-W</code></td><td><code>CTRL-W</code> 会删除从在光标处往回的第一个空白符之间的内容</td></tr>
<tr><td><code>CTRL-Y</code></td><td>将之前已经清除的文本粘贴回来(主要针对<code>CTRL-U</code>或<code>CTRL-W</code>).</td></tr>
<tr><td><code>CTRL-N</code></td><td>每按一次,是更接近的一条命令.</td></tr>
<tr><td><code>CTRL-P</code></td><td>此快捷键召回的顺序是由近及远的召回,</td></tr>
<tr><td><code>ALT-*</code></td><td>把能够补全[<code>ALT-?</code>]命令能生成的所有文本条目插入到标志点前.</td></tr>
<tr><td><code>CTRL-Q</code></td><td><code>Resume (XON)</code>.恢复/解冻,这个命令是恢复终端的stdin用的,可参见<code>CTRL-S</code>.</td></tr>
<tr><td><code>CTRL-R</code></td><td>回溯搜索(Backwards search)history缓冲区内的文本(在命令行下).注意:按下之后,提示符会变成<code>(reverse-i-search)'':</code>输入的搜索内容出现在单引号内,同时冒号后面出现最近最匹配的历史命令.</td></tr>
<tr><td><code>CTRL-S</code></td><td><code>Suspend(XOFF)</code>,挂起.这个是冻结终端的<code>stdin</code>.要恢复可以按<code>CTRL-Q</code>.</td></tr>
<tr><td><code>CTRL-T</code></td><td>交换光标位置与光标的前一个位置的字符内容(在命令行下)</td></tr>
<tr><td><code>CTRL-\</code></td><td>退出.和<code>CTRL-C</code>差不多,也可能dump一个&quot;core&quot;文件到你的工作目录下(这个文件可能对你没用).</td></tr>
</tbody></table>
<hr />
<p>terminal 快捷键</p>
<table><thead><tr><th>快捷键</th><th>快捷键说明</th></tr></thead><tbody>
<tr><td><code>Ctrl+Shift+t</code></td><td>new tab</td></tr>
<tr><td><code>Ctrl+Shift+n</code></td><td>new window</td></tr>
<tr><td><code>Ctrl+Shift+w</code></td><td>close tab</td></tr>
<tr><td><code>Ctrl+Shift+q</code></td><td>close window</td></tr>
<tr><td><code>Ctrl+page up</code></td><td>switch to previous tab</td></tr>
<tr><td><code>Ctrl+Shift+page up</code></td><td>switch to the left</td></tr>
</tbody></table>
<h3 id="广泛的"><a class="header" href="#广泛的">广泛的</a></h3>
<table><thead><tr><th>快捷键</th><th>快捷键说明</th></tr></thead><tbody>
<tr><td><code>CTRL-A</code></td><td>将光标移到行首(在命令行下)</td></tr>
<tr><td><code>CTRL-B</code></td><td>退格 (非破坏性的),这个只是将光标位置往回移动一个位置.</td></tr>
<tr><td><code>CTRL-C</code></td><td>中断,终结一个前台作业.</td></tr>
<tr><td><code>CTRL-D</code></td><td>&quot;EOF&quot; (文件结尾:end of file).它用于表示标准输入(<code>stdin</code>)的结束.</td></tr>
<tr><td><code>CTRL-E</code></td><td>将光标移动到行尾(在命令行下)</td></tr>
<tr><td><code>CTRL-F</code></td><td>将光标向前移动一个字符(在命令行下)</td></tr>
<tr><td><code>CTRL-G</code></td><td><code>BEL</code>.在一些老式打印机终端上,这会引发一个响铃.在xterm终端上可能是哔的一声.</td></tr>
<tr><td><code>CTRL-H</code></td><td>擦除(Rubout)(破坏性的退格).在光标往回移动的时候,同时擦除光标前的一个字符.</td></tr>
<tr><td><code>CTRL-I</code></td><td>水平制表符.</td></tr>
<tr><td><code>CTRL-J</code></td><td>新行(<code>换行[line feed]</code>并到行首).在脚本中,也可能表示为八进制形式(<code>'\012'</code>)或十六进制形式(<code>'\x0a'</code>).</td></tr>
<tr><td><code>CTRL-K</code></td><td>垂直制表符(Vertical tab).在控制台或 xterm 窗口输入文本时,<code>CTRL-K</code>会删除从光标所在处到行尾的所有字符.</td></tr>
<tr><td><code>CTRL-L</code></td><td>跳纸,换页(Formfeed),清屏.清空终端屏幕.在终端上,这个命令的作用和<code>clear</code>命令一样.但当这个命令发送到打印机时,<code>Ctrl-L</code>会直接跳到纸张(Paper sheet)的末尾.</td></tr>
<tr><td><code>CTRL-M</code></td><td>回车(Carriage return).</td></tr>
<tr><td><code>CTRL-N</code></td><td>擦除从history缓冲区召回的一行文本(在命令行下).如果当前输入是历史记录中选择的时候,这个是从这个历史记录开始,每按一次,是更接近的一条命令.</td></tr>
<tr><td><code>CTRL-O</code></td><td>产生一个新行(在命令行下).</td></tr>
<tr><td><code>CTRL-P</code></td><td>从history缓冲区召回上一次的命令(在命令行下).此快捷键召回的顺序是由近及远的召回,即按一次,召回的是前一次的命令,再按一次,是召回上一次之前的命令,这和<code>CTRL-N</code>都是以当前的输入为起点,但是两个命令操作刚好相反,<code>CTRL-N</code>是从起点开始由远及近(如果起点是历史命令的话).</td></tr>
<tr><td><code>CTRL-Q</code></td><td><code>Resume (XON)</code>.恢复/解冻,这个命令是恢复终端的stdin用的,可参见<code>CTRL-S</code>.</td></tr>
<tr><td><code>CTRL-R</code></td><td>回溯搜索(Backwards search)history缓冲区内的文本(在命令行下).注意:按下之后,提示符会变成<code>(reverse-i-search)'':</code>输入的搜索内容出现在单引号内,同时冒号后面出现最近最匹配的历史命令.</td></tr>
<tr><td><code>CTRL-S</code></td><td><code>Suspend(XOFF)</code>,挂起.这个是冻结终端的<code>stdin</code>.要恢复可以按<code>CTRL-Q</code>.</td></tr>
<tr><td><code>CTRL-T</code></td><td>交换光标位置与光标的前一个位置的字符内容(在命令行下).比如:<code>echo $var;</code>,假设光标在<code>a</code>上,那么,按下<code>C-T</code>之后,<code>v</code>和<code>a</code>将会交换位置:<code>echo $avr;</code>.</td></tr>
<tr><td><code>CTRL-U</code></td><td>擦除从光标位置开始到行首的所有字符内容.在某些设置下,<code>CTRL-U</code>会不以光标位置为参考而删除整行的输入.</td></tr>
<tr><td><code>CTRL-V</code></td><td>在输入文本的时候,按下<code>C-V</code>之后,可以插入控制字符.比如:<code>echo -e '\x0a';</code>和<code>echo &lt;CTRL-V&gt;&lt;CTRL-J&gt;;</code>这两种效果一样.这点功能在文本编辑器内非常有效.</td></tr>
<tr><td><code>CTRL-W</code></td><td>当在控制台或一个xterm窗口敲入文本时, <code>CTRL-W</code> 会删除从在光标处往后(回)的第一个空白符之间的内容.在某些设置里, <code>CTRL-W</code> 删除光标往后(回)到第一个非文字和数字之间的字符.</td></tr>
<tr><td><code>CTRL-X</code></td><td>在某些文字处理程序中,这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中.</td></tr>
<tr><td><code>CTRL-Y</code></td><td>将之前已经清除的文本粘贴回来(主要针对<code>CTRL-U</code>或<code>CTRL-W</code>).</td></tr>
<tr><td><code>CTRL-Z</code></td><td>暂停一个前台的作业; 在某些文本处理程序中也作为替换操作; 在MSDOS文件系统中作为EOF(End-of-file)字符.</td></tr>
<tr><td><code>CTRL-\</code></td><td>退出.和<code>CTRL-C</code>差不多,也可能dump一个&quot;core&quot;文件到你的工作目录下(这个文件可能对你没用).</td></tr>
<tr><td><code>CTRL-/</code></td><td>撤消操作,Undo.</td></tr>
<tr><td><code>CTRL-_</code></td><td>撤消操作.</td></tr>
<tr><td><code>CTRL-xx</code></td><td>在行首和光标两个位置间进行切换,此处是两个<code>&quot;x&quot;</code>字符.</td></tr>
<tr><td><code>ALT-B</code></td><td>光标往回跳一个词,词以非字母为界(跳动到当前光标所在词的开头).</td></tr>
<tr><td><code>ALT-F</code></td><td>光标往前跳一个词(移动到光标所在词的末尾).</td></tr>
<tr><td><code>ALT-D</code></td><td>删除光标所在位置到光标所在词的结尾位置的所有内容(如果光标是在词开头,则删除整个词).</td></tr>
<tr><td><code>ALT-BASKSPACE</code></td><td>删除光标所在位置到词开头的所有内容.</td></tr>
<tr><td><code>ALT-C</code></td><td>将光标所在位置的字母转为大写(如果光标在一个词的起始位置或之前,则词首字母大写).</td></tr>
<tr><td><code>ALT-U</code></td><td>将光标所在位置到词尾的所有字母转为大写.</td></tr>
<tr><td><code>ALT-L</code></td><td>将光标位置到词尾的所有字母转为小写.</td></tr>
<tr><td><code>ALT-R</code></td><td>取消所有变更,并将当前行恢复到在历史记录中的原始状态(前提是当前命令是从历史记录中来的,如果是手动输入,则会清空行).</td></tr>
<tr><td><code>ALT-T</code></td><td>当光标两侧都存在词的时候,交换光标两侧词的位置.如:`abc <ALT-T>bcd -&gt; bcd abc</td></tr>
<tr><td><code>ALT-.</code></td><td>使用前一次命令的最后一个词(命令本身也是一个词,参见后一篇的Bang命令中的词指示符概念).</td></tr>
<tr><td><code>ALT-_</code></td><td>同<code>ALT-.</code>.</td></tr>
<tr><td><code>ALT-数值</code></td><td>这个数值可以是正或者是负,这个键单独没有作用,必须后面再接其他内容,如果后面是字符,则表示重复次数.如:<code>[ALT-10,k]</code>则光标位置会插入<code>10</code>个<code>k</code>字符(负值在这种情况下无效); 如果后面接的是命令,则数字会影响后面命令的执行结果,如:<code>[ALT--10,CTRL-D]</code>则向<code>CTRL-D</code>默认方向相反(负数)的方向执行<code>10</code>次操作.</td></tr>
<tr><td><code>ALT-&lt;</code></td><td>移动到历史记录中的第一行命令.</td></tr>
<tr><td><code>ALT-&gt;</code></td><td>移动到历史的最后一行,即当前正在输入的行(没有输入的情况下为空).</td></tr>
<tr><td><code>ALT-P</code></td><td>从当前行开始向前搜索,有必要则向&quot;上&quot;移动,移动时,使用非增量搜索查找用户提供的字符串.</td></tr>
<tr><td><code>ALT-N</code></td><td>从当前行开始向后搜索,如果有必要向&quot;下&quot;移动,移动时,使用非增量搜索查找用户提供的字符串.</td></tr>
<tr><td><code>ALT-CTRL-Y</code></td><td>在标志点上插入前一个命令的第一个参数(一般是前一行的第二个词).如果有参数<code>n</code>,则插入前一个命令的第<code>n</code>个词(前一行的词编号从<code>0</code>开始,见历史扩展).负的参数将插入冲前一个命令的结尾开始的第n个词.参数<code>n</code>通过<code>M-No.</code>的方式传递,如:<code>[ALT-0,ALT-CTRL-Y]</code>插入前一个命令的第<code>0</code>个词(命令本身).</td></tr>
<tr><td><code>ALT-Y</code></td><td>轮询到删除环,并复制新的顶端文本.只能在<code>yank[CTRL-Y]</code>或者<code>yank-pop[M-Y]</code>之后使用这个命令.</td></tr>
<tr><td><code>ALT-?</code></td><td>列出能够补全标志点前的条目.</td></tr>
<tr><td><code>ALT-*</code></td><td>把能够补全[<code>ALT-?</code>]命令能生成的所有文本条目插入到标志点前.</td></tr>
<tr><td><code>ALT-/</code></td><td>试图对标志点前的文本进行文件名补全.<code>[CTRL-X,/]</code>把标志点前的文本当成文件名并列出可以补全的条目.</td></tr>
<tr><td><code>ALT-~</code></td><td>把标志点前的文本当成用户名并试图进行补全.<code>[CTRL-X,~]</code>列出可以作为用户名补全标志点前的条目.</td></tr>
<tr><td><code>ALT-$</code></td><td>把标志点前的文本当成Shell变量并试图进行补全.<code>[CTRL-X,$]</code>列出可以作为变量补全标志点前的条目.</td></tr>
<tr><td><code>ALT-@</code></td><td>把标志点前的文本当成主机名并试图进行补全.<code>[CTRL-X,@]</code>列出可以作为主机补全标志点前的条目.</td></tr>
<tr><td><code>ALT-!</code></td><td>把标志点前的文本当成命令名并试图进行补全.进行命令名补全时会依次使用别名,保留字,Shell函数,shell内部命令,最后是可执行文件名.<code>[CTRL-X,!]</code>把标志点前的文本当成命令名并列出可补全的条目.</td></tr>
<tr><td><code>ALT-TAB</code></td><td>把标志点前的文本与历史记录中的文本进行比较以寻找匹配的并试图进行补全.</td></tr>
<tr><td><code>ALT-{</code></td><td>进行文件名补全,把可以补全的条目列表放在大括号之间,让shell可以使用.</td></tr>
</tbody></table>
<hr />
<p>在控制台或<code>xterm</code> 窗口输入文本时,<code>CTRL-D</code> 删除在光标下的字符.从一个shell中退出 (类似于<code>exit</code>).如果没有字符存在,<code>CTRL-D</code> 则会登出该会话.在一个xterm窗口中,则会产生关闭此窗口的效果.</p>
<p><code>CTRL-K</code>
在脚本中,也可能表示为八进制形式(<code>'\013'</code>)或十六进制形式(<code>'\x0b'</code>).在脚本中,<code>CTRL-K</code>可能会有不一样的行为,下面的例子给出其不一样的行为:</p>
<pre><code class="language-bash">#!/bin/bash
## 一个`CTRL-K`垂直制表符的例子
var=$'\x0aBottom Line\x0bTop line\x0a'
## 直接输出
echo &quot;$var&quot;
## 使用col来过滤控制字符
echo &quot;$var&quot; | col
## 上面的显示将会不一样
exit 0
</code></pre>
<h3 id="系统快捷键"><a class="header" href="#系统快捷键">系统快捷键</a></h3>
<ul>
<li>不同<code>workspace</code>导航; ubuntu: <code>Super+PageUp/PageDown</code>; manjaro: <code>Ctrl+Super+Left/Right/Up/Down</code></li>
<li>将应用窗口移动到不同的<code>workspace</code>; ubuntu: <code>Shit+Super+ PageUp/PageDown</code>; manjaro: <code>Ctrl+Shift+Super+Left/Right/Up/Down</code></li>
</ul>
<h2 id="systemd"><a class="header" href="#systemd">systemd</a></h2>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程:命令篇</a>
<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程:实战篇</a></p>
<p>历史上,Linux 的启动一直采用<code>init</code>进程.下面的命令用来启动服务.</p>
<pre><code class="language-bash">$ sudo /etc/init.d/apache2 start # 或者
$ service apache2 start
</code></pre>
<p>这种方法有两个缺点.</p>
<ul>
<li>一是启动时间长.<code>init</code>进程是串行启动,只有前一个进程启动完,才会启动下一个进程.</li>
<li>二是启动脚本复杂.<code>init</code>进程只是执行启动脚本,不管其他事情.脚本需要自己处理各种情况,这往往使得脚本变得很长.</li>
</ul>
<p><code>Systemd</code> 就是为了解决这些问题而诞生的.它的设计目标是,为系统的启动和管理提供一套完整的解决方案.
根据 <code>Linux</code> 惯例,字母<code>d</code>是守护进程(<code>daemon</code>)的缩写. <code>Systemd</code> 这个名字的含义,就是它要守护整个系统.</p>
<p>使用了 <code>Systemd</code>,就不需要再用init了.<code>Systemd</code> 取代了<code>initd</code>,成为系统的第一个进程(<code>PID </code>等于 <code>1</code>),其他进程都是它的子进程.</p>
<pre><code class="language-bash">$ systemctl --version
</code></pre>
<p>上面的命令查看 <code>Systemd</code> 的版本.</p>
<h3 id="系统管理"><a class="header" href="#系统管理">系统管理</a></h3>
<p><code>Systemd</code> 并不是一个命令,而是一组命令,涉及到系统管理的方方面面.</p>
<h4 id="systemctl"><a class="header" href="#systemctl">systemctl</a></h4>
<p><code>systemctl</code> 是 <code>Systemd</code> 的主命令,用于管理系统.</p>
<pre><code class="language-bash">$ sudo systemctl reboot # 重启系统
$ sudo systemctl poweroff # 关闭系统,切断电源
$ sudo systemctl halt # CPU停止工作
$ sudo systemctl suspend # 暂停系统
$ sudo systemctl hibernate # 让系统进入冬眠状态
$ sudo systemctl hybrid-sleep # 让系统进入交互式休眠状态
$ sudo systemctl rescue # 启动进入救援状态(单用户状态)
</code></pre>
<h4 id="systemd-analyze"><a class="header" href="#systemd-analyze">systemd-analyze</a></h4>
<p><code>systemd-analyze</code>命令用于查看启动耗时.</p>
<pre><code class="language-bash">$ systemd-analyze # 查看启动耗时
$ systemd-analyze blame # 查看每个服务的启动耗时
$ systemd-analyze critical-chain # 显示瀑布状的启动过程流
$ systemd-analyze critical-chain atd.service # 显示指定服务的启动流
</code></pre>
<h4 id="hostnamectl"><a class="header" href="#hostnamectl">hostnamectl</a></h4>
<p><code>hostnamectl</code>命令用于查看当前主机的信息.</p>
<pre><code class="language-bash">$ hostnamectl # 显示当前主机的信息
$ sudo hostnamectl set-hostname rhel7 # 设置主机名.
</code></pre>
<h4 id="localectl"><a class="header" href="#localectl">localectl</a></h4>
<p><code>localectl</code>命令用于查看本地化设置.</p>
<pre><code class="language-bash">
$ localectl # 查看本地化设置
$ sudo localectl set-locale LANG=en_GB.utf8 # 设置本地化参数.
$ sudo localectl set-keymap en_GB
</code></pre>
<h4 id="timedatectl"><a class="header" href="#timedatectl">timedatectl</a></h4>
<p><code>timedatectl</code> 命令用于查看当前时区设置.</p>
<pre><code class="language-bash">$ timedatectl # 查看当前时区设置
$ timedatectl list-timezones # 显示所有可用的时区
$ sudo timedatectl set-timezone America/New_York # 设置当前时区
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SS
</code></pre>
<h4 id="loginctl"><a class="header" href="#loginctl">loginctl</a></h4>
<p><code>loginctl</code>命令用于查看当前登录的用户.</p>
<pre><code class="language-bash">$ loginctl list-sessions # 列出当前session
$ loginctl list-users # 列出当前登录用户
$ loginctl show-user ruanyf # 列出显示指定用户的信息
</code></pre>
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<h4 id="含义"><a class="header" href="#含义">含义</a></h4>
<p><code>Systemd</code> 可以管理所有系统资源.不同的资源统称为 <code>Unit</code>(单位).</p>
<p><code>Unit</code> 一共分成12种.</p>
<ul>
<li><code>Service unit</code>:系统服务</li>
<li><code>Target unit</code>:多个 <code>Unit</code> 构成的一个组</li>
<li><code>Device Unit</code>:硬件设备</li>
<li><code>Mount Unit</code>:文件系统的挂载点</li>
<li><code>Automount Unit</code>:自动挂载点</li>
<li><code>Path Unit</code>:文件或路径</li>
<li><code>Scope Unit</code>:不是由 <code>Systemd</code> 启动的外部进程</li>
<li><code>Slice Unit</code>:进程组</li>
<li><code>Snapshot Unit</code>:<code>Systemd</code> 快照,可以切回某个快照</li>
<li><code>Socket Unit</code>:进程间通信的 <code>socket</code></li>
<li><code>Swap Unit</code>:<code>swap</code> 文件</li>
<li><code>Timer Unit</code>:定时器</li>
</ul>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有<code>Unit </code>.</p>
<pre><code class="language-bash">$ systemctl list-units # 列出正在运行的 Unit
$ systemctl list-units --all # 列出所有Unit,包括没有找到配置文件的或者启动失败的
$ systemctl list-units --all --state=inactive # 列出所有没有运行的 Unit
$ systemctl list-units --failed # 列出所有加载失败的 Unit
$ systemctl list-units --type=service # 列出所有正在运行的, 类型为 service 的 Unit
</code></pre>
<h4 id="unit-的状态"><a class="header" href="#unit-的状态">Unit 的状态</a></h4>
<p><code>systemctl status</code>命令用于查看系统状态和单个 <code>Unit</code> 的状态.</p>
<pre><code class="language-bash">$ systemctl status # 显示系统状态
$ sysystemctl status bluetooth.service # 显示单个 Unit 的状态
$ systemctl -H root@rhel7.example.com status httpd.service # 显示远程主机的某个 Unit 的状态
</code></pre>
<p>除了<code>status</code>命令,<code>systemctl</code>还提供了三个查询状态的简单方法,主要供脚本内部的判断语句使用.</p>
<pre><code class="language-bash">$ systemctl is-active application.service # 显示某个 Unit 是否正在运行
$ systemctl is-failed application.service # 显示某个 Unit 是否处于启动失败状态
$ systemctl is-enabled application.service # 显示某个 Unit 服务是否建立了启动链接
</code></pre>
<h4 id="unit-管理"><a class="header" href="#unit-管理">Unit 管理</a></h4>
<p>对于用户来说,最常用的是下面这些命令,用于启动和停止 <code>Unit</code>(主要是 <code>service</code>).</p>
<pre><code class="language-bash">$ sudo systemctl start apache.service # 立即启动一个服务
$ sudo systemctl stop apache.service # 立即停止一个服务
$ sudo systemctl restart apache.service # 重启一个服务
$ sudo systemctl kill apache.service # 杀死一个服务的所有子进程
$ sudo systemctl reload apache.service # 重新加载一个服务的配置文件
$ sudo systemctl daemon-reload # 重载所有修改过的配置文件
$ systemctl show httpd.service # 显示某个 Unit 的所有底层参数
$ systemctl show -p CPUShares httpd.service # 显示某个 Unit 的指定属性的值
$ sudo systemctl set-property httpd.service CPUShares=500 # 设置某个 Unit 的指定属性
</code></pre>
<h4 id="依赖关系"><a class="header" href="#依赖关系">依赖关系</a></h4>
<p><code>Unit</code> 之间存在依赖关系:<code>A</code> 依赖于 <code>B</code>,就意味着 <code>Systemd</code> 在启动 <code>A</code> 的时候,同时会去启动 <code>B</code>.</p>
<p><code>systemctl list-dependencies</code>命令列出一个 <code>Unit</code> 的所有依赖.</p>
<pre><code class="language-bash">$ systemctl list-dependencies nginx.service
</code></pre>
<p>上面命令的输出结果之中,有些依赖是 <code>Target</code> 类型(详见下文),默认不会展开显示.如果要展开 <code>Target</code>,就需要使用<code>--all</code>参数.</p>
<pre><code class="language-bash">$ systemctl list-dependencies --all nginx.service
</code></pre>
<h3 id="unit-的配置文件"><a class="header" href="#unit-的配置文件">Unit 的配置文件</a></h3>
<h4 id="概述"><a class="header" href="#概述">概述</a></h4>
<p>每一个 <code>Unit</code> 都有一个配置文件,告诉 <code>Systemd</code> 怎么启动这个 <code>Unit</code> . <code>Systemd</code> 默认从目录<code>/etc/systemd/system/</code>读取配置文件.
但是,里面存放的大部分文件都是符号链接,指向目录<code>/usr/lib/systemd/system/</code>,真正的配置文件存放在那个目录, 也可能是<code>/lib/systemd/system/</code>.
<code>systemctl enable</code>命令用于在上面两个目录之间,建立符号链接关系.</p>
<pre><code class="language-bash">$ sudo systemctl enable clamd@scan.service # 等同于
$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service'
</code></pre>
<p>如果配置文件里面设置了开机启动,<code>systemctl enable</code>命令相当于激活开机启动.
与之对应的,<code>systemctl disable</code>命令用于在两个目录之间,撤销符号链接关系,相当于撤销开机启动.</p>
<pre><code class="language-bash">$ sudo systemctl disable clamd@scan.service
</code></pre>
<p>配置文件的后缀名,就是该 <code>Unit</code> 的种类,比如<code>sshd.socket</code>.如果省略,<code>Systemd</code> 默认后缀名为<code>.service</code>,所以<code>sshd</code>会被理解成<code>sshd.service</code>.</p>
<h4 id="配置文件的状态"><a class="header" href="#配置文件的状态">配置文件的状态</a></h4>
<p><code>systemctl list-unit-files</code> 命令用于列出所有配置文件.</p>
<pre><code class="language-bash">$ systemctl list-unit-files  # 列出所有配置文件
$ systemctl list-unit-files --type=service # 列出指定类型的配置文件
</code></pre>
<p>这个命令会输出一个列表.</p>
<pre><code class="language-bash">$ systemctl list-unit-files
UNIT FILE              STATE
chronyd.service        enabled
clamd@.service         static
clamd@scan.service     disabled
</code></pre>
<p>这个列表显示每个配置文件的状态,一共有四种.</p>
<ul>
<li><code>enabled</code>:已建立启动链接</li>
<li><code>disabled</code>:没建立启动链接</li>
<li><code>static</code>:该配置文件没有<code>[Install]</code>部分(无法执行),只能作为其他配置文件的依赖</li>
<li><code>masked</code>:该配置文件被禁止建立启动链接</li>
</ul>
<p>注意,从配置文件的状态无法看出,该 <code>Unit</code> 是否正在运行.这必须执行前面提到的<code>systemctl status</code>命令.</p>
<pre><code class="language-bash">$ systemctl status bluetooth.service
</code></pre>
<p>一旦修改配置文件,就要让 <code>SystemD</code> 重新加载配置文件,然后重新启动,否则修改不会生效.</p>
<pre><code class="language-bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
</code></pre>
<h4 id="配置文件的格式"><a class="header" href="#配置文件的格式">配置文件的格式</a></h4>
<p>配置文件就是普通的文本文件,可以用文本编辑器打开.</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容.</p>
<pre><code class="language-bash">$ systemctl cat atd.service
[Unit]
Description=ATD daemon
[Service]
Type=forking
ExecStart=/usr/bin/atd
[Install]
WantedBy=multi-user.target
</code></pre>
<p>从上面的输出可以看到,配置文件分成几个区块.每个区块的第一行,是用方括号表示的区别名,比如<code>[Unit]</code>.注意,配置文件的区块名和字段名,都是大小写敏感的.</p>
<p>每个区块内部是一些等号连接的键值对.</p>
<pre><code class="language-bash">[Section]
Directive1=value
Directive2=value
. . .
</code></pre>
<p>注意,键值对的等号两侧不能有空格.</p>
<h4 id="配置文件的区块"><a class="header" href="#配置文件的区块">配置文件的区块</a></h4>
<p><code>[Unit]</code>区块通常是配置文件的第一个区块,用来定义 <code>Unit</code> 的元数据,以及配置与其他 <code>Unit</code> 的关系.它的主要字段如下.</p>
<ul>
<li><code>Description</code>:简短描述</li>
<li><code>Documentation</code>:文档地址</li>
<li><code>Requires</code>:当前 <code>Unit</code> 依赖的其他 <code>Unit</code>,如果它们没有运行,当前 <code>Unit</code> 会启动失败</li>
<li><code>Wants</code>:与当前 <code>Unit</code> 配合的其他 <code>Unit</code>,如果它们没有运行,当前 <code>Unit</code> 不会启动失败</li>
<li><code>BindsTo</code>:与Requires类似,它指定的 <code>Unit</code> 如果退出,会导致当前 <code>Unit</code> 停止运行</li>
<li><code>Before</code>:如果该字段指定的 <code>Unit</code> 也要启动,那么必须在当前 <code>Unit</code> 之后启动</li>
<li><code>After</code>:如果该字段指定的 <code>Unit</code> 也要启动,那么必须在当前 <code>Unit</code> 之前启动</li>
<li><code>Conflicts</code>:这里指定的 <code>Unit</code> 不能与当前 <code>Unit</code> 同时运行</li>
<li><code>Condition</code>...:当前 <code>Unit</code> 运行必须满足的条件,否则不会运行</li>
<li><code>Assert</code>...:当前 <code>Unit</code> 运行必须满足的条件,否则会报启动失败</li>
</ul>
<p><code>[Install]</code>通常是配置文件的最后一个区块,用来定义如何启动,以及是否开机启动.它的主要字段如下.</p>
<ul>
<li><code>WantedBy</code>:它的值是一个或多个 <code>Target</code>,当前 <code>Unit</code> 激活时(<code>enable</code>)符号链接会放入<code>/etc/systemd/system</code>目录下面以 <code>Target</code> 名 + <code>.wants</code>后缀构成的子目录中</li>
<li><code>RequiredBy</code>:它的值是一个或多个 <code>Target</code>,当前 <code>Unit</code> 激活时,符号链接会放入<code>/etc/systemd/system</code>目录下面以 <code>Target</code> 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>:当前 <code>Unit</code> 可用于启动的别名</li>
<li><code>Also</code>:当前 <code>Unit</code> 激活(<code>enable</code>)时,会被同时激活的其他 <code>Unit</code></li>
</ul>
<p><code>[Service]</code>区块用来 <code>Service</code> 的配置,只有 <code>Service</code> 类型的 <code>Unit</code> 才有这个区块.它的主要字段如下.</p>
<ul>
<li><code>Type</code>:定义启动时的进程行为.它有以下几种值.</li>
<li><code>Type=simple</code>:默认值,执行 <code>ExecStart</code> 指定的命令,启动主进程</li>
<li><code>Type=forking</code>:以 <code>fork</code> 方式从父进程创建子进程,创建后父进程会立即退出</li>
<li><code>Type=oneshot</code>:一次性进程,<code>Systemd</code> 会等当前服务退出,再继续往下执行</li>
<li><code>Type=dbus</code>:当前服务通过<code>D-Bus</code>启动</li>
<li><code>Type=notify</code>:当前服务启动完毕,会通知<code>Systemd</code>,再继续往下执行</li>
<li><code>Type=idle</code>:若有其他任务执行完毕,当前服务才会运行</li>
<li><code>ExecStart</code>:启动当前服务的命令</li>
<li><code>ExecStartPre</code>:启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>:启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>:重启当前服务时执行的命令</li>
<li><code>ExecStop</code>:停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>:停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>:自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>:定义何种情况 <code>Systemd</code> 会自动重启当前服务,可能的值包括<code>always</code>(总是重启), <code>on-success</code>, <code>on-failure</code>, <code>on-abnormal</code>, <code>on-abort</code>, <code>on-watchdog</code></li>
<li><code>TimeoutSec</code>:定义 <code>Systemd</code> 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>:指定环境变量</li>
</ul>
<p><code>Unit</code> 配置文件的完整字段清单,请参考官方文档.</p>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>启动计算机的时候,需要启动大量的 <code>Unit</code>.如果每一次启动,都要一一写明本次启动需要哪些 <code>Unit</code>,显然非常不方便.<code>Systemd</code> 的解决方案就是 <code>Target</code>.
简单说,<code>Target</code> 就是一个 <code>Unit</code> 组,包含许多相关的 <code>Unit</code> .启动某个 <code>Target</code> 的时候,<code>Systemd</code> 就会启动里面所有的 <code>Unit</code>.
从这个意义上说,<code>Target</code> 这个概念类似于&quot;状态点&quot;,启动某个 <code>Target</code> 就好比启动到某种状态.</p>
<p>传统的<code>init</code>启动模式里面,有 <code>RunLevel</code> 的概念,跟 <code>Target</code> 的作用很类似.不同的是,<code>RunLevel</code> 是互斥的,不可能多个 <code>RunLevel</code> 同时启动,但是多个 <code>Target</code> 可以同时启动.</p>
<pre><code class="language-bash"># 查看当前系统的所有 Target
$ systemctl list-unit-files --type=target
# 查看一个 Target 包含的所有 Unit
$ systemctl list-dependencies multi-user.target
# 查看启动时的默认 Target
$ systemctl get-default
# 设置启动时的默认 Target
$ sudo systemctl set-default multi-user.target
# 切换 Target 时,默认不关闭前一个 Target 启动的进程,
# systemctl isolate 命令改变这种行为,
# 关闭前一个 Target 里面所有不属于后一个 Target 的进程
$ sudo systemctl isolate multi-user.target
</code></pre>
<p><code>Target</code> 与 传统 <code>RunLevel</code> 的对应关系如下.</p>
<p>Traditional runlevel      New target name     Symbolically linked to...</p>
<ul>
<li><code>Runlevel 0</code>  |  <code>runlevel0.target -&gt; poweroff.target</code></li>
<li><code>Runlevel 1</code>  |  <code>runlevel1.target -&gt; rescue.target</code></li>
<li><code>Runlevel 2</code>  |  <code>runlevel2.target -&gt; multi-user.target</code></li>
<li><code>Runlevel 3</code>  |  <code>runlevel3.target -&gt; multi-user.target</code></li>
<li><code>Runlevel 4</code>  |  <code>runlevel4.target -&gt; multi-user.target</code></li>
<li><code>Runlevel 5</code>  |  <code>runlevel5.target -&gt; graphical.target</code></li>
<li><code>Runlevel 6</code>  |  <code>runlevel6.target -&gt; reboot.target</code></li>
</ul>
<p>它与<code>init</code>进程的主要差别如下.</p>
<ul>
<li>默认的 <code>RunLevel</code>(在<code>/etc/inittab</code>文件设置)现在被默认的 <code>Target</code> 取代,位置是<code>/etc/systemd/system/default.target</code>,通常符号链接到<code>graphical.target</code>(图形界面)或者<code>multi-user.target</code>(多用户命令行).</li>
<li>启动脚本的位置,以前是<code>/etc/init.d</code>目录,符号链接到不同的 <code>RunLevel</code> 目录 (比如<code>/etc/rc3.d</code>, <code>/etc/rc5.d</code>等),现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录.</li>
<li>配置文件的位置,以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>,各种服务的配置文件存放在<code>/etc/sysconfig</code>目录.现在的配置文件主要存放在<code>/lib/systemd</code>目录,在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置.</li>
</ul>
<h3 id="日志管理"><a class="header" href="#日志管理">日志管理</a></h3>
<p><code>Systemd</code> 统一管理所有 <code>Unit</code> 的启动日志.带来的好处就是,可以只用<code>journalctl</code>一个命令,查看所有日志(内核日志和应用日志).日志的配置文件是<code>/etc/systemd/journald.conf</code>.</p>
<p><code>journalctl</code>功能强大,用法非常多.</p>
<pre><code class="language-bash">$ sudo journalctl  # 查看所有日志(默认情况下 ,只保存本次启动的日志)
$ sudo journalctl -k # 查看内核日志(不显示应用日志)
# 查看系统本次启动的日志
$ sudo journalctl -b
$ sudo journalctl -b -0
$ sudo journalctl -b -1 # 查看上一次启动的日志(需更改设置)
# 查看指定时间的日志
$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;
$ sudo journalctl --since &quot;20 min ago&quot;
$ sudo journalctl --since yesterday
$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;
$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;

$ sudo journalctl -n # 显示尾部的最新10行日志
$ sudo journalctl -n 20 # 显示尾部指定行数的日志
$ sudo journalctl -f # 实时滚动显示最新日志
$ sudo journalctl /usr/lib/systemd/systemd # 查看指定服务的日志
$ sudo journalctl _PID=1 # 查看指定进程的日志
$ sudo journalctl /usr/bin/bash # 查看某个路径的脚本的日志

$ sudo journalctl _UID=33 --since today # 查看指定用户的日志
$ sudo journalctl -u nginx.service # 查看某个 Unit 的日志
$ sudo journalctl -u nginx.service --since today
$ sudo journalctl -u nginx.service -f # 实时滚动显示某个 Unit 的最新日志

$ journalctl -u nginx.service -u php-fpm.service --since today # 合并显示多个 Unit 的日志
# 查看指定优先级(及其以上级别)的日志,共有8级
# 0: emerg , 1: alert , 2: crit , 3: err, 4: warning
# 5: notice, 6: info, 7: debug
$ sudo journalctl -p err -b

$ sudo journalctl --no-pager # 日志默认分页输出,--no-pager 改为正常的标准输出
$ sudo journalctl -b -u nginx.service -o json # 以 JSON 格式(单行)输出
$ sudo journalctl -b -u nginx.serviceqq -o json-pretty # 以 JSON 格式(多行)输出,可读性更好

$ sudo journalctl --disk-usage # 显示日志占据的硬盘空间
$ sudo journalctl --vacuum-size=1G # 指定日志文件占据的最大空间
$ sudo journalctl --vacuum-time=1years # 指定日志文件保存多久
</code></pre>
<h2 id="systemd-常见任务"><a class="header" href="#systemd-常见任务">Systemd 常见任务</a></h2>
<h3 id="开机启动"><a class="header" href="#开机启动">开机启动</a></h3>
<p>对于那些支持 <code>Systemd</code> 的软件,安装的时候,会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件.
如果你想让该软件开机启动,就执行下面的命令(以<code>httpd.service</code>为例).</p>
<pre><code class="language-bash">$ sudo systemctl enable httpd
</code></pre>
<p>上面的命令相当于在<code>/etc/systemd/system</code>目录添加一个符号链接,指向<code>/usr/lib/systemd/system</code>里面的<code>httpd.service</code>文件.
这是因为开机时,<code>Systemd</code>只执行<code>/etc/systemd/system</code>目录里面的配置文件.这也意味着,如果把修改后的配置文件放在该目录,就可以达到覆盖原始配置的效果.</p>
<h3 id="启动服务"><a class="header" href="#启动服务">启动服务</a></h3>
<p>设置开机启动以后,软件并不会立即启动,必须等到下一次开机.如果想现在就运行该软件,那么要执行<code>systemctl start</code>命令.</p>
<pre><code class="language-bash">$ sudo systemctl start httpd
</code></pre>
<p>执行上面的命令以后,有可能启动失败,因此要用<code>systemctl status</code>命令查看一下该服务的状态.</p>
<pre><code class="language-bash">$ sudo systemctl status httpd
httpd.service - The Apache HTTP Server
Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)
Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago
Main PID: 4349 (httpd)
Status: &quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&quot;
CGroup: /system.slice/httpd.service
├─4349 /usr/sbin/httpd -DFOREGROUND
...
12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...
...
</code></pre>
<p>上面的输出结果含义如下.</p>
<ul>
<li><code>Loaded行</code>:配置文件的位置,是否设为开机启动</li>
<li><code>Active行</code>:表示正在运行</li>
<li><code>Main PID行</code>:主进程<code>ID</code></li>
<li><code>Status行</code>:由应用本身(这里是 <code>httpd</code> )提供的软件当前状态</li>
<li><code>CGroup块</code>:应用的所有子进程</li>
<li><code>日志块</code>:应用的日志</li>
</ul>
<h3 id="停止服务"><a class="header" href="#停止服务">停止服务</a></h3>
<p>终止正在运行的服务,需要执行<code>systemctl stop</code>命令.</p>
<pre><code class="language-bash">$ sudo systemctl stop httpd.service
</code></pre>
<p>有时候,该命令可能没有响应,服务停不下来.这时候就不得不&quot;杀进程&quot;了,向正在运行的进程发出<code>kill</code>信号.</p>
<pre><code class="language-bash">$ sudo systemctl kill httpd.service
</code></pre>
<p>此外,重启服务要执行<code>systemctl restart</code>命令.</p>
<pre><code class="language-bash">$ sudo systemctl restart httpd.service
</code></pre>
<h3 id="读懂配置文件"><a class="header" href="#读懂配置文件">读懂配置文件</a></h3>
<p>一个服务怎么启动,完全由它的配置文件决定.下面就来看,配置文件有些什么内容.
前面说过,配置文件主要放在<code>/usr/lib/systemd/system</code>目录,也可能在<code>/etc/systemd/system</code>目录.找到配置文件以后,使用文本编辑器打开即可.
<code>systemctl cat</code>命令可以用来查看配置文件,下面以<code>sshd.service</code>文件为例,它的作用是启动一个 <code>SSH</code> 服务器,供其他用户以 <code>SSH</code> 方式登录.</p>
<pre><code class="language-bash">$ systemctl cat sshd.service
[Unit]
Description=OpenSSH server daemon
...
[Service]
EnvironmentFile=/etc/sysconfig/sshd
...
[Install]
WantedBy=multi-user.target
</code></pre>
<p>可以看到,配置文件分成几个区块,每个区块包含若干条键值对.</p>
<p>下面依次解释每个区块的内容.</p>
<h4 id="unit-区块启动顺序与依赖关系"><a class="header" href="#unit-区块启动顺序与依赖关系">[Unit] 区块:启动顺序与依赖关系.</a></h4>
<p><code>Unit</code>区块的<code>Description</code>字段给出当前服务的简单描述,<code>Documentation</code>字段给出文档位置.接下来的设置是启动顺序和依赖关系,这个比较重要.</p>
<p><code>After</code>字段:表示如果<code>network.target</code>或<code>sshd-keygen.service</code>需要启动,那么<code>sshd.service</code>应该在它们之后启动.
相应地,还有一个<code>Before</code>字段,定义<code>sshd.service</code>应该在哪些服务之前启动.</p>
<p>注意,<code>After</code>和<code>Before</code>字段只涉及启动顺序,不涉及依赖关系.</p>
<p>举例来说,某 <code>Web</code> 应用需要 <code>postgresql</code> 数据库储存数据.在配置文件中,它只定义要在 <code>postgresql</code> 之后启动,而没有定义依赖 <code>postgresql</code> .
上线后,由于某种原因,<code>postgresql</code> 需要重新启动,在停止服务期间,该 <code>Web</code> 应用就会无法建立数据库连接.</p>
<p>设置依赖关系,需要使用<code>Wants</code>字段和<code>Requires</code>字段.
<code>Wants</code>字段:表示<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在&quot;弱依赖&quot;关系,即如果<code>sshd-keygen.service</code>启动失败或停止运行,不影响<code>sshd.service</code>继续执行.</p>
<p><code>Requires</code>字段则表示&quot;强依赖&quot;关系,即如果该服务启动失败或异常退出,那么<code>sshd.service</code>也必须退出.
注意,<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系,与启动顺序无关,默认情况下是同时启动的.</p>
<h4 id="service-区块启动行为"><a class="header" href="#service-区块启动行为">[Service] 区块:启动行为</a></h4>
<p><code>Service</code>区块定义如何启动当前服务.</p>
<h4 id="启动命令"><a class="header" href="#启动命令">启动命令</a></h4>
<p>许多软件都有自己的环境参数文件,该文件可以用 <code>EnvironmentFile</code> 字段读取.</p>
<p><code>EnvironmentFile</code>字段:指定当前服务的环境参数文件.该文件内部的<code>key=value</code>键值对,可以用<code>$key</code>的形式,在当前配置文件中获取.</p>
<p>上面的例子中,<code>sshd</code> 的环境参数文件是<code>/etc/sysconfig/sshd</code>.
配置文件里面最重要的字段是<code>ExecStart</code>.
<code>ExecStart</code>字段:定义启动进程时执行的命令.</p>
<p>上面的例子中,启动<code>sshd</code>,执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>,其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件.</p>
<p>与之作用相似的,还有如下这些字段.</p>
<ul>
<li><code>ExecReload字段</code>:重启服务时执行的命令</li>
<li><code>ExecStop字段</code>:停止服务时执行的命令</li>
<li><code>ExecStartPre字段</code>:启动服务之前执行的命令</li>
<li><code>ExecStartPost字段</code>:启动服务之后执行的命令</li>
<li><code>ExecStopPost字段</code>:停止服务之后执行的命令</li>
</ul>
<p>请看下面的例子.</p>
<pre><code class="language-service">[Service]
ExecStart=/bin/echo execstart1
ExecStart=
ExecStart=/bin/echo execstart2
ExecStartPost=/bin/echo post1
ExecStartPost=/bin/echo post2
</code></pre>
<p>上面这个配置文件,第二行<code>ExecStart</code>设为空值,等于取消了第一行的设置,运行结果如下.</p>
<pre><code class="language-bash">execstart2
post1
post2
</code></pre>
<p>所有的启动设置之前,都可以加上一个连词号(<code>-</code>),表示&quot;抑制错误&quot;,即发生错误的时候,不影响其他命令的执行.
比如,<code>EnvironmentFile=-/etc/sysconfig/sshd</code>(注意等号后面的那个连词号),就表示即使<code>/etc/sysconfig/sshd</code>文件不存在,也不会抛出错误.</p>
<h4 id="启动类型"><a class="header" href="#启动类型">启动类型</a></h4>
<p><code>Type</code>字段定义启动类型.它可以设置的值如下.</p>
<ul>
<li><code>simple(默认值)</code>: <code>ExecStart</code>字段启动的进程为主进程</li>
<li><code>forking</code>:<code>ExecStart</code>字段将以<code>fork()</code>方式启动,此时父进程将会退出,子进程将成为主进程</li>
<li><code>oneshot</code>:类似于<code>simple</code>,但只执行一次,<code>Systemd</code>会等它执行完,才启动其他服务</li>
<li><code>dbus:</code>类似于<code>simple</code>,但会等待 <code>D-Bus</code> 信号后启动</li>
<li><code>notify:</code>类似于<code>simple</code>,启动结束后会发出通知信号,然后 <code>Systemd</code> 再启动其他服务</li>
<li><code>idle:</code>类似于<code>simple</code>,但是要等到其他任务都执行完,才会启动该服务.一种使用场合是为让该服务的输出,不与其他服务的输出相混合</li>
</ul>
<p>下面是一个<code>oneshot</code>的例子,笔记本电脑启动时,要把触摸板关掉,配置文件可以这样写.</p>
<pre><code class="language-service">[Unit]
Description=Switch-off Touchpad
[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off
[Install]
WantedBy=multi-user.target
</code></pre>
<p>上面的配置文件,启动类型设为<code>oneshot</code>,就表明这个服务只要运行一次就够了,不需要长期运行.
如果关闭以后,将来某个时候还想打开,配置文件修改如下.</p>
<pre><code class="language-service">[Unit]
Description=Switch-off Touchpad
[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off start
ExecStop=/usr/bin/touchpad-off stop
RemainAfterExit=yes
[Install]
WantedBy=multi-user.target
</code></pre>
<p>上面配置文件中,<code>RemainAfterExit</code>字段设为<code>yes</code>,表示进程退出以后,服务仍然保持执行.
这样的话,一旦使用<code>systemctl stop</code>命令停止服务,<code>ExecStop</code>指定的命令就会执行,从而重新开启触摸板.</p>
<h4 id="重启行为"><a class="header" href="#重启行为">重启行为</a></h4>
<p><code>Service</code>区块有一些字段,定义了重启行为.</p>
<p><code>KillMode</code>字段:定义 <code>Systemd</code> 如何停止 <code>sshd</code> 服务.</p>
<p>上面这个例子中,将<code>KillMode</code>设为<code>process</code>,表示只停止主进程,不停止任何 <code>sshd</code> 子进程,即子进程打开的 <code>SSH session</code> 仍然保持连接.
这个设置不太常见,但对 <code>sshd</code> 很重要,否则你停止服务的时候,会连自己打开的 <code>SSH session</code> 一起杀掉.</p>
<p><code>KillMode</code>字段可以设置的值如下.</p>
<ul>
<li><code>control-group</code>(默认值):当前控制组里面的所有子进程,都会被杀掉</li>
<li><code>process</code>:只杀主进程</li>
<li><code>mixed</code>:主进程将收到 <code>SIGTERM</code> 信号,子进程收到 <code>SIGKILL</code> 信号</li>
<li><code>none</code>:没有进程会被杀掉,只是执行服务的 <code>stop</code> 命令.</li>
</ul>
<p>接下来是<code>Restart</code>字段.<code>Restart</code>字段:定义了 <code>sshd</code> 退出后,<code>Systemd</code> 的重启方式.
上面的例子中,<code>Restart</code>设为<code>on-failure</code>,表示任何意外的失败,就将重启<code>sshd</code>.如果 <code>sshd</code> 正常停止(比如执行<code>systemctl stop</code>命令),它就不会重启.</p>
<p>Restart字段可以设置的值如下.</p>
<ul>
<li><code>no</code>(默认值):退出后不会重启</li>
<li><code>on-success</code>:只有正常退出时(退出状态码为<code>0</code>),才会重启</li>
<li><code>on-failure</code>:非正常退出时(退出状态码非<code>0</code>),包括被信号终止和超时,才会重启</li>
<li><code>on-abnormal</code>:只有被信号终止和超时,才会重启</li>
<li><code>on-abort</code>:只有在收到没有捕捉到的信号终止时,才会重启</li>
<li><code>on-watchdog</code>:超时退出,才会重启</li>
<li><code>always</code>:不管是什么退出原因,总是重启</li>
</ul>
<p>对于守护进程,推荐设为<code>on-failure</code>.对于那些允许发生错误退出的服务,可以设为<code>on-abnormal</code>.
最后是<code>RestartSec</code>字段,表示 <code>Systemd</code> 重启服务之前,需要等待的秒数.上面的例子设为等待<code>42</code>秒.</p>
<h4 id="install-区块"><a class="header" href="#install-区块">[Install] 区块</a></h4>
<p><code>Install</code>区块,定义如何安装这个配置文件,即怎样做到开机启动.</p>
<ul>
<li><code>WantedBy字段</code>:表示该服务所在的 <code>Target</code>.</li>
</ul>
<p><code>Target</code>的含义是服务组,表示一组服务.<code>WantedBy=multi-user.target</code>指的是,<code>sshd</code>所在的 <code>Target</code> 是<code>multi-user.target</code>.
这个设置非常重要,因为执行<code>systemctl enable sshd.service</code>命令时,<code>sshd.service</code>的一个符号链接,就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中. <code>Systemd</code> 有默认的启动 <code>Target</code>.</p>
<pre><code class="language-bash">$ systemctl get-default
multi-user.target
</code></pre>
<p>上面的结果表示,默认的启动 <code>Target</code> 是 <code>multi-user.target</code>.在这个组里的所有服务,都将开机启动.这就是为什么<code>systemctl enable</code>命令能设置开机启动的原因.
使用 <code>Target</code> 的时候,<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用.</p>
<pre><code class="language-bash"># 查看 multi-user.target 包含的所有服务
$ systemctl list-dependencies multi-user.target
# 切换到另一个 target
# shutdown.target 就是关机状态
$ sudo systemctl isolate shutdown.target
</code></pre>
<p>一般来说,常用的 <code>Target</code> 有两个:一个是<code>multi-user.target</code>,表示多用户命令行状态;
另一个是<code>graphical.target</code>,表示图形用户状态,它依赖于<code>multi-user.target</code>.官方文档有一张非常清晰的 <code>Target</code> 依赖关系图.</p>
<h3 id="target-的配置文件"><a class="header" href="#target-的配置文件">Target 的配置文件</a></h3>
<p><code>Target</code> 也有自己的配置文件.</p>
<pre><code class="language-bash">$ systemctl cat multi-user.target
[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
</code></pre>
<p>注意,<code>Target</code> 配置文件里面没有启动命令. 上面输出结果中,主要字段含义如下.</p>
<ul>
<li><code>Requires</code>字段:要求<code>basic.target</code>一起运行.</li>
<li><code>Conflicts</code>字段:冲突字段.如果<code>rescue.service</code>或<code>rescue.target</code>正在运行,<code>multi-user.target</code>就不能运行,反之亦然.</li>
<li><code>After</code>:表示<code>multi-user.target</code>在<code>basic.target</code> ,  <code>rescue.service</code>, <code>rescue.target</code>之后启动,如果它们有启动的话.</li>
<li><code>AllowIsolate</code>:允许使用<code>systemctl isolate</code>命令切换到<code>multi-user.target</code>.</li>
</ul>
<h3 id="修改配置文件后重启"><a class="header" href="#修改配置文件后重启">修改配置文件后重启</a></h3>
<p>修改配置文件以后,需要重新加载配置文件,然后重新启动相关服务.</p>
<pre><code class="language-bash">$ sudo systemctl daemon-reload  # 重新加载配置文件
$ sudo systemctl restart foobar # 重启相关服务
</code></pre>
<h2 id="cgroup"><a class="header" href="#cgroup">cgroup</a></h2>
<p><a href="https://wiki.archlinux.org/title/Cgroups">Control groups</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnomemd"><a class="header" href="#gnomemd">gnome.md</a></h1>
<h2 id="录制屏幕"><a class="header" href="#录制屏幕">录制屏幕</a></h2>
<p>如果是<code>Gnome3</code>系用户,可以按<code>ctrl + shift + alt + r</code>,屏幕右下角有红点出现,则开始录屏,
要结束的话再按一次<code>ctrl + shift + alt + r</code>,录好的视频在<code>~/video</code>下</p>
<h2 id="图片格式转换"><a class="header" href="#图片格式转换">图片格式转换</a></h2>
<p><code>pdf</code>转成图片格式. 包名: <code>pdftoppm</code>. 语法是: <code>pdftoppm input.pdf outputname -png -f {page} -singlefile</code></p>
<pre><code class="language-bash">pdftoppm  -png -rx 300 -ry 300  input.pdf outputname
</code></pre>
<p>这个命令将会把<code>PDF</code>的每一页转换成<code>png</code>格式, 文件名为<code>outputname-01.png</code>,<code>outputname-02.png</code>等等.
如果只想转换其中的特定一页, 使用<code>-f {page}</code>选项指定. 例如<code>-f 1</code>表示第一页.</p>
<p><code>gnome</code>默认的查看图片程序为<code>eog</code>: eye of gnome</p>
<h2 id="ubuntu-自带截图"><a class="header" href="#ubuntu-自带截图">ubuntu 自带截图</a></h2>
<p><code>ubuntu</code> 自带截图程序叫做<code>gnome-serceenshot</code></p>
<p><a href="https://www.jianshu.com/p/7f453c144f9c">Ubuntu设置截图到剪贴板,像QQ一样截图</a>. 可以定义一个快捷键,保存到桌面文件</p>
<pre><code class="language-bash">gnome-screenshot -a --file=(~&quot;/Desktop/$(date +%s).png&quot;)
</code></pre>
<p><code>date +%s</code>给出 UTC 时间</p>
<p>在 Ubuntu(18.04,16.04)或 Debian(Jessie 和更新版本)中安装 <code>GPaste</code></p>
<p>对于 Debian,GPaste 可用于 Jessie 和更新版本,而对于 Ubuntu,GPaste 在 16.04 及更新版本的仓库中(因此可在 Ubuntu 18.04 Bionic Beaver 中使用).</p>
<p>你可以使用以下命令在 Debian 或 Ubuntu 中安装 GPaste(守护程序和 Gnome Shell 扩展):</p>
<pre><code class="language-bash">sudo apt install gnome-shell-extensions-gpaste gpaste
</code></pre>
<p>安装完成后,按下 <code>Alt + F2</code> 并输入 <code>r</code> 重新启动 Gnome Shell,然后按回车键.现在应该启用了 GPaste Gnome Shell 扩展,其图标应显示在顶部 Gnome Shell 面板上.
如果没有,请使用 Gnome Tweaks(Gnome Tweak Tool)启用扩展.</p>
<p>Debian 和 Ubuntu 的 GPaste 3.28.0 中有一个错误,如果启用了图像支持选项会导致它崩溃,所以现在不要启用此功能.
这在 GPaste 3.28.2 中被标记为已修复,但 Debian 和 Ubuntu 仓库中尚未提供此包.</p>
<h4 id="mp3-文件标签乱码"><a class="header" href="#mp3-文件标签乱码">MP3 文件标签乱码</a></h4>
<p>对于用 <code>GStreamer</code> 做后端的播放器, 如 <code>Rhythmbox``, totem</code>, 设置如下的环境变量后即可正确读取 <code>mp3</code> 中 <code>GBK</code> 编码的 <code>ID3 tag</code>:</p>
<pre><code class="language-bash">export GST_ID3_TAG_ENCODING=GBK:UTF-8:GB18030
export GST_ID3V2_TAG_ENCODING=GBK:UTF-8:GB18030
</code></pre>
<h2 id="gnome-蓝牙传送文件"><a class="header" href="#gnome-蓝牙传送文件">gnome 蓝牙传送文件</a></h2>
<p><code>bluetooth-sendto</code>; 用于通过蓝牙传输文件的GTK应用程序</p>
<ul>
<li>说明; <code>bluetooth-sendto [--device=XX:XX:XX:XX:XX:XX [--name=NAME]] [file...]</code></li>
<li>描述; <code>bluetooth-sendto</code> 将显示一个通过蓝牙传输文件的对话框. <code>bluetooth-sendto</code>是<code>gnome-bluetooth</code>的一部分, 参见<a href="http://live.gnome.org/GnomeBluetooth">GnomeBluetooth</a></li>
<li>选项;
<ul>
<li><code>--device</code>;  定义要发送文件的设备地址.  如果省略, 将显示一个选择器.</li>
<li><code>--name</code>; 定义要发送文件的设备名称.  如果省略, 将被自动检测.</li>
<li><code>file</code> 要发送到设备的文件.  如果省略, 将显示一个选择器.</li>
</ul>
</li>
</ul>
<h2 id="gnome-快捷键"><a class="header" href="#gnome-快捷键">gnome 快捷键</a></h2>
<p>在设置--<code>Keyboard Shortcuts</code> 中, 我习惯的键位如下:</p>
<pre><code class="language-yaml">Launchers:
    Home folder : Super+E # ymy
    Launch Terminal: Ctrl+Alt+T
    Move to workspace above: Super + Page Up
    Move to workspace down: Super + Page Down
    Move window one workspace up: Shift + Super + Page Up
    Move window one workspace down: Shift + Super + Page Down
    Switch to workspace 1: Super + Home
    Switch to last workspace: Super + End
    Switch Applications : Super + Tab # 在所有打开的应用间切换
    Switch windows : Alt + Tab # ymy,在同一个 workspace 内切换
    Switch window Directly: Alt + Escape
    Switch windows of an application: Alt+` or Super +`

Navigation:
    Hide all normal windows : Super+D # ymy

ScreenShots:
    Copy a screenshot of a windows to clipboard: Ctrl +Alt +Print
    Copy a screenshot of an area to clipboard: Shit + Super + S #ymy
    Save a screenshot of an area to Pictures: Shift + Print

System:
    Lock Screen: Super + L
    Log out: Ctrl + Alt +Delete
    Show all applications: Super+A
    Show the overview: Super +S
    Show the run command prompt: Alt + F2

Typing:
    Switch to next input source: Super + Space
    Switch to previous input source: Shift + Super + Space

Windows:
    Hide window: Super + H
    Maxmize window: Super + Up
    Restore window: Super + Down
    View split on left: Super + Left
    View split on right: Super + right
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-2-process"><a class="header" href="#linux-2-process">linux-2-process</a></h1>
<h2 id="unix进程"><a class="header" href="#unix进程">UNIX进程</a></h2>
<p><a href="https://www.w3cschool.cn/xfgms6/5xsq8ozt.html">UNIX进程</a></p>
<h3 id="进程列表"><a class="header" href="#进程列表">进程列表</a></h3>
<p><code>PID</code>是每个进程唯一号码. 使用 <code>ps</code> 获取所有正在运行的进程列表.</p>
<pre><code class="language-bash">$ ps -auxefw # 所有正在运行进程的详尽列表
</code></pre>
<p>然而, 更典型的用法是使用管道或者<code>pgrep</code>:</p>
<pre><code class="language-bash">$ ps axww | grep cron
  586  ??  Is     0:01.48 /usr/sbin/cron -s
$ ps aux | grep 'ss[h]' #找到所有所有 ssh 进程的 pid
$ pgrep -l sshd # 查找所有进程名中有sshd 的进程ID
$ echo $$   # 你的 shell 的PID
$ fuser -va 22/tcp # 列出使用端口22的进程,fuser:使用文件或者socket 确定进程
$ fuser -va /home   # 列出访问 /home 分区的进程
$ strace df # 跟踪系统调用和信号
$ truss df # 同上(FreeBSD/Solaris/类Unix)
$ history | tail -50 # 显示最后50个使用过的命令
</code></pre>
<h3 id="优先级"><a class="header" href="#优先级">优先级</a></h3>
<p>用 <code>renice</code> 更改正在运行进程的优先级. 负值是更高的优先级, 最小为<code>-20</code>, 其正值与 <code>nice</code> 值的意义相同.</p>
<pre><code class="language-bash"># renice -5 586 # 更强的优先级586: old priority 0, new priority -5
</code></pre>
<p>使用 <code>nice</code> 命令启动一个已定义优先级的进程.  正值为低优先级, 负值为高优先级. 确定你知道<code>/usr/bin/nice</code> 或者使用 shell 内置命令(<code>which nice</code>).</p>
<pre><code class="language-bash">$ nice -n -5 top # 更高优先级(/usr/bin/nice)
$ nice -n 5 top # 更低优先级(/usr/bin/nice)
$ nice +5 top # tcsh 内置 nice 命令(同上)
</code></pre>
<p><code>nice</code> 可以影响 <code>CPU</code> 的调度, 另一个实用命令 <code>ionice</code> 可以调度磁盘 <code>IO</code>, 这对于<code>IO</code>密集型应用程序非常有用.
此命令仅可在 <code>Linux</code> (AFAIK) 上使用. 你可以选择一个类型(<code>idle</code>,<code>best effort</code>,<code>real time</code>), 它的 man 页很短并有很好的解释.</p>
<pre><code class="language-bash">$ ionice c3 -p123 # 给 pid 123 设置为 idle 类型
$ ionice -c2 -n0 firefox # 用 best effort 类型运行 firefox 并且设为高优先级
$ ionice -c3 -p$$ # 将当前的进程(shell)的磁盘 IO 调度设置为 idle 类型
</code></pre>
<p>例中最后一条命令对于编译(或调试)一个大型项目会非常有用. 每一个运行于此 <code>shell</code> 的命令都会有一个较低的优先级, 但并不妨碍这个系统. <code>$$</code> 是你 <code>shell</code> 的 <code>pid</code> (试试 <code>echo $$</code>).</p>
<h3 id="前台后台"><a class="header" href="#前台后台">前台/后台</a></h3>
<p>当一个进程在 <code>shell</code> 中已运行, 可以使用 <code>[Ctrl]-[Z]</code> (<code>^Z</code>), <code>bg</code> 和 <code>fg</code> 来 调入调出前后台, 使用 <code>jobs</code> 列出后台列表.</p>
<p><code>nohup</code> 英文全称 <code>no hang up</code>(不挂起), 用于在系统后台不挂断地运行命令, 退出终端不会影响程序的运行.
<code>nohup</code> 命令, 在默认情况下(非重定向时), 会输出一个名叫 <code>nohup.out </code>的文件到当前目录下, 如果当前目录的 <code>nohup.out</code> 文件不可写, 输出重定向到 <code>$HOME/nohup.out</code> 文件中.</p>
<p>语法格式</p>
<p><code>nohup Command [ Arg ...  ] [&amp;]</code></p>
<p>参数说明:</p>
<ul>
<li><code>Command</code>: 要执行的命令.</li>
<li><code>Arg</code>: 一些参数, 可以指定输出文件.</li>
<li><code>&amp;</code>: 让命令在后台执行, 终端退出后命令仍旧执行.</li>
</ul>
<p>例如以下命令在后台执行 <code>root</code> 目录下的 <code>runoob.sh</code> 脚本:</p>
<pre><code class="language-bash">nohup /root/runoob.sh &amp;
</code></pre>
<p>如果要停止运行, 你需要使用以下命令查找到 <code>nohup</code> 运行脚本到 <code>PID</code>, 然后使用 <code>kill</code> 命令来删除:</p>
<pre><code class="language-bash">ps -aux | grep &quot;runoob.sh&quot;
</code></pre>
<p>以下命令在后台执行 root 目录下的 <code>runoob.sh</code> 脚本, 并重定向输入到 <code>runoob.log</code> 文件:</p>
<pre><code class="language-bash">nohup /root/runoob.sh &amp;&gt; runoob.log  &amp;
</code></pre>
<p><code>&amp;&gt;</code> 解释: 将标准输出<code>&amp;1</code>以及标准错误<code>2</code>共同重定向到 <code>runoob.log</code> 文件中.</p>
<h3 id="top"><a class="header" href="#top">Top</a></h3>
<p><code>top</code> 程序用来实时显示系统中各个进程的运行信息.  当 top 在运行的时候, 按下 <code>h</code> 键会显示帮助画面. 常用键如下:</p>
<ul>
<li><code>u</code> [用户名] 只显示属于此用户的进程. 使用 <code>+</code> 或者空白可以查看所有用户</li>
<li><code>k [PID]</code> 结束 <code>PID</code> 进程</li>
<li><code>1</code> 显示所有进程状态信息(<code>Linux</code>才有)</li>
<li><code>R</code> 将当前排序倒转</li>
</ul>
<h2 id="kill命令与信号"><a class="header" href="#kill命令与信号">Kill命令与信号</a></h2>
<p>使用 kill 或 killall 终止或发送一个信号给进程.</p>
<pre><code class="language-bash">$ ping -i 60 cb.vu &gt; ping.log &amp; # [1] 4712
$ kill -s TERM 4712  # 同 kill -15 4712
$ killall -1 httpd # 发送 HUP 信号终止进程 httpd
$ pkill -9 http # 发送 KILL 信号终止包含 http 的进程
$ pkill -TERM -u www # 发送 TERM 信号终止 www 所有者进程
$ fuser -k -TERM -m /home # 终止所有访问 /home 的进程(卸载该分区前) -k Signal -m file
</code></pre>
<p>下面是一些重要的信号:</p>
<ul>
<li><code>1</code>:   <code>HUP</code> (挂起)</li>
<li><code>2</code>:   <code>INT</code> (中断)</li>
<li><code>3</code>:   <code>QUIT</code> (退出)</li>
<li><code>9</code>:   <code>KILL</code> (<code>KILL</code> 信号不能被捕捉, 不能被忽略. )</li>
<li><code>15</code>:   <code>TERM</code> (软件终止信号)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-3"><a class="header" href="#linux-3">linux-3</a></h1>
<h2 id="zsh和bash的不同"><a class="header" href="#zsh和bash的不同">zsh和Bash的不同</a></h2>
<p><a href="https://blog.csdn.net/lixinze779/article/details/81012318">zsh和Bash究竟有何不同</a>
<a href="https://www.xshell.net/shell/bash_zsh.html">zsh和Bash,究竟有何不同 坑很深</a></p>
<pre><code class="language-bash">chsh -s /bin/bash
chsh -s /bin/zsh
</code></pre>
<p>开始之前: 理解<code>zsh</code>的仿真模式(emulation mode)</p>
<p>一种流行的说法是,<code>zsh</code>是与<code>Bash</code>兼容的.这种说法既对,也不对,因为<code>zsh</code>本身作为一种脚本语言,是与<code>Bash</code>不兼容的.
符合<code>Bash</code>规范的脚本无法保证被<code>zsh</code>解释器正确执行.
但是,<code>zsh</code>实现中包含了一个屌炸天的仿真模式(emulation mode),支持对两种主流的Bourne衍生版shell(<code>bash</code>,<code>ksh</code>)和<code>C shell</code>的仿真(<code>csh</code>的支持并不完整).
在<code>Bash</code>的仿真模式下,可以使用与<code>Bash</code>相同的语法和命令集合,从而达到近乎完全兼容的目的.
为了激活对<code>Bash</code>的仿真,需要显式执行:</p>
<pre><code class="language-bash">$ emulate bash
</code></pre>
<p>等效于:</p>
<pre><code class="language-bash">$ emulate sh
</code></pre>
<p><code>zsh</code>是不会根据文件开头的<code>shebang</code>(如<code>#!/bin/sh</code>和<code>#!/bin/bash</code>)自动采取兼容模式来解释脚本的,
因此,要让<code>zsh</code>解释执行一个其他<code>Shell</code>的脚本,你仍然必须手动<code>emulate sh</code>或者<code>emulate ksh</code>,告诉<code>zsh</code>对何种Shell进行仿真.</p>
<p>那么,<code>zsh</code>究竟在何时能够自动仿真某种Shell呢?</p>
<p>对于如今的绝大部分<code>GNU/Linux</code>(Debian系除外)和<code>Mac OS X</code>用户来说,系统默认的<code>/bin/sh</code>指向的是<code>bash</code>:</p>
<pre><code class="language-bash">$ file /bin/sh
/bin/sh: symbolic link to `bash'
</code></pre>
<p>不妨试试用<code>zsh</code>来取代<code>bash</code>作为系统的<code>/bin/sh</code>:</p>
<p><code># ln -sf /bin/zsh /bin/sh </code></p>
<p>所有的<code>Bash</code>脚本仍然能够正确执行,因为<code>zsh</code>在作为<code>/bin/sh</code>存在时,能够自动采取其相应的兼容模式(<code>emulate sh</code>)来执行命令.
也许正是因为这个理由,Grml直接选择了<code>zsh</code>作为它的<code>/bin/sh</code>,对现有的Bash脚本能做到近乎完美的兼容.</p>
<h3 id="shebang"><a class="header" href="#shebang">shebang</a></h3>
<p>无关主题: 关于<code>/bin/sh</code>和<code>shebang</code>的可移植性</p>
<p>说到<code>/bin/sh</code>,就不得不提一下,在<code>zsh</code>的语境下,<code>sh</code>指的是大多数<code>GNU/Linux</code>发行版上<code>/bin/sh</code>默认指向的<code>bash</code>,
或者至少是一个<code>Bash</code>的子集(若并非全部<code>GNU Bash</code>的最新特性都被实现的话),而非指<code>POSIX shell</code>.
因此,<code>zsh</code>中的<code>emulate sh</code>可以被用来对<code>Bash</code>脚本进行仿真.</p>
<p>众所周知,<code>Debian</code>的默认<code>/bin/sh</code>是 <code>dash</code>(<code>Debian Almquist shell</code>),这是一个纯粹<code>POSIX shell</code>兼容的实现,基本上你要的<code>bash</code>和<code>ksh</code>里的那些高级特性它都没有.</p>
<p>&quot;如果你在一个<code>#!/bin/sh</code>脚本中用到了非<code>POSIX shell</code>的东西,说明你的脚本写得是错的,不关我们发行版的事情.&quot;
Debian开发者们在把默认的<code>/bin/sh</code>换成<code>dash</code>,导致一些脚本出错时这样宣称道.</p>
<p>当然,我们应该继续假装与<code>POSIX shell</code>标准保持兼容是一件重要的事情,即使现在大家都已经用上了更高级的shell.</p>
<p>因为有非<code>GNU</code>的<code>Unix</code>,和<code>Debian GNU/Linux</code>这类发行版的存在,你不能够假设系统的<code>/bin/sh</code>总是<code>GNU Bash</code>,
也不应该把<code>#!/bin/sh</code>用作一个<code>Bash</code>脚本的<code>shebang</code>(--除非你愿意放弃你手头<code>Shell</code>的高级特性,写只与<code>POSIX shell</code>兼容的脚本).</p>
<p>如果想要这个脚本能够被方便地移植的话,应指定其依赖的具体Shell解释器: <code>#!/usr/bin/env bash </code>
这样系统才能够总是使用正确的<code>Shell</code>来运行脚本.
(当然,显式地调用<code>bash</code>命令来执行脚本,<code>shebang</code>怎样写就无所谓了)</p>
<h3 id="echo命令--字符串转义"><a class="header" href="#echo命令--字符串转义">echo命令 / 字符串转义</a></h3>
<p><code>zsh</code>比之于<code>Bash</code>,可能最容易被注意到的一点不同是,<code>zsh</code>中的<code>echo</code>和<code>printf</code>是内置的命令.</p>
<pre><code class="language-zsh">$ which echo
echo: shell built-in command

$ which printf
printf: shell built-in command
</code></pre>
<p><code>Bash</code>中的<code>echo</code>和<code>printf</code>同样是内置命令:</p>
<pre><code class="language-bash">$ type echo
echo is a shell builtin

$ type printf
echo is a shell builtin
</code></pre>
<p>因为<code>which</code>本身并不是Bash中的内置命令, <code>which</code>在<code>zsh</code>中是一个内置命令.</p>
<p><code>zsh</code>内置的<code>echo</code>命令,与我们以前在<code>GNU Bash</code>中常见的<code>echo</code>命令,使用方式是不兼容的.</p>
<p>首先,请看Bash:</p>
<pre><code class="language-bash">$ echo \\
\
$ echo \\\\
\\
</code></pre>
<p>我们知道,因为这里传递给<code>echo</code>的只是一个字符串(允许使用反斜杠<code>\</code>转义),所以不加引号与加上双引号是等价的.
<code>Bash</code>输出了我们预想中的结果: 每两个连续的<code>\</code>转义成一个<code>\</code>字符输出,最终<code>2</code>个变<code>1</code>个,<code>4</code>个变<code>2</code>个.没有任何惊奇之处.</p>
<p>你能猜到<code>zsh</code>的输出结果么?</p>
<pre><code class="language-bash">$ echo \\
\
$ echo \\\\
\
</code></pre>
<p>我们还知道,要想避免一个字符串被反斜杠转义,可以把它放进单引号.
正如我们在Bash中所清楚看到的这样,所有的反斜杠都照原样输出:</p>
<pre><code class="language-bash">$ echo '\\'
\\
$ echo '\\\\'
\\\\
</code></pre>
<p>再一次,你能猜到zsh的输出结果么?</p>
<pre><code class="language-bash">$ echo '\\'
\
$ echo '\\\\'
\\
</code></pre>
<p>这个解释是这样的: 在前一种不加引号(或者加了双引号)的情形下,<strong>传递给<code>echo</code>内部命令的字符串将首先被转义</strong>,
<code>echo \\</code>中的<code>\\</code>被转义成<code>\</code>,<code>echo \\\\</code>中的<code>\\\\</code>被转义成<code>\\</code>.</p>
<p>然后,在<code>echo</code>这个内部命令输出到终端的时候,它还要把这个东西再转义一遍,一个单独的<code>\</code>没法转义,所以仍然是作为<code>\</code>输出;
连续的<code>\\</code>被转义成<code>\</code>,所以输出就是<code>\</code>.因此,<code>echo \\</code>和<code>echo \\\\</code>的输出相同,都是<code>\</code>.</p>
<p>为了让<code>zsh</code>中<code>echo</code>的输出不被转义,需要显式地指明<code>-E</code>选项:</p>
<pre><code class="language-bash">$ echo -E \\
\
$ echo -E \\\\
\\
</code></pre>
<p>于是,我们也就知道在后一种加单引号的情形下,如何得到与原字符串完全相同的输出了:</p>
<pre><code class="language-bash">$ echo -E '\\'
\\
$ echo -E '\\\\'
\\\\
</code></pre>
<p>而<code>Bash</code>的<code>echo</code>默认就是不对输出进行转义的,若要得到转义的效果,需显式地指定<code>-e</code>选项.<code>Bash</code>和<code>zsh</code>中<code>echo</code>命令用法的不兼容,在这里体现出来了.</p>
<h3 id="word-splitting变量的自动分字"><a class="header" href="#word-splitting变量的自动分字">(word splitting)变量的自动分字</a></h3>
<p>在<code>Bash</code>中,你可以通过调用外部命令<code>echo</code>输出一个字符串:</p>
<pre><code class="language-bash">echo $text
</code></pre>
<p>我们知道,<code>Bash</code><strong>会对传递给命令的字符串进行分字(根据空格或换行符)</strong>,然后作为多个参数传给<code>echo</code>.
当然,作为分隔符的换行,在最终输出时就被抹掉了.</p>
<p>于是,更好的习惯是把变量名放在双引号中,把它作为一个字符串传递,这样就可以保留文本中的换行符,将其原样输出.</p>
<pre><code class="language-bash">echo &quot;$text&quot;
</code></pre>
<p>在<code>zsh</code>中,你不需要通过双引号来告诉解释器&quot;<code>$text</code>是一个字符串&quot;.
解释器不会把它转换成一个由<code>空格</code>或者<code>\n</code>分隔的参数列表或者别的什么.
所以,没有<code>Bash</code>中的<code>trick</code>,直接<code>echo $text</code>就可以保留换行符.
但是,如前一节所说,我们需要一个多余的工作来保证输出的是未转义的原始文本,那就是<code>-E</code>选项:</p>
<pre><code class="language-bash">echo -E $text
</code></pre>
<p>从这里我们看到,<strong><code>zsh</code>中的变量在传递给命令时是不会被自动切分成<code>words</code>然后以多个参数的形式存在的</strong>.它仍然保持为一个量.</p>
<p>这是它与传统的<code>Bourne</code>衍生shell(<code>ksh</code>,<code>bash</code>)的一个重要不兼容之处.这是<code>zsh</code>的特性,而不是一个bug.</p>
<h3 id="通配符展开globbing"><a class="header" href="#通配符展开globbing">通配符展开(globbing)</a></h3>
<p>通配符展开(<code>globbing</code>)也许是<code>Unix shell</code>中最为实用化的功能之一.
比起正则表达式,它的功能相当有限,不过它的确能满足大部分时候的需求: 依据固定的前缀或后缀匹配文件.
需要更复杂模式的时候其实是很少见的,至少在文件的命名和查找上.</p>
<p><code>Bash</code>和<code>zsh</code>对通配符展开的处理方式有何不同呢?
举个例子,假如我们想要列举出当前目录下所有的<code>.markdown</code>文件,但实际上又不存在这样的文件.
在<code>zsh</code>中: (注意到这里使用了内置的<code>echo</code>,因为我们暂时还不想用到外部的系统命令)</p>
<pre><code class="language-zsh">$ echo *.markdown
zsh: no matches found: *.markdown
</code></pre>
<p><code>Bash</code>中:</p>
<pre><code class="language-bash">$ echo *.markdown
*.markdown
</code></pre>
<p>zsh因为通配符展开失败而报错; 而<code>Bash</code>在通配符展开失败时,会放弃把它作为通配符展开,直接把它当做字面量返回.</p>
<p>看起来,<code>zsh</code>的处理方式更优雅,因为这样你就可以知道这个通配符确实无法展开;
而在Bash中,你很难知道究竟是不存在这样的文件,还是存在一个文件名为<code>'*.markdown'</code>的文件.</p>
<p>接下来就是不那么和谐的方面了.</p>
<p>在<code>zsh</code>中,用<code>ls</code>查看当然还是报错:</p>
<pre><code class="language-zsh">$ ls *.markdown
zsh: no matches found: *.markdown
</code></pre>
<p>Bash,这时候调用<code>ls</code>也会报错.
因为当前目录下没有<code>.markdown</code>后缀的文件,通配符展开失败后变成字面的<code>'*.markdown'</code>,这个文件自然也不可能存在,所以外部命令<code>ls</code>报错:</p>
<pre><code class="language-bash">$ ls *.markdown
ls: cannot access *.markdown: No such file or directory
</code></pre>
<p>同样是错误,差别在哪里? 对于<code>zsh</code>,这是一个语言级别的错误;
对于<code>Bash</code>,这是一个外部命令执行的错误.这件差别很重要,因为它意味着后者可以被轻易地<code>catch</code>,而前者不能.</p>
<p>想象一个常见的命令式编程语言,<code>Java</code>或者<code>Python</code>.你可以用<code>try...catch</code>或类似的语言结构来捕获运行时的异常,比较优雅地处理无法预料的错误.</p>
<p><code>Shell</code>当然没有通用的异常机制,但是,你可以通过检测某一段命令的返回值来模拟捕获运行时的错误.例如,在<code>Bash</code>里可以这样:</p>
<pre><code class="language-bash">$ if ls *.markdown &amp;&gt;/dev/null; then :; else echo $?; fi
2
</code></pre>
<p>于是,在通配符展开失败的情形下,我们也能轻易地把外部命令的错误输出重定向到<code>/dev/null</code>,然后根据返回的错误码执行后续的操作.</p>
<p>不过在<code>zsh</code>中,这个来自<code>zsh</code>解释器自身的错误输出却无法被重定向:</p>
<pre><code class="language-zsh">$ if ls *.markdown &amp;&gt;/dev/null; then :; else echo $?; fi
zsh: no matches found: *.markdown
1
</code></pre>
<p>大部分时候,我们并不想看到这些丑陋多余的错误输出,我们期望程序能完全捕获这些错误,然后完成它该完成的工作.
但这也许是一种正常的行为.
理由是,在程序语言里,<code>syntax error</code>一般是无法简单地由用户在运行阶段自行<code>catch</code>的,这个报错工作将直接由解释器来完成.除非,当然,除非我们用了邪恶的<code>eval</code>.</p>
<pre><code class="language-zsh">$ if eval &quot;ls *.markdown&quot; &amp;&gt;/dev/null; then :; else echo $?; fi
1
</code></pre>
<p><code>Eval is evil</code>. 但在<code>zsh</code>中捕获这样的错误,似乎没有更好的办法了.
必须这么做的原因就是: <code>zsh</code>中,通配符展开失败是一个语法错误.而在<code>Bash</code>中则不是.</p>
<p>基于上述理由,依赖于<code>Bash</code>中通配符匹配失败而直接把<code>*</code>当作字面量传递给命令的写法,在<code>zsh</code>中是无法正常运行的.
例如,在<code>Bash</code>中你可以: (虽然在大部分情况下能用,但显然不加引号是不科学的)</p>
<pre><code class="language-bash">$ find /usr/share/git -name *.el
</code></pre>
<p>因为<code>zsh</code>不会在<code>glob</code>扩展失败后自动把<code>*</code>当成字面量,而是直接报错终止运行,
所以在<code>zsh</code>中你必须给<code>*.el</code>加上引号,来避免这种扩展:</p>
<pre><code class="language-bash">$ find /usr/share/git -name &quot;*.el&quot;
</code></pre>
<h3 id="字符串比较"><a class="header" href="#字符串比较">字符串比较</a></h3>
<p>在<code>Bash</code>中判断两个字符串是否相等:</p>
<pre><code class="language-bash">[ &quot;$foo&quot; = &quot;$bar&quot; ]
</code></pre>
<p>或与之等效的(现代编程语言中更常见的<code>==</code>比较运算符):</p>
<pre><code class="language-bash">[ &quot;$foo&quot; == &quot;$bar&quot; ]
</code></pre>
<p><strong>注意等号左右必须加空格,变量名一定要放在双引号中</strong>.(写过<code>Shell</code>的都知道这些规则的重要性)</p>
<p>在条件判断的语法上,<code>zsh</code>基本和<code>Bash</code>相同,没有什么改进.除了它的解释器想得太多,以至于不小心把<code>==</code>当做了一个别的东西:</p>
<pre><code class="language-bash">$ [ foo == bar ]; echo $?
zsh: = not found
</code></pre>
<p>要想使用我们最喜欢的<code>==</code>,只有把它用引号给保护起来,不让解释器做多余的解析:</p>
<pre><code class="language-bash">$ [ foo &quot;==&quot; bar ]; echo $?
1
</code></pre>
<p>所以,为了少打几个字符,还是老老实实用更省事的<code>=</code>吧.</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>同样用一个简单的例子来说明<code>Bash</code>:</p>
<pre><code class="language-bash">array=(alpha bravo charlie delta)
echo $array
echo ${array[*]}
echo ${#array[*]}
for ((i=0; i &lt; ${#array[*]}; i++));
do
    echo ${array[$i]}
done
</code></pre>
<p>输出:</p>
<pre><code class="language-bash">alpha
alpha bravo charlie delta
4
alpha
bravo
charlie
delta
</code></pre>
<p>很容易看到,<code>Bash</code>的数组下标是从<code>0</code>开始的.<code>$array</code>取得的实际上是数组的第一个元素的值,也就是<code>${array[0]}</code>(这些行为和<code>C</code>有点像).</p>
<p>要想取得整个数组的值,必须使用<code>${array[*]}</code>或<code>${array[@]}</code>,因此,获取数组的长度可以使用<code>${#array[*]}</code>.
在<code>Bash</code>中,必须记得在访问数组元素时给整个数组名连同下标加上花括号,
比如,<code>${array[*]}</code>不能写成<code>$array[*]</code>,否则解释器会首先把<code>$array</code>当作一个变量来处理.</p>
<p>再来看这段<code>zsh</code>:</p>
<pre><code class="language-zsh">array=(alpha bravo charlie delta)
echo $array
echo $array[*]
echo $#array
for ((i=1; i &lt;= $#array[*]; i++));
do
echo $array[$i]
done
</code></pre>
<p>输出:</p>
<pre><code class="language-zsh">alpha bravo charlie delta
alpha bravo charlie delta
4
alpha
bravo
charlie
delta
</code></pre>
<p>在<code>zsh</code>中,<code>$array</code>和<code>$array[*]</code>一样,可以用来取得整个数组的值.因此获取数组的长度可直接用<code>$#array</code>.</p>
<p><code>zsh</code>的默认数组下标是从<code>1</code>而不是<code>0</code>开始的,这点更像<code>C shell</code>.
(虽然一直无法理解一个名字叫<code>C</code>的<code>shell</code>为何会采用<code>1</code>作为数组下标开始这种奇葩设定)</p>
<p>最后,<code>zsh</code>不需要借助花括号来访问数组元素,因此<code>Bash</code>中必需的花括号都被略去了.</p>
<h3 id="关联数组"><a class="header" href="#关联数组">关联数组</a></h3>
<p><code>Bash 4.0+</code>和<code>zsh</code>中都提供了对类似<code>AWK</code>关联数组的支持.</p>
<pre><code class="language-bash">declare -A array
array[mort]=foo
</code></pre>
<p>和普通的数组一样,在<code>Bash</code>中,必须显式地借助花括号来访问一个数组元素:</p>
<pre><code class="language-bash">echo ${array[mort]}
</code></pre>
<p>而<code>zsh</code>中则没有必要:</p>
<pre><code class="language-bash">echo $array[mort]
</code></pre>
<p>说到这里,我们注意到<code>zsh</code>有一个不同寻常的特性: <strong>支持使用方括号进行更复杂的<code>globbing</code></strong>,
<code>array[mort]</code>这样的写法事实上会造成二义性:
究竟是取<code>array</code>这个关联数组以<code>mort</code>为<code>key</code>的元素值呢,还是以通配符展开的方式匹配当前目录下以<code>&quot;array&quot;</code>开头,以<code>&quot;m&quot;</code>,<code>&quot;o&quot;</code>,<code>&quot;r&quot;</code>或<code>&quot;t&quot;</code>任一字符结尾的文件名呢?</p>
<p>在<code>array[mort]=</code>作为命令开始的情况下,不存在歧义,这是一个对关联数组的赋值操作.
在前面带有<code>$</code>的情况下,<code>zsh</code>会自动把<code>$array[mort]</code>识别成取关联数组的值,这也没有太大问题.
问题出在它存在于命令中间,却又不带<code>$</code>的情况,比如:</p>
<pre><code class="language-bash">read -r -d ' ' array[mort] &lt;&lt; 'EOF' hello world EOF
</code></pre>
<p>我们的本意是把这个<code>heredoc</code>赋值给<code>array[mort]</code>数组元素.在<code>Bash</code>中,这是完全合法的.
然而,在<code>zsh</code>中,解释器会首先试图对<code>&quot;array[mort]&quot;</code>这个模式进行<code>glob</code>展开,如果当前目录下没有符合该模式的文件,当然就会报出一个语法错误:</p>
<pre><code class="language-zsh">zsh: no matches found: array[mort]
</code></pre>
<p>这是一件很傻的事情,为了让这段脚本能够被<code>zsh</code>解释器正确执行,我们需要把<code>array[mort]</code>放在引号中以防止被展开:</p>
<pre><code class="language-zsh">read -r -d '' 'array[mort]' &lt;&lt; 'EOF' hello world EOF
</code></pre>
<p>这是<code>zsh</code>在扩展了一些强大功能的同时带来的不便之处(或者说破坏了现有脚本兼容性的安全隐患,又或者是让解释器混乱的<code>pitfalls</code>).</p>
<p>顺便说一句,用<code>Rake</code>构建过项目的<code>Rails</code>程序员都知道,有些时候需要在命令行下通过方括号给<code>rake</code>传递参数值,如:</p>
<pre><code class="language-zsh">$ rake seeder:seed[100]
</code></pre>
<p><code>zsh</code>这个对方括号展开的特性确实很不方便.如果不想每次都用单引号把参数括起来,可以完全禁止<code>zsh</code>对某条命令后面的参数进行<code>glob</code>扩展: (<code>~/.zshrc</code>)</p>
<pre><code class="language-zsh">alias rake=&quot;noglob rake&quot;
</code></pre>
<p>嗯,对于<code>rake</code>命令来说,<code>glob</code>扩展基本是没有用的.你可以关掉它.</p>
<h3 id="分号与空语句-if-then"><a class="header" href="#分号与空语句-if-then">分号与空语句 if then</a></h3>
<p>虽然有点无聊,但还是想提一下: <code>Bash</code>不允许语句块中使用空语句,最小化的语句是一个<code>noop</code>命令(<code>:</code>).而<code>zsh</code>允许空语句.
刚开始写<code>Bash</code>的时候,总是记不得什么时候该加分号什么时候不该加.比如</p>
<pre><code class="language-bash">if [ 1 ] then : fi
</code></pre>
<p>如果放在一行里写,应该是</p>
<pre><code class="language-bash">if [ 1 ]; then :; fi
</code></pre>
<p><code>then</code>后面是不能接分号的,如果写成</p>
<pre><code class="language-bash">if [ 1 ]; then; :; fi
</code></pre>
<p>就会报错:</p>
<pre><code class="language-bash">bash: syntax error near unexpected token `;'
</code></pre>
<p>解释是: <code>then</code>表示一个代码段的开始,<code>fi</code>表示结束,这中间的内容必须是若干行命令,或者以分号<code>;</code>结尾的放在同一行内的多条命令.
我们知道在传统的<code>shell</code>中,分号本身并不是一条命令,空字符串也不是一条命令,因此,<code>then</code>后面紧接着的分号就会带来一条语法错误.(有些时候对某个&quot;语言特性&quot;的所谓解释只是为了掩饰设计者在一开始犯的错误,所以就此打住)</p>
<p>在<code>zsh</code>中,上述两种写法都合法.因为它允许只包含一个分号的空命令.</p>
<pre><code class="language-zsh">$ ;
</code></pre>
<p>当然,因为分号只是一个语句分隔符,所以没有也是可以的.这种写法在<code>zsh</code>中合法: (<code>then</code>的语句块为空)</p>
<pre><code class="language-zsh">if [ 1 ]; then fi
</code></pre>
<h2 id="linux技巧"><a class="header" href="#linux技巧">Linux技巧</a></h2>
<p><a href="https://coolshell.cn/articles/8883.html">应该知道的Linux技巧</a></p>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<ul>
<li>学习 <code>Bash</code> .你可以<code>man bash</code>来看看<code>bash</code>的东西,并不复杂也并不长.你用别的shell也行,但是bash是很强大的并且也是系统默认的.(学习zsh或tsch只会让你在很多情况下受到限制)</li>
<li>学习 <code>vim</code> .在Linux下,基本没有什么可与之竞争的编译辑器(就算你是一个Emacs或Eclipse的重度用户).你可以看看&lt;简明vim攻略&gt;和 &lt;Vim的冒险游戏&gt;以及&lt;给程序员的Vim速查卡&gt;还有&lt;把Vim变成一个编程的IDE&gt;等等.</li>
<li>了解 <code>ssh</code>.明白不需要口令的用户认证(通过<code>ssh-agent</code>, <code>ssh-add</code>),学会用<code>ssh</code>翻墙,用<code>scp</code>而不是<code>ftp</code>传文件,等等.你知道吗? <code>scp</code> 远端的时候,你可以按<code>tab</code>键来查看远端的目录和文件(当然,需要无口令的用户认证),这都是bash的功劳.</li>
<li>熟悉<code>bash</code>的作业管理,如: <code>&amp;</code>, <code>Ctrl-Z</code>, <code>Ctrl-C</code>, <code>jobs</code>, <code>fg</code>, <code>bg</code>, <code>kill</code>, 等等.当然,你也要知道<code>Ctrl+\</code>(SIGQUIT)和<code>Ctrl+C</code> (SIGINT)的区别.</li>
<li>简单的文件管理 :  <code>ls</code> 和 <code>ls -l</code> (你最好知道 <code>ls -l</code> 的每一列的意思),
<code>less</code>, <code>head</code>, <code>tail</code> 和 <code>tail -f</code>, <code>ln</code> 和 <code>ln -s</code> (你知道明白<code>hard link</code>和<code>soft link</code>的不同和优缺点),
<code>chown</code>, <code>chmod</code>, <code>du</code> (如果你想看看磁盘的大小 <code>du -sk *</code>), <code>df</code>, <code>mount</code>,<code>find</code></li>
<li>基础的网络管理:  <code>ip</code> 或 <code>ifconfig</code>, <code>dig</code>,<code>netstat</code>, <code>ping</code>, <code>traceroute</code>, 等</li>
<li>理解正则表达式,还有<code>grep</code>/<code>egrep</code>的各种选项.比如:  <code>-o</code>, <code>-A</code>, 和 <code>-B</code> 这些选项是很值得了解的.</li>
<li>学习使用 <code>apt-get</code> 和 <code>yum</code> 来查找和安装软件(前者的经典分发包是Ubuntu,后者的经典分发包是Redhat),我还建议你试着从源码编译安装软件.</li>
</ul>
<h3 id="日常"><a class="header" href="#日常">日常</a></h3>
<ul>
<li>在 <code>bash</code> 里,使用 <code>Ctrl-R</code> 而不是上下光标键来查找历史命令.</li>
<li>在 <code>bash</code> 里,使用 <code>Ctrl-W</code> 来删除最后一个单词,使用 <code>Ctrl-U</code> 来删除一行.请<code>man bash</code>后查找<code>Readline Key Bindings</code>一节来看看<code>bash</code>的默认热键,比如: <code>Alt-.</code> 把上一次命令的最后一个参数打出来,而<code>Alt-*</code> 则列出你可以输入的命令.</li>
<li>回到上一次的工作目录:  <code>cd –</code>  (回到<code>home</code>是<code> cd ~</code>)</li>
<li>使用 <code>xargs</code>.这是一个很强大的命令.你可以使用<code>-L</code>来限定有多少个命令,也可以用<code>-P</code>来指定并行的进程数.
如果你不知道你的命令会变成什么样,你可以使用<code>xargs echo</code>来看看会是什么样.当然, <code>-I{}</code> 也很好用.示例:</li>
</ul>
<pre><code class="language-bash">find . -name \*.py | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname
</code></pre>
<ul>
<li><code>pstree -p</code> 可以帮你显示进程树.</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 来找到或是<code>kill</code>某个名字的进程. (<code>-f</code> 选项很有用).</li>
<li>了解可以发给进程的信号.例如: 要挂起一个进程,使用 <code>kill -STOP [pid]</code>. 使用 <code>man 7 signal</code> 来查看各种信号,使用<code>kill -l</code> 来查看数字和信号的对应表</li>
<li>使用 <code>nohup</code> 或  <code>disown</code> 如果你要让某个进程运行在后台.</li>
<li>使用<code>netstat -lntp</code>来看看有侦听在网络某端口的进程.当然,也可以使用<code>lsof</code>.</li>
<li>在<code>bash</code>的脚本中,你可以使用<code>set -x</code>来debug输出.使用 <code>set -e</code> 来当有错误发生的时候<code>abort</code>执行.考虑使用 <code>set -o pipefail</code> 来限制错误.还可以使用<code>trap</code>来截获信号(如截获<code>ctrl+c</code>).</li>
<li>在bash 脚本中,<code>subshells</code> (写在圆括号里的) 是一个很方便的方式来组合一些命令.一个常用的例子是临时地到另一个目录中,例如:</li>
</ul>
<pre><code class="language-bash"># do something in current dir
(cd /some/other/dir; other-command)
# continue in original dir
</code></pre>
<ul>
<li>
<p>在 bash 中有很多<strong>变量展开</strong>.如: 检查一个变量是否存在: <code>${name:?error message}</code>.
比如脚本参数的表达式:  <code>input_file=${1:?usage: $0 input_file}</code>.
计算表达式:  <code>i=$(( (i + 1) % 5 ))</code>.
一个序列:  <code>{1..10}</code>.
截断一个字符串:  <code>${var%suffix}</code> 和 <code>${var#prefix}</code>.
示例: <code>if var=foo.pdf; then echo ${var%.pdf}.txt;fi;</code></p>
</li>
<li>
<p>通过 <code>&lt;(some command)</code> 可以把某命令当成一个文件.
示例: 比较一个本地文件和远程文件<code> /etc/hosts</code>:  <code>diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</code></p>
</li>
<li>
<p>了解什么叫 &quot;here documents&quot; ,就是诸如 <code>cat &lt;&lt;EOF</code> 这样的东西.</p>
</li>
<li>
<p>在 bash中,使用重定向到标准输出和标准错误.如:  <code>some-command &gt;logfile 2&gt;&amp;1</code>.
另外,要确认某命令没有把某个打开了的文件句柄重定向给标准输入,最佳实践是加上 <code>&lt;/dev/null</code>,把<code>/dev/null</code>重定向到标准输入.</p>
</li>
<li>
<p>使用 <code>man ascii</code> 来查看 <code>ASCII</code> 表.</p>
</li>
<li>
<p>在远端的 ssh 会话里,使用 <code>screen</code> 或 <code>dtach</code> 来保存你的会话.</p>
</li>
<li>
<p>若要<code>debug Web</code>,试试<code>curl</code> 和 <code>curl -I</code> 或是 <code>wget</code> .(我觉得debug Web的利器是<code>firebug</code>,<code>curl</code>和<code>wget</code>是用来抓网页的.)</p>
</li>
<li>
<p>把 <code>HTML</code> 转成文本: <code>lynx -dump -stdin</code></p>
</li>
<li>
<p>如果你要处理<code>XML</code>,使用 <code>xmlstarlet</code></p>
</li>
<li>
<p>对于 <code>Amazon S3</code>, <code>s3cmd</code> 是一个很方便的命令(还有点不成熟)</p>
</li>
<li>
<p>在<code>ssh</code>中,知道怎么来使用<code>ssh</code>隧道.通过 <code>-L</code> or <code>-D</code> (还有<code>-R</code>) ,翻墙神器.</p>
</li>
<li>
<p>你还可以对你的 <code>ssh</code> 做点优化.比如,<code>.ssh/config</code> 包含着一些配置: 避免链接被丢弃,链接新的<code>host</code>时不需要确认,转发认证,以前使用压缩(如果你要使用scp传文件):</p>
</li>
</ul>
<pre><code class="language-bash">TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
StrictHostKeyChecking=no
Compression=yes
ForwardAgent=yes
</code></pre>
<ul>
<li>如果你输入了一行命令,但你改变注意了,又不想删除它,因为你要在历史命令中找到它,但你也不想执行它.
那么,你可以按下 <code>Alt-#</code> ,于是这个命令关就被加了一个<code>#</code>字符,于是就被注释掉了.</li>
</ul>
<h3 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h3>
<ul>
<li>了解 <code>sort</code> 和 <code>uniq</code> 命令 (包括 <code>uniq</code> 的 <code>-u</code> 和 <code>-d</code> 选项).</li>
<li>了解用 <code>cut</code>, <code>paste</code>, 和 <code>join</code> 命令来操作文本文件.很多人忘了在<code>cut</code>前使用<code>join</code>.</li>
<li>如果你知道怎么用<code>sort</code>/<code>uniq</code>来做集合交集,并集,差集能很大地促进你的工作效率.
假设有两个文本文件<code>a</code>和<code>b</code>已经被 <code>uniq</code>了,那么,用<code>sort</code>/<code>uniq</code>会是最快的方式,无论这两个文件有多大(<code>sort</code>不会被内存所限,你甚至可以使用<code>-T</code>选项,如果你的<code>/tmp</code>目录很小)</li>
</ul>
<pre><code class="language-bash">cat a b | sort | uniq &gt; c   # c is a union b 并集
cat a b | sort | uniq -d &gt; c   # c is a intersect b 交集
cat a b b | sort | uniq -u &gt; c   # c is set difference a - b 差集
</code></pre>
<ul>
<li>了解和字符集相关的命令行工具,包括排序和性能.
很多的Linux安装程序都会设置<code>LANG </code>或是其它和字符集相关的环境变量.
这些东西可能会让一些命令(如: <code>sort</code>)的执行性能慢N多倍(注: 就算是你用<code>UTF-8</code>编码文本文件,你也可以很安全地使用<code>ASCII</code>来对其排序).
如果你想<code>Disable</code>那个<code>i18n</code> 并使用传统的基于<code>byte</code>的排序方法,那就设置<code>export LC_ALL=C</code> (实际上,你可以把其放在 <code>.bashrc</code>).
如果这设置这个变量,你的<code>sort</code>命令很有可能会是错的.</li>
<li>了解 <code>awk</code> 和 <code>sed</code> ,并用他们来做一些简单的数据修改操作.例如: 求第<code>3</code>列的数字之和:  <code>awk '{ x += $3 } END { print x }'</code>.这可能会比Python快<code>3</code>倍,并比Python的代码少<code>3</code>倍.</li>
<li>使用 <code>shuf</code> 来打乱一个文件中的行或是选择文件中一个随机的行.</li>
<li>了解<code>sort</code>命令的选项.了解<code>key</code>是什么(<code>-t</code>和<code>-k</code>).具体说来,你可以使用<code>-k1,1</code>来对第一列排序,<code>-k1</code>来对全行排序.</li>
<li><code>sort -s</code> 会很有用.
例如: 如果你想对两列排序,先对第二列,再对第一列,那么你可以这样:  <code>sort -k1,1 | sort -s -k2,2</code></li>
<li>我们知道,在<code>bash</code>命令行下,<code>Tab</code>键是用来做目录文件自动完成的事的.
但是如果你想输入一个<code>Tab</code>字符(比如: 你想在<code>sort -t</code>选项后输入<code>&lt;tab&gt;</code>字符),你可以先按<code>Ctrl-V</code>,然后再按<code>Tab</code>键,就可以输入<code>&lt;tab&gt;</code>字符了.当然,你也可以使用<code>\t</code>.</li>
<li>如果你想查看二进制文件,你可以使用<code>hd</code>命令(在CentOS下是<code>hexdump</code>命令),如果你想编译二进制文件,你可以使用<code>bvi</code>命令(http://bvi.sourceforge.net/ 墙)</li>
<li>另外,对于二进制文件,你可以使用<code>strings</code>(配合<code>grep</code>等)来查看二进制中的文本.</li>
<li>对于文本文件转码,你可以试一下<code> iconv</code>.或是试试更强的 <code>uconv</code> 命令(这个命令支持更高级的Unicode编码)</li>
<li>如果你要分隔一个大文件,你可以使用<code>split</code>命令(split by size)和<code>csplit</code>命令(split by a pattern).</li>
</ul>
<h3 id="系统调试"><a class="header" href="#系统调试">系统调试</a></h3>
<ul>
<li>如果你想知道磁盘,CPU,或网络状态,你可以使用 <code>iostat</code>, <code>netstat</code>, <code>top</code> (或更好的 <code>htop</code>), 还有 <code>dstat</code> 命令.你可以很快地知道你的系统发生了什么事.关于这方面的命令,还有<code>iftop</code>, <code>iotop</code>等(参看&lt;28个Unix/Linux的命令行神器&gt;)</li>
<li>要了解内存的状态,你可以使用<code>free</code>和<code>vmstat</code>命令.具体来说,你需要注意 <code>&quot;cached&quot;</code> 的值,这个值是<code>Linux</code>内核占用的内存.还有<code>free</code>的值.</li>
<li>Java 系统监控有一个小的技巧是,你可以使用<code>kill -3 &lt;pid&gt;</code> 发一个<code>SIGQUIT</code>的信号给<code>JVM</code>,可以把堆栈信息(包括垃圾回收的信息)<code>dump</code>到<code>stderr/logs</code>.</li>
<li>使用 <code>mtr </code>会比使用 <code>traceroute</code> 要更容易定位一个网络问题.</li>
<li>如果你要找到哪个<code>socket</code>或进程在使用网络带宽,你可以使用 <code>iftop</code> 或 <code>nethogs</code>.</li>
<li><code>Apache</code>的一个叫 <code>ab</code> 的工具是一个很有用的,用<code>quick-and-dirty</code>的方式来测试网站服务器的性能负载的工作.如果你需要更为复杂的测试,你可以试试 <code>siege</code>.</li>
<li>如果你要抓网络包的话,试试 <code>wireshark</code> 或 <code>tshark.</code></li>
<li>了解 <code>strace</code> 和 <code>ltrace</code>.这两个命令可以让你查看进程的系统调用,这有助于你分析进程的hang在哪了,怎么crash和failed的.你还可以用其来做性能<code>profile</code>,使用 <code>-c</code> 选项,你可以使用<code>-p</code>选项来<code>attach</code>上任意一个进程.</li>
<li>了解用<code>ldd</code>命令来检查相关的动态链接库.注意: <code>ldd</code>的安全问题</li>
<li>使用<code>gdb</code>来调试一个正在运行的进程或分析<code>core dump</code>文件.参看我写的&lt;GDB中应该知道的几个调试方法&gt;</li>
<li>学会到 <code>/proc</code> 目录中查看信息.这是一个Linux内核运行时记录的整个操作系统的运行统计和信息,比如:  <code>/proc/cpuinfo</code>, <code>/proc/xxx/cwd</code>, <code>/proc/xxx/exe</code>, <code>/proc/xxx/fd/</code>, <code>/proc/xxx/smaps</code>.</li>
<li>如果你调试某个东西为什么出错时,<code>sar</code>命令会有用.它可以让你看看 CPU, 内存, 网络, 等的统计信息.</li>
<li>使用 <code>dmesg</code> 来查看一些硬件或驱动程序的信息或问题.</li>
</ul>
<h3 id="ubuntu死机解决方法"><a class="header" href="#ubuntu死机解决方法">Ubuntu死机解决方法</a></h3>
<p><a href="https://www.jianshu.com/p/36fb9eed82a3">https://www.jianshu.com/p/36fb9eed82a3</a></p>
<hr />
<p>进入<code>TTY</code>终端. <code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录,
也可能是<code>Ctrl+Alt+F2</code>,<code>Ctrl+Alt+F3</code>等等, 不同系统可能有点点区别.
输入<code>top</code>命令, 找到可能造成假死的进程, 用<code>kill</code>命令结束掉进程. 然后<code>Ctrl+Alt+F7</code>回到桌面</p>
<hr />
<p>直接注销用户: <code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录. 然后执行以下的任意一个命令注销桌面重新登录.</p>
<pre><code class="language-bash">sudo pkill Xorg
# 或者
sudo restart lightdm
</code></pre>
<hr />
<p>底层方法: 如果上面两种方法不成功, 那有可能是比较底层的软件出现问题. 可以试试 :<strong>reisub 方法</strong>.</p>
<p>说具体一点, 是一种系统请求, 直接交给内核处理. 键盘上一般都有一个键<code>SysRq</code>, 和<code>PrtSc</code>(PrintScreen,截屏)在一个键位上, 这就是系统请求的键.
这个方法可以在死机的情况下安全地重启计算机, 数据不会丢失.</p>
<p>其实 <code>SysRq</code>是一种叫做系统请求的东西, 按住<code>Alt-PrtSc</code> 的时候就相当于按住了<code>SysRq</code>键, 这个时候输入的一切都会直接由 <code>Linux</code> 内核来处理, 它可以进行许多低级操作.
这个时候 <code>reisub</code> 中的每一个字母都是一个独立操作, 分别表示:</p>
<ul>
<li><code>r</code> : <code>unRaw</code> 将键盘控制从 <code>X Server</code> 那里抢回来</li>
<li><code>e</code> : <code>tErminate</code> 给所有进程发送 <code>SIGTERM</code> 信号, 让它们自己解决善后</li>
<li><code>i</code> : <code>kIll</code> 给所有进程发送 <code>SIGKILL</code> 信号, 强制他们马上关闭</li>
<li><code>s</code> : <code>Sync</code> 将所有数据同步至磁盘</li>
<li><code>u</code> : <code>Unmount</code> 将所有分区挂载为只读模式</li>
<li><code>b</code> : <code>reBoot</code> 重启</li>
</ul>
<p>如果某一天你的 <code>Linux</code> 死机了, 键盘不听使唤了, <code>Ctrl+Alt+F1</code> 已经没有任何反应, 该怎么办呢?
使用'魔法键': <code>Alt+SysRq + r,e,i,s,u,b</code>(确实很好背, 就是单词 <code>busier</code>的倒写).</p>
<p>首先, 你的系统要支持这个功能, 接下来就是操作: 同时按下<code>&lt;Alt&gt;+&lt;SysRq&gt;</code>不行, 只会蹦出来一个屏幕截图窗口. 所以, 真正的做法应该是:</p>
<ul>
<li>伸出你的左手, 同时按住<code>&lt;Ctrl&gt;+&lt;Alt&gt;</code>键, 下面几步时, 一直不松开</li>
<li>右手先按一下<code>&lt;SysRq&gt;</code>or<code>PrcSc</code>, 左手别松开, 等<code>1</code>秒,</li>
<li>右手按一下<code>R</code>, 左手别松开, 等<code>1</code>秒,</li>
<li>右手按一下<code>E</code>, 左手别松开. 这时包括桌面在内, 所有程序都会终止, 你会看到一个黑乎乎的屏幕, 稍微等一段时间</li>
<li>右手依次按下<code>I</code>,<code>S</code>,<code>U</code>,<code>B</code>,左手别松开. 每按一次都等那么几秒种, 你会发现每按一次, 屏幕上信息都会有所变化.
最后按下<code>B</code>时, 屏幕显示<code>reset</code>, 这时你的左手可以松开了, 等几秒钟, 计算机就会安全重启.</li>
</ul>
<hr />
<p>开启<code>SysRq</code>功能: <a href="https://blog.csdn.net/jasonchen_gbd/article/details/79080576">Linux中的SysRq魔术键</a>. 幸运的是: <code>Ubuntu</code> 默认已经开启了这个功能.</p>
<p>首先要确保内核打开了<code>CONFIG_MAGIC_SYSRQ</code>配置项, 这样<code>SysRq</code>的底层处理才可用.
另外内核中有一个宏定义<code>SYSRQ_DEFAULT_ENABLE</code>, 表示系统默认情况下是否启用<code>SysRq</code>功能键.
当然, 不管这个值是不是<code>yes</code>, 你都可以通过<code>proc</code>文件系统来开启或关闭<code>SysRq</code>键:</p>
<pre><code class="language-bash"># 查看当前SysRq是否被开启(0表示关闭):
cat /proc/sys/kernel/sysrq
# 开启SysRq:
echo 1 &gt; /proc/sys/kernel/sysrq
# 也可以使用sysctl命令
sysctl -w kernel.sysrq=1
</code></pre>
<p>实际上<code>sysctl</code>这条命令就是通过修改<code>/proc/sys/kernel/sysrq</code>来生效的. 可以把<code>kernel.sysrq=1</code>设置到<code>/etc/sysctl.conf</code>中, 使<code>SysRq</code>在下次系统重启仍生效.
[Ryzen随机卡死问题](https://mrswolf.github.io/zh-cn/2019/05/24/manjaro%E8%B8%A9%E5%9D%91%E8%AE%B0/)</p>
<pre><code class="language-bash"># 编辑或新建99-sysctl.conf
sudo nano /etc/sysctl.d/99-sysctl.conf
# 添加以下内容, 按Alt+PrtSc+REISUB可以安全重启
kernel.sysrq = 1
</code></pre>
<p><code>0</code>表示完全关闭<code>SysRq</code>, <code>1</code>表示使能<code>SysRq</code>的所有功能, 还可以设置成其他数字来选择开启部分功能, 可参考内核里的<code>Documentation/sysrq.txt</code>.</p>
<p>我们可以直接通过按键的方式或者通过写<code>/proc/sysrq-trigger</code>的方式来触发<code>SysRq</code>的操作. <code>SysRq</code>支持的操作可参考下面的HELP输出:
即<code>SysRq键+一个字母</code>来触发一个操作, 例如<code>SysRq+t</code>打印所有任务的状态.</p>
<p>也可以不通过按键, 而是写<code>/proc/sysrq-trigger</code>的方式, 用法形如:</p>
<pre><code class="language-bash">echo c &gt; /proc/sysrq-trigger
</code></pre>
<p>即向<code>sysrq-trigger</code>写入相应的字母即可. 并且, 无论<code>/proc/sys/kernel/sysrq</code>是什么值, 这种方式都是可用的.</p>
<h3 id="transmission-屏蔽ipv4"><a class="header" href="#transmission-屏蔽ipv4">transmission 屏蔽Ipv4</a></h3>
<p><code>cd ~/.config/transmission/blocklists</code></p>
<p>创建空文件,文件名任意,写入
<code>Ipv4:0.0.0.0-255.255.255.255</code></p>
<p>然后
<code>cd ~/.config/transmission</code>
<code>vim settings.json</code></p>
<p>设置<code>ip</code>屏蔽生效
<code>&quot;blocklist-enabled&quot;: true,</code></p>
<h2 id="unixlinux命令行常用工具"><a class="header" href="#unixlinux命令行常用工具">Unix/Linux命令行常用工具</a></h2>
<p><a href="https://coolshell.cn/articles/7829.html">28个Unix/Linux的命令行神器</a></p>
<hr />
<p><code>dstat</code> &amp; <code>sar</code></p>
<p><code>iostat</code>, <code>vmstat</code>, <code>ifstat</code> 三合一的工具,用来查看系统性能(我在&lt;性能调优攻略&gt;中提到过那三个xxstat工具).</p>
<p>官方网站: http://dag.wieers.com/rpm/packages/dstat/</p>
<p>你可以这样使用:</p>
<pre><code class="language-bash">alias dstat='dstat -cdlmnpsy'
dstat screenshot
</code></pre>
<hr />
<p><code>slurm</code></p>
<p>查看网络流量的一个工具
官方网站:   Simple Linux Utility for Resource Management</p>
<hr />
<p><code>screen</code>, <code>dtach</code>, <code>tmux</code>, <code>byobu</code></p>
<p>你是不是经常需要 <code>SSH</code> 或者 <code>telent</code> 远程登录到 <code>Linux</code> 服务器? 你是不是经常为一些长时间运行的任务而头疼,比如系统备份,<code>ftp</code> 传输等等.
通常情况下我们都是为每一个这样的任务开一个远程终端窗口,因为他们执行的时间太长了.
必须等待它执行完毕,在此期间可不能关掉窗口或者断开连接,否则这个任务就会被杀掉,一切半途而废了.</p>
<p><code>Screen</code> 是一个可以在多个进程之间多路复用一个物理终端的窗口管理器.
<code>Screen</code>中有会话的概念,用户可以在一个<code>screen</code>会话中创建多个<code>screen</code>窗口,在每一个<code>screen</code>窗口中就像操作一个真实的<code>telnet/SSH</code>连接窗口那样.
请参看IBM DeveloperWorks的这篇文章&lt;使用 <code>screen</code> 管理你的远程会话&gt;</p>
<p><code>dtach</code> 是用来模拟<code>screen</code>的<code>detach</code>的功能的小工具,其可以让你随意地<code>attach</code>到各种会话上 .</p>
<p><code>tmux</code> 是一个优秀的终端复用软件,类似<code>GNU Screen</code>,但来自于<code>OpenBSD</code>,采用<code>BSD</code>授权.
使用它最直观的好处就是,通过一个终端登录远程主机并运行<code>tmux</code>后,在其中可以开启多个控制台而无需再浪费多余的终端来连接这台远程主机;
当然其功能远不止于此.
与<code>screen</code>相比的优点: 可以横向和纵向分割窗口,且窗格可以自由移动和调整大小.
可在多个缓冲区进行复制和粘贴,支持跨窗口搜索; 非正常断线后不需重新<code>detach</code>; ... 有人说--与<code>tmux</code>相比,<code>screen</code>简直弱爆了.</p>
<p><code>byobu</code>是<code>Ubuntu</code>开发的,在<code>Screen</code>的基础上进行包装,使其更加易用的一个工具.
最新的<code>Byobu</code>,已经是基于<code>Tmux</code>作为后端了.可通过<code>byobu-tmux</code>这个命令行前端来接受各种与<code>tmux</code>一模一样的参数来控制它.</p>
<hr />
<p><code>multitail</code></p>
<p><code>MultiTail</code>是个用来实现同时监控多个文档,类似<code>tail</code>命令的功能的软件.
他和<code>tail</code>的区别就是他会在控制台中打开多个窗口,这样使同时监控多个日志文档成为可能.
他还可以看<code>log</code>文件的统计,合并<code>log</code>文件,过滤<code>log</code>文件,分屏, ...</p>
<p>官网: http://www.vanheusden.com/multitail/</p>
<hr />
<p><code>tpp</code></p>
<p>终端下的<code>PPT</code>,要是在某某大会上用这个演示<code>PPT</code>,就太TMD的Geek了.</p>
<p>官网: http://www.ngolde.de/tpp.html</p>
<hr />
<p><code>xargs</code> &amp; <code>parallel</code></p>
<p>Executes tasks from input (even multithread).</p>
<p><code>xargs</code> 是一个比较古老的命令,有简单的并行功能,这个不说了.
对于<code>GNU parallel</code> ( online manpage )来说,它不仅能够处理本机上多执行绪,还能分散至远端电脑协助处理.
而使用<code>GNU parallel</code>前,要先确定本机有安装<code>GNU parallel/ssh/ rsync</code>,远端电脑也要安装<code>ssh</code>.</p>
<hr />
<p><code>duplicity</code> &amp; <code>rsyncrypto</code></p>
<p><code>Duplicity</code>是使用<code>rsync</code>算法加密的高效率备份软件,<code>Duplicity</code>支持目录加密生产和格式上传到远程或本地文件服务器.</p>
<p><code>rsyncrypto</code> 就是<code>rsync+encryption</code>.对于<code>rsync</code>的算法可参看酷壳的<code>rsync</code>核心算法.</p>
<hr />
<p><code>nethack</code> &amp; <code>slash'em</code></p>
<p><code>NetHack</code>(Wiki),20年历史的古老电脑游戏.
没有声音,没有漂亮的界面,不过这个游戏真的很有意思.网上有个家伙说: 如果你一生只做一件事情,那么玩NetHack.
这句话很惹眼,但也让人觉得这个游戏很复杂不容易上手.其实,这个游戏很虽然很复杂,却容易上手.
虽然玩通关很难,但上手很容易.NetHack上有许多复杂的规则,<code>the DevTeam thinks of everything</code>(开发团队想到了所有的事情).
各种各样的怪物,各种各样的武器...,有许多<code>spoilers</code>文件来说明其规则.
除了每次开始随机生成的地图,每次玩游戏,你也都会碰到奇怪的事情: 因为喝了一种药水,变成了机器人;
因为踢坏了商店的门被要求高价赔偿;你的狗为你偷来了商店的东西... 这有点象人生,你不能完全了解这个世界,但你仍然可以选择自己的面对方式.</p>
<p>网上有许多文章所这是最好的电脑游戏或最好的电脑游戏之一.
也许是因为它开放的源代码让人赞赏,古老的历史让人宽容,复杂的规则让人敬畏.
虽然它不是当前流行的游戏,但它比任何一个当前流行的游戏都更有可能再经受20年的考验.</p>
<p><code>Slash'EM</code> 也是一个基于<code>NetHack</code>的经典游戏.</p>
<hr />
<p><code>lftp</code></p>
<p>利用<code>lftp</code>命令行<code>ftp</code>工具进行网站数据的增量备份,镜像,就像使用<code>rsync</code>一样.</p>
<hr />
<p><code>ack</code></p>
<p><code>ack</code>是一个<code>perl</code>脚本,是<code>grep</code>的一个可选替换品.其可以对匹配字符有高亮显示.
是为程序员专门设计的,默认递归搜索,缺省提供多种文件类型供选.</p>
<hr />
<p><code>calcurse</code> &amp; <code>remind+wyrd</code></p>
<p><code>calcurse</code> 是一个命令行下的日历和日程软件.<code>remind+wyrd</code>也很类似.
关于日历,我不得不提一个Linux的<code>Cycle</code>日历,也是一个神器,呵呵.</p>
<hr />
<p><code>newsbeuter</code> &amp; <code>rsstail</code></p>
<p><code>newsbeuter</code> 和 <code>rsstail</code> 是命令行下RSS的阅读工具.</p>
<hr />
<p><code>powertop</code></p>
<p>做个环保的程序员,看看自己的电脑里哪些程序费电.<code>PowerTOP</code> 是一个让 Intel 平台的笔记本电脑节省电源的 <code>Linux</code> 工具.
此工具由 <code>Intel</code> 公司发布.它可以帮助用户找出那些耗电量大的程序,通过修复或者关闭那些应用程序或进程,从而为用户节省电源.</p>
<hr />
<p><code>htop</code> &amp; <code>iotop</code></p>
<p><code>htop</code> 和 <code>iotop</code>  用来查看进程,内存和<code>IO</code>负载.</p>
<hr />
<p><code>ttyrec</code> &amp; <code>ipbt</code></p>
<p><code>ttyrec</code> 是一个 <code>tty</code> 控制台录制程序,其所录制的数据文件可以使用与之配套的 <code>ttyplay</code> 播放.
不管是你在 <code>tty</code> 中的各种操作,还是在 <code>tty</code> 中耳熟能详的软件,都可进行录制.</p>
<p><code>ipbt</code> 是一个用来回放 <code>ttyrec</code> 所录制的控制台输入过程的工具.</p>
<p>与此类似的还有 <code>Shelr</code> 和 <code>termrec</code></p>
<hr />
<p><code>rsync</code></p>
<p>通过<code>SSH</code>进行文件同步的经典工具(核心算法)</p>
<hr />
<p><code>mtr</code></p>
<p><code>MTR</code>--<code>traceroute 2.0</code>,其是把 <code>traceroute</code> 和 <code>ping</code> 集成在一块的一个小工具 用于诊断网络.</p>
<hr />
<p><code>socat</code> &amp; <code>netpipes</code></p>
<p><code>socat</code>是一个多功能的网络工具,名字来由是<code>Socket CAT</code>,可以看作是<code>netcat</code>的N倍加强版.
<code>netpipes</code> 和 <code>socat</code> 一样,主要是用来在命令行来进行<code>socket</code>操作的命令,这样你就可以在<code>Shell</code>脚本下行进<code>socket</code>网络通讯了.</p>
<hr />
<p><code>iftop</code> &amp; <code>iptraf</code></p>
<p><code>iftop</code> 和<code>iptraf</code>可以用来查看当前网络链接的一些流量情况.</p>
<hr />
<p><code>siege</code> &amp; <code>tsung</code></p>
<p><code>Siege</code> 是一个压力测试和评测工具,设计用于WEB开发这运算应用在压力下的承受能力:
可以根据配置对一个WEB站点进行多用户的并发访问,记录每个用户所有请求过程的相应时间,并在一定数量的并发访问下重复进行.</p>
<p><code>Tsung</code> 是一个压力测试工具,可以测试包括<code>HTTP</code>, <code>WebDAV</code>, <code>PostgreSQL</code>, <code>MySQL</code>, <code>LDAP</code>, and <code>XMPP/Jabber</code>等服务器.
针对 <code>HTTP</code> 测试,<code>Tsung</code> 支持 <code>HTTP 1.0/1.1</code> ,包含一个代理模式的会话记录,支持 <code>GET</code>,<code>POST</code> 和 <code>PUT</code> 以及 <code>DELETE</code> 方法,支持 <code>Cookie</code> 和基本的 <code>WWW</code> 认证,同时还支持 <code>SSL</code>.</p>
<p>参看: 十个免费的<code>Web</code>压力测试工具</p>
<hr />
<p><code>ledger</code></p>
<p><code>ledger</code> 一个命令行下记帐的小工具.</p>
<hr />
<p><code>taskwarrior</code></p>
<p><code>TaskWarrior</code> 是一个基于命令行的 <code>TODO</code> 列表管理工具.
主要功能包括: 标签,彩色表格输出,报表和图形,大量的命令,底层<code>API</code>,多用户文件锁等功能.</p>
<hr />
<p><code>curl</code></p>
<p><code>cURL</code>是一个利用URL语法在命令行下工作的文件传输工具,<code>1997</code>年首次发行.
它支持文件上传和下载,所以是综合传输工具,但按传统,习惯称<code>cURL</code>为下载工具.
<code>cURL</code>还包含了用于程序开发的<code>libcurl</code>.
<code>cURL</code>支持的通讯协议有<code>FTP</code>,<code>FTPS</code>,<code>HTTP</code>,<code>HTTPS</code>,<code>TFTP</code>,<code>SFTP</code>,<code>Gopher</code>,<code>SCP</code>,<code>Telnet</code>,<code>DICT</code>,<code>FILE</code>,<code>LDAP</code>,<code>LDAPS</code>,<code>IMAP</code>,<code>POP3</code>,<code>SMTP</code> 和 <code>RTSP</code>.</p>
<hr />
<p><code>rtorrent</code> &amp; <code>aria2</code></p>
<p><code>rTorrent</code> 是一个非常简洁,优秀,非常轻量的<code>BT</code>客户端. 它使用了 <code>ncurses</code> 库以 <code>C++</code> 编写, 因此它完全基于文本并在终端中运行.
将 <code>rTorrent</code> 用在安装有 <code>GNU Screen</code> 和 <code>Secure Shell</code> 的低端系统上作为远程的 <code>BT</code> 客户端是非常理想的.</p>
<p><code>aria2</code> 是 <code>Linux</code> 下一个不错的高速下载工具.
由于它具有分段下载引擎,所以支持从多个地址或者从一个地址的多个连接来下载同一个文件.这样自然就大大加快了文件的下载速度.
<code>aria2</code> 也具有断点续传功能,这使你随时能够恢复已经中断的文件下载.
除了支持一般的 <code>http(s)</code> 和 <code>ftp</code> 协议外,<code>aria2</code> 还支持 <code>BitTorrent</code> 协议.这意味着,你也可以使用 <code>aria2</code> 来下载 <code>torrent</code> 文件.</p>
<hr />
<p><code>ttytter</code> &amp; <code>earthquake</code></p>
<p><code>TTYtter</code> 是一个 <code>Perl</code> 写的命令行上发 <code>Twitter</code> 的工具,可以进行所有其他平台客户端能进行的事情,当然,支持中文.
脚本控,CLI控,终端控,Perl控的最愛.</p>
<p><code>Earthquake</code> 也是一个命令行上的<code>Twitter</code>客户端.</p>
<hr />
<p><code>vifm</code> &amp; <code>ranger</code></p>
<p><code>Vifm</code> 基于 <code>ncurses</code> 的文件管理器,<code>DOS</code>风格,用键盘操作.</p>
<hr />
<p><code>Ranger</code> 用 <code>Python</code> 完成,默认为使用 <code>Vim</code> 风格的按键绑定,比如 <code>hjkl(上下左右)</code>,<code>dd(剪切)</code>,<code>yy(复制)</code>等等.
功能很全,扩展/可配置性也非常不错.
类似<code>MacOS X</code>下Finder(文件管理器)的多列文件管理方式.支持多标签页.实时预览文本文件和目录.</p>
<hr />
<p><code>cowsay</code> &amp; <code>sl</code></p>
<p><code>cowsay</code>  不说了,如下所示,哈哈哈.还有<code>xcowsay</code>,你可以自己搜一搜.</p>
<p><code>sl</code>是什么? <code>ls</code>? ,呵呵,你会经常把<code>ls</code> 打成<code>sl</code>吗? 如果是的话,这个东西可以让你娱乐一下,你会看到一辆火车呼啸而过~~,相当拉风.
你可以使用<code>sudo apt-get install sl</code> 安装.</p>
<p>最后,再介绍一个命令中<code>linuxlogo</code>,你可以使用 <code>sudo apt-get install linuxlogo</code>来安装.
然后,就可以使用<code>linuxlogo -L</code>, 来看一下各种<code>Linux</code>的<code>logo</code>了</p>
<h2 id="终端复用器-tmux"><a class="header" href="#终端复用器-tmux">终端复用器 tmux</a></h2>
<p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a>
<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">Linux 守护进程的启动方法</a></p>
<p><code>Tmux</code> 是一个终端复用器<code>(terminal multiplexer)</code>, 非常有用,属于常用的开发工具.</p>
<hr />
<p>会话与进程
命令行的典型使用方式是,打开一个终端窗口(terminal window,以下简称<code>窗口</code>),在里面输入命令.
用户与计算机的这种临时的交互,称为一次<code>会话</code>(session).
会话的一个重要特点是,窗口与其中启动的进程是连在一起的.打开窗口,会话开始; 关闭窗口,会话结束,会话内部的进程也会随之终止,不管有没有运行完.</p>
<p>一个典型的例子就是,<code>SSH</code> 登录远程计算机,打开一个远程窗口执行命令.
这时,网络突然断线,再次登录的时候,是找不回上一次执行的命令的.因为上一次 <code>SSH</code> 会话已经终止了,里面的进程也随之消失了.
为了解决这个问题,会话与窗口可以<code>解绑</code>: 窗口关闭时,会话并不终止,而是继续运行,等到以后需要的时候,再让会话<code>绑定</code>其他窗口.</p>
<h3 id="oh-my-zsh-插件-tmux"><a class="header" href="#oh-my-zsh-插件-tmux">oh-my-zsh 插件 tmux</a></h3>
<p><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/tmux"> ohmyzsh/ohmyzsh </a></p>
<p>该插件为终端多路复用器<code>tmux</code>提供<code>aliases</code>.  要使用它, 请将<code>tmux</code>添加到<code>zshrc</code>文件中的<code>plugins</code>数组中.</p>
<pre><code class="language-zshrc">plugins=(... tmux)
</code></pre>
<p>别名 命令  描述</p>
<ul>
<li><code>ta</code>:  <code>tmux attach -t</code>  连接新<code>tmux</code>会话到后台运行的会话</li>
<li><code>tad</code>:  <code>tmux attach -d -t</code>  分离某个已命名会话</li>
<li><code>ts</code>:  <code>tmux new-session -s</code> 创建新的命名会话</li>
<li><code>tl</code>:  <code>tmux list-sessions</code>  显示所有正在运行的会话</li>
<li><code>tksv</code>:  <code>tmux kill-server</code>  终止所有正运行的会话</li>
<li><code>tkss</code>:  <code>tmux kill-session -t</code>  终止某个已命名会话</li>
<li><code>tmux</code>:  <code>_zsh_tmux_plugin_run</code>  开始一个新的<code>tmux</code>会话</li>
</ul>
<h3 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h3>
<p><code>Tmux</code> 一般需要自己安装.</p>
<pre><code class="language-bash"># Ubuntu 或 Debian
$ sudo apt-get install tmux
# CentOS 或 Fedora
$ sudo yum install tmux
# Mac
$ brew install tmux
</code></pre>
<hr />
<p>启动与退出
安装完成后,键入<code>tmux</code>命令,就进入了 <code>Tmux</code> 窗口.
命令会启动 <code>Tmux</code> 窗口,底部有一个状态栏. 大概如下所示</p>
<pre><code class="language-bash">[session1]0:zsh* ~~~ &quot;OP7050&quot; 17:12 05-2月-21
</code></pre>
<p>状态栏的左侧是窗口信息(编号和名称), <code>session1</code>是会话的名字, <code>0:zsh*</code>是窗口的编号和名称, <code>*</code>表示这个窗口被激活. 右侧是系统信息.
按下<code>Ctrl+d</code>或者输入<code>exit</code>命令,就可以退出 <code>Tmux</code> 窗口, 并退出会话. 按<code>ctrl+b d</code>会退出窗口, 但将会话转移到后台运行.</p>
<hr />
<p>会话快捷键
下面是一些会话相关的快捷键.</p>
<ul>
<li>
<p><code>Ctrl+b d</code>: 分离当前会话.</p>
</li>
<li>
<p><code>Ctrl+b s</code>: 列出所有会话, 交互式选取</p>
</li>
<li>
<p><code>Ctrl+b $</code>: 重命名当前会话.</p>
</li>
<li>
<p><code>Ctrl+b c</code>: 创建新窗口.</p>
</li>
<li>
<p><code>Ctrl+b ,</code>: 重命名当前窗口.</p>
</li>
<li>
<p><code>Ctrl+b p</code>: 前一个窗口.</p>
</li>
<li>
<p><code>Ctrl+b n</code>: 后一个窗口.</p>
</li>
<li>
<p><code>tmux kill-session</code> 关闭一个会话</p>
</li>
<li>
<p><code>tmux kill-window  killw</code> -- 关闭一个窗口</p>
</li>
</ul>
<p>还可以加上<code>-a</code>选项使用</p>
<hr />
<p>前缀键</p>
<p><code>Tmux</code> 窗口有大量的快捷键.所有快捷键都要通过前缀键唤起.默认的前缀键是<code>Ctrl+b</code>,即先按下<code>Ctrl+b</code>,快捷键才会生效.
举例来说,帮助命令的快捷键是<code>Ctrl+b ?</code>.它的用法是,在 <code>Tmux</code> 窗口中,先按下<code>Ctrl+b</code>,再按下<code>?</code>,就会显示帮助信息.
然后,按下 <code>ESC</code> 键或<code>q</code>键,就可以退出帮助.</p>
<h3 id="会话管理"><a class="header" href="#会话管理">会话管理</a></h3>
<hr />
<p>新建会话
第一个启动的 <code>Tmux</code> 窗口,编号是<code>0</code>,第二个窗口的编号是<code>1</code>,以此类推.这些窗口对应的会话,就是 <code>0</code> 号会话,<code>1</code> 号会话.
使用编号区分会话,不太直观,更好的方法是为会话起名.</p>
<pre><code class="language-bash">$ tmux new -s &lt;session-name&gt;
</code></pre>
<p>上面命令新建一个指定名称的会话.</p>
<hr />
<p>分离会话</p>
<p>在 <code>Tmux</code> 窗口中,按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令,就会将当前会话与窗口分离.</p>
<pre><code class="language-bash">$ tmux detach
</code></pre>
<p>上面命令执行后,就会退出当前 <code>Tmux</code> 窗口,但是会话和里面的进程仍然在后台运行.
<code>tmux ls</code>命令可以查看当前所有的 <code>Tmux</code> 会话.</p>
<pre><code class="language-bash">$ tmux ls
# or
$ tmux list-session
</code></pre>
<hr />
<p>接入会话</p>
<p><code>tmux attach</code>命令用于重新接入某个已存在的会话.</p>
<pre><code class="language-bash"># 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &lt;session-name&gt;
</code></pre>
<hr />
<p>杀死会话</p>
<p><code>tmux kill-session</code>命令用于杀死某个会话.</p>
<pre><code class="language-bash"># 使用会话编号
$ tmux kill-session -t 0
# 使用会话名称
$ tmux kill-session -t &lt;session-name&gt;
</code></pre>
<hr />
<p>切换会话</p>
<p><code>tmux switch</code>命令用于切换会话.</p>
<pre><code class="language-bash"># 使用会话编号
$ tmux switch -t 0
# 使用会话名称
$ tmux switch -t &lt;session-name&gt;
</code></pre>
<hr />
<p>重命名会话</p>
<p><code>tmux rename-session</code>命令用于重命名会话.</p>
<pre><code class="language-bash">$ tmux rename-session -t 0 &lt;new-name&gt;
</code></pre>
<p>上面命令将<code>0</code>号会话重命名.</p>
<h3 id="最简操作流程"><a class="header" href="#最简操作流程">最简操作流程</a></h3>
<p>综上所述,以下是 <code>Tmux</code> 的最简操作流程.</p>
<ul>
<li>
<p>查看现存会话, <code>tl</code>:  <code>tmux list-sessions</code></p>
</li>
<li>
<p>新建会话,<code>tmux new-session -s name</code>:<code>ts</code></p>
</li>
<li>
<p>在 <code>Tmux</code> 窗口运行所需的程序.</p>
</li>
<li>
<p>按下快捷键<code>Ctrl+b d</code>将会话分离,</p>
</li>
<li>
<p>下次使用时,重新连接到会话,<code>tmux attach-session -t name</code>:<code>ta</code></p>
</li>
<li>
<p><code>tkss</code>:  <code>tmux kill-session -t</code>  终止某个已命名会话</p>
</li>
<li>
<p><code>tksv</code>:  <code>tmux kill-server</code>  终止所有正运行的会话</p>
</li>
<li>
<p><code>ctrl+b c</code>:创建一个新窗口</p>
</li>
<li>
<p><code>ctrl+b p</code>: 切换到上一个窗口</p>
</li>
<li>
<p><code>ctrl+b n</code>: 切换到下一个窗口</p>
</li>
<li>
<p><code>ctrl+b &lt;数字&gt;</code>: 切换到指定编号的窗口</p>
</li>
<li>
<p><code>ctrl+b w </code>: 从列表中选择窗口</p>
</li>
<li>
<p><code>ctrl+b ,</code>: 窗口重命名</p>
</li>
<li>
<p><code>ctrl+b %</code>:划分左右两个窗格</p>
</li>
<li>
<p><code>ctrl+b &quot;</code>: 划分上下两个窗格</p>
</li>
<li>
<p><code>ctrl+b &lt;方向键&gt;</code>: 切换输入到其他窗格</p>
</li>
<li>
<p><code>ctrl+b ;</code>: 切换输入到上一个窗格</p>
</li>
<li>
<p><code>ctrl+b {</code>: 当前窗格与上一个交换位置</p>
</li>
<li>
<p><code>ctrl+b }</code>: 与下一个窗格交换位置</p>
</li>
<li>
<p><code>ctrl+b ctrl+o</code>: 所有窗格向前移动一个位置</p>
</li>
<li>
<p><code>ctrl+b alt+o</code>: 所有窗格向后移动一个位置</p>
</li>
<li>
<p><code>ctrl+b x</code>:  关闭当前窗格</p>
</li>
<li>
<p><code>ctrl+b !</code>: 将当前窗格拆分为独立窗口</p>
</li>
<li>
<p><code>ctrl+b z</code>: 将当前窗格全屏显示, 按两次恢复原状</p>
</li>
<li>
<p><code>ctrl+b ctrl+&lt;方向&gt;</code>: 调整窗口大小</p>
</li>
<li>
<p><code>ctrl+b space</code>: 重新排列当前窗格.</p>
</li>
<li>
<p><code>ctrl+b p</code>: 显示窗口编号.</p>
</li>
<li>
<p><code>ctrl+b t</code>: 显示时间</p>
</li>
<li>
<p><code>ctrl+b i</code>: 显示当前窗格信息</p>
</li>
</ul>
<hr />
<p><code>tmux</code>允许将命令绑定到大多数键(可以有前缀键).
指定键时, 大多数写法表示自己(例如, <code>A</code>至<code>Z</code>).  <code>Ctrl</code>键的前缀可以是<code>C-</code>或<code>^</code>, <code>Alt</code>(Meta)为<code>M-</code>.
此外, 还接受以下特殊键名:
<code>Up</code>, <code>Down</code>, <code>Left</code>, <code>Right</code>, <code>BSpace</code>, <code>BTab</code>, <code>DC (Delete)</code>, <code>End</code>, <code>Enter</code>, <code>Escape</code>, <code>F1</code> to <code>F12</code>, <code>Home</code>, <code>IC (Insert)</code>, <code>NPage/PageDown/PgDn</code>, <code>PPage/PageUp/PgUp</code>, <code>Space</code>, and <code>Tab</code>. 请注意, 要绑定<code>'</code>或<code>&quot;</code>键, 必须使用引号, 例如:</p>
<pre><code class="language-tmux">bind-key '&quot;' split-window
bind-key &quot;'&quot; new-window
</code></pre>
<p>与键绑定相关的命令如下:</p>
<pre><code class="language-tmux">bind-key [-nr] [-T key-table] key command [arguments]
(alias: bind)
</code></pre>
<p>将<code>key</code>与<code>command</code>绑定. 按键组合存放在<code>key table</code>中. 默认情况下(不带<code>-T</code>, 该键绑定在<code>prefix</code>键表中.
这个表中的按键, 要首先按下<code>前缀键</code>, 再按后面的组合. 例如, 默认绑定中, <code>c</code>绑定到<code>prefix</code>表中的<code>new-window</code>, 因此<code>Ctrl-b c</code>会创建一个新窗口).
<code>root</code>表中的组合没有前置键, 直接生效. 比如将<code>c</code>绑定到根表中的新窗口(实际中并不推荐), 这样直接按下<code>c</code>就会创建一个新窗口. <code>-n</code>是<code>-T root</code>的别名.
也可以把<code>key</code>绑定到自定义的``key table<code>中, 可以使用</code>switch-client -T <code>命令切换到自定义的</code>key table<code>. </code>-r<code> flag 表示按键可以重复, 请参见</code>repeat-time`选项.</p>
<h2 id="imagemagick-使用"><a class="header" href="#imagemagick-使用">Imagemagick 使用</a></h2>
<p><a href="https://imagemagick.org/">ImageMagick</a></p>
<p>使用<code>ImageMagick</code>创建,编辑,合成或转换位图图像.
它可以读取和写入各种格式(超过200种)的图像,包括PNG,JPEG,GIF,HEIC,TIFF,DPX,EXR,WebP,Postscript,PDF和SVG.
<code>ImageMagick</code>可以调整图像大小,翻转,镜像,旋转,变形,剪切和变换图像,调整图像颜色,应用各种特殊效果或绘制文本,线条,多边形,椭圆和贝塞尔曲线.
<code>ImageMagick</code>是免费软件,可以即用型二进制分发形式提供,也可以作为源代码提供,您可以在开放应用程序和专有应用程序中使用,复制,修改和分发它们.  它是在派生的<code>Apache 2.0</code>许可下分发的.
<code>ImageMagick</code>利用多个计算线程来提高性能,并且可以读取,处理或写入兆,千兆或兆像素的图像大小.</p>
<p><code>ImageMagick</code>有一个单文件版本--<code>magick</code>,在<code>Linux</code>上完整的便携式应用程序,无需安装.  只需下载并运行.
<code>AppImage</code>需要<code>FUSE</code>和<code>libc</code>才能运行.  许多发行版都具有开箱即用的有效<code>FUSE</code>设置.  但是,如果对您不起作用,则必须手动安装和配置<code>FUSE</code>.</p>
<p><a href="https://github.com/AppImage/AppImageKit/wiki/FUSE">FUSE</a></p>
<p>AppImage需要FUSE才能运行.  Filesystem in Userspace (FUSE)是一种允许非root用户安装文件系统的系统. 在 Ubuntu 上安装<code>FUSE</code>:</p>
<pre><code class="language-bash">sudo apt install fuse
sudo modprobe fuse
sudo groupadd fuse

user=&quot;$(whoami)&quot;
sudo usermod -a -G fuse $user
</code></pre>
<p>下载便携版<code>magick</code>程序之后,运行以下命令,将绘制一个示例的进度图</p>
<pre><code class="language-bash">magick -size 320x90 canvas:none -stroke snow4 -size 1x90 -tile gradient:white-snow4 \
  -draw 'roundrectangle 16, 5, 304, 85 20,40' +tile -fill snow \
  -draw 'roundrectangle 264, 5, 304, 85  20,40' -tile gradient:chartreuse-green \
  -draw 'roundrectangle 16,  5, 180, 85  20,40' -tile gradient:chartreuse1-chartreuse3 \
  -draw 'roundrectangle 140, 5, 180, 85  20,40' +tile -fill none \
  -draw 'roundrectangle 264, 5, 304, 85 20,40' -strokewidth 2 \
  -draw 'roundrectangle 16, 5, 304, 85 20,40' \( +clone -background snow4 \
  -shadow 80x3+3+3 \) +swap -background none -layers merge \( +size -pointsize 90 \
  -strokewidth 1 -fill red label:'50 %' -trim +repage \( +clone -background firebrick3 \
  -shadow 80x3+3+3 \) +swap -background none -layers merge \) -insert 0 -gravity center \
  -append -background white -gravity center -extent 320x200 cylinder_shaded.png
</code></pre>
<h3 id="几何参数"><a class="header" href="#几何参数">几何参数</a></h3>
<p>Image Geometry</p>
<p>许多命令行选项采用几何参数来指定诸如所需的图像宽度和高度以及其他尺寸数量之类的内容.
因为用户想要图像的最终尺寸,大小和位置有如此多的变化(并且因为ImageMagick希望提供它们),所以geometry参数可以采用多种形式. 我们将在本节中描述其中的许多内容.</p>
<p>采用某些几何参数形式的图像选项和设置包括以下内容. 请记住,其中一些的 parse 方式略有不同. 有关更多选项,请参见有关单个选项或设置的文档.</p>
<pre><code class="language-magic">-adaptive-resize , -border , -borderwidth , -chop , -crop , -density , -extent , -extract , -frame , -geometry , -iconGeometry , -liquid-rescale , -page ,
-region , -repage , -resize , -sample , -scale , -shave , -splice , -thumbnail , -window
</code></pre>
<p>geometry参数可以采用下表中列出的任何形式. 这些将在表格后面的小节中详细介绍.
通常的形式是<code>size[offset]</code>,这意味着需要大小,而<code>offset</code>是可选的. 有时也可能是<code>[size]offset</code>的形式. 在任何情况下,几何参数中都不允许有空格.</p>
<p>格式和含义:
大小;  一般说明(实际行为可能因不同的选项和设置而异)</p>
<ul>
<li><code>scale%</code>;     高度和宽度均按指定的百分比缩放.</li>
<li><code>scale-x%xscale-y%</code>   按指定百分比分别缩放的高度和宽度.  (只需要一个<code>％</code>符号. )</li>
<li><code>width</code>       给定的宽度,自动选择的高度以保留宽高比.</li>
<li><code>xheight</code>     给定的高度,自动选择的宽度以保留宽高比.</li>
<li><code>widthxheight</code>        给定的高度和宽度的最大值,保留宽高比.</li>
<li><code>widthxheight^</code>      给定的宽度和高度的最小值,保留宽高比.</li>
<li><code>widthxheight!</code>       着重给出宽度和高度,忽略原始宽高比.</li>
<li><code>widthxheight&gt;</code>      缩小尺寸大于相应的<code>width</code>或<code>height</code>参数的图像.</li>
<li><code>widthxheight&lt;</code>   放大尺寸小于相应的<code>width</code>或<code>height</code>参数的图像.</li>
<li><code>area@</code>       调整图像大小以具有以像素为单位的指定区域. 长宽比被保留.</li>
<li><code>x:y</code> 在此,<code>x</code>和<code>y</code>表示纵横比(例如<code>3:2=1.5</code>).</li>
<li><code>{size}{offset}</code>  指定偏移量(默认为<code>+0+0</code>). 下面的<code>{size}</code>是指以上任何形式.</li>
<li><code>{size}{+-}x{+-}y</code>    水平和垂直偏移<code>x</code>和<code>y</code>,以像素为单位. 两者都需要<code>+-</code>号(sign). 偏移量受<code>-gravity</code>设置的影响.
偏移不受<code>％</code>或其他大小运算符的影响. 请注意,除了<code>center</code>选项,对于所有重力选项,正<code>X</code>和<code>Y</code>偏移都朝向图像中心. 对于<code>East</code>,<code>+X</code>是左边.
对于<code>South</code>,<code>+Y</code>是上. 对于<code>SouthEast</code>,<code>+X</code>是左,<code>+Y</code>是上. 对于<code>center</code>,使用常规的<code>X</code>和<code>Y</code>方向约定(<code>+X</code>向左,<code>+Y</code>向下).</li>
</ul>
<h3 id="output-filename"><a class="header" href="#output-filename">Output Filename</a></h3>
<h3 id="文件名引用"><a class="header" href="#文件名引用">文件名引用</a></h3>
<p>使用<code>embedded formatting character </code>输出图像列表.
假设我们的输出文件名是<code>image-%d.jpg</code>, 并且我们的输入的图像列表包括3张图像.  您可以期望输出以下图像文件:</p>
<pre><code class="language-bash">image-0.jpg
image-1.jpg
image-2.jpg
</code></pre>
<p>或检索图像属性以修改图像文件名.  例如,</p>
<pre><code class="language-bash">magick rose: -set filename:area '%wx%h' 'rose-%[filename:area].png'
</code></pre>
<p>用以下文件名写入图像:</p>
<pre><code class="language-bash">rose-70x46.png
</code></pre>
<p>最后, 要将多个JPEG图像转换为单独的PDF页面, 请使用:</p>
<pre><code class="language-bash">magick *.jpg +adjoin page-%d.pdf
</code></pre>
<h3 id="crop-剪切图像"><a class="header" href="#crop-剪切图像">crop 剪切图像</a></h3>
<p><a href="https://imagemagick.org/script/command-line-tools.php">Imagemagick 命令行工具</a></p>
<p><code>-crop geometry{@}{!}</code></p>
<p>切出图像的一个或多个矩形区域.</p>
<p>有关几何参数的完整详细信息,请参见图像几何.</p>
<p><code>geometry</code>参数的宽度和高度给出了裁剪后剩余图像的大小,偏移量中的<code>x</code>和<code>y</code>(如果存在)给出了裁剪图像相对于原始图像的左上角的位置.
如果要指定删除的数量,请改用<code>-shave</code>.</p>
<p>如果存在x和y偏移,则生成单个图像,该图像由裁剪区域中的像素组成. 偏移量指定: 裁减区域的左上角相对于图像的左上角,向右和向下.
可以通过<code>-gravity</code>改变默认的方向, <code>-gravity</code>可以设置为
<code>NorthEast</code>, <code>East</code>, or <code>SouthEast</code>
<code>SouthWest</code>, <code>South</code>, or <code>SouthEast </code></p>
<p>如果省略<code>x</code>和<code>y</code>偏移,则生成指定几何形状的<code>tiles</code>(平铺,瓷砖),这些图块覆盖整​​个<code>input</code>图像.
如果指定的几何形状超出输入图像的尺寸,则最右边的图块和底部的图块将较小.</p>
<p>您可以在几何参数中添加<code>@</code>,以将图像平均划分为生成的图块数量.</p>
<p>通过将<code>!</code>惊叹号标志添加到几何参数,将适当设置裁剪后的图像虚拟画布页面大小和偏移,表现成<code>viewport</code>or <code>window</code>的效果.
这意味着画布页面大小设置为与您指定的大小完全相同,图像偏移设置为裁剪区域的相对左上角.</p>
<p>如果裁剪后的图像在其虚拟画布上<code>missed</code>了实际图像,则会返回一个特殊的单像素透明<code>missed</code>图像,并给出<code>crop missed</code>警告.</p>
<p>在裁剪图像之前,可能需要<code>+repage </code>图像,以确保将裁剪坐标框重定位到可见图像的左上角.
同样,您可能希望在裁剪后使用<code>+repage </code>来删除遗留的页面偏移量. 当您要写入支持图像偏移量的图像格式(例如<code>PNG</code>)时,尤其如此.</p>
<h3 id="inline-image-crop"><a class="header" href="#inline-image-crop">Inline Image Crop</a></h3>
<p>有时在读取图像时裁剪图像很方便.  假设您有数百张要转换为PNG缩略图的大JPEG图像:</p>
<pre><code class="language-bash">magick '*.jpg' -crop 120x120+10+5 thumbnail%03d.png
</code></pre>
<p>此处读取所有图像, 然后裁剪.  读取每个图像时, 裁剪图像的速度更快且资源占用更少:</p>
<pre><code class="language-bash">magick '*.jpg[120x120+10+5]' thumbnail%03d.png
</code></pre>
<p>在<code>ubuntu-20</code>上使用上面的命令转换<code>pdf</code>可能会报错,</p>
<pre><code class="language-bash">gs: symbol lookup error: /usr/lib/x86_64-linux-gnu/libgs.so.9: undefined symbol: cmsCreateContext
</code></pre>
<p>下面的帖子建议更新<code>ghostscript</code>
<a href="https://askubuntu.com/questions/1258602/errors-converting-pdf-with-imagemagick-on-ubuntu-18">Errors converting PDF with Imagemagick on Ubuntu 18</a></p>
<p>从 <a href="https://github.com/ArtifexSoftware/ghostpdl">ArtifexSoftware/ghostpdl </a> 下载<code>ghostscript</code>的最新版本, 比如<code>ghostscript-9.53.3-linux-x86_64</code>,
用它替换<code>/usr/bin/gs</code>即可.</p>
<h3 id="density"><a class="header" href="#density">density</a></h3>
<p>-density width
-density widthxheight</p>
<p>设置图像的水平和垂直分辨率, 以渲染到设备.</p>
<p>此选项指定在对光栅图像进行编码时要存储的图像分辨率, 或在将Postscript, PDF, WMF和SVG等矢量格式渲染(reading)到光栅图像时指定要存储的图像分辨率.
图像分辨率提供了渲染到输出设备或光栅图像时要应用的度量单位. 默认的度量单位是每英寸点数(<code>DPI</code>).  <code>-units</code> 选项可用于选择每厘米点数(不同单位).</p>
<p>默认分辨率是每英寸72点, 相当于每像素一个点(Macintosh和Postscript标准). 计算机屏幕通常每英寸72或96点, 而打印机通常每英寸支持150, 300, 600或1200点.
要确定显示器的分辨率, 请使用标尺测量屏幕的宽度(以英寸为单位), 然后除以水平像素数(在1024x768显示器上为1024).</p>
<p>如果文件格式支持, 则此选项可用于更新存储的图像分辨率. 请注意, Photoshop存储并从专有的嵌入式配置文件中获取图像分辨率.
如果未从图像中删除此配置文件, 则Photoshop将继续使用其以前的分辨率来处理图像, 而忽略标准文件头中指定的图像分辨率.</p>
<p><code>-density</code>选项设置属性, 并且不会更改基础栅格图像. 它可用于通过调整应用于像素的比例来调整渲染尺寸以用于桌面发布.
要调整图像的大小, 以使其具有相同的大小, 但分辨率不同, 请使用<code>-resample</code>选项.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linxu-包管理"><a class="header" href="#linxu-包管理">linxu 包管理</a></h1>
<h2 id="ubuntu-镜像使用帮助"><a class="header" href="#ubuntu-镜像使用帮助">Ubuntu 镜像使用帮助</a></h2>
<p>清华大学的源</p>
<p>域名选择</p>
<pre><code class="language-bash">https://mirrors.tuna.tsinghua.edu.cn 自动选择
https://mirrors6.tuna.tsinghua.edu.cn 只解析 IPv6
https://mirrors4.tuna.tsinghua.edu.cn 只解析 IPv4
</code></pre>
<p>Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>.将系统自带的该文件做个备份,将该文件替换为下面内容,即可使用 <code>TUNA</code> 的软件源镜像.</p>
<pre><code class="language-bash"># 默认注释了源码镜像以提高 apt update 速度,如有需要可自行取消注释
deb https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
# deb-src https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
# deb-src https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
# deb-src https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
# deb-src https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse

# 预发布软件源,不建议启用
# deb https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
# deb-src https://mirrors6.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
</code></pre>
<h3 id="dpkg创建包dpkg-buildpackage"><a class="header" href="#dpkg创建包dpkg-buildpackage">dpkg创建包,dpkg-buildpackage</a></h3>
<p><code>dget</code> -- Download Debian source and binary packages</p>
<p>SYNOPSIS</p>
<pre><code>dget [options] URL ...
dget [options] [--all] package[=version] ...
</code></pre>
<p>DESCRIPTION</p>
<p>dget downloads Debian packages.</p>
<p>In the first form, dget fetches the requested <code>URLs</code>.  If this is a <code>.dsc</code> or <code>.changes</code> file,
then dget acts as a source-package aware form of wget: it also fetches any files referenced in the <code>.dsc/.changes</code> file.
The downloaded source is then checked with <code>dscverify</code> and, if successful, unpacked by <code>dpkg-source</code>.</p>
<h3 id="完整的重构建"><a class="header" href="#完整的重构建">完整的(重)构建</a></h3>
<p>为保证完整的软件包(重)构建能顺利进行,你必须保证系统中已经安装</p>
<pre><code>build-essential 软件包;

列于 Build-Depends 域的软件包(参看 第 4.1 节 `control`);

列于 Build-Depends-indep 域的软件包(参看 第 4.1 节 `control`).
</code></pre>
<p>然后在源代码目录中执行以下命令:</p>
<p>$ dpkg-buildpackage -us -uc</p>
<p>这样会自动完成所有从源代码包构建二进制包的工作,包括:</p>
<pre><code>清理源代码树(debian/rules clean)

构建源代码包(dpkg-source -b)

构建程序(debian/rules build)

构建二进制包(fakeroot debian/rules binary)

制作 .dsc 文件

用 dpkg-genchanges 命令制作 .changes 文件.
</code></pre>
<p>如果构建结果令人满意,那就用 debsign 命令以你的私有 GPG 密钥签署 .dsc 文件和 .changes 文件.你需要输入密码两次. [63]</p>
<p>对于非本地 Debian 软件包,比如 gentoo, 构建软件包之后,你将会在上一级目录(~/gentoo) 中看到下列文件:</p>
<pre><code>gentoo_0.9.12.orig.tar.gz

这是原始的源代码 tarball,最初由 dh_make -f ../gentoo-0.9.12.tar.gz 命令创建,它的内容与上游 tarball 相同,仅被重命名以符合 Debian 的标准.

gentoo_0.9.12-1.dsc

这是一个从 control 文件生成的源代码概要,可被 dpkg-source(1) 程序解包.

gentoo_0.9.12-1.debian.tar.gz

这个压缩的 Tar 归档包含你的 debian 目录内容.其他所有对于源代码的修改都由 quilt 补丁存储于 debian/patches 中.

如果其他人想要重新构建你的软件包,他们可以使用以上三个文件很容易地完成.只需复制三个文件,再运行 dpkg-source -x gentoo_0.9.12-1.dsc. [64]

gentoo_0.9.12-1_i386.deb

这是你的二进制包,可以使用 dpkg 程序安装或卸载它,就像其他软件包一样.

gentoo_0.9.12-1_i386.changes

这个文件描述了当前修订版本软件包中的全部变更,它被 Debian FTP 仓库维护程序用于安装二进制和源代码包.它是部分从 changelog 和 .dsc 文件生成的.

随着你不断完善这个软件包,程序的行为会发生变化,也会有更多新特性添加进来.下载你软件包的人可以查看这个文件来快速找到有哪些变化,Debian 仓库维护程序还会把它的内容发表至 debian-devel-changes@lists.debian.org 邮件列表.
</code></pre>
<p>在上传到 Debian FTP 仓库中前,gentoo_0.9.12-1.dsc 文件和 gentoo_0.9.12-1_i386.changes 文件必须用 debsign 命令签署,其中使用你自己存放在 ~/.gnupg/ 目录中的 GPG 私钥. 用你的公钥,可以令 GPG 签名证明这些文件真的是你的.</p>
<p>debsign 命令可以用来以指定 ID 的 GPG 密钥进行签署 (这方便了赞助(sponsor)软件包), 只要照着下边在 ~/.devscripts 中的内容:</p>
<p>DEBSIGN_KEYID=Your_GPG_keyID</p>
<p>.dsc 和 .changes 文件中很长的数字串是其中提及文件的 SHA1/SHA256 校验和.下载你软件包的人可以使用 sha1sum(1) 或 sha256sum(1) 来进行核对.如果校验和不符,则说明文件已被损坏或偷换</p>
<h3 id="hostname"><a class="header" href="#hostname">Hostname</a></h3>
<p><a href="https://www.lifewire.com/what-is-a-hostname-2625906">What Is a Hostname? </a></p>
<p>域名(英语:<code>Domain Name</code>),又称网域,是由一串用点分隔的名字组成的<code>Internet</code>上某一台计算机或计算机组的名称,
用于在数据传输时对计算机的定位标识(有时也指地理位置)</p>
<p>由于<code>IP</code>地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点,人们设计出了域名,
并通过网域名称系统(<code>DNS</code>,<code>Domain Name System</code>)来将域名和<code>IP</code>地址相互映射,使人更方便地访问互联网,
而不用去记住能够被机器直接读取的<code>IP</code>地址数串</p>
<p>A <code>hostname</code> is a label assigned to a <code>device</code> (a host) on a <code>network</code>.</p>
<p>It distinguishes one device from another on a specific network or over the internet.
The hostname for a computer on a home network may be something like <code>new laptop</code>, <code>Guest-Desktop</code>, or <code>FamilyPC</code>.</p>
<p>Hostnames are also used by <code>DNS</code> servers so you can access a website by a common, easy-to-remember name. This way, you don't have to remember a string of numbers (an <code>IP address</code>) to open a website.</p>
<p>A computer's hostname may instead be referred to as a computer name, sitename, or nodename.
You may also see hostname <code>spelled</code> as host name.</p>
<h3 id="主机的例子hostname"><a class="header" href="#主机的例子hostname">主机的例子,Hostname</a></h3>
<p>Each of the following is an example of a Fully Qualified Domain Name with its hostname written off to the side:</p>
<ul>
<li><code>www.google.com: www</code></li>
<li><code>images.google.com: images</code></li>
<li><code>products.office.com: products</code></li>
<li><code>www.microsoft.com: www</code></li>
</ul>
<p>The hostname (like <code>products</code>) is the text that <em>precedes</em> the <code>domain</code> name (for example, office), which is the text that comes before the <em>top-level domain</em> (<code>.com</code>).</p>
<h3 id="在-windows-中找出-hostname"><a class="header" href="#在-windows-中找出-hostname">在 windows 中找出 Hostname</a></h3>
<p>Executing <code>hostname</code> from the Command Prompt is the easiest way to show the hostname of a computer.</p>
<h2 id="linux查看硬件信息"><a class="header" href="#linux查看硬件信息">Linux查看硬件信息</a></h2>
<p><a href="https://linux.cn/article-11422-1.html">用 Linux 命令显示硬件信息 </a></p>
<p>最简单的方法是使用标准的 Linux GUI 程序之一:</p>
<ul>
<li><code>i-nex</code> 收集硬件信息, 并且类似于 Windows 下流行的 <code>CPU-Z</code> 的显示.</li>
<li><code>HardInfo</code> 显示硬件具体信息, 甚至包括一组八个的流行的性能基准程序, 你可以用它们运算你的系统性能.</li>
<li><code>KInfoCenter</code> 和 <code>Lshw</code> 也能够显示硬件的详细信息, 并且可以从许多软件仓库中获取.</li>
</ul>
<h3 id="硬件概述"><a class="header" href="#硬件概述">硬件概述</a></h3>
<p><code>inxi</code> 命令能够列出包括 CPU, 图形, 音频, 网络, 驱动, 分区, 传感器等详细信息. 当论坛里的人尝试帮助其他人解决问题的时候, 他们常常询问此命令的输出.</p>
<pre><code class="language-bash">inxi -Fxz
</code></pre>
<p><code>-F</code> 参数意味着你将得到完整的输出, <code>x</code> 增加细节信息, <code>z</code> 参数隐藏像 <code>MAC</code> 和 <code>IP</code> 等私人身份信息.</p>
<hr />
<p><code>hwinfo</code> 和 <code>lshw</code> 命令以不同的格式显示大量相同的信息:
<code>hwinfo --short</code> 或 <code>lshw -short</code>
这两条命令的长格式输出非常详细, 但也有点难以阅读:
<code>hwinfo</code> 或<code>lshw</code></p>
<h3 id="cpu-详细信息"><a class="header" href="#cpu-详细信息">CPU 详细信息</a></h3>
<p>通过命令你可以了解关于你的 CPU 的任何信息. 使用 <code>lscpu</code> 命令或与它相近的 <code>lshw</code> 命令查看 <code>CPU</code> 的详细信息:</p>
<p><code>lscpu</code>  或 <code>lshw -C cpu</code></p>
<p>在这两个例子中, 输出的最后几行都列出了所有 <code>CPU</code> 的功能. 你可以查看你的处理器是否支持特定的功能.</p>
<p>使用这些命令的时候, 你可以使用 <code>grep</code> 过滤信息. 例如, 只查看 CPU 品牌和型号:</p>
<pre><code class="language-bash">lshw -C cpu | grep -i product
</code></pre>
<p>仅查看 <code>CPU</code> 的速度(兆赫兹):</p>
<pre><code class="language-bash">lscpu | grep -i mhz
</code></pre>
<p>或其 <code>BogoMips</code> 额定功率:</p>
<pre><code class="language-bash">lscpu | grep -i bogo
</code></pre>
<p><code>grep</code> 命令的 <code>-i</code>参数代表搜索结果忽略大小写.</p>
<h3 id="内存"><a class="header" href="#内存">内存</a></h3>
<p><code>Linux</code> 命令行使你能够收集关于你的计算机内存的所有可能的详细信息.
你甚至可以不拆开计算机机箱就能确定是否可以为计算机添加额外的内存条.</p>
<p>使用 <code>dmidecode</code> 命令列出每根内存条和其容量:</p>
<pre><code class="language-bash">dmidecode -t memory | grep -i size
</code></pre>
<p>使用以下命令获取系统内存更多的信息, 包括类型, 容量, 速度和电压:</p>
<pre><code class="language-bash">lshw -short -C memory
</code></pre>
<p>你肯定想知道的一件事是你的计算机可以安装的最大内存:</p>
<pre><code class="language-bash">dmidecode -t memory | grep -i max
</code></pre>
<p>现在检查一下计算机是否有空闲的插槽可以插入额外的内存条. 你可以通过使用命令在不打开计算机机箱的情况下就做到:</p>
<pre><code class="language-bash">lshw -short -C memory | grep -i empty
</code></pre>
<p>输出为空则意味着所有的插槽都在使用中.</p>
<h3 id="显卡"><a class="header" href="#显卡">显卡</a></h3>
<p>确定你的计算机拥有多少显卡内存需要下面的命令. 首先使用 <code>lspci</code> 列出所有设备信息然后过滤出你想要的显卡设备信息:</p>
<pre><code class="language-bash">lspci | grep -i vga
</code></pre>
<p>视频控制器的设备号输出信息通常如下:</p>
<pre><code class="language-bash">00:02.0 VGA compatible controller: Intel Corporation 82Q35 Express Integrated Graphics Controller (rev 02)
</code></pre>
<p>现在再加上视频设备号重新运行 <code>lspci</code> 命令:</p>
<pre><code class="language-bash">lspci -v -s 00:02.0
</code></pre>
<p>输出信息中 <code>prefetchable</code> 那一行显示了系统中的显卡内存大小:</p>
<p>使用<code>xrandr</code> 可以设置屏幕输出的大小, 方向或反射.  它还可以设置屏幕尺寸.</p>
<hr />
<p>安装专有显卡驱动:</p>
<p>首先查看显卡硬件型号<code>ubuntu-drivers devices</code>, 使用<code>ubuntu-drivers -h</code>可以查看使用帮助:</p>
<p>用法: <code>ubuntu-drivers [OPTIONS] COMMAND [ARGS]...</code></p>
<p>选项:</p>
<p><code>--gpgpu</code>:gpgpu驱动程序
<code>--free-only</code>:仅考虑免费软件包
<code>--package-list PATH</code>:使用已安装软件包列表,创建文件(在<code>install</code>模式)
<code>--no-oem</code>: 不包括OEM软件包,默认值: <code>False</code>
<code>-h</code>, <code>--help</code>:显示此消息并退出.</p>
<p>命令:</p>
<p><code>autoinstall</code>:已弃用, 请改用<code>install</code>
<code>debug</code>:打印有关驱动程序的所有可用信息和调试数据.
<code>devices</code>:显示所有需要驱动程序的设备以及哪些软件包可用
<code>install</code>:安装驱动程序<code>[driver[:version][,driver[:version]]]</code>
<code>list</code>:显示适用于当前系统的所有驱动程序包.
<code>  list-oem</code>:显示适用于此系统的所有OEM软件包</p>
<hr />
<p>使用下面的命令展示当前内存使用量(兆字节):</p>
<pre><code class="language-bash">free -m
</code></pre>
<p>这条命令告诉你多少内存是空闲的, 多少命令正在使用中以及交换内存的大小和是否正在使用. <code>top</code> 命令为你提供内存使用更加详细的信息.
它显示了当前全部内存和 CPU 使用情况并按照进程 ID, 用户 ID 及正在运行的命令细分. 同时这条命令也是全屏输出.</p>
<h3 id="磁盘文件系统和设备"><a class="header" href="#磁盘文件系统和设备">磁盘文件系统和设备</a></h3>
<p>你可以轻松确定有关磁盘, 分区, 文件系统和其他设备信息.</p>
<p>显示每个磁盘设备的描述信息:</p>
<pre><code class="language-bash">lshw -short -C disk
</code></pre>
<p>通过以下命令获取任何指定的 <code>SATA</code> 磁盘详细信息, 例如其型号, 序列号以及支持的模式和扇区数量等:</p>
<pre><code class="language-bash">hdparm -i /dev/sda
</code></pre>
<p>当然, 如果需要的话你应该将 <code>sda</code> 替换成 <code>sdb</code> 或者其他设备号.</p>
<p>列出所有磁盘及其分区和大小:</p>
<pre><code class="language-bash">lsblk
</code></pre>
<p>使用以下命令获取更多有关扇区数量, 大小, 文件系统 ID 和 类型以及分区开始和结束扇区:</p>
<pre><code class="language-bash">fdisk -l
</code></pre>
<p>要启动 Linux, 你需要确定 <code>GRUB</code> 引导程序的可挂载分区. 你可以使用 <code>blkid</code> 命令找到此信息. 它列出了每个分区的唯一标识符(UUID)及其文件系统类型(例如 ext3 或 ext4):</p>
<pre><code class="language-bash">blkid
</code></pre>
<p>使用以下命令列出已挂载的文件系统和它们的挂载点, 以及已用的空间和可用的空间(兆字节为单位):</p>
<pre><code class="language-bash">df -m
</code></pre>
<p>最后, 你可以列出所有的 <code>USB</code> 和 <code>PCI</code> 总线以及其他设备的详细信息:</p>
<pre><code class="language-bash">lsusb
</code></pre>
<p>或</p>
<pre><code class="language-bash">lspci
</code></pre>
<h3 id="网络"><a class="header" href="#网络">网络</a></h3>
<p>Linux 提供大量的网络相关命令, 下面只是几个例子.</p>
<p>查看你的网卡硬件详细信息:</p>
<pre><code class="language-bash">lshw -C network
</code></pre>
<p><code>ifconfig</code> 是显示网络接口的传统命令:</p>
<pre><code class="language-bash">ifconfig -a
</code></pre>
<p>但是现在很多人们使用:</p>
<pre><code class="language-bash">ip link show
</code></pre>
<p>或</p>
<pre><code class="language-bash">netstat -i
</code></pre>
<p>在阅读输出时, 了解常见的网络缩写十分有用:</p>
<p>缩写    含义</p>
<ul>
<li><code>lo</code>    回环接口</li>
<li><code>eth0</code> 或 <code>enp*</code>    以太网接口</li>
<li><code>wlan0</code>    无线网接口</li>
<li><code>ppp0</code>    点对点协议接口(由拨号调制解调器, PPTP VPN 连接或者 USB 调制解调器使用)</li>
<li><code>vboxnet0</code> 或 <code>vmnet*</code>    虚拟机网络接口</li>
</ul>
<p>表中的星号是通配符, 代表不同系统的任意字符.</p>
<p>使用以下命令显示默认网关和路由表:</p>
<pre><code class="language-bash">ip route | column -t
</code></pre>
<p>或</p>
<pre><code class="language-bash">netstat -r
</code></pre>
<h3 id="软件"><a class="header" href="#软件">软件</a></h3>
<p>让我们以显示最底层软件详细信息的两条命令来结束.
例如, 如果你想知道是否安装了最新的固件该怎么办? 这条命令显示了 <code>UEFI</code> 或 <code>BIOS</code> 的日期和版本:</p>
<pre><code class="language-bash">dmidecode -t bios
</code></pre>
<p>内核版本是多少, 以及它是 64 位的吗? 网络主机名是什么? 使用下面的命令查出结果:</p>
<pre><code class="language-bash">uname -a
</code></pre>
<h3 id="快速查询表"><a class="header" href="#快速查询表">快速查询表</a></h3>
<p>用途   命令</p>
<ul>
<li>显示所有硬件信息   <code>inxi -Fxz</code> 或 <code>hwinfo --short</code> 或 <code>lshw  -short</code></li>
<li><code>CPU</code> 信息   <code>lscpu</code> 或 <code>lshw -C cpu</code></li>
<li>显示 <code>CPU</code> 功能(例如 PAE, SSE2)  <code>lshw -C cpu | grep -i capabilities</code></li>
<li>报告 <code>CPU</code> 位数   <code>lshw -C cpu | grep -i width</code></li>
<li>显示当前内存大小和配置   <code>dmidecode -t memory | grep -i size</code> 或 <code>lshw -short -C memory</code></li>
<li>显示硬件支持的最大内存   <code>dmidecode -t memory | grep -i max</code></li>
<li>确定是否有空闲内存插槽   <code>lshw -short -C memory | grep -i empty</code>(输出为空表示没有可用插槽)</li>
<li>确定显卡内存数量   <code>lspci | grep -i vga</code> 然后指定设备号再次使用; 例如: <code>lspci -v -s 00:02.0</code>
显卡内存数量就是  <code>prefetchable</code> 的值</li>
<li>显示当前内存使用情况  <code>free -m</code> 或 <code>top</code></li>
<li>列出磁盘驱动器   <code>lshw -short -C disk</code></li>
<li>显示指定磁盘驱动器的详细信息   <code>hdparm -i /dev/sda</code>(需要的话替换掉 <code>sda</code> )</li>
<li>列出磁盘和分区信息   <code>lsblk</code>(简单) 或 <code>fdisk -l</code>(详细)</li>
<li>列出分区 ID(UUID)   <code>blkid</code></li>
<li>列出已挂载文件系统挂载点以及已用和可用空间   d<code>f -m</code></li>
<li>列出 USB 设备   <code>lsusb</code></li>
<li>列出 PCI 设备   <code>lspci</code></li>
<li>显示网卡详细信息  <code> lshw -C network</code></li>
<li>显示网络接口   <code>ifconfig -a</code> 或 <code>ip link show</code> 或 <code>netstat -i</code></li>
<li>显示路由表   <code>ip route | column -t</code> 或 <code>netstat -r</code></li>
<li>显示 UEFI/BIOS 信息   <code>dmidecode -t bios</code></li>
<li>显示内核版本网络主机名等   <code>uname -a</code></li>
</ul>
<p><a href="https://blog.csdn.net/zdwzzu2006/article/details/7747977">Linux下/proc目录简介</a></p>
<p>Linux 内核提供了一种通过 <code>/proc</code> 文件系统,在运行时访问内核内部数据结构, 改变内核设置的机制.proc文件系统是一个伪文件系统,它只存在内存当中,而不占用外存空间.它以文件系统的方式为访问系统内核数据的操作提供接口.</p>
<p>用户和应用程序可以通过proc得到系统的信息,并可以改变内核的某些参数.
由于系统的信息,如进程,是动态改变的,所以用户或应用程序读取proc文件时,proc文件系统是动态从系统内核读出所需信息并提交的.
下面列出的这些文件或子文件夹,并不是都是在你的系统中存在,这取决于你的内核配置和装载的模块.
另外,在<code>/proc</code>下还有三个很重要的目录:<code>net</code>,<code>scsi</code>和<code>sys</code>. <code>Sys</code>目录是可写的,可以通过它来访问或修改内核的参数,而<code>net</code>和<code>scsi</code>则依赖于内核配置.例如,如果系统不支持<code>scsi</code>,则<code>scsi</code>目录不存在.</p>
<p>除了以上介绍的这些,还有的是一些以数字命名的目录,它们是进程目录.
系统中当前运行的每一个进程都有对应的一个目录在<code>/proc</code>下,以进程的 <code>PID</code>号为目录名,它们是读取进程信息的接口.
而<code>self</code>目录则是读取进程本身的信息接口,是一个<code>link</code>.</p>
<h2 id="shell-语法"><a class="header" href="#shell-语法">shell 语法</a></h2>
<h3 id="空白字符"><a class="header" href="#空白字符">空白字符</a></h3>
<p><a href="https://blog.csdn.net/boyinnju/article/details/6877087">对C标准中空白字符的理解</a>
<a href="https://blog.csdn.net/Jerry_1126/java/article/details/85009615">Shell中去掉文件中的换行符简单方法</a></p>
<p><code>C</code>标准库里<code>&lt;ctype.h&gt;</code>中声明了一个函数:</p>
<p><code>int isspace(int c);</code></p>
<p>该函数判断字符<code>c</code>是否为一个空白字符.</p>
<p><code>C</code>标准中空白字符有六个:
空格(<code>' '</code>), 换页(<code>'\f'</code>), 换行(<code>'\n'</code>), 回车(<code>'\r'</code>), 水平制表符(<code>'\t'</code>), 垂直制表符(<code>'\v'</code>)</p>
<hr />
<p>空格: ASCII码为<code>0x20</code>,而不是<code>0x00</code>.<code>0x00</code>代表空(<code>NULL</code>)</p>
<p><code>0X00-0XFF</code> <code>16</code>进制一共<code>256</code>个,刚好是一个<code>bit</code>的范围.</p>
<hr />
<p>回车('\r')效果是输出回到本行行首,结果可能会将这一行之前的输出覆盖掉,例如执行:</p>
<pre><code class="language-bash">puts(&quot;hello world!\rxxx&quot;);
#在终端输出的是:
xxxlo world!
</code></pre>
<p>如果将上面的字符串写入文件中,例如执行:</p>
<pre><code class="language-bash">char *s = &quot;hello world!\rxxx&quot;;
FILE *str = fopen(&quot;t.txt&quot;,&quot;r&quot;);
fwrite(s, 16, 1, str);
</code></pre>
<p>用文本编辑器打开<code>t.txt</code>.显示的效果将由打开的编辑器所决定.
vi将<code>\r</code>用<code>^M</code>代替,而记事本就没有显示该字符.</p>
<hr />
<p>换行('\n')
顾名思义,换行就是转到下一行输出.例如:</p>
<pre><code class="language-bash">puts(&quot;hello\nworld!&quot;);
#在终端中将输出
hello
world!
</code></pre>
<p>但需要注意的是,终端输出要达到换行效果用<code>\n</code>就可以,但要在文本文件输出中达到换行效果在各个系统中有所区别.
在<code>*nix</code>系统中,每行的结尾是&quot;<code>\n</code>&quot;,windows中则是&quot;<code>\n\r</code>&quot;,mac则是&quot;<code>\r</code>&quot;.</p>
<hr />
<p>水平制表符('\t')</p>
<p>相信大家对'\t'还是比较熟悉的.一般来说,其在终端和文件中的输出显示相当于按下键盘<code>TAB</code>键效果.
一般系统中,显示水平制表符将占8列.同时水平制表符开始占据的初始位置是第<code>8*n</code>列(第一列的下标为0).例如:</p>
<pre><code class="language-bash">puts(&quot;0123456\txx&quot;);
puts(&quot;0123456t\txx&quot;);
</code></pre>
<hr />
<p>垂直制表符('\v')</p>
<p>垂直制表符不常用.它的作用是让<code>'\v'</code>后面的字符从下一行开始输出,且开始的列数为<code>\v</code>前一个字符所在列后面一列.例如:</p>
<pre><code class="language-bash">puts(&quot;01\v2345&quot;);
</code></pre>
<hr />
<p>换页('\f')</p>
<p>换页符的在终端的中的效果相当于<code>*nix</code>中<code>clear</code>命令.
终端在输出<code>'\f'</code>之后内容之前,会将整个终端屏幕清空空,然后在输出内容.给人的该觉是在<code>clear</code>命令后的输出字符串.</p>
<p>最后我想说明一点,<code>\t \r, \v \f</code>也是控制字符,它们会控制字符的输出方式.
它们在终端输出时会有上面的表现,但如果写入文本文件,一般文本编辑器(vi或记事本)对<code>\t \r, \v \f</code>的显示是没有控制效果的.</p>
<h3 id="shell-换行"><a class="header" href="#shell-换行">shell 换行</a></h3>
<p>把换行符注释掉,如果同时想插入注释,可以用<code>$()</code>或者两个<code>backtick</code>包裹注释</p>
<pre><code class="language-bash">emcc -o ./dist/test.html `# 目标文件` \
--shell-file ./tmp.html `# 模板文件` \
--source-map-base dist `# source map 根路径` \
-O3 `# 优化级别` \
</code></pre>
<h3 id="删除换行符"><a class="header" href="#删除换行符">删除换行符</a></h3>
<p>文件中每行都以<code>\n</code>结尾,如果要去掉换行符,使用<code>sed</code>命令</p>
<pre><code class="language-bash">[root@host ~]# sed -i 's/\n//g' FileName
</code></pre>
<p>或者使用<code>tr</code>命令: tr - translate or delete characters</p>
<pre><code class="language-bash">[root@host ~]# cat fileName | tr  -d '\n'
</code></pre>
<p>有一种简单的方法:</p>
<p><code>xargs</code> - build and execute command lines from standard input</p>
<pre><code class="language-bash">cat FileName | xargs | echo -n   # 连文件末尾换行符也去掉
# 或者
cat FileName | xargs           # 会保留文件末尾的换行符
</code></pre>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p><a href="https://blog.csdn.net/luliuliu1234/article/details/80994391">Shell 中eval的用法</a></p>
<pre><code class="language-bash">eval command-line
</code></pre>
<p>其中<code>command-line</code>是在终端上键入的一条普通命令行.
然而当在它前面放上<code>eval</code>时,其结果是<code>shell</code>在执行命令行之前扫描它两次.如:</p>
<pre><code class="language-bash">$ pipe=&quot;|&quot;
$ eval ls $pipe wc -l
1
2
3
</code></pre>
<p>shell第1次扫描命令行时,它替换出<code>pipe</code>的值<code>|</code>,接着<code>eval</code>使它再次扫描命令行,这时shell把<code>|</code>作为管道符号了.</p>
<p>如果变量中包含任何需要<code>shell</code>直接在命令行中看到的字符,就可以使用eval.
命令行结束符(<code>;  |  &amp;</code>),I/o重定向符(<code>&lt; &gt;</code>)和引号就属于对shell具有特殊意义的符号,必须直接出现在命令行中.</p>
<p><code>eval echo \$$#</code>取得最后一个参数, 如:</p>
<pre><code class="language-bash">$ cat last    #此处last是一个脚本文件,内容是下一行显示
$  eval echo \$$#
$ ./last one two three four

four
</code></pre>
<p>第一遍扫描后,shell把反斜杠去掉了.当shell再次扫描该行时,它替换了<code>$4</code>的值,并执行echo命令</p>
<hr />
<p>以下示意如何用<code>eval</code>命令创建指向变量的<code>指针</code>:</p>
<pre><code class="language-bash">x=100
ptrx=x
eval echo \$$ptrx  #指向 ptrx,用这里的方法可以理解上面的例子
eval $ptrx=50 #将 50 存到 ptrx 指向的变量中.
echo $x
</code></pre>
<pre><code class="language-bash"># ptrx 指向x
echo $ptrx
x
# \$ 转义之后,再跟 x 连成一个字符串
echo \$$ptrx
$x
# eval 执行两次扫描,所以相当于 echo $x
eval echo \$$ptrx
</code></pre>
<h3 id="chmod"><a class="header" href="#chmod">chmod</a></h3>
<p>chmod - change file mode bits</p>
<p>SYNOPSIS</p>
<p><code>chmod [OPTION]... MODE[,MODE]... FILE...</code>
<code>chmod [OPTION]... OCTAL-MODE FILE...</code>
<code>chmod [OPTION]... --reference=RFILE FILE...</code></p>
<p>DESCRIPTION</p>
<p>chmod 后面可以接符号表示新的权限,也可以接一个octal number --表示新的mode bits.</p>
<p>符号mode的格式一般是<code>[ugoa...][[-+=][perms...]...]</code>,<code>perms</code>一般是<code>0</code>,或者<code>rwxXst</code>中的多个字符,
或者<code>ugo</code>中的一个字符.多种符号mode可以给出,用逗号隔开.</p>
<p><code>ugoa</code>表示控制特定用户访问权限:</p>
<ul>
<li>u:the user who owns it</li>
<li>g:other users in the file's group</li>
<li>o:other users not in the file's group</li>
<li>a:all  users
如果没有给出,默认就是 a,but bits that are set in the umask are not affected.</li>
</ul>
<p>operator <code>+</code>添加权限,<code>-</code>删除权限,<code>=</code>设置为<code>xxx</code>,except that a directory's unmentioned set user and group ID bits are not affected.</p>
<p><code>rwxXst</code>表示mode bits,read (r), write (w), execute (or  search  for directories)  (x),
execute/search  only if the file is a directory or already has execute permission for some user (X),
set user or group ID on execution (s), restricted deletion flag or sticky bit (t)</p>
<p>或者指定<code>ugo</code>中的一个,
the permissions granted to the user who owns the file (u),
the permissions granted to other users who are members of the file's group (g),
and the permissions granted to users that are in neither of the two preceding categories (o).</p>
<hr />
<p>数字模式</p>
<p>数字mode 是1到4个 octal digits(0-7),derived by adding up the bits with values 4, 2, and 1.</p>
<p>省略的数字被认为是前置的<code>0</code>.</p>
<p>第一位数字选择用户组
the set user ID (4) and
set group  ID(2)  and
restricted deletion or sticky (1) attributes.</p>
<p>第二位数字选择权限
read (4), write (2), and execute (1);</p>
<p>第三位数字设定组中其他用户的权限</p>
<p>第四位数字设定不在组中用户的权限</p>
<h2 id="shell脚本"><a class="header" href="#shell脚本">shell脚本</a></h2>
<h3 id="shell脚本中的符号"><a class="header" href="#shell脚本中的符号">shell脚本中的符号</a></h3>
<p><a href="https://www.cnblogs.com/xuxm2007/archive/2011/10/20/2218846.html">shell脚本中一些特殊符号</a></p>
<h3 id="formfactor-脚本"><a class="header" href="#formfactor-脚本">formfactor 脚本</a></h3>
<p>复制结果的脚本</p>
<pre><code class="language-bash">#!/usr/bin/env python3
import os,shutil,time,gfm
# 复制到论文中的都是 ci==1.50 的结果
user_name='tom'
# 配置计算结果目录,论文目录,论文压缩文件目录
originpath=os.getcwd()
result_path=os.path.join(originpath,'expression-results/')
paper_path=os.path.join('/home',user_name,'private','paper-2.prd/')
desk_path=os.path.join('/home',user_name,'Desktop','paper.ff/')
# 复制计算结果到论文目录
shutil.copy(os.path.join(result_path,'fig.baryons.ge.charge.L-0.90.ci-1.50.pdf'),os.path.join(paper_path,'fig4.pdf'))
shutil.copy(os.path.join(result_path,'fig.baryons.ge.neutral.L-0.90.ci-1.50.pdf'),os.path.join(paper_path,'fig5.pdf'))
shutil.copy(os.path.join(result_path,'fig.baryons.gm.charge.L-0.90.ci-1.50.pdf'),os.path.join(paper_path,'fig2.pdf'))
shutil.copy(os.path.join(result_path,'fig.baryons.gm.neutral.L-0.90.ci-1.50.pdf'),os.path.join(paper_path,'fig3.pdf'))
# cd 到论文目录,重新编译论文
os.chdir(paper_path)
# 清除之前的编译结果,重新编译
os.system('latexmk -C')
os.system('./build.sh')
# 如果桌面有压缩文件目录,就删除,shutil.copytree需要目标不存在
src_list=['fig1.pdf','fig2.pdf','fig3.pdf','fig4.pdf','fig5.pdf','octetFF.tex','octetFF.pdf']
# 把论文目录的东西复制到桌面目录中
if  os.path.isdir(desk_path):
    for src in src_list:
        shutil.copy2(src,desk_path)
else:
    os.mkdir(desk_path)
    for src in src_list:
        shutil.copy2(src,desk_path)

## 切换到桌面整理目录
os.chdir(desk_path)

print(&quot;+++++++\nthe file left in&quot;,os.getcwd(),&quot;\n+++++++&quot;)
os.listdir(desk_path)

# 产生论文压缩文件
os.system('rm ../paper.7z; 7z a ../paper.7z '+desk_path)
# 回到原来的文件夹
os.listdir(originpath)
</code></pre>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<p><a href="https://www.jianshu.com/p/ac2bc0ad3d74">Linux环境变量总结</a></p>
<p><code>Linux</code>是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,具体做法是设置不同用户的环境变量.</p>
<h3 id="linux环境变量分类"><a class="header" href="#linux环境变量分类">Linux环境变量分类</a></h3>
<hr />
<p>按照生命周期来分,Linux环境变量可以分为两类:</p>
<ol>
<li>永久的:需要用户修改相关的配置文件,变量永久生效.</li>
<li>临时的:用户利用<code>export</code>命令,在当前终端下声明环境变量,关闭Shell终端失效.</li>
</ol>
<hr />
<p>按照作用域来分,Linux环境变量可以分为:</p>
<ol>
<li>系统环境变量:系统环境变量对该系统中所有用户都有效.</li>
<li>用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.</li>
</ol>
<h3 id="linux设置环境变量的方法"><a class="header" href="#linux设置环境变量的方法">Linux设置环境变量的方法</a></h3>
<ol>
<li>在<code>/etc/profile</code>文件中添加变量 对所有用户生效(永久的)</li>
</ol>
<p>用<code>vim</code>在文件<code>/etc/profile</code>文件中增加变量,该变量将会对<code>Linux</code>下所有用户有效,并且是<code>永久的</code>.
例如:编辑<code>/etc/profile</code>文件,添加<code>CLASSPATH</code>变量</p>
<pre><code class="language-bash">vim /etc/profile
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
</code></pre>
<p>要想马上生效,运行<code>source /etc/profile</code>,不然只能在下次重进此用户时生效.</p>
<ol start="2">
<li>在用户目录下的<code>~/.bashrc</code>文件中增加变量 [对单一用户生效(永久的)]</li>
</ol>
<p>用<code>vim ~/.bashrc</code>文件中增加变量,改变量仅会对当前用户有效,并且是<code>永久的</code>.</p>
<pre><code class="language-bash">vim ~/.bashrc
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
</code></pre>
<ol>
<li>直接运行<code>export</code>命令定义变量 [只对当前shell(BASH)有效(临时的)]</li>
</ol>
<p>在shell的命令行下直接使用<code>export 变量名=变量值</code></p>
<p>定义变量,该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的,
shell关闭了,变量也就失效了,再打开新shell时就没有这个变量,需要使用的话还需要重新定义.</p>
<h3 id="linux环境变量使用"><a class="header" href="#linux环境变量使用">Linux环境变量使用</a></h3>
<p>Linux中常见的环境变量有:</p>
<hr />
<p>PATH:指定命令的搜索路径</p>
<p>PATH声明用法:</p>
<pre><code class="language-bash">export PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:--------:&lt; PATH n &gt;
</code></pre>
<p>你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登陆时生效.</p>
<p>可以利用<code>echo $PATH</code>查看当前当前系统PATH路径.</p>
<pre><code>HOME:指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录).
HISTSIZE:指保存历史命令记录的条数.
LOGNAME:指当前用户的登录名.
HOSTNAME:指主机的名称,许多应用程序如果要用到主机名的话,通常是从这个环境变量中来取得的
SHELL:指当前用户用的是哪种Shell.
LANG/LANGUGE:和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.
MAIL:指当前用户的邮件存放目录.
</code></pre>
<p>注意:上述变量的名字并不固定,如HOSTNAME在某些Linux系统中可能设置成HOST</p>
<ol start="2">
<li>Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:</li>
</ol>
<ul>
<li><code>echo</code>  显示某个环境变量值 <code>echo $PATH</code></li>
<li><code>export</code>  设置一个新的环境变量 <code>export HELLO=&quot;hello&quot;</code> (可以无引号)</li>
<li><code>env</code>  显示所有环境变量</li>
<li><code>set</code>  显示本地定义的<code>shell</code>变量</li>
<li><code>unset</code>  清除环境变量 <code>unset HELLO</code></li>
<li><code>readonly</code>  设置只读环境变量 <code>readonly HELLO</code></li>
</ul>
<ol start="3">
<li>C程序调用环境变量函数</li>
</ol>
<ul>
<li><code>getenv()</code> 返回一个环境变量.</li>
<li><code>setenv()</code> 设置一个环境变量.</li>
<li><code>unsetenv()</code> 清除一个环境变量.</li>
</ul>
<h2 id="linux-grub2"><a class="header" href="#linux-grub2">Linux Grub2</a></h2>
<p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2017/06/29/7094693.html#auto_id_37">grub2详解(翻译和整理官方手册)</a>
<a href="https://www.gnu.org/software/grub/manual/html_node/Simple-configuration.html#Simple-configuration">官方手册原文</a></p>
<p><code>grub2-mkconfig</code>是根据<code>/etc/default/grub</code>文件来创建配置文件的.该文件中定义的是<code>grub</code>的全局宏,修改内置的宏可以快速生成<code>grub</code>配置文件.
实际上在<code>/etc/grub.d/</code>目录下还有一些<code>grub</code>配置脚本,这些<code>shell</code>脚本读取一些脚本配置文件(如<code>/etc/default/grub</code>),根据指定的逻辑生成<code>grub</code>配置文件.
若有兴趣,不放读一读<code>/etc/grub.d/10_linux</code>文件,它指导了创建<code>grub.cfg</code>的细节,例如如何生成启动菜单.</p>
<pre><code class="language-bash">[root@xuexi ~]# ls /etc/grub.d/
00_header  00_tuned  01_users  10_linux  20_linux_xen  20_ppc_terminfo  30_os-prober  40_custom  41_custom  README
</code></pre>
<p>在<code>/etc/default/grub</code>中,使用<code>key=vaule</code>的格式,<code>key</code>全部为大小字母,如果<code>vaule</code>部分包含了空格或其他特殊字符,则需要使用引号包围.</p>
<p>例如,下面是一个<code>/etc/default/grub</code>文件的示例:</p>
<pre><code class="language-bash">[root@xuexi ~]# cat /etc/default/grub
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR=&quot;$(sed 's, release .*$,,g' /etc/system-release)&quot;
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT=&quot;console&quot;
GRUB_CMDLINE_LINUX=&quot;crashkernel=auto biosdevname=0 net.ifnames=0 rhgb quiet&quot;
GRUB_DISABLE_RECOVERY=&quot;true&quot;
</code></pre>
<p>虽然可用的宏较多,但可能用的上的就几个:
<code>GRUB_DEFAULT</code>, <code>GRUB_TIMEOUT</code>, <code>GRUB_CMDLINE_LINUX</code>和<code>GRUB_CMDLINE_LINUX_DEFAULT</code>.</p>
<p>以下列出了部分key.</p>
<hr />
<p><code>GRUB_DEFAULT</code></p>
<p>默认的菜单项,默认值为<code>0</code>.其值可为数值<code>N</code>,表示从<code>0</code>开始计算的第<code>N</code>项是默认菜单,也可以指定对应的<code>title</code>表示该项为默认的菜单项.
使用数值比较好,因为使用的<code>title</code>可能包含了容易改变的设备名.例如有如下菜单项</p>
<pre><code class="language-grub">menuentry 'Example GNU/Linux distribution' --class gnu-linux --id example-gnu-linux {
    ...
}
</code></pre>
<p>如果想将此菜单设为默认菜单,则可设置<code>GRUB_DEFAULT=example-gnu-linux</code>.</p>
<p>如果<code>GRUB_DEFAULT</code>的值设置为<code>saved</code>,则表示默认的菜单项是<code>GRUB_SAVEDEFAULT</code>或<code>grub-set-default</code>所指定的菜单项.</p>
<h3 id="uefi-系统下的安装"><a class="header" href="#uefi-系统下的安装">UEFI 系统下的安装</a></h3>
<p><a href="https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">GRand Unified Bootloader</a></p>
<p>安装</p>
<p>本节假设您正在 <code>x86_64</code> 系统上安装 <code>GRUB</code>. 对于 <code>IA32</code> (32 位) <code>UEFI </code>系统(不要和 32 位 CPU 相混淆),  将<code>x86_64-efi</code>替换成<code>i386-efi</code>.
首先安装软件包 <code>grub</code> 和 <code>efibootmgr</code>. 其中<code>GRUB</code>是启动引导器, <code>efibootmgr</code>被 <code>GRUB</code> 脚本用来将启动项写入 <code>NVRAM</code> .</p>
<p>然后按照下列步骤安装 <code>GRUB</code>:</p>
<p>挂载 <code>EFI</code> 系统分区, 在本节之后的内容里, 把 <code>esp</code> 替换成挂载点.
选择一个启动引导器标识, 这里叫做 <code>new</code>. 这将在 <code>esp/EFI/</code> 中创建一个<code>new</code>目录来储存 <code>EFI</code> 二进制文件, 而且这个名字还会在 <code>UEFI</code> 启动菜单中表示 <code>new</code> 启动项.
执行下面的命令来将 <code>GRUB EFI</code> 应用 <code>grubx64.efi</code> 安装到 <code>esp/EFI/new/</code>, 并将其模块安装到 <code>/boot/grub/x86_64-efi/</code>.</p>
<pre><code># grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=new
</code></pre>
<p>上述安装完成后 GRUB 的主目录将位于 <code>/boot/grub/</code>. 注意上述例子中, grub-install 还将在固件启动管理器中创建一个条目, 名叫 <code>new</code>.</p>
<p>在配置完成后, 记得生成主配置文件.</p>
<p>提示:  如果你使用了 <code>--removable</code> 选项, 那 <code>GRUB</code> 将被安装到 <code>esp/EFI/BOOT/BOOTX64.EFI</code> (当使用 <code>i386-efi</code> 时是 e<code>sp/EFI/BOOT/BOOTIA32.EFI</code>),
此时即使 <code>EFI</code> 变量被重设或者你把这个驱动器接到其他电脑上, 你仍可从这个驱动器上启动.
通常来说, 你只要像操作 <code>BIOS</code> 设备一样在启动时选择这个驱动器就可以了.
如果和 <code>Windows</code> 一起多系统启动, 注意 <code>Windows</code> 通常会在那里安装一个 <code>EFI</code> 可执行程序, 这只是为了重建 <code>Windows</code> 的 UEFI 启动项.</p>
<p>注意:
<code>--efi-directory</code> 和 <code>--bootloader-id</code> 是 <code>GRUB UEFI</code> 特有的. -<code>-efi-directory</code> 替代了已经废弃的 <code>--root-directory</code>.
您可能注意到在 <code>grub-install</code> 命令中没有一个 <code>&lt;device_path&gt;</code> 选项, 例如 <code>/dev/sda</code>. 事实上即使提供了 <code>&lt;device_path&gt;</code>, 也会被 <code>GRUB</code> 安装脚本忽略, 因为 <code>UEFI</code> 启动加载器不使用 MBR 启动代码或启动扇区.
确保 <code>grub-install</code> 命令是在你想要用 GRUB 引导的那个系统上运行的. 也就是说如果你是用安装介质启动进入了安装环境中, 你需要在 <code>chroot</code> 之后再运行 <code>grub-install</code>.
如果因为某些原因不得不在安装的系统之外运行 <code>grub-install</code>, 在后面加上 <code>--boot-directory= </code>选项来指定挂载 <code>/boot</code> 目录的路径, 例如 <code>--boot-directory=/mnt/boot</code>.</p>
<h3 id="grub-修复"><a class="header" href="#grub-修复">grub 修复</a></h3>
<p><a href="https://www.cnblogs.com/jpfss/p/9462792.html">Linux与Windows 10用grub引导教程</a></p>
<p>首先, 在你装了 Windows 之后, Windows 在装机过程中会将硬盘划分出一个约 <code>100MB</code> 大小的分区, 称为 <code>EFI</code> 分区.
这个分区就是起引导作用的. 在资源管理器中是看不到的这个分区的, 可以在磁盘管理中看到, 管理则需要借助 <code>DiskGenius</code> 工具.
可以看到该分区包含 3 个文件夹(如果你没有装 <code>Linux</code> 的话, 就只有两个), 分别是 <code>Boot</code>, <code>Microsoft</code> 和 <code>Manjaro</code>, 其中 <code>Boot</code> 文件夹就是 <code>UEFI</code> 引导所必需的文件.</p>
<p>我们继续打开 <code>Microsoft/Boot</code> 文件夹, 将会看到许多文件, 这些文件就是启动 <code>Windows 10</code> 所必需的, 包含了语言包, 字体等, <code>BCD</code> 包含了 <code>Windows</code> 引导开始以后的信息.
其中, <code>bootmgfw.efi </code>是 <code>Windows</code> 默认引导文件.</p>
<pre><code class="language-bash">EFI/Boot/bootx64.efi
EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>以上是采用 <code>UEFI</code> 启动 <code>Windows 10</code> 的文件结构, 也就是说, 当你按下开机按钮的时候, 首先 <code>UEFI</code> 找到 <code>EFI</code> 分区的 <code>Boot</code> 文件夹, 然后加载 <code>bootx64.efi</code> 文件, 读取文件信息, 找到 <code>EFI/Microsoft/Boot/bootmgfw.efi</code>, 按照 <code>bootmgfw.efi</code> 的要求, 加载所需的启动信息, 启动 <code>Windows 10</code>.</p>
<hr />
<p>准备工作</p>
<p>在正式装系统之前, 我们还需要做一些准备工作:</p>
<p>关闭 <code>Windows</code> 的快速启动
这个功能的作用是在于关机的时候不完全断电, 类似将系统处于<code>休眠</code>状态, 这样可以让开机更加迅速. 但这也就导致了只能使用 <code>Windows</code> 系统.</p>
<p>关闭 <code>BIOS</code> 的 <code>Secure Boot </code>的功能</p>
<p>在默认情况下, <code>UEFI</code> 固件只会加载那些被签名的引导程序. 在缺少 <code>Secure Boot</code> 功能的传统 PC 机上, 恶意的后门程序可以加载自身, 进而摇身一变伪装成一个引导程序.
这样的话, <code>BIOS</code> 就会在启动的时候加载后门程序, 这样它就可以躲过操作系统, 把自己隐藏得很深.
但是不得不说, 这对我们安装 <code>Linux</code> 造成了很大的困扰, 也是直接导致我们重启到 Windows 10 后进不去 <code>Linux</code> 的原因.
首先我们要关闭这个功能: 进入 <code>BIOS</code> 找到 <code>Secure Boot</code>, 选择 <code>disabled</code>, 这样就关闭了. 当然, 有些人进入 <code>BIOS</code> 会发现 Secure Boot 这个选项是灰色的(比如我的就是), 这时你需要先给你的 <code>BIOS</code> 设一个密码, 然后就能关 Secure Boot 了.</p>
<hr />
<p>安装 Linux</p>
<p>所有的准备都已经完成, 这时就可以准备刻录 U 盘了, 推荐<code>Rufus</code>和<code>USBWriter</code>.
刻录完成后, 重启按 <code>f12</code>, 选择从 USB 设备启动, 对于绝大多数发行版来说一路回车就行了, 只需要注意一点: 在选择挂载 <code>boot</code> 位置的时候, 一定要挂载在 <code>efi</code> 分区, 别的都不行.
重启之后, 不出意外的话, 你会直接进入 Windows 10, 不要担心, 这时 Linux 已经安装成功了, 我们只需要将引导文件替换一下.</p>
<hr />
<p>替换引导文件</p>
<p>先用 <code>DG</code> 打开 <code>EFI</code> 分区, 你会看到多了一个文件夹, 名称取决于你安装的是哪一个发行版.
我安装的是 <code>Manjaro Linux</code>, 名称就是 <code>Manjaro</code>, 打开之后会发现里面有一个名为 <code>grubx64.efi</code> 的文件, 这就是启动 <code>Linux</code> 的引导文件.
和 <code>Windows 10</code> 的 <code>bootmgfw.efi</code> 类似, 我们想要用 <code>grubx64.efi</code> 引导代替掉 <code>bootmgfw.efi</code>, 这样就可以用 <code>GRUB</code> 引导了. 步骤:</p>
<p>进入管理员命令行. 方法: <code>win + x</code>, 再按 <code>a</code>
输入 <code>bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</code>. 提示操作成功的话, 就完成了.</p>
<p>注: 如果输入以上命令提示<code>参数错误</code>的话, 将<code>{bootmgr}</code>改为 <code>'{bootmgr}'</code>, 原因是 <code>PowerShell</code> 和 <code>CMD</code> 语法的差别.</p>
<p>至此, 如果你安装的是除 <code>Arch</code> 之外绝大多数发行版, 那么接下来就和你没有啥关系了, 你已经成功了, 好好享受吧!</p>
<p>开机之后会发现进入 <code>GRUB</code> 的引导了, 通常会包含至少三个选项(以 <code>Manjaro</code> 举例): <code>Manjaro</code>, <code>Manjaro 高级选项</code>和 <code>Windows Manager</code>.
这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题.</p>
<hr />
<p>修复 <code>Windows</code> 引导</p>
<p>这一点是我安装 Arch Llinux 的时候发现的, Arch Linux 安装过程是手动安装的, 在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区(当然可能不是所有人都会遇到),
所以在 GRUB 界面可能会看不到 Windows Manager 选项, 导致进不去 Windows 10, 这里就需要手动编辑 GRUB 信息,
我们打开 <code>/boot/grub/grub.cfg</code> 文件, 发现里面确实没有 Windows 10 的启动信息, 在后面加上:</p>
<pre><code class="language-bash">menuentry &quot;Microsoft Windows 10&quot; {
    insmod part_gpt
    insmod fat
    insmod search_fs_uuid
    insmod chain
    search --fs-uuid --set=root $hints_string $fs_uuid
    chainloader /EFI/Microsoft/Boot/bootmgfw.efi
    }
</code></pre>
<p>注意:</p>
<p>这里的 <code>$hints_string</code>, 代表的是终端执行命令:</p>
<pre><code class="language-bash">sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>后的输出;</p>
<p>而 <code>$fs_uuid</code> 代表的是:</p>
<pre><code class="language-bash">sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>的输出. 然后保存. 在终端执行命令: <code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>, 就 <code>OK</code> 了.</p>
<p>到此, Arch Linux 和 Windows 10 双系统也配置完毕了.</p>
<hr />
<p>附加问题</p>
<ul>
<li>在 Windows 10 进行了一个大更新后, 会发现 GRUB 引导界面没有了, 还是直接进入了 Windows 10, 这时只需要按照 替换引导文件 的方法重新输入一遍命令就行.</li>
<li>使用 Linux 某个发行版一段时间之后, 难免会想尝试一下另一个发行版. 这时请务必将之前的发型版的引导文件删除, 否则可能会出现无论怎么设置都无法进入 GRUB 的情况. 例如: 我之前用的是 <code>Ubuntu</code>, 我现在换成了 Manjaro, 我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹.</li>
<li>在我使用 <code>Manjaro</code> 更新了一次 <code>Linux</code> 的内核后, 进不去 Windows 10 了, 这个时候千万不要直接修复 <code>Windows 10</code> 引导, 这会格式化 <code>EFI</code> 分区, 只需要按上面修复 <code>Windows</code> 引导 的方法编辑一下 <code>GRUB</code> 就可以了.</li>
</ul>
<hr />
<p><a href="https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E5%8A%A8%E8%8F%9C%E5%8D%95%E6%9D%A1%E7%9B%AE%E7%A4%BA%E4%BE%8B">Arch Wiki 上的示例</a></p>
<p>这个模式寻找 <code>Windows</code> 的启动加载器的位置, 然后当用户选择了相应的菜单条目的时候, 通过链式载入的方法在 <code>GRUB</code> 之后加载它.
这里主要的任务是找到 EFI 系统分区然后从上面运行启动加载器. 注意:  这个启动项仅在 <code>UEFI</code> 模式下才起作用, 而且 <code>Windows</code> 和 <code>UEFI</code> 的位数必须相同.</p>
<pre><code class="language-bash">if [ &quot;${grub_platform}&quot; == &quot;efi&quot; ]; then
    menuentry &quot;Microsoft Windows Vista/7/8/8.1 UEFI/GPT&quot; {
    insmod part_gpt
    insmod fat
    insmod chain
    search --no-floppy --fs-uuid --set=root $hints_string $fs_uuid
    chainloader /EFI/Microsoft/Boot/bootmgfw.efi
    }
fi
</code></pre>
<p>其中 <code>$hints_string</code> 和 <code>$fs_uuid</code> 由下述两个命令得到.</p>
<p><code>$fs_uuid</code> 命令检测 EFI 系统分区的 <code>UUID</code> :</p>
<pre><code class="language-bash"># grub-probe --target=fs_uuid esp/EFI/Microsoft/Boot/bootmgfw.efi
1ce5-7f28
</code></pre>
<p>或者你可以(以 <code>root</code> 身份)运行 <code>blkid</code> 然后从结果中找到 <code>EFI</code> 系统分区的 <code>UUID</code> .</p>
<p><code>$hints_string</code> 命令可以确定 EFI 系统分区的位置, 在当前的例子中是 <code>harddrive 0</code>:</p>
<pre><code class="language-bash"># grub-probe --target=hints_string esp/EFI/Microsoft/Boot/bootmgfw.efi
--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=ahci0,gpt1
</code></pre>
<p>这两个命令都是假设 <code>Windows</code> 使用的 <code>ESP</code> 是挂载在<code>$esp</code>上的. 当然,  <code>Windows</code> 的 <code>EFI</code> 文件路径可能有变,因为这就是 <code>Windows</code> ....</p>
<h3 id="我使用的-grub-自定义"><a class="header" href="#我使用的-grub-自定义">我使用的 grub 自定义</a></h3>
<p><a href="https://www.gnu.org/software/grub/manual/grub/grub.html#search">Writing your own configuration file</a></p>
<ul>
<li>编辑 <code>/etc/default/grub</code></li>
</ul>
<pre><code class="language-grub">GRUB_DEFAULT=0 #设置默认为第一个
GRUB_TIMEOUT=10 #设置等待时间
GRUB_TIMEOUT_STYLE=menu # 强制显示启动菜单
</code></pre>
<ul>
<li>编辑 <code>/etc/grub.d/40_custom</code>, 添加 <code>windows</code>启动项,</li>
</ul>
<pre><code class="language-bash">if [ &quot;${grub_platform}&quot; == &quot;efi&quot; ]; then
    menuentry &quot;Windows UEFI GPT&quot; {
    insmod part_gpt
    insmod fat
    insmod chain
    search --no-floppy --set=root --fs-uuid &quot;C045-C995&quot;
    chainloader /EFI/Microsoft/Boot/bootmgfw.efi
    }
fi
</code></pre>
<p>然后运行<code>sudo os-prober ;sudo update-grub</code></p>
<h3 id="grub-命令行手动引导"><a class="header" href="#grub-命令行手动引导">grub 命令行手动引导</a></h3>
<p>链式加载<code>UEFI</code>模式下安装的 <code>Windows/Linux</code></p>
<pre><code class="language-bash">insmod fat
set root=(hd1,gpt1)
chainloader /EFI/Microsoft/Boot/bootmgfw.efi
boot
</code></pre>
<h3 id="grub-参数"><a class="header" href="#grub-参数">grub 参数</a></h3>
<p><a href="https://askubuntu.com/questions/716957/what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean">nomodeset, quiet and splash</a></p>
<ul>
<li>
<p><code>nomodeset</code> ; 最新的内核已将<code>video mode setting</code>移入内核.
So all the programming of the hardware specific clock rates and registers on the video card 发生在内核中,
而不是<code>X</code>服务器启动后的<code>X</code>驱动中. 如此, 可以在开机时展示高分辨率<code>splash/boot</code>画面, 并实现平滑过渡, 不用闪烁一下子.
然而有些显卡无法正常工作, 并且最终会出现黑屏. 添加<code>nomodeset</code>参数指示内核在加载<code>X</code>之前不加载显卡驱动程序, 而改用<code>BIOS</code>模式.</p>
</li>
<li>
<p><code>quiet splash</code>; <code>splash</code>(由<code>/boot/grub/grub.cfg</code>设置)导致显示启动画面. 同时, 您希望启动过程安静一些, 否则所有类型的消息都会覆盖启动屏幕.
尽管在<code>GRUB</code>中指定了这些参数, 但它们是影响内核或其模块加载的内核参数, 而不是改变<code>GRUB</code>行为的参数. 来自<code>GRUB_CMDLINE_LINUX_DEFAULT</code>的重要部分是<code>CMDLINE_LINUX</code></p>
</li>
<li>
<p><code>acpi</code>, <code>noapic</code> and <code>nolapic</code>;通常不需要这些参数, 除非你的<code>BIOS</code>很古老, 不支持这些标准.</p>
</li>
</ul>
<p><code>ACPI</code>(Advanced Configuration and Power Interface)是用于处理电源管理的标准.
较早的系统可能不完全支持<code>ACPI</code>, 因此有时它有助于向内核提示不使用它. <code>acpi=off</code></p>
<p><code>APIC</code>(<code>Advanced Programmable Interrupt Controller</code>)是在较新的系统上发行的一种功能.
<code>&quot;local&quot;</code>版本称为<code>LAPIC</code>. 该控制器可以生成和处理中断, 中断是硬件用来传递消息的信号.
同样, <code>APIC</code>的某些实现在较旧的系统上可能会出现问题, 因此禁用它很有用.  <code>noapic</code> ,<code>nolapic</code>.</p>
<p>有时, <code>APIC</code>可以正常工作, 但是传递消息可能会减慢速度, 这可能会干扰音频和视频处理. 人们也可能出于这个原因禁用它.</p>
<h3 id="acpi-伪装-windows"><a class="header" href="#acpi-伪装-windows">ACPI 伪装 windows</a></h3>
<p><a href="https://blog.csdn.net/hustcw98/article/details/81979172">Manjaro折腾记录</a>
<a href="https://unix.stackexchange.com/questions/246672/how-to-set-acpi-osi-parameter-in-the-grub">how to set acpi_osi parameter in the grub</a></p>
<p>有时从suspend恢复时, 会发现登录后整个桌面一片黑色, 只有一个亮亮的鼠标可以移动.</p>
<pre><code class="language-bash">vim /etc/default/grub
## 在 GRUB_CMDLINE_LINUX_DEFAUT= 后面添加下面的语句
acpi_osi=! acpi_osi='Windows 2009'
</code></pre>
<p><code>acpi_osi=!</code>清空表示<code>acpi_osi</code>原来的值, 然后假装成<code>Windows 7, Win Server 2008 R2</code>,
具体的版本对应可以参考: <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/acpi/winacpi-osi">如何使用 _OSI 识别 ACPI 中的 Windows 版本</a>.</p>
<p>对于<code>Debian</code>系列的发行版, 可能需要转义引号, 写成<code>acpi_osi=\&quot;Windows 2009\&quot;</code>,修改后, 运行<code>sudo update-grub</code>重新生成引导配置.
可以使用<code>cat /proc/cmdline</code>检查内核启动的参数, 参考<a href="https://blog.csdn.net/baidu_33879812/article/details/104906774">Linux中proc/cmdline</a></p>
<hr />
<p><code>Manjaro</code>在更新内核到<code>Linux 5.11.14-1</code>的时候出现问题, 开机提示<code>NMI watchdog: Watchdog detected hard LOCKUP on cpu x</code>,删除这个配置之后可以正常进入.</p>
<hr />
<p>20210423  测试:</p>
<ul>
<li><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;apparmor=1 security=apparmor resume=UUID=0f163abf-8e60-4626-a4de-54332c64db51 udev.log_priority=3&quot;</code>: 不设置这个选项, 可以正常启动.</li>
<li>加上<code>acpi_osi=! acpi_osi='Windows 2009'</code> : 可以正常启动</li>
<li>加上<code>acpi_osi=! acpi_osi='Windows 2015'</code>  : 可以正常启动</li>
</ul>
<p>三种参数的开机日志基本没啥区别</p>
<h2 id="概念解释"><a class="header" href="#概念解释">概念解释</a></h2>
<h3 id="查看网络配置"><a class="header" href="#查看网络配置">查看网络配置</a></h3>
<p>EXAMPLES</p>
<ul>
<li><code>ip addr</code> Shows addresses assigned to all network interfaces.</li>
<li><code>ip neigh</code> Shows the current neighbour table in kernel.</li>
<li><code>ip link set x up</code> Bring up interface x.</li>
<li><code>ip link set x down</code> Bring down interface x.</li>
<li><code>ip route</code> Show table routes.</li>
</ul>
<p>EXAMPLES</p>
<ul>
<li><code>ip ro</code> Show all route entries in the kernel.</li>
<li><code>ip route add default via 192.168.1.1 dev eth0</code> Adds a default route (for all addresses) via the local gateway 192.168.1.1 that can be reached on device eth0.</li>
<li><code>ip route add 10.1.1.0/30 encap mpls 200/300 via 10.1.1.1 dev eth0</code> Adds an ipv4 route with mpls encapsulation attributes attached to it.</li>
<li><code>ip -6 route add 2001:db8:1::/64 encap seg6 mode encap segs 2001:db8:42::1,2001:db8:ffff::2 dev eth0</code> Adds an IPv6 route with SRv6 encapsulation and two segments attached.</li>
</ul>
<hr />
<p><code>Ubuntu 18.04 Server</code> 安装好后,Netplan 的默认描述文件是:<code>/etc/netplan/50-cloud-init.yaml</code>.</p>
<p><a href="https://blog.csdn.net/uaniheng/article/details/104233137?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">Ubuntu18.04的网络配置 netplan</a></p>
<h3 id="配置netplan-固定ip"><a class="header" href="#配置netplan-固定ip">配置netplan 固定ip</a></h3>
<p><code>vim /etc/netplan/50-cloud-init.yaml </code></p>
<p>配置如下:</p>
<pre><code class="language-bash">network:
    ethernets:
        enp3s0:
            addresses: [192.168.0.20/24]  //IP址
            gateway4: 192.168.0.1  // 网关
            nameservers:
             addresses: [114.114.114.114, 192.168.0.1] //DNS
            dhcp4: no
            optional: no
    version: 2
</code></pre>
<p>或者配置dhcp自动获取ip</p>
<p><code>vim /etc/netplan/50-cloud-init.yaml </code></p>
<p>配置如下:</p>
<pre><code class="language-bash">network:
    ethernets:
        enp3s0:
            dhcp4: true
            optional: yes
    version: 2
</code></pre>
<p>应用:</p>
<p><code>sudo netplan apply</code></p>
<h3 id="查看mac地址"><a class="header" href="#查看mac地址">查看MAC地址</a></h3>
<ul>
<li><code>ifconfig | awk '/eth/{print $1,$5}'</code></li>
<li><code>arp -a | awk '{print $4}</code></li>
<li><code>sudo lshw -C network</code></li>
<li><code>sudo lshw -c network | grep serial</code></li>
</ul>
<pre><code class="language-bash">wlp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000
      link/ether 10:5b:ad:df:4c:cd brd ff:ff:ff:ff:ff:ff
    inet 192.168.32.6/24 brd 192.168.32.255 scope global dynamic noprefixroute wlp2s0
       valid_lft 4185sec preferred_lft 4185sec
    inet6 fe80::310a:df04:1f02:d5ac/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
</code></pre>
<p><code>link/ether 10:5b:ad:df:4c:cd brd ff:ff:ff:ff:ff:ff</code> This is the mac address</p>
<h3 id="子网掩码"><a class="header" href="#子网掩码">子网掩码</a></h3>
<p><a href="https://www.zhihu.com/question/263438014/answer/278015413">为什么每台电脑都要设置子网掩码?</a>
<a href="https://zhidao.baidu.com/question/517459209.html">24 28 30 位的子网掩码是多少 </a></p>
<p>例如:
IP地址为<code>130.39.37.100</code>,
网络地址为<code>130.39.0.0</code>,
子网地址为<code>130.39.37.0</code>,
子网掩码为<code>255.255.255.0</code>,
网络地址部分和子网标识部分对应<code>1</code>,host部分对应<code>0</code>.
使用CIDR表示为:<code>130.39.37.100/24</code>即<code>IP地址/ 掩码长度</code>.</p>
<p><code>ipv4</code>是<code>8bit.8bit.8bit.8bit</code>的形式,二进制到十六进制是<code>4</code>位到<code>1</code>位,<code>8bit</code>相当于两个<code>16</code>进制数字.
所以<code>ipv4</code>是四段地址:<code>0x0x.0x0x.0x0x.0x0x</code>,每段两个<code>16</code>进制数字.
<code>24</code>表示掩码开头有<code>24</code>个<code>1</code>,对应地址中的<code>3</code>段,也就是公网地址是<code>3</code>段.</p>
<p><code>awk</code>执行按位<strong>与</strong>操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
awk 'BEGIN {
    num1 = 10
    num2 = 6
    printf &quot;(%d AND %d) = %d\n&quot;, num1, num2, and(num1, num2)
}'
</code></pre>
<p>设</p>
<pre><code class="language-ip">A:10.1.1.10 /24
B:10.1.1.20 /24
C:50.1.1.80 /24
</code></pre>
<p>AB在同一局域网,C位于外网.</p>
<p>三个表:</p>
<ul>
<li><code>ARP</code>表:主机维护,存放<code>IP</code>地址和<code>MAC</code>地址对应关系.</li>
<li><code>MAC</code>地址表:交换机维护,存放<code>MAC</code>地址和交换机端口对应关系.</li>
<li>路由表:路由器维护,存放<code>IP</code>地址和路由器端口对应关系.</li>
</ul>
<p>首先<code>AB</code>通信,
例如<code>A</code>要给<code>B</code>发送一个数据包,目前<code>A</code>知道<code>B</code>的<code>IP</code>地址,根据掩码规则判定<code>B</code>和自己在同一个局域网,同一个广播域.</p>
<p>接下来<code>A</code>通过广播方式获取<code>B</code>的<code>MAC</code>地址,添加到自己的<code>ARP</code>表中.
然后把要发送的包封装,然后发送给交换机,交换机收到数据包后解封装得到<code>B</code>的<code>MAC</code>地址,
根据<code>MAC</code>地址表转发到<code>B</code>所连接的交换机端口,完成发送.</p>
<p>如果<code>A</code>要和<code>C</code>通信,发送一个包给<code>C</code>的话,也只知道<code>C</code>的<code>IP</code>地址,然后<code>A</code>根据掩码规则发现<code>C</code>和自己不是同一个局域网的,
广播不到<code>C</code>,所以<code>A</code>只能把数据包发给网关,由网关发出去给到<code>C</code>.</p>
<p><code>A</code>同样通过广播方式获取网关的<code>MAC</code>地址,然后把<code>C</code>的<code>IP</code>地址和网关的<code>MAC</code>地址封装到数据包后发给交换机,
交换机解封装后对比<code>MAC</code>地址表,发现是发给网关的包,就转发到网关即路由器所在的交换机端口.
路由器收到包之后再解封装,得到<code>C</code>的<code>IP</code>地址,然后根据自己的路由表转发到相应的端口.完成通信.</p>
<p>所以如果计算机上不设置子网掩码,从第一步就不能完成,下面就更不能继续了.
如果同一个广播域里有机器设置不同的子网掩码,依然能够通信,只不过有的内网包需要到网关绕一圈.</p>
<p>外网包的话只要网关设置对了就没问题.</p>
<h3 id="查看登录用户"><a class="header" href="#查看登录用户">查看登录用户</a></h3>
<p><a href="https://blog.csdn.net/wanchaopeng/article/details/88425067">linux查看当前登录用户</a></p>
<ul>
<li>
<p><code>w</code>命令:显示目前登入系统的用户信息. 选项:</p>
</li>
<li>
<p><code>-f</code>: 开启或关闭显示用户从何处登入系统.</p>
</li>
<li>
<p><code>-h</code>: 不显示各栏位的标题信息列.</p>
</li>
<li>
<p><code>-s</code>: 使用简洁格式列表,不显示用户登入时间,终端机阶段作业和程序所耗费的CPU时间.</p>
</li>
<li>
<p><code>-u</code>: 忽略执行程序的名称,以及该程序耗费CPU时间的信息.</p>
</li>
<li>
<p><code>-V</code>: 显示版本信息.</p>
</li>
</ul>
<p>输出的结果的含义:</p>
<ul>
<li>
<p><code>USER</code> 登录的用户名</p>
</li>
<li>
<p><code>TTY</code> 登录终端</p>
</li>
<li>
<p><code>FROM</code> 从哪个IP地址登录</p>
</li>
<li>
<p><code>LOGIN</code>@ 登录时间</p>
</li>
<li>
<p><code>IDLE</code> 用户闲置时间</p>
</li>
<li>
<p><code>JCPU</code> 指的是和该终端连接的所有进程占用的时间,这个时间里并不包括过去的后台作业时间,但却包括当前正在运行的后台作业所占用的时间</p>
</li>
<li>
<p><code>PCPU</code> 当前进程所占用的时间</p>
</li>
<li>
<p><code>WHAT</code> 当前正在运行的命令</p>
</li>
<li>
<p><code>who</code>; 显示当前已登录的用户信息,输出的结果有:用户名,登录终端,登录的时间</p>
</li>
<li>
<p><code>last</code>; 列出目前与过去登入系统的用户相关信息.</p>
</li>
<li>
<p><code>-R</code>: 省略 hostname 的栏位</p>
</li>
<li>
<p><code>-n</code>:指定输出记录的条数.</p>
</li>
<li>
<p><code>-f file</code>:指定用文件<code>file</code>作为查询用的<code>log</code>文件.</p>
</li>
<li>
<p><code>-t time</code>:显示到指定的时间.</p>
</li>
<li>
<p><code>-h </code>:显示帮助.</p>
</li>
<li>
<p><code>-i</code> or<code>--ip</code>:以<code>数字</code>and <code>点</code>的形式显示<code>ip</code>地址.</p>
</li>
<li>
<p><code>-x</code>:显示系统关闭, 用户登录和退出的历史.</p>
</li>
</ul>
<p>命令的输出包含:用户名,登录终端,登录IP,登录时间,退出时间(在线时间)</p>
<ul>
<li>
<p><code>lastlog</code>;检查某特定用户上次登录的时间. 选项:</p>
</li>
<li>
<p><code>-b</code>, <code>--before DAYS</code>: 仅打印早于 DAYS 的最近登录记录</p>
</li>
<li>
<p><code>-h</code>, <code>--help</code>: 显示此帮助信息并推出</p>
</li>
<li>
<p><code>-R</code>, <code>--root CHROOT_DIR</code> directory to chroot into</p>
</li>
<li>
<p><code>-t</code>, <code>--time DAYS</code> : 仅打印比 DAYS 新近的登录记录</p>
</li>
<li>
<p><code>-u</code>, <code>--user LOGIN</code> : 打印 LOGIN 用户的最近登录记录</p>
</li>
</ul>
<p>注意:<code>lastlog</code>命令默认读取的是<code>/var/log/wtmp</code>这个文件的数据,一定注意这个文件不能用<code>vi</code>来查看.
命令输出包括:用户名,登录终端,登录<code>IP</code>,最后一次登录时.</p>
<h3 id="linux目录含义"><a class="header" href="#linux目录含义">Linux目录含义</a></h3>
<p><a href="https://www.jianshu.com/p/142deb98ed5a">Linux各目录含义</a></p>
<ul>
<li>FHS标准; <code>linux</code>系统的目录都遵循一个标准, 即由<code>Linux</code>基金会发布的 文件系统层次结构标准 (<code>Filesystem Hierarchy Standard</code>, FHS).
这个标准里面定义了linux系统该有哪些目录,各个目录应该存放什么,起什么作用等等:</li>
</ul>
<p>目录  含义</p>
<ul>
<li>
<p><code>/bin</code>  <code>binary</code>,即用来存放二进制可执行文件,并且比较特殊的是<code>/bin</code>里存放的是所有一般用户都能使用的可执行文件,如:<code>cat</code>, <code>chmod</code>, <code>chown</code>, <code>mv</code>, <code>mkdir</code>, <code>cd</code> 等常用指令</p>
</li>
<li>
<p><code>/boot</code>  存放开机时用到的引导文件</p>
</li>
<li>
<p><code>/dev</code>  device(并不是<code>develop</code>哦),任何设备都以文件的形式存放在这个目录中</p>
</li>
<li>
<p><code>/etc</code>  <code>Editable Text Configuration</code>(早期含义为<code>etcetera</code>,但是有争议),存放系统配置文件,如各种服务的启动配置,账号密码等</p>
</li>
<li>
<p><code>/home</code>  用户的主目录,每当新建一个用户系统都会在这个目录下创建以该用户名为名称的目录作为该用户的主目录.并且在命令行中~代表当前用户的主目录,~yousiku表示yousiku这个用户的主目录</p>
</li>
<li>
<p><code>/lib</code>  library,存放着系统开机时所需的函数库以及/bin和/sbin目录下的命令会调用的函数库</p>
</li>
<li>
<p><code>/lib64</code>  存放相对于/lib中支持64位格式的函数库</p>
</li>
<li>
<p><code>/media</code>  可移除的媒体设备,如光盘,DVD等</p>
</li>
<li>
<p><code>/mnt</code>  <code>mount</code>,临时挂载的设备文件</p>
</li>
<li>
<p><code>/opt</code>  <code>optional</code>,可选的软件包,即第三方软件.我们可以将除了系统自带软件之外的其他软件安装到这个目录下</p>
</li>
<li>
<p><code>/proc</code>  <code>process</code>,该目录是一个虚拟文件系统,即该目录的内容存放于内存中而不是硬盘中,存放着系统内核以及进程的运行状态信息</p>
</li>
<li>
<p><code>/root</code>  超级管理员root的主目录</p>
</li>
<li>
<p><code>/run</code>  最近一次开机后所产生的各项信息,如当前的用户和正在运行中的守护进程等</p>
</li>
<li>
<p><code>/sbin</code>  存放一些只有root账户才有权限执行的可执行文件,如init, ip, mount等命令</p>
</li>
<li>
<p><code>/srv</code>  service,存放一些服务启动后所需的数据</p>
</li>
<li>
<p><code>/sys</code>  system,与/proc类似也是一个虚拟文件系统,存放系统核心与硬件相关的信息</p>
</li>
<li>
<p><code>/tmp</code>  temporary,存放临时文件,可以被所有用户访问,系统重启时会清空该目录</p>
</li>
<li>
<p><code>/usr</code>  Unix Software Resource(并不是指user哦),存放着所有用户的绝大多数工具和应用程序(下文详细介绍)</p>
</li>
<li>
<p><code>/var</code>  variable,存放动态文件,如系统日志,程序缓存等(下文详细介绍)</p>
</li>
<li>
<p><code>/usr</code>目录; <code>Unix Software Resource</code> 意为 <code>Unix</code>系统软件资源.
系统自带的软件都装在这个目录下(好比Windows系统的<code>C:\Windows</code>),用户安装的第三方软件也在这个目录下(好比Windows系统的<code>C:\Program Files</code>).
不同的是, 在Windows系统上安装软件通常将该软件的所有文件放置在同一个目录下,但在Linux系统, 安装软件会将该软件的不同文件分别放置在<code>/usr</code>目录下的不同子目录下.
而不应该自行创建该软件自己的独立目录. <code>/usr</code>目录一般有以下子目录:</p>
</li>
</ul>
<p>目录  含义</p>
<ul>
<li><code>/usr/bin</code>  即<code>/bin</code>,用链接文件到方式将<code>/bin</code>链接至此</li>
<li><code>/usr/etc</code>  应用程序的配置文件</li>
<li><code>/usr/games</code>  与游戏相关的数据</li>
<li><code>/usr/include</code>  <code>c/c++</code>程序的头文件</li>
<li><code>/usr/lib</code>  即<code>/lib</code>,用链接文件到方式将<code>/lib</code>链接至此</li>
<li><code>/usr/lib64</code>  即<code>/lib64</code>,用链接文件到方式将<code>/lib64</code>链接至此</li>
<li><code>/usr/libexec</code>  不常用的执行文件或脚本</li>
<li><code>/usr/local</code>  应用程序的安装目录,每个应用程序目录下还会有对应的<code>bin</code>, <code>etc</code>, <code>lib</code>等目录</li>
<li><code>/usr/sbin</code>  即<code>/sbin</code>,用链接文件到方式将<code>/sbin</code>链接至此</li>
<li><code>/usr/share</code>  共享文件,通常是一些文字说明文件,如软件文档等</li>
<li><code>/usr/src</code>  <code>source</code>,应用程序源代码</li>
<li><code>/usr/tmp</code>  应用程序临时文件</li>
</ul>
<h3 id="输入法"><a class="header" href="#输入法">输入法</a></h3>
<p>添加删除输入法在系统设置目录, 直接搜索<code>settings-Region&amp;Language--input sources</code>, 添加输入法是按照语言进行的, 先选择语言, 然后可以选择具体的输入法.
如<code>Intelligent Pinyin</code></p>
<ul>
<li>
<p>切换输入法可以使用如下命令: <code>im-config -s fcitx</code>,
<code>-s</code>:    无动作;  对可能发生的事件进行模拟,但实际上不更改配置文件.</p>
</li>
<li>
<p>如果要查看当前可用的输入法可以使用 <code>im-config -l</code> , 更多查看 <code>man im-config</code>.</p>
</li>
<li>
<p><code>ibus-setup</code>: 图形界面程序, 用于设置<code>ibus</code>输入法框架</p>
</li>
<li>
<p>查看环境变量<code>$XDG_CURRENT_DESKTOP</code>的值来看自己处于哪个图形环境.</p>
</li>
<li>
<p>重启输入法; <code>ibus restart</code>:</p>
</li>
<li>
<p>重启 ibus 守护进程;  <code>ibus-daemon -drx</code></p>
<ul>
<li><code>-d --daemonize</code>:作为后台程序运行</li>
<li><code>-r, --replace</code>: 如果有旧的<code>ibus-daemon</code>在运行, 就替换它.</li>
<li><code>-x, --xim</code>: 运行<code>XIM</code>服务器</li>
</ul>
</li>
<li>
<p>gedit设置默认编码UTF-8;
<a href="https://blog.csdn.net/miscclp/article/details/39154639">gedit默认编码设置</a>.
在终端下输入:</p>
</li>
</ul>
<pre><code class="language-bash">gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;['UTF-8', 'GB18030', 'GB2312', 'GBK', 'BIG5', 'CURRENT', 'UTF-16']&quot;
</code></pre>
<ul>
<li>导入ibus词库
<a href="https://blog.csdn.net/betabin/article/details/7798668">iBus拼音输入法导入搜狗词库</a></li>
</ul>
<p>终端下输入<code>ibus-setup</code>--<code>Input Method</code>--<code>Chinese - intelligent pinyin</code>,
点击右侧的 <code>preference</code>--<code>user data</code>--<code>import</code>, 把制作好的词库导入进去即可. 测试:</p>
<pre><code>亥姆霍兹方程
重整化群
</code></pre>
<h3 id="定制自己的libpinyin"><a class="header" href="#定制自己的libpinyin">定制自己的libpinyin</a></h3>
<p><a href="https://blog.csdn.net/godbreak/article/details/9031887">ibus下定制自己的libpinyin</a></p>
<p>智能拼音输入法从<code>ibus-pinyin</code>更名为<code>ibus-libpinyin</code></p>
<p><code>libpinyin</code>添加了词库导入功能,并刚刚修复相关<code>bug</code>,所以要先更新<code>libpinyin</code>到最新版.
在<code>libpinyin</code>的配置界面(可以从<code>语言选项</code>---<code>输入源</code>找到,实在找不到,<code>/usr/share/ibus-libpinyin/setup/main2.py</code>),可以找到<strong>用户数据导入选项</strong>.</p>
<p>这个要求文件:</p>
<ol>
<li>文件采用本地编码格式</li>
<li>格式为每行<code>字符 拼音 位置(可选)</code>,且字符数和拼音数要对应,例如<code>你好 ni'hao 5</code>.</li>
</ol>
<p>去搜狗词库下搜狗细胞词库文件,然后下个<strong>深蓝词库转换器</strong>(<code>exe</code>),<code>wine</code>中打开转换器,选择从搜狗细胞词库转换到手机<code>QQ</code>格式,转换结束后不要选择文件保存本地,编码格式不大对,在输出框里面全选复制粘贴到你的文本编辑器,保存为<code>.txt</code>后缀.
然后在<code>libpinyin</code>配置界面导入即可.导入完成后,<code>kill ibus-engine-libpinyin</code>进程,再切回拼音输入法.</p>
<h2 id="日常维护"><a class="header" href="#日常维护">日常维护</a></h2>
<h3 id="开机报错"><a class="header" href="#开机报错">开机报错</a></h3>
<p><a href="https://askubuntu.com/questions/1160113/system-program-problem-detected">System program problem detected?</a></p>
<p>查看转储到您的磁盘上的崩溃报告. 目录是<code>/var/crash/</code>, 它将包含几个文件, 这些文件将您指向它所涉及的软件包以及崩溃的原因.
该目录描述为:</p>
<blockquote>
<p><code>/var/crash</code>: 系统崩溃转储(可选)
该目录包含系统故障转储.
自本标准发布之日起, Linux不支持系统故障转储, 但其他可能符合FHS的系统也可能支持系统转储.</p>
</blockquote>
<p><code>Ubuntu</code>版本使用此(可选)目录来转储崩溃和执行崩溃的软件包, 称为<code>apport</code> (and <code>whoopsie</code>).
如果您想获得关于崩溃的真正详细的报告, 请安装<code>GDB</code>: <code>The GNU Project Debugger</code> with <code>sudo apt-get install gdb</code>.</p>
<ul>
<li>如何摆脱它</li>
</ul>
<p>取决于您所说的<code>摆脱</code>. 理想的解决方法是检查报告中包含的内容, 然后尝试找到解决方法.
如果不需要包装或良性包装, 也可以将其清除. 多数情况下, 它是一项核心功能.</p>
<p>您可以选择以下任意一种来删除崩溃报告, 直到实际删除该软件包为止(如果错误来自于<code>apport</code>本身, 那将非常具有讽刺意味):</p>
<ul>
<li><code>sudo rm /var/crash/*</code>将删除旧的崩溃并停止通知您, 直到某些软件包再次崩溃为止.</li>
<li>您可以通过<code>sudo systemctl disable apport</code>停止服务(并通过<code>sudo systemctl enable apport</code>再次启用它)</li>
<li>如果不想看到崩溃报告, 可以通过<code>vim /etc/default/apport</code>将其禁用. 并将<code>enabled = 1</code>更改为<code> enabled = 0</code>. 反向编辑将再次启用它.</li>
<li>您可以使用<code>sudo apt purge apport</code>(使用<code>sudo apt install apport</code>再次安装)
+还有一种桌面方法(<code>问题报告</code>选项):</li>
</ul>
<p><a href="https://askubuntu.com/questions/346953/how-to-read-and-use-crash-reports">如何阅读和使用崩溃报告</a>有一些有趣的答案.
它有一个示例崩溃报告和一种跟踪崩溃的方法.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-5"><a class="header" href="#linux-5">linux-5</a></h1>
<h2 id="权限"><a class="header" href="#权限">权限</a></h2>
<p>Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统,区别在于它们不仅是多任务系统,而且也是多用户系统.
这到底意味着什么?它意味着多个用户可以在同一时间使用同一台计算机.</p>
<p>例如,如果一台 计算机连接到一个网络或者因特网,那么远程用户通过<code>ssh</code>(安全 shell)可以登录并操纵这台电脑.
事实上,远程用户也能运行图形界面应用程序,并且图形化的输出结果会出现在远端的显示器上.
<code>X</code>窗口系统把这个作为基本设计理念的一部分,并支持这种功能.</p>
<p>在这一章中,我们将看看这一系统安全的本质部分,会介绍以下命令:</p>
<ul>
<li><code>id</code> – 显示用户身份号</li>
<li><code>chmod</code> – 更改文件模式</li>
<li><code>umask</code> – 设置默认的文件权限</li>
<li><code>su</code> – 以另一个用户的身份来运行 shell</li>
<li><code>sudo</code> – 以另一个用户的身份来执行命令</li>
<li><code>chown</code> – 更改文件所有者</li>
<li><code>chgrp</code> – 更改文件组所有权</li>
<li><code>passwd</code> – 更改用户密码</li>
</ul>
<h3 id="拥有者组成员和其他人"><a class="header" href="#拥有者组成员和其他人">拥有者,组成员,和其他人</a></h3>
<p>在第四章探究文件系统时,当我们试图查看一个像<code>/etc/shadow</code>那样的文件的时候,我们会遇到一个问题.</p>
<pre><code class="language-bash">file /etc/shadow
/etc/shadow: regular file, no read permission
less /etc/shadow
/etc/shadow: Permission denied
</code></pre>
<p>产生这种错误信息的原因是,作为一个普通用户,我们没有权限来读取这个文件.</p>
<p>在 Unix 安全模型中,一个用户可能拥有文件和目录.
当一个用户拥有一个文件或目录时, 用户可以设置这个文件或目录的访问权限.
用户,反过来又属于用户组(由一个或多个用户组成),文件和目录的owner 可以对用户组成员授予对这些文件和目录的访问权限.
除了对一个用户组授予权限之外,owner 还能给其他人授予一些权限.在 Unix 术语中,每个人 是指整个世界.</p>
<p>可以用 <code>id</code> 命令,来找到关于你自己身份的信息:</p>
<pre><code class="language-bash">id
uid=500(me) gid=500(me) groups=500(me)
</code></pre>
<p>让我们看一下输出结果.
当用户创建帐户之后,系统会给用户分配一个号码,叫做用户 <code>ID</code> 或者 <code>uid</code>,然后,为了符合人类的习惯,这个 <code>ID</code> 映射到一个用户名.</p>
<p>系统又会给这个用户分配一个原始的组 <code>ID</code> 或者是 <code>gid</code>,这个 <code>gid</code> 可能属于另外的组.</p>
<p>上面的例子来自于 <code>Fedora</code> 系统, 比方说 <code>Ubuntu</code> 的输出结果可能看起来有点儿不同:</p>
<pre><code class="language-bash">id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
</code></pre>
<p>正如我们能看到的,两个系统中用户的 <code>uid</code> 和 <code>gid</code> 号码是不同的.
原因很简单,因为 <code>Fedora</code> 系统 从500开始进行普通用户帐户的编号,而 <code>Ubuntu</code> 从1000开始.
我们也能看到 <code>Ubuntu</code> 的用户属于 更多的用户组.这和<code>Ubuntu</code> 管理系统设备和服务权限的方式有关系.</p>
<p>那么这些信息来源于哪里呢?像 <code>Linux</code> 系统中的许多东西一样,来自一系列的文本文件.</p>
<p>用户帐户定义在 <code>/etc/passwd</code> 文件里面,用户组定义在<code> /etc/group</code> 文件里面.</p>
<p>当用户帐户和用户组创建以后, 这些文件随着文件 <code>/etc/shadow</code> 的变动而修改,文件 /<code>etc/shadow</code> 包含了关于用户密码的信息.</p>
<p>对于每个用户帐号,文件<code>/etc/passwd</code> 定义了用户(登录)名,<code>uid</code>,<code>gid</code>,帐号的真实姓名,家目录, 和登录 <code>shell</code>.如果你查看一下文件<code>/etc/passwd</code> 和文件<code>/etc/group</code> 的内容,你会注意到除了普通 用户帐号之外,还有超级用户(<code>uid 0</code>)帐
号,和各种各样的系统用户.</p>
<p>在下一章中,当我们讨论进程时,你会知道这些其他的<code>用户</code>是谁,实际上,他们相当忙碌.</p>
<p>然而许多像 Unix 的系统会把普通用户分配到一个公共的用户组中,例如<code>users</code>,
现在的 Linux 会创建一个独一无二的,只有一个成员的用户组,这个用户组与用户同名.
这样使某种类型的 权限分配更容易些.</p>
<h3 id="读取写入和执行"><a class="header" href="#读取写入和执行">读取,写入,和执行</a></h3>
<p>对于文件和目录的访问权力是根据读访问,写访问,和执行访问来定义的.
如果我们看一下 <code>ls</code> 命令的输出结果,我们能得到一些线索,这是怎样实现的:</p>
<pre><code class="language-bash">&gt; foo.txt
ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt
</code></pre>
<p>列表的前十个字符是文件的属性.这十个字符的第一个字符表明文件类型.
下表是你可能经常看到 的文件类型(还有其它的,不常见类型):</p>
<hr />
<p>属性 文件类型</p>
<ul>
<li><code>-</code> 一个普通文件</li>
<li><code>d</code> 一个目录</li>
<li><code>l</code> 一个符号链接.注意对于符号链接文件,剩余的文件属性总是<code>rwxrwxrwx</code>,而且都是 虚拟值.
真正的文件属性是指符号链接所指向的文件的属性.</li>
<li><code>c</code> 一个字符设备文件.这种文件类型是指按照字节流,来处理数据的设备. 比如说终端机,或者调制解调器</li>
<li><code>b</code> 一个块设备文件.这种文件类型是指按照数据块,来处理数据的设备,例如一个硬盘,或者 CD-ROM 盘.</li>
</ul>
<p>剩下的九个字符,叫做文件模式,代表着<strong>文件所有者</strong>,<strong>文件组所有者</strong>,和<strong>其他人</strong>的<strong>读</strong>,<strong>写</strong>,<strong>执行</strong>权限.</p>
<h3 id="chmod---更改文件模式"><a class="header" href="#chmod---更改文件模式">chmod - 更改文件模式</a></h3>
<p>更改文件或目录的模式(权限),可以利用 <code>chmod</code> 命令.
注意只有文件的所有者或者超级用户才能更改文件或目录的模式.
<code>chmod</code> 命令支持两种不同的方法来改变文件模式:八进制数字表示法,或 符号表示法.</p>
<p>首先我们讨论一下八进制数字表示法.</p>
<p>虽然我们能知道二进制的意义(因为计算机只有一个手指),但是八进制和十六进制对什么 好处呢?
答案是为了人类的便利.许多时候,在计算机中,一小部分数据以二进制的形式表示.
以 RGB 颜色为例来说明.大多数的计算机显示器,每个像素由三种颜色组成:<code>8</code>位红色,<code>8</code>位绿色, <code>8</code>位蓝色.
这样,一种可爱的中蓝色就由24位数字来表示:<code>010000110110111111001101</code></p>
<p>我不认为你每天都喜欢读写这类数字.另一种数字系统对我们更有帮助.
每个十六进制 数字代表四个二进制.在八进制中,每个数字代表三个二进制数字.
那么代表中蓝色的<code>24</code>位 二进制能够压缩成<code>6</code>位十六进制数:<code>436FCD</code></p>
<p>因为十六进制中的两个数字对应二进制的<code>8</code>位数字,我们可以看到<code>43</code>代表红色,<code>6F</code>代表绿色,<code>CD</code>代表蓝色.</p>
<p>现在,十六进制表示法(经常叫做<code>hex</code>)比八进制更普遍,但是我们很快会看到,
用八进制 来表示<code>3</code>个二进制数非常有用处...</p>
<p>通过八进制表示法,我们使用八进制数字来设置所期望的权限模式.
因为每个八进制数字代表了<code>3</code>个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上.
下表展示了 我们所要表达的意思:</p>
<p>Octal Binary File Mode</p>
<ul>
<li>
<p><code>0</code> <code>000</code> <code>---</code></p>
</li>
<li>
<p><code>1</code> <code>001</code> <code>--x</code></p>
</li>
<li>
<p><code>2</code> <code>010</code> <code>-w-</code></p>
</li>
<li>
<p><code>3</code> <code>011</code> <code>-wx</code></p>
</li>
<li>
<p><code>4</code> <code>100</code> <code>r--</code></p>
</li>
<li>
<p><code>5</code> <code>101</code> <code>r-x</code></p>
</li>
<li>
<p><code>6</code> <code>110</code> <code>rw-</code></p>
</li>
<li>
<p><code>7</code> <code>111</code> <code>rwx</code></p>
</li>
<li>
<p><code>r</code>:<code>4</code></p>
</li>
<li>
<p><code>w</code>:<code>2</code></p>
</li>
<li>
<p><code>x</code>:<code>1</code></p>
</li>
</ul>
<p>通过使用<code>3</code>个八进制数字,我们能够设置<strong>文件所有者</strong>,<strong>文件的用户组</strong>,和<strong>其他人</strong>的权限:</p>
<pre><code class="language-bash">&gt; foo.txt
ls -l foo.txt
chmod 600 foo.txt
</code></pre>
<p>通过传递参数 <code>600</code>,我们能够设置文件所有者的权限为读写权限,而删除<strong>用户组</strong>和<strong>其他人</strong>的所有权限.
虽然八进制到二进制的映射看起来不方便,但通常只会用到一些常见的映射关系:</p>
<ul>
<li><code>7</code>: <code>rwx</code></li>
<li><code>6</code> :<code>rw-</code></li>
<li><code>5</code>: <code>r-x</code></li>
<li><code>4</code>:<code>r--</code></li>
<li><code>0</code>:<code>---</code></li>
</ul>
<p><code>chmod</code> 命令支持一种符号表示法,来指定文件模式.</p>
<p>符号表示法分为三部分:更改会影响谁, 要执行哪个操作,要设置哪种权限.
通过字符 <code>u</code>,<code>g</code>,<code>o</code>,和 <code>a</code>的组合来指定 要影响的对象,如下所示:</p>
<ul>
<li><code>u</code> <code>user</code>的简写,意思是文件或目录的所有者.</li>
<li><code>g</code> 用户组</li>
<li><code>o</code> <code>others</code>的简写,意思是其他所有的人</li>
<li><code>a</code> <code>all</code>的简写,是<code>u</code>, <code>g</code>和<code>o</code>三者的联合</li>
</ul>
<p>如果没有指定字符,则假定使用<code>all</code>.</p>
<p>执行的操作可能是一个<code>+</code>字符,表示加上一个权限,
一个<code>-</code>,表示删掉一个权限,
或者是一个<code>=</code>,表示只有指定的权限可用,其它所有的权限被删除.
权限由 <code>r</code>,<code>w</code>,和 <code>x</code> 来指定.</p>
<p>这里是一些符号表示法的实例:</p>
<ul>
<li><code>u+x</code> 为文件所有者添加可执行权限.</li>
<li><code>u-x</code> 删除文件所有者的可执行权限.</li>
<li><code>+x</code> 为文件所有者,用户组,和其他所有人添加可执行权限. 等价于 <code>a+x</code>.</li>
<li><code>o-rw</code> 除了文件所有者和用户组,删除其他人的读权限和写权限.</li>
<li><code>go=rw</code> 给群组的主人和任意文件拥有者的人读写权限.如果群组的主人或全局之前已
经有了执行的权限,他们将被移除.</li>
<li><code>u+x,go=rw</code> 给文件拥有者执行权限并给组和其他人读和执行的权限.多种设定可以用逗号分开.</li>
</ul>
<p>一些人喜欢使用八进制表示法,而另些人真正地喜欢符号表示法.
符号表示法的优点是, 允许你设置文件模式的单个组成部分的属性,而没有影响其他的部分.</p>
<p>要注意<code>chmod</code>的<code>--recursive</code>选项: 它可以同时作用于文件和目录,所以它并不是如我们期望的那么有用处,
因为我们很少希望文件和目录拥有同样的权限.</p>
<h3 id="umask---设置默认权限"><a class="header" href="#umask---设置默认权限">umask - 设置默认权限</a></h3>
<p>当创建一个文件时,<code>umask</code> 命令控制着文件的默认权限.
<code>umask</code> 命令使用八进制表示法来表达从文件模式属性中删除一个位掩码.大家看下面的例子:</p>
<pre><code class="language-bash">rm -f foo.txt
umask
:0002
&gt;foo.txt
ls -l foo.txt
:-rw-rw-r-- 1 me me 0 2008-03-06 14:53 foo.txt
</code></pre>
<p>首先,删除文件<code>foo.txt</code>,确保我们从新开始.下一步,运行不带参数的 <code>umask</code> 命令, 看一下当前的掩码值.
<code>umask</code>的数值是<code>0002</code>(<code>0022</code>是另一个常用值),这个数值是掩码的八进制表示形式.
下一步,我们创建文件<code>foo.txt</code>,并且保留它的权限.</p>
<p>我们可以看到文件所有者和用户组都得到读权限和写权限,而其他人只是得到读权限.
其他人没有得到写权限的原因是由掩码值决定的.重复我们的实验,这次自己设置掩码值:</p>
<pre><code class="language-bash">rm foo.txt
umask 0000
&gt; foo.txt
ls -l foo.txt
-rw-rw-rw- me me 0 2008-03-06 14:58 foo.txt
</code></pre>
<p>当掩码设置为<code>0000</code>(实质上是关掉它)之后,我们看到其他人能够读写文件.
为了弄明白这是 怎么回事,我们需要看一下掩码的八进制形式.把掩码展开成二进制形式,然后与文件属性相比较,看看有什么区别:</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Original file mode</td><td><code>--- rw- rw- rw-</code></td></tr>
<tr><td>Mask</td><td><code>000 000 000 010</code></td></tr>
<tr><td>Result</td><td><code>--- rw- rw- r--</code></td></tr>
</tbody></table>
<p>此刻先忽略掉开头的三个零(我们一会儿再讨论),注意掩码中若出现一个数字<code>1</code>,
则 删除文件模式中和这个<code>1</code>在相同位置的属性,在这是指其他人的写权限.这就是掩码要完成的任务.
掩码的二进制形式中,出现数字<code>1</code>的位置,相应地关掉一个文件模式属性.</p>
<p>看一下掩码0022的作用:</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Original file mode</td><td><code>--- rw- rw- rw-</code></td></tr>
<tr><td>Mask</td><td><code>000 000 010 010</code></td></tr>
<tr><td>Result</td><td><code>--- rw- r-- r--</code></td></tr>
</tbody></table>
<p>又一次,二进制中数字<code>1</code>出现的位置,相对应的属性被删除.
再试一下其它的掩码值(一些带数字7的) ,习惯于掩码的工作原理.当你实验完成之后,要记得清理现场:</p>
<pre><code class="language-bash">rm foo.txt; umask 0002
</code></pre>
<p>大多数情况下,你不必修改掩码值,系统提供的默认掩码值就很好了.
然而,在一些高安全级别下,你要能控制掩码值.</p>
<h3 id="一些特殊权限"><a class="header" href="#一些特殊权限">一些特殊权限</a></h3>
<p>虽然我们通常看到一个八进制的权限掩码用三位数字来表示,但是从技术层面上来讲, 用四位数字来表示它更确切些.
为什么呢?因为,除了读取,写入,和执行权限之外,还有其它的,较少用到的权限设置.</p>
<p>其中之一是 <code>setuid</code> 位(八进制<code>4000</code>).
当一个普通用户运行一个程序,这个程序由根用户(<code>root</code>) 所有,并且设置了 <code>setuid</code> 位,
那么这个程序运行时就具有超级用户的特权,这样程序就可以访问普通用户禁止访问的文件和目录.</p>
<p>第二个是 <code>setgid</code> 位(八进制<code>2000</code>),这个类似 <code>setuid</code> 位.
如果设置了一个<strong>目录</strong>的<code>setgid</code>位,则目录中新创建的文件的用户组继承自<code>父目录</code>.</p>
<p>第三个是 <code>sticky</code> 位(八进制<code>1000</code>).这个继承于Unix,在 Unix 中,它可能把一个可执行文件 标志为<code>不可交换的</code>.
在 Linux 中,会忽略文件的 <code>sticky</code> 位,但是如果一个目录设置了 <code>sticky</code> 位, 那么它能阻止用户删除或重命名文件,
除非用户是这个目录(文件)的所有者,或是超级用户.这个经常用来控制访问共享目录,比方说<code>/tmp</code>.</p>
<p>这里有一些例子,使用<code>chmod</code>命令和符号表示法,来设置这些特殊的权限.
首先, 授予一个程序 <code>setuid</code> 权限.</p>
<pre><code class="language-bash">chmod u+s program
</code></pre>
<p>下一步,授予一个目录 <code>setgid</code> 权限:</p>
<pre><code class="language-bash">chmod g+s dir
</code></pre>
<p>最后,授予一个目录 <code>sticky</code> 权限:</p>
<pre><code class="language-bash">chmod +t dir
</code></pre>
<p>当浏览 <code>ls</code> 命令的输出结果时,你可以确认这些特殊权限.</p>
<ul>
<li>具有 <code>setuid</code>属性的程序:<code>-rwsr-xr-x</code></li>
<li>具有 <code>setgid</code>属性的目录:<code>drwxrwsr-x</code></li>
<li>具有 <code>sticky</code> 属性的目录:<code>drwxrwxrwt</code></li>
</ul>
<h3 id="更改身份"><a class="header" href="#更改身份">更改身份</a></h3>
<p>在不同的时候,我们会发现很有必要具有另一个用户的身份.
经常地,我们想要得到超级 用户特权,来执行一些管理任务,但是也有可能变为另一个普通用户,比如说测试一个帐号.
有三种方式,可以拥有多重身份:</p>
<ol>
<li>注销系统并以其他用户身份重新登录系统.</li>
<li>使用 <code>su</code> 命令.</li>
<li>使用 <code>sudo</code> 命令.</li>
</ol>
<p>我们将跳过第一种方法,因为我们知道怎样使用它,并且它缺乏其它两种方法的方便性.
在我们自己的 <code>shell</code> 会话中, <code>su</code> 命令允许你,
假定为另一个用户的身份,以这个用户的 <code>ID</code> 启动一个新的 <code>shell</code> 会话,或者是以这个用户的身份来发布一个命令.</p>
<p><code>sudo</code> 命令允许管理员设置一个叫做<code>/etc/sudoers</code>的配置文件,并且定义了一些具体命令,特殊用户可以执行这些命令.
选择使用哪个命令,很大程度上是由你使用的 <code>Linux</code> 发行版来决定的.
你的发行版可能这两个命令都包含,但系统配置可能会偏袒其中之一.我们先介绍 <code>su</code> 命令.</p>
<h4 id="su---以其他用户身份和组id运行一个shell"><a class="header" href="#su---以其他用户身份和组id运行一个shell">su - 以其他用户身份和组ID运行一个shell</a></h4>
<p>su 命令用来以另一个用户的身份来启动 shell.这个命令语法看起来像这样:</p>
<pre><code class="language-bash">su [-[l]] [user]
</code></pre>
<p>如果包含<code>-l</code>选项,那么会为指定用户启动一个需要登录的 <code>shell</code> .
这意味着会加载此用户的 <code>shell</code> 环境, 并且工作目录会更改到这个用户的家目录.这通常是我们所需要的.
如果不指定用户,那么就假定是超级用户.
注意,选项<code>-l</code>可以缩写为<code>-</code>,这是经常用到的形式.启动超级用户的 shell, 我们可以这样做:</p>
<pre><code class="language-bash">su -
Password:
[root@linuxbox ~]#
</code></pre>
<p>按下回车符之后,<code>shell</code> 提示我们输入超级用户的密码.
如果密码输入正确,出现一个新的 <code>shell</code> 提示符, 这表明这个 <code>shell</code> 具有超级用户特权(提示符的末尾字符是<code>#</code>而不是<code>$</code>),
并且当前工作目录是超级用户的家目录 (通常是<code>/root</code>).
一旦进入一个新的 <code>shell</code>,我们能执行超级用户所使用的命令.当工作完成后, 输入<code>exit</code>,则返回到原来的 <code>shell</code>:</p>
<pre><code class="language-bash">[root@linuxbox ~]# exit
[me@linuxbox ~]$
</code></pre>
<p>以这样的方式使用 <code>su</code> 命令,也可以只执行单个命令,而不是启动一个新的可交互的 shell:</p>
<pre><code class="language-bash">su -c 'command'
</code></pre>
<p>使用这种模式,命令传递到一个新 <code>shell</code> 中执行.
把命令用单引号引起来很重要,因为我们不想命令在我们的 <code>shell</code> 中展开,但需要在新 <code>shell</code> 中展开.</p>
<pre><code class="language-bash">su -c 'ls -l /root/*'
</code></pre>
<h4 id="sudo---以另一个用户身份执行命令"><a class="header" href="#sudo---以另一个用户身份执行命令">sudo - 以另一个用户身份执行命令</a></h4>
<p><code>sudo</code> 命令在很多方面都相似于 <code>su</code> 命令,但是 <code>sudo</code> 还有一些非常重要的功能.</p>
<p>管理员能够配置 <code>sudo</code> 命令,从而允许一个普通用户以不同的身份(通常是超级用户),通过一种非常可控的方式来执行命令.
尤其是,只有一个用户可以执行一个或多个特殊命令时,(更体现了 <code>sudo</code> 命令的方便性).</p>
<p>另一个重要差异是 <code>sudo</code> 命令不要求超级用户的密码.使用 <code>sudo</code> 命令时,用户使用他/她自己的密码 来认证.
比如说,例如,<code>sudo</code> 命令经过配置,允许我们运行一个虚构的备份程序,叫做<code>backup_script</code>, 这个程序要求超级用户权限.
通过 <code>sudo</code> 命令,这个程序会像这样运行:</p>
<pre><code class="language-bash">sudo backup_script
Password:
System Backup Starting...
</code></pre>
<p>按下回车键之后,<code>shell</code> 提示我们输入我们的密码(不是超级用户的).一旦认证完成,则执行 具体的命令.</p>
<p><code>su</code> 和 <code>sudo</code> 之间的一个重要区别是 <code>sudo</code> 不会重新启动一个 <code>shell</code>,也不会加载另一个 用户的 <code>shell</code> 运行环境.
这意味者命令不必用单引号引起来.注意通过指定各种各样的选项,这 种行为可以被推翻.
详细信息,阅读 <code>sudo</code> 手册页.</p>
<p>想知道 <code>sudo</code> 命令可以授予哪些权限,使用<code>-l</code>选项,列出所有权限:</p>
<pre><code class="language-bash">sudo -l
User me may run the following commands on this host:
(ALL) ALL
</code></pre>
<blockquote>
<p>Ubuntu 与 sudo</p>
</blockquote>
<p><code>Unix</code> 采取的方法是只有在需要的时候,才授予普通用户超级用户权限.这样,普遍会 用到 <code>su</code> 和 <code>sudo</code> 命令.</p>
<p>几年前,大多数的 Linux 发行版都依赖于 <code>su</code> 命令,来达到目的.<code>su</code> 命令不需要 <code>sudo</code> 命令 所要求的配置, <code>su</code> 命令拥有一个 <code>root</code> 帐号,是 Unix 中的传统.</p>
<p>但这会引起问题.所有用户会企图以 <code>root</code> 用户帐号来操纵系统.
事实上,一些用户专门以 <code>root</code> 用户帐号来操作系统, 因为这样做,的确消除了所有那些讨厌的权限
被拒绝的消息.相比于 <code>Windows</code> 系统安全性而言, 这样做,你就削弱了 <code>Linux</code> 系统安全性能.</p>
<p>当引进 <code>Ubuntu</code> 的时候,它的创作者们采取了不同的策略.
默认情况下,<code>Ubuntu</code> 不允许用户登录到 <code>root</code>帐号(因为不能为 <code>root</code> 帐号设置密码),而是使用 <code>sudo</code> 命令授予普通用户超级用户权限.</p>
<p>通过 <code>sudo</code> 命令,最初的用户可以拥有超级用户权限,也可以授予随后的用户帐号相似的权力.</p>
<h3 id="chown---更改文件所有者和用户组"><a class="header" href="#chown---更改文件所有者和用户组">chown - 更改文件所有者和用户组</a></h3>
<p><code>chown</code> 命令被用来更改文件或目录的所有者和用户组.使用这个命令需要超级用户权限.
<code>chown</code> 命令 的语法看起来像这样:</p>
<pre><code class="language-bash">chown [owner][:[group]] file...
</code></pre>
<p><code>chown </code>命令可以更改文件所有者和/或文件用户组,依据于这个命令的第一个参数.这里有 一些例子:</p>
<hr />
<p>参数 结果</p>
<ul>
<li><code>bob</code> 把文件所有者从当前属主更改为用户<code>bob</code></li>
<li><code>bob:users</code> 把文件所有者改为用户 <code>bob</code>,文件用户组改为用户组 <code>users</code>.</li>
<li><code>:admins</code> 把文件用户组改为组 <code>admins</code>,文件所有者不变.</li>
<li><code>bob:</code> 文件所有者改为用户 <code>bob</code>,文件用户组改为<code>bob</code> 登录系统时所属的用户组.</li>
</ul>
<p>比方说,我们有两个用户: <code>janet</code>(拥有超级用户访问权限),<code>tony</code>(没有).</p>
<p>用户<code>janet</code>想要从 她的家目录复制一个文件到用户 <code>tony</code> 的家目录.
因为用户 <code>janet</code> 想要 <code>tony</code>能够编辑这个文件, <code>janet</code> 把这个文件的所有者更改为<code>tony</code>:</p>
<pre><code class="language-bash">[janet@linuxbox ~]$ sudo cp myfile.txt ~tony
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt
[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
</code></pre>
<p>这里,我们看到用户 <code>janet</code> 把文件从她的目录复制到 <code>tony</code> 的家目录.
下一步,<code>janet</code> 把文件所有者 从 <code>root</code>(因为使用了<code>sudo</code> 命令)改到 <code>tony</code>.
通过在第一个参数中使用末尾的<code>:</code>字符,<code>janet</code> 同时把文件用户组改为<code>tony</code> 登录系统时所属的用户组(也叫<code>tony</code>).</p>
<p>注意,第一次使用 <code>sudo</code> 命令之后,为什么(<code>shell</code>)没有提示 <code>janet</code> 输入她的密码?
这是因为在 大多数的配置中,<code>sudo</code> 命令会相信你几分钟,直到计时结束.</p>
<h3 id="chgrp---更改用户组所有权"><a class="header" href="#chgrp---更改用户组所有权">chgrp - 更改用户组所有权</a></h3>
<p>在旧版 Unix 系统中,<code>chown</code> 命令只能更改文件所有权,而不是用户组所有权.
为了达到目的, 使用一个独立的命令,<code>chgrp</code> 来完成.除了限制多一点之外,<code>chgrp</code> 命令与 <code>chown</code> 命令使用起来很相似.</p>
<h3 id="练习使用权限"><a class="header" href="#练习使用权限">练习使用权限</a></h3>
<p>我们将展示一个常见问题的解决方案,这个问题是如何设置一个共享目录.
假想我们有两个用户, 他们分别是 <code>bill</code> 和 <code>karen</code>.他们都有音乐 CD 收藏品,也愿意设置一个共享目录.
在这个共享目录中,他们分别以 <code>Ogg Vorbis</code> 或 <code>MP3</code> 的格式来存储他们的音乐文件.
通过 <code>sudo</code> 命令, 用户 <code>bill</code> 具有超级用户访问权限.</p>
<p>我们需要做的第一件事,是创建一个以 <code>bill</code> 和 <code>karen</code> 为成员的用户组.
下一步,<code>bill</code> 创建了存储音乐文件的目录:<code>sudo mkdir /usr/local/share/Music</code></p>
<p>因为 <code>bill</code> 正在他的家目录之外操作文件,所以需要超级用户权限.这个目录创建之后,它具有以下所有权和权限:</p>
<pre><code class="language-bash">ls -ld /usr/local/share/Music
drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music
</code></pre>
<p>正如我们所见到的,这个目录由 <code>root</code> 用户拥有,并且具有权限<code>755</code>.
为了使这个目录共享,允许(用户 <code>karen</code>)写入,<code>bill</code> 需要更改目录用户组所有权和权限:</p>
<pre><code class="language-bash">[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music
[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music
</code></pre>
<p>那么这是什么意思呢? 它的意思是,现在我们拥有一个目录,<code>/usr/local/share/Music</code>,
这个目录由 <code>root</code> 用户拥有,并且允许用户组 <code>music</code> 读取和写入.</p>
<p>用户组 <code>music</code> 有两个成员 <code>bill</code> 和 <code>karen</code>,这样 <code>bill</code> 和 <code>karen</code> 能够在目录 <code>/usr/local/share/Music</code> 中创建文件.其他用户能够列出目录中的内容,但是不能在其中创建文件.</p>
<p>但是我们仍然会遇到问题.
通过我们目前所拥有的权限,在 <code>Music</code> 目录中创建的文件,只具有用户 <code>bill</code> 和 <code>karen</code> 的普通权限:</p>
<pre><code class="language-bash">[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill bill 0 2008-03-24 20:03 test_file
</code></pre>
<p>实际上,存在两个问题.
第一个,系统中默认的掩码值是<code>0022</code>,这会禁止用户组成员编辑属于同组成员的文件.
如果共享目录中只包含文件,这就不是个问题,但是因为这个目录将会存储音乐, 通常音乐会按照艺术家和唱片的层次结构来组织分类.
所以用户组成员需要在同组其他成员创建的目录中创建文件和目录.
我们将把用户 <code>bill</code> 和 <code>karen</code> 使用的掩码值改为<code>0002</code>.</p>
<p>第二个问题是,<code>bill</code>创建的文件(或目录)的用户组会被设置为<code>bill</code>,而不是<code>music</code>用户组 .
通过设置此目录的 <code>setgid</code> 位来解决这个问题:</p>
<pre><code class="language-bash">[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music
</code></pre>
<p>现在测试一下,看看是否新的权限解决了这个问题.
<code>bill</code> 把他的掩码值设为<code>0002</code>,删除 先前的测试文件,并创建了一个新的测试文件和目录:</p>
<pre><code class="language-bash">[bill@linuxbox ~]$ umask 0002
[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file
[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file
[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill music 4096 2008-03-24 20:24 test_dir
-rw-rw-r-- 1 bill music 0 2008-03-24 20:22 test_file
</code></pre>
<p>现在,创建的文件和目录都具有正确的权限,允许用户组 <code>music</code> 的所有成员在目录 <code>Music</code> 中创建文件和目录.</p>
<p>剩下一个问题是关于 <code>umask</code> 命令的.
<code>umask</code> 命令设置的掩码值只能在当前 <code>shell</code> 会话中生效,若当前 <code>shell</code> 会
话结束后,则必须重新设置.在这本书的第三部分,我们将看一下,怎样使掩码值永久生效.</p>
<h3 id="更改用户密码"><a class="header" href="#更改用户密码">更改用户密码</a></h3>
<p>这一章最后一个话题,我们将讨论自己帐号的密码(和其他人的密码,如果你具有超级用户权限).
使用 <code>passwd</code> 命令,来设置或更改用户密码.命令语法如下所示:</p>
<pre><code class="language-bash">passwd [user]
</code></pre>
<p>只要输入 <code>passwd</code> 命令,就能更改你的密码.<code>shell</code> 会提示你输入你的旧密码和你的新密码:</p>
<pre><code class="language-bash">passwd
(current) UNIX password:
New UNIX password:
</code></pre>
<p>passwd 命令将会试着强迫你使用<code>强</code>密码.
这意味着,它会拒绝接受太短的密码,与先前相似的密码, 字典中的单词作为密码,或者是太容易猜到的密码:</p>
<p>如果你具有超级用户权限,你可以指定一个用户名作为 <code>passwd</code> 命令的参数,这样可以设置另一个用户的密码.</p>
<p>还有其它的 <code>passwd</code> 命令选项对超级用户有效,允许帐号锁定,密码失效,等等.
详细内容,参考 passwd 命令的手册页.</p>
<h2 id="linux-用户和用户组管理"><a class="header" href="#linux-用户和用户组管理">Linux 用户和用户组管理</a></h2>
<p><a href="https://www.runoob.com/linux/linux-user-manage.html">Linux 用户和用户组管理</a></p>
<p><code>Linux</code>系统是一个多用户多任务的分时操作系统,任何一个要使用系统资源的用户, 都必须首先向系统管理员申请一个账号,然后以这个账号的身份进入系统.</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪,并控制他们对系统资源的访问;
另一方面也可以帮助用户组织文件,并为用户提供安全性保护.
每个用户账号都拥有一个唯一的用户名和各自的口令.用户在登录时键入正确的用户名和口令后,就能够进入系统和自己的主目录.</p>
<p>实现用户账号的管理,要完成的工作主要有如下几个方面:</p>
<ul>
<li>用户账号的添加, 删除与修改.</li>
<li>用户口令的管理.</li>
<li>用户组的管理.</li>
</ul>
<h3 id="linux系统用户账号的管理"><a class="header" href="#linux系统用户账号的管理">Linux系统用户账号的管理</a></h3>
<p>用户账号的管理工作主要涉及到用户账号的添加, 修改和删除.</p>
<p>添加用户账号就是在系统中创建一个新账号,然后为新账号分配用户号, 用户组, 主目录和登录Shell等资源.
刚添加的账号是被锁定的,无法使用.</p>
<hr />
<p>添加新的用户账号使用useradd命令,其语法如下:</p>
<pre><code class="language-bash">useradd 选项 用户名
</code></pre>
<p>选项:</p>
<ul>
<li><code>-c comment</code>  指定一段注释性描述.</li>
<li><code>-d 目录</code>  指定用户主目录,如果此目录不存在,则同时使用<code>-m</code>选项,可以创建主目录.</li>
<li><code>-g 用户组</code>  指定用户所属的用户组.</li>
<li><code>-G用户组,用户组</code> 指定用户所属的附加组.</li>
<li><code>-s Shell文件</code>  指定用户的登录Shell.</li>
<li><code>-u 用户号</code>  指定用户的用户号,如果同时有<code>-o</code>选项,则可以重复使用其他用户的标识号.</li>
</ul>
<p>用户名:   指定新账号的登录名.</p>
<hr />
<p>实例1</p>
<pre><code class="language-bash">useradd –d  /home/sam -m sam
</code></pre>
<p>此命令创建了一个用户<code>sam</code>,其中<code>-d</code>和<code>-m</code>选项用来为登录名<code>sam</code>产生一个主目录 <code>/home/sam</code>
(<code>/home</code>为默认的用户主目录所在的父目录)</p>
<hr />
<p>实例2</p>
<pre><code class="language-bash">useradd -s /bin/sh -g group –G adm,root gem
</code></pre>
<p>此命令新建了一个用户<code>gem</code>,该用户的登录<code>Shell</code>是<code> /bin/sh</code>,
它属于<code>group</code>用户组,同时又属于<code>adm</code>和<code>root</code>用户组,其中<code>group</code>用户组是其主组.</p>
<p>这里可能新建组:<code>groupadd group</code>及<code>groupadd adm</code></p>
<p>增加用户账号就是在<code>/etc/passwd</code>文件中为新用户增加一条记录,同时更新其他系统文件如<code>/etc/shadow</code>, <code>/etc/group</code>等.</p>
<p>Linux提供了集成的系统管理工具<code>userconf</code>,它可以用来对用户账号进行统一管理.</p>
<h3 id="删除帐号"><a class="header" href="#删除帐号">删除帐号</a></h3>
<p>如果一个用户的账号不再使用,可以从系统中删除.
删除用户账号就是要将<code>/etc/passwd</code>等系统文件中的该用户记录删除,必要时还删除用户的主目录.</p>
<p>删除一个已有的用户账号使用<code>userdel</code>命令,其格式如下:</p>
<pre><code>userdel 选项 用户名
</code></pre>
<p>常用的选项是 <code>-r</code>,它的作用是把用户的主目录一起删除.例如:</p>
<pre><code class="language-bash">userdel -r sam
</code></pre>
<p>此命令删除用户<code>sam</code>在系统文件中(主要是<code>/etcpasswd/</code>, <code>/etc/shadow</code>, <code>/etc/group</code>等)的记录,同时删除用户的主目录.</p>
<h2 id="修改帐号"><a class="header" href="#修改帐号">修改帐号</a></h2>
<p>修改用户账号就是根据实际情况更改用户的有关属性,如用户号, 主目录, 用户组, 登录Shell等.</p>
<p>修改已有用户的信息使用<code>usermod</code>命令,其格式如下:</p>
<pre><code class="language-bash">usermod 选项 用户名
</code></pre>
<p>常用的选项包括<code>-c,</code> <code>-d</code>, <code>-m</code>,<code> -g</code>,<code> -G</code>,<code> -s</code>,<code>-u</code>以及<code>-o</code>等,这些选项的意义与<code>useradd</code>命令中的选项一样,可以为用户指定新的资源值.</p>
<p>另外,有些系统可以使用选项:<code>-l 新用户名</code>
这个选项指定一个新的账号,即将原来的用户名改为新的用户名.</p>
<p>例如:</p>
<pre><code class="language-bash">usermod -s /bin/ksh -d /home/z –g developer sam
</code></pre>
<p>此命令将用户<code>sam</code>的登录<code>Shell</code>修改为<code>ksh</code>,主目录改为<code>/home/z</code>,用户组改为<code>developer</code>.</p>
<h3 id="用户口令的管理"><a class="header" href="#用户口令的管理">用户口令的管理</a></h3>
<p>用户管理的一项重要内容是用户口令的管理.
用户账号刚创建时没有口令,但是被系统锁定,无法使用,必须为其指定口令后才可以使用,即使是指定空口令.</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>.
超级用户可以为自己和其他用户指定口令,普通用户只能用它修改自己的口令.命令的格式为:</p>
<pre><code class="language-bash">passwd 选项 用户名
</code></pre>
<p>可使用的选项:</p>
<ul>
<li><code>-l</code> 锁定口令,即禁用账号.</li>
<li><code>-u</code> 口令解锁.</li>
<li><code>-d</code> 使账号无口令.</li>
<li><code>-f</code> 强迫用户下次登录时修改口令.</li>
</ul>
<p>如果默认用户名,则修改当前用户的口令.</p>
<p>例如,假设当前用户是<code>sam</code>,则下面的命令修改该用户自己的口令:</p>
<pre><code class="language-bash">$ passwd
Old password:******
New password:*******
Re-enter new password:*******
</code></pre>
<p>如果是超级用户,可以用下列形式指定任何用户的口令:</p>
<pre><code class="language-bash">passwd sam
New password:*******
Re-enter new password:*******
</code></pre>
<p>普通用户修改自己的口令时,<code>passwd</code>命令会先询问原口令,验证后再要求用户输入两遍新口令,
如果两次输入的口令一致,则将这个口令指定给用户;而超级用户为用户指定口令时,就不需要知道原口令.</p>
<p>为了系统安全起见,用户应该选择比较复杂的口令,例如最好使用<code>8</code>位长的口令,口令中包含有大写, 小写字母和数字,并且应该与姓名, 生日等不相同.</p>
<p>为用户指定空口令时,执行下列形式的命令:</p>
<pre><code class="language-bash">passwd -d sam
</code></pre>
<p>此命令将用户 <code>sam</code> 的口令删除,这样用户 <code>sam</code> 下一次登录时,系统就不再允许该用户登录了.</p>
<p><code>passwd</code> 命令还可以用 <code>-l(lock)</code> 选项锁定某一用户,使其不能登录,例如:</p>
<pre><code class="language-bash">passwd -l sam
</code></pre>
<h3 id="linux系统用户组的管理"><a class="header" href="#linux系统用户组的管理">Linux系统用户组的管理</a></h3>
<p>每个用户都有一个用户组,系统可以对一个用户组中的所有用户进行集中管理.
不同Linux 系统对用户组的规定有所不同,如 ubuntu 下的用户属于与它同名的用户组,这个用户组在创建用户时同时创建.</p>
<p>用户组的管理涉及用户组的添加, 删除和修改.组的增加, 删除和修改实际上就是对<code>/etc/group</code>文件的更新.</p>
<hr />
<p>增加一个新的用户组使用<code>groupadd</code>命令.其格式如下:</p>
<pre><code class="language-bash">groupadd 选项 用户组
</code></pre>
<p>可以使用的选项有:</p>
<ul>
<li><code>-g</code> <code>GID</code> 指定新用户组的组标识号(GID).</li>
<li><code>-o</code> 一般与<code>-g</code>选项同时使用,表示新用户组的GID可以与系统已有用户组的GID相同.</li>
</ul>
<hr />
<p>实例1:</p>
<pre><code class="language-bash">groupadd group1
</code></pre>
<p>此命令向系统中增加了一个新组<code>group1</code>,新组的组标识号是在当前已有的最大组标识号的基础上加<code>1</code>.</p>
<p>实例2:</p>
<pre><code class="language-bash">groupadd -g 101 group2
</code></pre>
<p>此命令向系统中增加了一个新组<code>group2</code>,同时指定新组的组标识号是<code>101</code>.</p>
<hr />
<p>如果要删除一个已有的用户组,使用<code>groupdel</code>命令,其格式如下:</p>
<pre><code class="language-bash">groupdel 用户组
</code></pre>
<p>例如:</p>
<pre><code class="language-bash">groupdel group1
</code></pre>
<p>此命令从系统中删除组<code>group1</code>.</p>
<hr />
<p>修改用户组的属性使用<code>groupmod</code>命令.其语法如下:</p>
<pre><code class="language-bash">groupmod 选项 用户组
</code></pre>
<p>常用的选项有:</p>
<ul>
<li><code>-g GID</code> 为用户组指定新的组标识号.</li>
<li><code>-o</code>  与<code>-g</code>选项同时使用,用户组的新<code>GID</code>可以与系统已有用户组的<code>GID</code>相同.</li>
<li><code>-n 新用户组</code>  将用户组的名字改为新名字</li>
</ul>
<p>实例1:</p>
<pre><code class="language-bash">groupmod -g 102 group2
</code></pre>
<p>此命令将组<code>group2</code>的组标识号修改为102.</p>
<p>实例2:</p>
<pre><code class="language-bash">groupmod –g 10000 -n group3 group2
</code></pre>
<p>此命令将组<code>group2</code>的标识号改为<code>10000</code>,组名修改为<code>group3</code>.</p>
<hr />
<p>如果一个用户同时属于多个用户组,那么用户可以在用户组之间切换,以便具有其他用户组的权限.
用户可以在登录后,使用命令<code>newgrp</code>切换到其他用户组,这个命令的参数就是目的用户组.例如:</p>
<pre><code class="language-bash">$ newgrp root
</code></pre>
<p>这条命令将当前用户切换到<code>root</code>用户组,前提条件是<code>root</code>用户组确实是该用户的主组或附加组.
类似于用户账号的管理,用户组的管理也可以通过集成的系统管理工具来完成.</p>
<h3 id="与用户账号有关的系统文件"><a class="header" href="#与用户账号有关的系统文件">与用户账号有关的系统文件</a></h3>
<p>完成用户管理的工作有许多种方法,但是每一种方法实际上都是对有关的系统文件进行修改.</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中,这些文件包括<code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>等.</p>
<p>下面分别介绍这些文件的内容.</p>
<h4 id="etcpasswd文件"><a class="header" href="#etcpasswd文件">/etc/passwd文件</a></h4>
<p><code>/etc/passwd</code>文件是用户管理工作涉及的最重要的一个文件</p>
<p>Linux系统中的每个用户都在<code>/etc/passwd</code>文件中有一个对应的记录行,它记录了这个用户的一些基本属性.</p>
<p>这个文件对所有用户都是可读的.它的内容类似下面的例子:</p>
<pre><code class="language-bash">＃ cat /etc/passwd
root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh
</code></pre>
<p>从上面的例子我们可以看到,<code>/etc/passwd</code>中一行记录对应着一个用户,
每行记录又被冒号(<code>:</code>)分隔为7个字段,其格式和具体含义如下:</p>
<p><code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></p>
<ol>
<li><code>用户名</code>是代表用户账号的字符串.</li>
</ol>
<p>通常长度不超过<code>8</code>个字符,并且由大小写字母或数字组成.登录名中不能有冒号(<code>:</code>),因为冒号在这里是分隔符.
为了兼容起见,登录名中最好不要包含点字符(<code>.</code>),并且不使用连字符(<code>-</code>)和加号(<code>+</code>)打头.</p>
<ol>
<li><code>口令</code>一些系统中,存放着加密后的用户口令字.</li>
</ol>
<p>虽然这个字段存放的只是用户口令的加密串,不是明文,但是由于<code>/etc/passwd</code>文件对所有用户都可读,所以这仍是一个安全隐患.
因此,现在许多Linux 系统(如<code>SVR4</code>)都使用了 <code>shadow</code> 技术,把真正的加密后的用户口令字存放到<code>/etc/shadow</code>文件中,而在<code>/etc/passwd</code>文件的口令字段中只存放一个特殊的字符,例如<code>x</code>或者<code>*</code>.</p>
<ol start="3">
<li><code>用户标识号</code>是一个整数,系统内部用它来标识用户.
一般情况下它与用户名是一一对应的.
如果几个用户名对应的用户标识号是一样的,系统内部将把它们视为同一个用户,但是它们可以有不同的口令, 不同的主目录以及不同的登录Shell等.</li>
</ol>
<p>通常用户标识号的取值范围是<code>0</code>~<code>65 535</code>.<code>0</code>是超级用户<code>root</code>的标识号,<code>1</code>~<code>99</code>由系统保留,作为管理账号,普通用户的标识号从<code>100</code>开始.在Linux系统中,这个界限是<code>500</code>.</p>
<ol start="4">
<li><code>组标识号</code>字段记录的是用户所属的用户组.</li>
</ol>
<p>它对应着<code>/etc/group</code>文件中的一条记录.</p>
<ol start="5">
<li><code>注释性描述</code>字段记录着用户的一些个人情况.</li>
</ol>
<p>例如用户的真实姓名, 电话, 地址等,这个字段并没有什么实际的用途.在不同的Linux 系统中,这个字段的格式并没有统一.
在许多Linux系统中,这个字段存放的是一段任意的注释性描述文字,用做<code>finger</code>命令的输出.</p>
<ol start="6">
<li><code>主目录</code>,也就是用户的起始工作目录.</li>
</ol>
<p>它是用户在登录到系统之后所处的目录.
在大多数系统中,各用户的主目录都被组织在同一个特定的目录下,而用户主目录的名称就是该用户的登录名.
各用户对自己的主目录有读, 写, 执行(搜索)权限,其他用户对此目录的访问权限则根据具体情况设置.</p>
<ol start="7">
<li>用户登录后,要启动一个进程,负责将用户的操作传给内核,这个进程是用户登录到系统后运行的命令解释器或某个特定的程序,即<code>Shell</code>.</li>
</ol>
<p><code>Shell</code>是用户与Linux系统之间的接口.Linux的<code>Shell</code>有许多种,每种都有不同的特点.
常用的有<code>sh</code>(Bourne Shell), <code>csh</code>(C Shell), <code>ksh</code>(Korn Shell), <code>tcsh</code>(TENEX/TOPS-20 type C Shell), <code>bash</code>(Bourne Again Shell)等.</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个<code>Shell</code>.
如果不指定<code>Shell</code>,那么系统使用<code>sh</code>为默认的登录<code>Shell</code>,即这个字段的值为<code>/bin/sh</code>.</p>
<p>用户的登录<code>Shell</code>也可以指定为某个特定的程序(此程序不是一个命令解释器).
利用这一特点,我们可以限制用户只能运行指定的应用程序,在该应用程序运行结束后,用户就自动退出了系统.
有些<code>Linux</code>系统要求只有那些在系统中登记了的程序才能出现在这个字段中.</p>
<ol start="8">
<li>系统中有一类用户称为伪用户(pseudo users).</li>
</ol>
<p>这些用户在<code>/etc/passwd</code>文件中也占有一条记录,但是不能登录,因为它们的登录<code>Shell</code>为空.
它们的存在主要是方便系统管理,满足相应的系统进程对文件属主的要求.</p>
<p>常见的伪用户如下所示:</p>
<ul>
<li><code>bin</code>:  拥有可执行的用户命令文件</li>
<li><code>sys</code>:  拥有系统文件</li>
<li><code>adm</code>:  拥有帐户文件</li>
<li><code>uucp</code>:  <code>UUCP</code>使用</li>
<li><code>lp</code>:  <code>lp</code>或<code>lpd</code>子系统使用</li>
<li><code>nobody</code>:  <code>NFS</code>使用</li>
</ul>
<h4 id="拥有帐户文件"><a class="header" href="#拥有帐户文件">拥有帐户文件</a></h4>
<ul>
<li>除了上面列出的伪用户外,还有许多标准的伪用户,例如:<code>audit</code>, <code>cron</code>, <code>mail</code>, <code>usenet</code>等,它们也都各自为相关的进程和文件所需要.</li>
</ul>
<p>由于<code>/etc/passwd</code>文件是所有用户都可读的,如果用户的密码太简单或规律比较明显的话,一台普通的计算机就能够很容易地将它破解.
因此对安全性要求较高的Linux系统都把加密后的口令字分离出来,单独存放在一个文件中,这个文件是<code>/etc/shadow</code>文件. 有超级用户才拥有该文件读权限,这就保证了用户密码的安全性.</p>
<ul>
<li><code>/etc/shadow</code>中的记录行与<code>/etc/passwd</code>中的一一对应,它由<code>pwconv</code>命令根据<code>/etc/passwd</code>中的数据自动产生,
它的文件格式与<code>/etc/passwd</code>类似,由若干个字段组成,字段之间用<code>:</code>隔开.这些字段是:
<code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></li>
</ul>
<ol>
<li><code>登录名</code>是与<code>/etc/passwd</code>文件中的登录名相一致的用户账号</li>
<li><code>口令</code>字段存放的是加密后的用户口令字,长度为<code>13</code>个字符.如果为空,则对应用户没有口令,登录时不需要口令;
如果含有不属于集合<code> { ./0-9A-Za-z }</code>中的字符,则对应的用户不能登录.</li>
<li><code>最后一次修改时间</code>表示的是从某个时刻起,到用户最后一次修改口令时的天数.时间起点对不同的系统可能不一样.
例如在<code>SCO Linux </code>中,这个时间起点是<code>1970年1月1日</code>.</li>
<li><code>最小时间间隔</code>指的是两次修改口令之间所需的最小天数.</li>
<li><code>最大时间间隔</code>指的是口令保持有效的最大天数.</li>
<li><code>警告时间</code>字段表示的是从系统开始警告用户到用户密码正式失效之间的天数.</li>
<li><code>不活动时间</code>表示的是用户没有登录活动但账号仍能保持有效的最大天数.</li>
<li><code>失效时间</code>字段给出的是一个绝对的天数,如果使用了这个字段,那么就给出相应账号的生存期.期满后,该账号就不再是一个合法的账号,也就不能再用来登录了.</li>
</ol>
<p>下面是<code>/etc/shadow</code>的一个例子:</p>
<pre><code class="language-bash">＃ cat /etc/shadow

root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::
adm:*::0:0::::
uucp:*::0:0::::
nuucp:*::0:0::::
auth:*::0:0::::
cron:*::0:0::::
listen:*::0:0::::
lp:*::0:0::::
sam:EkdiSECLWPdSa:9740:0:0::::
</code></pre>
<ul>
<li>用户组的所有信息都存放在<code>/etc/group</code>文件中.</li>
</ul>
<p>将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段.
每个用户都属于某个用户组;一个组中可以有多个用户,一个用户也可以属于不同的组.
当一个用户同时是多个组中的成员时,在<code>/etc/passwd</code>文件中记录的是用户所属的主组,也就是登录时所属的默认组,而其他组称为附加组.</p>
<p>用户要访问属于附加组的文件时,必须首先使用<code>newgrp</code>命令使自己成为所要访问的组中的成员.
用户组的所有信息都存放在<code>/etc/group</code>文件中.此文件的格式也类似于<code>/etc/passwd</code>文件,由冒号(<code>:</code>)隔开若干个字段,这些字段有:</p>
<p><code>组名:口令:组标识号:组内用户列表</code></p>
<ul>
<li><code>组名</code>是用户组的名称,由字母或数字构成.与<code>/etc/passwd</code>中的登录名一样,组名不应重复.</li>
<li><code>口令</code>字段存放的是用户组加密后的口令字.一般Linux 系统的用户组都没有口令,即这个字段一般为<code>空</code>,或者是<code>*</code>.</li>
<li><code>组标识号</code>与用户标识号类似,也是一个整数,被系统内部用来标识组.</li>
<li><code>组内用户列表</code>是属于这个组的所有用户的列表,不同用户之间用逗号(<code>,</code>)分隔.这个用户组可能是用户的主组,也可能是附加组.</li>
</ul>
<p><code>/etc/group</code>文件的一个例子如下:</p>
<pre><code class="language-bash">root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
</code></pre>
<h3 id="添加批量用户"><a class="header" href="#添加批量用户">添加批量用户</a></h3>
<p>添加和删除用户对每位Linux系统管理员都是轻而易举的事,比较棘手的是如果要添加几十个, 上百个甚至上千个用户时,我们不太可能还使用useradd一个一个地添加,必然要找一种简便的创建大量用户的方法.
Linux系统提供了创建大量用户的工具,可以让您立即创建大量用户,方法如下:</p>
<ol>
<li>先编辑一个文本用户文件.</li>
</ol>
<p>每一列按照<code>/etc/passwd</code>密码文件的格式书写,要注意每个用户的用户名, <code>UID</code>, 宿主目录都不可以相同,其中密码栏可以留做空白或输入<code>x</code>号.一个范例文件<code>user.txt</code>内容如下:</p>
<pre><code class="language-bash">user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
...
</code></pre>
<ol start="2">
<li>以root身份执行命令 <code>/usr/sbin/newusers</code>,从刚创建的用户文件<code>user.txt</code>中导入数据,创建用户:</li>
</ol>
<pre><code class="language-bash">newusers &lt; user.txt
</code></pre>
<p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查<code>/etc/passwd</code> 文件是否已经出现这些用户的数据,并且用户的宿主目录是否已经创建.</p>
<ol start="3">
<li>执行命令<code>/usr/sbin/pwunconv</code>.</li>
</ol>
<p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码,然后回写到<code> /etc/passwd</code> 中,并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉.
这是为了方便下一步的密码转换工作,即先取消 <code>shadow password</code> 功能.</p>
<pre><code class="language-bash">pwunconv
</code></pre>
<ol start="4">
<li>编辑每个用户的密码对照文件.</li>
</ol>
<p>格式为:<code>用户名:密码</code></p>
<p>实例文件 <code>passwd.txt</code> 内容如下:</p>
<pre><code class="language-bash">user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456
</code></pre>
<ol start="5">
<li>以 <code>root</code> 身份执行命令 <code>/usr/sbin/chpasswd</code>.</li>
</ol>
<p>创建用户密码,<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏.</p>
<pre><code class="language-bash">chpasswd &lt; passwd.txt
</code></pre>
<ol start="6">
<li>确定密码经编码写入<code>/etc/passwd</code>的密码栏后.</li>
</ol>
<p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>,并将结果写入 <code>/etc/shadow</code>.</p>
<pre><code class="language-bash">pwconv
</code></pre>
<p>这样就完成了大量用户的创建了,之后您可以到<code>/home</code>下检查这些用户宿主目录的权限设置是否都正确,并登录验证用户密码是否正确.</p>
<h2 id="第十一章进程"><a class="header" href="#第十一章进程">第十一章:进程</a></h2>
<p>通常,现在的操作系统都支持多任务,意味着操作系统(给用户)造成了一种假象,(让用户觉得) 它同时能够做多件事情,事实上,它是快速地轮换执行这些任务的.</p>
<p>Linux 内核通过使用<strong>进程</strong>,来管理多任务.通过进程,Linux 安排不同的程序等待使用 CPU.
有时候,计算机变得呆滞,运行缓慢,或者一个应用程序停止响应.
在这一章中,我们将看一些可用的命令行工具,这些工具帮助我们查看程序的执行状态,以及怎样终止行为不当的进程.</p>
<p>这一章将介绍以下命令:</p>
<ul>
<li><code>ps</code> – 报告当前进程快照</li>
<li><code>top</code> – 显示任务</li>
<li><code>jobs</code> – 列出活跃的任务</li>
<li><code>bg</code> – 把一个任务放到后台执行</li>
<li><code>fg</code> – 把一个任务放到前台执行</li>
<li><code>kill</code> – 给一个进程发送信号</li>
<li><code>killall</code> – 杀死指定名字的进程</li>
<li><code>shutdown</code> – 关机或重启系统</li>
</ul>
<h3 id="进程是怎样工作的"><a class="header" href="#进程是怎样工作的">进程是怎样工作的</a></h3>
<p>当系统启动的时候,内核先把一些它自己的程序初始化为进程,然后运行一个叫做 <code>init</code> 的程序.
<code>init</code>再依次运行一系列被称为 <code>init 脚本</code>的 <code>shell</code> 脚本(位于<code>/etc</code>),它们可以启动所有的系统服务.</p>
<p>其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户接口.
这样,即使我们没有登录系统,至少系统也在忙于执行一些例行事务.</p>
<p>一个程序可以发动另一个程序,这个事实在进程方案中,表述为一个父进程创建了一个子进程.</p>
<p>内核维护每个进程的信息,以此来保持事情有序.
例如,系统分配给每个进程一个数字,这个数字叫做 进程 <code>ID</code>或 <code>PID</code>.<code>PID</code> 号按升序分配,<code>init</code> 进程的 <code>PID</code> 总是1.
内核也对分配给每个进程的内存进行跟踪. 像文件一样,进程也有所有者和用户 <code>ID</code>,有效用户 <code>ID</code>,等等.</p>
<h3 id="查看进程"><a class="header" href="#查看进程">查看进程</a></h3>
<p>查看进程,最常使用的命令(有几个命令)是<code> ps</code>.<code>ps</code> 程序有许多选项,它最简单地使用形式是这样的:</p>
<pre><code class="language-bash">ps
</code></pre>
<p>正如我们所看到的, 默认情况下,ps 不会显示很多进程信息,只是列出与当前终端会话相关的进程.</p>
<p>为了得到更多信息, 我们需要加上一些选项,但是在这样做之前,我们先看一下 <code>ps</code> 命令运行结果的其它字段.</p>
<p>TTY 是 <code>Teletype</code> 的简写,是指进程的控制终端.这里,<code>Unix</code> 展示它的年龄.<code>TIME</code> 字段表示 进程所消耗的 <code>CPU</code> 时间数量.</p>
<p>如果给 <code>ps</code> 命令加上选项,我们可以得到更多关于系统运行状态的信息:</p>
<pre><code class="language-bash">ps x
</code></pre>
<p>加上 <code>x</code> 选项(注意没有开头的 <code>-</code> 字符),告诉 <code>ps</code> 命令,展示所有进程,不管它们由什么 终端(如果有的话)控制.
在 <code>TTY</code> 一栏中出现的 <code>?</code> ,表示没有控制终端.使用这个 <code>x</code> 选项,可以 看到我们所拥有的每个进程的信息.</p>
<p>因为系统中正运行着许多进程,所以 <code>ps</code> 命令的输出结果很长.把 <code>ps</code> 的输出结果管道到<code>less</code>命令经常很有帮助.
一些选项组合也会产生很长的输出结果,所以最大化 终端仿真器窗口,也是一个好主意.</p>
<p>输出结果中,新添加了一栏,标题为 <code>STAT</code> .<code>STAT</code> 是 <code>state</code> 的简写,它揭示了进程当前状态:</p>
<hr />
<p>状态 意义</p>
<ul>
<li><code>R</code> :  运行.这意味着,进程正在运行或准备运行.</li>
<li><code>S</code> :  正在睡眠. 进程没有运行,而是,正在等待一个事件, 比如说,一个按键或者网络数据包.</li>
<li><code>D</code> :  不可中断睡眠.进程正在等待<code> I/O</code>,比方说,一个磁盘驱动器的<code> I/O</code>.</li>
<li><code>T</code> :  已停止. 已经指示进程停止运行.稍后介绍更多.</li>
<li><code>Z</code> :  一个死进程或<code>僵尸</code>(zombie)进程.这是一个已经终止的子进程,但是它的父进程还没有清空它. (父进程没有把子进程从进程表中删除)</li>
<li><code>&lt;</code> : 一个高优先级进程.这可能会授予一个进程更多重要的资源,给它更多的CPU 时间. 进程的这种属性叫做niceness.
具有高优先级的进程据说是不好的(less nice), 因为它占用了比较多的 CPU 时间,这样就给其它进程留下很少时间.</li>
<li><code>N</code> :低优先级进程. 一个低优先级进程(一个<code>好</code>进程)只有当其它高优先级进程执行之后,才会得到处理器时间.</li>
</ul>
<p>进程状态信息之后,可能还跟随其他的字符.这表示各种外来进程的特性.详细信息请看 <code>ps</code> 手册页.</p>
<p>另一个流行的选项组合是 <code>aux</code>(不带开头的<code>-</code>字符).这会给我们更多信息:</p>
<pre><code class="language-bash">ps aux
</code></pre>
<p>这个选项组合,能够显示属于每个用户的进程信息.使用这个选项,可以唤醒 <code>BSD 风格</code> 的输出结果.</p>
<p>Linux 版本的 <code>ps</code> 命令,可以模拟几个不同 Unix 版本中的 <code>ps</code> 程序的行为.
通过这些选项,我们得到 这些额外的列.</p>
<hr />
<p>标题 意思</p>
<ul>
<li><code>USER</code> 用户 <code>ID</code>. 进程的所有者.</li>
<li><code>%CPU</code> 以百分比表示的 CPU 使用率</li>
<li><code>%MEM</code> 以百分比表示的内存使用率</li>
<li><code>VSZ</code> 虚拟内存大小</li>
<li><code>RSS</code> 进程占用的物理内存的大小,以千字节为单位.</li>
<li><code>START</code> 进程运行的起始时间.若超过<code>24</code>小时,则用天表示.</li>
</ul>
<p>寻找进程:<code>top ps pgrep</code>
发送信号:<code>kill</code></p>
<p><code>ps</code> 选项</p>
<ul>
<li><code>ps u -C lyx</code>: Display user-oriented format, with command <code>lyx</code></li>
<li><code>ps u t 2</code> : Display user-oriented format, with tty <code>2</code></li>
<li><code>ps l</code>:  Display BSD long format.</li>
</ul>
<p>For BSD formats and when the stat keyword is used, additional characters may be displayed:</p>
<ul>
<li><code>&lt;</code> :高优先级进程 (not nice to other users)</li>
<li><code>N</code> : 低优先级进程 (nice to other users)</li>
<li><code>L</code> : has pages locked into memory (for real-time and custom IO)</li>
<li><code>s</code> : is a session leader</li>
<li><code>l</code> : 多线程进程 (using CLONE_THREAD, like NPTL pthreads do)</li>
<li><code>+</code> : 在前端进程组中</li>
</ul>
<h3 id="与-awk结合使用"><a class="header" href="#与-awk结合使用">与 <code>awk</code>结合使用</a></h3>
<pre><code class="language-bash">ps  aux |awk '$8 ~ &quot;Z[\x00-\x7F]*&quot;' # 匹配zombie 进程
ps  aux | gawk '$8 ~ &quot;Z\\w*&quot;' # 此处要用 \\ 对 \ 进行转义, 查看zombie进程
</code></pre>
<p>自带的排序功能</p>
<pre><code class="language-bash">ps jax --sort=uid,-ppid,+pid # 按照 uid, ppid, pid 排序,+表示升序,-表示降序
ps aux --sort=-start | less # 按照运行时间排序
ps ux --sort=-start_time | head -n 10 # 查看用户最近运行的进程
</code></pre>
<h3 id="top-命令"><a class="header" href="#top-命令">top 命令</a></h3>
<p><a href="https://javawind.net/p131">linux top命令VIRT,RES,SHR,DATA的含义</a></p>
<p>虽然 <code>ps</code> 命令能够展示许多计算机运行状态的信息,但是它只是提供,<code>ps</code> 命令执行时刻的机器状态快照.
为了看到更多动态的信息,我们使用 <code>top</code> 命令:</p>
<pre><code class="language-bash">top
</code></pre>
<p><code>top</code> 程序连续显示系统进程更新的信息(默认情况下,每三分钟更新一次),<code>top</code>这个名字来源于这个事实,<code>top</code> 程序是用来查看系统中<code>顶端</code>进程的.
<code>top</code> 显示结果由两部分组成: 最上面是系统概要,下面是进程列表,以 <code>CPU</code> 的使用率排序.</p>
<p>其中系统概要包含许多有用信息.下表是对系统概要的说明:</p>
<hr />
<p>行号 字段 意义</p>
<ol>
<li><code>top</code>--程序名. <code>14:59:20</code> 当前时间. <code>up 6:30</code> 这是正常运行时间.它是计算机从上次启动到现在所运行的时间. 在这个例子里,系统已经运行了六个半小时.
<code>2 users</code> 有两个用户登录系统.<code>load average</code>: 加载平均值是指,等待运行的进程数目,也就是说,处于运行状态的进程个数, 这些进程共享<code>CPU</code>.
展示了三个数值,每个数值对应不同的时间周期.第一个是最后<code>60</code>秒的平均值, 下一个是前<code>5</code>分钟的平均值,最后一个是前<code>15</code>分钟的平均值.若平均值低于<code>1.0</code>,则指示计算机 工作不忙碌.</li>
<li><code>Tasks</code>: 总结了进程数目和各种进程状态.</li>
<li><code>Cpu(s)</code>: 这一行描述了<code> CPU</code> 正在执行的进程的特性.
<code>0.7%us</code>: <code>0.7%</code> 的<code>CPU</code>被用于用户进程, user processes. 这意味着进程在内核之外.
<code>1.0%sy</code>: <code>1.0%</code>的 <code>CPU</code> 时间被用于 系统(内核)进程.
<code>0.0%ni</code> : <code>0.0%</code>的 <code>CPU</code> 时间被用于<code>nice</code>(低优先级)进程.
<code>98.3%id</code>: <code>98.3%</code>的 <code>CPU</code> 时间是空闲的.
<code>0.0%wa</code> : <code>0.0%</code>的 <code>CPU</code> 时间来等待 <code>I/O</code>.</li>
<li><code>Mem</code>: 展示物理内存的使用情况.</li>
<li><code>Swap</code>: 展示交换分区(虚拟内存)的使用情况.</li>
</ol>
<p><code>top</code> 程序接受一系列从键盘输入的命令.两个最有趣的命令是 <code>h</code> 和 <code>q</code>.
<code>h</code>:显示程序的帮助屏幕,<code>q</code>: 退出 <code>top</code> 程序.</p>
<p>两个主要的桌面环境都提供了图形化应用程序,来显示与 <code>top</code> 程序相似的信息 (和 <code>Windows</code> 中的任务管理器差不多),
但是我觉得 <code>top</code> 程序要好于图形化的版本, 因为它运行速度快,并且消费很少的系统资源.
毕竟,我们的系统监测程序不能成为系统怠工的源泉,而这是我们试图追踪的信息.</p>
<p><code>Z,B,E,e</code>全局:<code>Z</code>颜色; <code>B</code>粗体; <code>E</code>/<code>e</code>摘要/任务存储单位
<code>l,t,m </code>切换摘要:<code>l</code>加载平均值; <code>t</code>任务/cpu 统计信息样式; <code>m</code>内存信息
<code>0,1,2,3,I</code>切换:<code>0</code>为零; <code>1/2/3</code> cpus或 <code>numa</code>节点视图; <code>I</code> <code>Irix</code>模式
<code>f,F,X</code> 字段:<code>f</code>/<code>F</code>添加/删除/顺序/排序; <code>X</code>增加固定宽度</p>
<p>下面这些命令需要可见的任务显示窗口</p>
<ul>
<li><code>L</code>,<code>＆</code>,<code>&lt;</code>,<code>&gt;</code>.定位:<code>L</code>/<code>＆</code>查找/再次; 按不同的列排序:<code>&lt;</code>/<code>&gt;</code></li>
<li><code>R</code>,<code>H</code>,<code>J</code>,<code>C</code>.切换:<code>R</code>排序; <code>H</code>Threads; <code>J</code>Num justify数字对齐; <code>C</code>坐标</li>
<li><code>c</code>,<code>i</code>,<code>S</code>,<code>j</code>.切换:<code>c</code> Cmd名称/行; <code>i</code>空闲; <code>S</code>Time;<code>j</code>字符串对齐</li>
<li><code>x</code>,<code>y</code>,切换高亮显示:<code>x</code>用来排序的字段;<code>y</code>正在运行任务</li>
<li><code>z</code>,<code>b</code>,切换:<code>z</code>颜色/单色; <code>b</code>粗体/反色(仅适用于<code>x</code>或<code>y</code>)</li>
<li><code>u</code>,<code>U</code>,<code>o</code>,<code>O</code>. 筛选依据:<code>u</code>/<code>U</code>有效/任何用户; <code>o</code>/<code>O</code>其他条件</li>
<li><code>n</code>,<code>＃</code>,<code>^O</code>.设置:显示任务最大为<code>n</code>/<code>＃</code>个;显示:<code>Ctrl +O</code>其他过滤器</li>
<li><code>V</code>,<code>v</code>.切换:<code>V</code>forest 视图; <code>v</code>forest view children</li>
</ul>
<p><code>k</code>,<code>r</code>操作任务:<code>k</code>,<code>kill</code>; <code>r</code>,<code>renice</code>
<code>d</code>或<code>s</code>,设置更新间隔
<code>W</code>,<code>Y</code>写入配置文件<code>W</code>;检查其他输出<code>Y</code>
<code>q</code>退出</p>
<h3 id="top-内存占用virtresshr"><a class="header" href="#top-内存占用virtresshr">top 内存占用VIRT,RES,SHR</a></h3>
<p><a href="https://blog.csdn.net/xu1314/article/details/7719651">Top的VIRT是什么</a></p>
<p>Top命令监控某个进程的资源占有情况, 下面是各种内存:</p>
<p><code>VIRT</code>: virtual memory usage</p>
<ol>
<li>进程&quot;需要的&quot;虚拟内存大小, 包括进程使用的库, 代码, 数据等</li>
<li>假如进程申请 <code>100m</code> 的内存, 但实际只使用了 <code>10m</code>, 那么它会增长 <code>100m</code>, 而不是实际的使用量</li>
</ol>
<p><code>RES</code>: resident memory usage 常驻内存</p>
<ol>
<li>进程当前使用的内存大小, 但不包括 <code>swap out</code></li>
<li>包含其他进程的共享</li>
<li>如果申请 <code>100m</code> 的内存, 实际使用 <code>10m</code>, 它只增长 <code>10m</code>, 与 <code>VIRT</code> 相反</li>
<li>关于库占用内存的情况, 它只统计<code>加载的库文件</code> 所占内存大小</li>
</ol>
<p><code>SHR</code>: shared memory</p>
<ol>
<li>除了<code>自身进程</code>的共享内存, 也包括<code>其他进程</code>的共享内存</li>
<li>虽然进程只使用了几个共享库的函数, 但它包含了<code>整个共享库</code>的大小</li>
<li>计算某个进程所占的物理内存大小公式: <code>RES – SHR</code></li>
<li><code>swap out</code> 后, 它将会降下来</li>
</ol>
<p>DATA</p>
<ol>
<li>数据占用的内存. 如果 <code>top</code> 没有显示, 按 <code>f</code> 键可以显示出来.</li>
<li>该程序真正要求的数据空间, 是真正在运行中要使用的.</li>
</ol>
<h3 id="控制进程"><a class="header" href="#控制进程">控制进程</a></h3>
<p>现在我们可以看到和监测进程,然后得到一些对它们的控制权.
为了我们的实验,我们将使用 一个叫做 <code>xlogo</code> 的小程序,作为我们的实验品.</p>
<p>这个 <code>xlogo</code> 程序是 <code>X</code> 窗口系统 (底层引擎使图形界面显示在屏幕上)提供的实例程序,这个实例简单地显示一个大小可调的包含 X 标志的窗口.</p>
<p>首先,我们需要知道测试的主题:</p>
<pre><code class="language-bash">xlogo
</code></pre>
<p>命令执行之后,一个包含 <code>X</code> 标志的小窗口应该出现在屏幕的某个位置上.在一些系统中,<code>xlogo</code> 命令 会打印一条警告信息,但是不用理会它.
小贴士:如果你的系统不包含 xlogo 程序,试着用 <code>gedit</code> 或者 <code>kwrite</code> 来代替.</p>
<p>通过调整它的窗口大小,我们能够证明 <code>xlogo</code> 程序正在运行.如果这个标志以新的尺寸被重画, 则这个程序正在运行.</p>
<p>注意,为什么我们的 <code>shell</code> 提示符还没有返回?这是因为 <code>shell</code> 正在等待这个程序结束, 就像到目前为止我们用过的其它所有程序一样.如果我们关闭 <code>xlogo</code> 窗口,<code>shell</code> 提示符就返回了.</p>
<h4 id="中断一个进程"><a class="header" href="#中断一个进程">中断一个进程</a></h4>
<p>我们再运行 <code>xlogo</code> 程序一次,观察一下发生了什么事.首先,执行 <code>xlogo</code> 命令,并且 证实这个程序正在运行.
下一步,回到终端窗口,按下 <code>Ctrl-c</code>.</p>
<p>在一个终端中,输入 <code>Ctrl-c</code>,中断一个程序.这意味着,我们礼貌地要求终止这个程序. 输入 <code>Ctrl-c</code> 之后, <code>xlogo</code> 窗口关闭,<code>shell</code> 提示符返回.通过这个技巧,许多(但不是全部)命令行程序可以被中断.</p>
<h4 id="把一个进程放置到后台执行"><a class="header" href="#把一个进程放置到后台执行">把一个进程放置到后台(执行)</a></h4>
<p>比方说,我们想让 <code>shell</code> 提示符返回,却不想终止 <code>xlogo</code> 程序.为达到这个目的,我们把 这个程序放到后台执行.</p>
<p>把终端看作是一个有前台(表层放置可见的事物,像 <code>shell</code> 提示符) 和后台(表层之下放置隐藏的事物)(的设备).
启动一个程序,让它立即在后台 运行,我们在程序命令之后,加上<code>&amp;</code>字符:
注意,在<code>bash</code>中,会把<code>&amp;</code>当作语句结束的标志,后面不能再出现<code>;</code>,否则会报错.
而在<code>zsh</code>中,可以在<code>&amp;</code>后面再加上<code>;</code>号.</p>
<pre><code class="language-bash">xlogo &amp;
[1] 28236
</code></pre>
<p>执行命令之后,这个 <code>xlogo</code> 窗口出现,并且 <code>shell</code> 提示符返回,同时打印一些有趣的数字.
这条信息是 <code>shell</code> 特性的一部分,叫做工作控制.
通过这条信息,<code>shell</code> 告诉我们,已经启动了 工作号为<code>1</code>(<code>[1]</code>),<code>PID</code> 为<code>28236</code>的程序.
如果我们运行 <code>ps</code> 命令,可以看到我们的进程.</p>
<p>shell 功能--工作控制,这个 可以列出从终端中启动的任务.执行 <code>jobs</code> 命令,我们可以看到这个输出列表:</p>
<pre><code class="language-bash">jobs
[1]+ Running
xlogo &amp;
</code></pre>
<p>结果显示我们有一个任务,编号为<code>1</code>,它正在运行,并且这个任务的命令是 <code>xlogo &amp;</code>.</p>
<pre><code class="language-bash">jobs [-lnprs] [jobspec ...] or jobs -x command [args]
</code></pre>
<p>Display status of jobs.</p>
<p>Lists the active jobs.  JOBSPEC restricts output to that job.
Without options, the status of all active jobs is displayed.</p>
<p>Options:</p>
<ul>
<li><code>-l</code>    lists process IDs in addition to the normal information</li>
<li><code>-n</code>    lists only processes that have changed status since the last notification</li>
<li><code>-p</code>    lists process IDs only</li>
<li><code>-r</code>    restrict output to running jobs</li>
<li><code>-s</code>    restrict output to stopped jobs</li>
</ul>
<p>If -x is supplied, COMMAND is run after all job specifications that appear in ARGS have been replaced with the process ID of that job's   process group leader.</p>
<p>Exit Status:</p>
<p>Returns success unless an invalid option is given or an error occurs.
If -x is used, returns the exit status of COMMAND.</p>
<h4 id="进程返回到前台"><a class="header" href="#进程返回到前台">进程返回到前台</a></h4>
<p>一个在后台运行的进程对一切来自键盘的输入都免疫,也不能用 <code>Ctrl-c</code> 来中断它.
使用 <code>fg</code> 命令,让一个进程返回前台执行:</p>
<pre><code class="language-bash">jobs
[1]+ Running
xlogo &amp;
fg %1
xlogo
</code></pre>
<p><code>fg</code> 命令之后,跟随着一个百分号和工作序号(叫做 <code>jobspec</code>).如果我们只有一个后台任务,那么 <code>jobspec</code> 是可有可无的.
输入 <code>Ctrl-c</code> 来终止 <code>xlogo</code> 程序.</p>
<h4 id="停止一个进程"><a class="header" href="#停止一个进程">停止一个进程</a></h4>
<p>有时候,我们想要停止一个进程,而没有终止它.这样会把一个前台进程移到后台等待.
输入<code>Ctrl-z</code>,可以停止一个前台进程.让我们试一下.在命令提示符下,执行 <code>xlogo</code> 命令, 然后输入 <code>Ctrl-z</code>:</p>
<pre><code class="language-bash">xlogo
[1]+ Stopped xlogo
</code></pre>
<p>停止 <code>xlogo</code> 程序之后,通过调整 <code>xlogo</code> 的窗口大小,我们可以证实这个程序已经停止了.
它看起来像死掉了一样.使用 <code>fg</code> 命令,可以恢复程序到前台运行,或者用 <code>bg</code> 命令把程序移到后台.</p>
<pre><code class="language-bash">bg %1
[1]+ xlogo &amp;
</code></pre>
<p>和 <code>fg</code> 命令一样,如果只有一个任务的话, <code>jobspec</code> 参数是可选的.
因为把一个进程从前台移到后台很方便,如果我们从命令行启动一个图形界面的程序,但是忘记把它放到后台执行,即没有在命令后加上字符<code>&amp;</code>,(也不用担心).</p>
<p>为什么要从命令行启动一个图形界面程序呢?有两个原因.
第一个,你想要启动的程序,可能 没有在窗口管理器的菜单中列出来(比方说 <code>xlogo</code>).
第二个,从命令行启动一个程序, 你能够看到一些错误信息,如果从窗口系统中运行程序的话,这些信息是不可见的.
有时候, 一个程序不能从图形界面菜单中启动.这时候,应该从命令行中启动它.我们可能会看到 错误信息,这些信息揭示了问题所在.
一些图形界面程序还有许多有意思并且有用的命令行选项.</p>
<h4 id="signals"><a class="header" href="#signals">Signals</a></h4>
<p><code>kill</code> 命令被用来<code>杀死</code>程序.这样我们就可以终止需要杀死的程序.这里有一个实例:</p>
<pre><code class="language-bash">xlogo &amp;
:[1] 28401
kill 28401
:[1]+ Terminated
xlogo
</code></pre>
<p>首先,我们在后台启动 <code>xlogo</code> <code>程序.shell</code> 打印出 <code>jobspec</code> 和这个后台进程的 <code>PID</code>.
下一步,我们使用 <code>kill</code> 命令,并且指定我们想要终止的进程 <code>PID</code>.也可以用 <code>jobspec</code>(例如,<code>%1</code>)来代替 <code>PID</code>.</p>
<p>虽然这个命令很直接了当,但不仅仅这些.这个 <code>kill</code> 命令不是确切地<code>杀死</code>程序,而是给程序 发送信号.
信号是操作系统与程序之间进行通信,所采用的几种方式中的一种.</p>
<p>我们已经看到 信号,在使用 <code>Ctrl-c</code> 和 <code>Ctrl-z</code> 的过程中.当终端接受了其中一个按键组合后,它会给在前端运行 的程序发送一个信号.
在使用 <code>Ctrl-c</code> 的情况下,会发送一个叫做 <code>INT</code>(中断)的信号;当使用 <code>Ctrl-z</code> 时,则发送一个叫做 <code>TSTP</code>(终端停止)的信号.程序,反过来,倾听信号的到来,当程序 接到信号之后,则做出响应.</p>
<p>一个程序能够倾听和响应信号,这个事实允许一个程序做些事情, 比如,当程序接到一个终止信号时,它可以保存所做的工作.</p>
<h4 id="通过-kill命令给进程发送信号"><a class="header" href="#通过-kill命令给进程发送信号">通过 kill命令给进程发送信号</a></h4>
<p><code>kill</code> 命令被用来给程序发送信号.它最常见的语法形式看起来像这样:</p>
<pre><code class="language-bash">kill [-signal] PID...
</code></pre>
<p>如果在命令行中没有指定信号,那么默认情况下,发送 <code>TERM</code>(终止)信号.<code>kill</code> 命令被经常 用来发送以下命令:</p>
<hr />
<p>常用信号
| 编号 | 名字 | 含义 |</p>
<ul>
<li>
<p><code>1</code> <code>HUP</code> <code>挂起</code> : 这是美好往昔的痕迹,那时候终端机通过电话线和调制解调器连接到 远端的计算机.这个信号
被用来告诉程序,控制的终端机已经<code>挂起</code>. 通过关闭一个终端会话,可以说明这个信号的作用.发送这个信号到终端机上的前台程序,程序会终止.
许多守护进程也使用这个信号,来重新初始化.这意味着,当发送这个信号到一个守护进程后, 这个进程会重新启动,并且重新读取它的配置文件.<code>Apache</code> 网络服务器守护进程就是一个例子.</p>
</li>
<li>
<p><code>2</code> <code>INT</code> <code>中断</code>:实现和 <code>Ctrl-c</code> 一样的功能,由终端发送.通常,它会终止一个程序.</p>
</li>
<li>
<p><code>9</code> <code>KILL</code> <code>杀死</code> : 这个信号很特别.鉴于进程可能会选择不同的方式来处理信号,其中也包含忽略信号.
<code>Kill</code>并不发送<code>9</code>信号到目标进程.而是内核立即终止 这个进程.
当一个进程以这种方式终止的时候,它没有机会去做些<code>清理</code>工作,或者是保存劳动成果.
因为这个原因,把 <code>KILL</code> 信号看作杀手锏,当其它终止信号失败后,再使用它.</p>
</li>
<li>
<p><code>15</code> <code>TERM</code> <code>终止</code>: 这是 <code>kill</code> 命令发送的默认信号.如果程序仍然<code>活着</code>,可以接受信号,那么 这个信号终止程序.</p>
</li>
<li>
<p><code>18</code> <code>CONT</code> <code>继续</code>: 在停止一段时间后,进程恢复运行.</p>
</li>
<li>
<p><code>19</code> <code>STOP</code> <code>停止</code>: 这个信号导致进程停止运行,而没有终止.类似<code>KILL</code> 信号,它不被发送到目标进程,因此它不能被忽略.</p>
</li>
</ul>
<p>让我们实验一下 <code>kill</code> 命令:</p>
<pre><code class="language-bash">xlogo &amp;
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
</code></pre>
<p>在这个例子里,我们在后台启动 <code>xlogo</code> 程序,然后通过 <code>kill</code> 命令,发送给它一个 <code>HUP</code> 信号.
这个 <code>xlogo</code> 程序终止运行,并且 <code>shell</code> 指示这个后台进程已经接受了一个挂起信号.
在看到这条 信息之前,你可能需要多按几次 <code>enter</code> 键.注意,既可以用号码,也可以用名字,不过要在名字前面 加上字母<code>SIG</code>,来指定所要发送的信号.</p>
<pre><code class="language-bash">xlogo &amp;
[1] 13546
kill -1 13546
[1]+ Hangup
xlogo
</code></pre>
<p>重复上面的例子,试着使用其它的信号.记住,你也可以用 <code>jobspecs</code> 来代替 <code>PID</code> .</p>
<p>进程,和文件一样,拥有所有者,所以为了能够通过 <code>kill</code> 命令来给进程发送信号, 你必须是进程的所有者(或者是超级用户).</p>
<p>除了上表列出的 <code>kill</code> 命令最常使用的信号之外,还有一些系统频繁使用的信号.以下是其它一些常用 信号列表:</p>
<hr />
<p>其它常用信号
| 编号 | 名字 | 含义 |</p>
<ul>
<li><code>3</code> <code>QUIT</code> <code>退出</code></li>
<li><code>11</code> <code>SEGV</code> <code>段错误</code>: 如果一个程序非法使用内存,就会发送这个信号.也就是说, 程序试图写入内存,而这个内存空间是不允许此程序写入的</li>
<li><code>20</code> <code>TSTP</code> <code>终端停止</code>: 当按下 <code>Ctrl-z</code> 组合键后,终端发送这个信号.不像 <code>STOP</code> 信号, <code>TSTP</code> 信号由目标进程
接收,且可能被忽略.</li>
<li><code>28</code> <code>WINCH</code> <code>改变窗口大小</code>: 当改变窗口大小时,系统会发送这个信号. 一些程序,像 <code>top</code> 和 <code>less</code> 程序会响
应这个信号,按照新窗口的尺寸,刷新显示的内容.</li>
</ul>
<p>为了满足读者的好奇心,通过下面的命令可以得到一个完整的信号列表:</p>
<pre><code class="language-bash">kill -l
</code></pre>
<h4 id="通过-killall命令给多个进程发送信号"><a class="header" href="#通过-killall命令给多个进程发送信号">通过 killall命令给多个进程发送信号</a></h4>
<p>也有可能通过 <code>killall</code> 命令,给匹配特定程序或用户名的多个进程发送信号.下面是 <code>killall</code> 命令的语法形式:</p>
<pre><code class="language-bash">killall [-u user] [-signal] name...
</code></pre>
<p>为了说明情况,我们将启动一对 <code>xlogo</code> 程序的实例,然后再终止它们:</p>
<pre><code class="language-bash">$ xlogo &amp;
[1] 18801
$ xlogo &amp;
[2] 18802
$ killall xlogo
[1]- Terminated xlogo
[2]+ Terminated xlogo
</code></pre>
<p>记住,和 <code>kill</code> 命令一样,你必须拥有超级用户权限才能给不属于你的进程发送信号.</p>
<h3 id="更多和进程相关的命令"><a class="header" href="#更多和进程相关的命令">更多和进程相关的命令</a></h3>
<p>因为监测进程是一个很重要的系统管理任务,所以有许多命令与它相关.玩玩下面几个命令:</p>
<hr />
<p>| 命令名 | 命令描述 |</p>
<ul>
<li><code>pstree</code> : 输出一个树型结构的进程列表,这个列表展示了进程间父/子关系.</li>
<li><code>vmstat</code>: 输出一个系统资源使用快照,包括内存,交换分区和磁盘<code>I/O</code>. 为了看到连续的显示结果,则在命令名后加上延时的时间(以秒为单位).例如,<code>vmstat 5</code>. 终止输出,按下 <code>Ctrl-c</code> 组合键.</li>
<li><code>xload</code>: 一个图形界面程序,可以画出系统负载的图形.</li>
<li><code>tload</code>: 与 <code>xload</code> 程序相似,但是在终端中画出图形.使用 <code>Ctrl-c</code>,来终止输出.</li>
</ul>
<h2 id="第十二章shell环境"><a class="header" href="#第十二章shell环境">第十二章:shell环境</a></h2>
<p>正如我们之前所讨论到的,<code>shell</code> 在 <code>shell</code>会话中维护着大量的信息,这些信息称为 (<code>shell</code>) 环境.
存储在 <code>shell</code>环境中的数据被程序用来确定配置属性.</p>
<p>然而大多数程序用配置文件来存储程序设置, 某些程序也会查找存储在<code>shell</code> 环境中的数值来调整他们的行为.
知道了这些,我们就可以用 <code>shell</code> 环境 来自定制 <code>shell</code> 经历.</p>
<p>在这一章,我们将用到以下命令:</p>
<ul>
<li><code>printenv</code> - 打印部分或所有的环境变量</li>
<li><code>set</code> - 设置 <code>shell</code> 选项</li>
<li><code>export</code> — 导出环境变量,让随后执行的程序知道.</li>
<li><code>alias</code> - 创建命令别名</li>
</ul>
<h3 id="什么存储在环境变量中"><a class="header" href="#什么存储在环境变量中">什么存储在环境变量中?</a></h3>
<p>shell 在环境中存储了两种基本类型的数据,虽然对于 bash 来说,很大程度上这些类型是不可辨别的.
它们是环境变量和 shell 变量.</p>
<p>Shell 变量是由 <code>bash</code> 存放的少量数据,而剩下的基本上 都是环境变量.</p>
<p>除了变量,shell 也存储了一些可编程的数据,命名为别名和 shell 函数.
我们 已经在第六章讨论了别名,而 shell 函数(涉及到 shell 脚本)将会在第五部分叙述.</p>
<h3 id="检查环境变量"><a class="header" href="#检查环境变量">检查环境变量</a></h3>
<p>我们既可以用 bash 的内部命令 <code>set</code>,或者是 <code>printenv</code> 程序来查看什么存储在环境当中.</p>
<p><code>set</code> 命令可以显示shell 和环境变量两者,而 <code>printenv</code> 只是显示环境变量.
因为环境变量内容列表相当长,所以最好 把每个命令的输出结果管道到 less 命令:</p>
<pre><code class="language-bash">$ printenv | less
</code></pre>
<p>执行以上命令之后,我们应该能得到类似以下内容:</p>
<pre><code class="language-bash">KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
...
</code></pre>
<p>我们所看到的是环境变量及其数值的列表.
例如,我们看到一个叫做 USER 的变量,这个变量值是 <code>me</code>.<code>printenv</code> 命令也能够列出特定变量的数值:</p>
<pre><code class="language-bash">$ printenv USER
me
</code></pre>
<p>当使用没有带选项和参数的 <code>set</code> 命令时,shell 和环境变量二者都会显示,同时也会显示定义的 shell 函数.
不同于 <code>printenv</code> 命令,<code>set</code> 命令的输出结果很礼貌地按照字母顺序排列:</p>
<pre><code class="language-bash">$ set | less
</code></pre>
<p>也可以通过 <code>echo</code> 命令来查看一个变量的内容,像这样:</p>
<pre><code class="language-bash">$ echo $HOME
/home/me
</code></pre>
<p>如果 shell 环境中的一个成员既不可用 <code>set</code> 命令也不可用 <code>printenv</code> 命令显示,则这个变量是别名.
输入不带参数的 <code>alias</code> 命令来查看它们:</p>
<pre><code class="language-bash">$ alias
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
...
</code></pre>
<h3 id="一些有趣的变量"><a class="header" href="#一些有趣的变量">一些有趣的变量</a></h3>
<p>shell 环境中包含相当多的变量,虽然你的 shell 环境可能不同于这里展示的,但是你可能会看到 以下变量在你的 shell 环境中:</p>
<hr />
<p>环境变量
变量 内容</p>
<ul>
<li><code>DISPLAY</code>: 如果你正在运行图形界面环境,那么这个变量就是你显示器的名字.
通常,它是 <code>:0</code>, 意思是由<code>X</code>产生的第一个显示器.</li>
<li><code>EDITOR</code>: 文本编辑器的名字.</li>
<li><code>SHELL</code>: shell 程序的名字.</li>
<li><code>HOME</code>: 用户家目录.</li>
<li><code>LANG</code>: 定义了字符集以及语言编码方式.</li>
<li><code>OLD_PWD</code>: 先前的工作目录.</li>
<li><code>PAGER</code>: 页输出程序的名字.这经常设置为<code>/usr/bin/less</code>.</li>
<li><code>PATH</code>: 由冒号分开的目录列表,当你输入可执行程序名后,会搜索这个目录列表.</li>
<li><code>PS1</code>: <code>Prompt String 1</code>. 这个定义了你的shell 提示符的内容.随后我们可以看到,这个变量 内容可以全面地定制.</li>
<li><code>PWD</code>: 当前工作目录.</li>
<li><code>TERM</code>: 终端类型名.类 Unix 的系统支持许多终端协议;这个变量设置你的终端仿真器所用的协议.</li>
<li><code>TZ</code>: 指定你所在的时区.大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ,然后应用一个由这个变量指定的偏差来显示本地时间.</li>
<li><code>USER</code>: 你的用户名</li>
</ul>
<p>如果缺失了一些变量,不要担心,这些变量会因发行版本的不同而不同.</p>
<h3 id="如何建立-shell-环境"><a class="header" href="#如何建立-shell-环境">如何建立 shell 环境?</a></h3>
<p>当我们登录系统后,启动 bash 程序,并且会读取一系列称为启动文件的配置脚本, 这些文件定义了默认的可供所有用户共享的 shell 环境.
然后是读取更多位于我们自己家目录中的启动文件,这些启动文件定义了用户个人的 shell 环境.</p>
<p>精确的启动顺序依赖于要运行的 shell 会话 类型.
有两种 shell 会话类型:一个是登录 shell 会话,另一个是非登录 shell 会话.
登录 shell 会话会提示用户输入用户名和密码;例如,我们启动一个虚拟控制台会话.
当我们在 GUI 模式下 运行终端会话时,非登录 shell 会话会出现.</p>
<p>登录 shell 会读取一个或多个启动文件,正如表12-2所示:</p>
<hr />
<p>表12-2: 登录 shell 会话的启动文件文件 内容</p>
<ul>
<li><code>/etc/profile</code>: 应用于所有用户的全局配置脚本.</li>
<li><code>~/.bash_profile</code>: 用户私人的启动文件.可以用来扩展或重写全局配置脚本中的设置.</li>
<li><code>~/.bash_login</code>: 如果文件 <code>~/.bash_profile</code> 没有找到,<code>bash</code> 会尝试读取这个脚本.</li>
<li><code>~/.profile</code>: 如果文件 <code>~/.bash_profile</code> 或文件<code>~/.bash_login</code> 都没有找到,<code>bash</code> 会试图读取这个文件.
这是基于 Debian发行版的默认设置,比方说 Ubuntu.</li>
</ul>
<p>非登录 shell 会话会读取以下启动文件:</p>
<hr />
<p>表12-3: 非登录 shell 会话的启动文件
文件 内容</p>
<ul>
<li><code>/etc/bash.bashrc</code> 应用于所有用户的全局配置文件.</li>
<li><code>~/.bashrc</code> 用户私有的启动文件.可以用来扩展或重写全局配置脚本中的设置.</li>
</ul>
<p>除了读取以上启动文件之外,非登录 shell 会话也会继承它们父进程的环境设置,通常是一个登录 <code>shell</code>.
浏览一下你的系统,看一看系统中有哪些启动文件.记住--因为上面列出的大多数文件名都以圆点开头 (意味着它们是隐藏文件),你需要使用带<code>-a</code>选项的 <code>ls</code> 命令.</p>
<p>在普通用户看来,文件 <code>~/.bashrc</code> 可能是最重要的启动文件,因为它几乎总是被读取.</p>
<p>非登录 shell 默认 会读取它,并且大多数登录 shell 的启动文件会设置成读取 <code>~/.bashrc</code> 文件.
一个启动文件的内容如果我们看一下典型的 <code>.bash_profile</code> 文件(来自于 <code>CentOS 4</code> 系统),它看起来像这样:</p>
<pre><code class="language-bash"># .bash_profile
# 或取别名和函数
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# 用户自定义的环境和自启动程序
PATH=$PATH:$HOME/bin
export PATH
</code></pre>
<p>以<code>#</code>开头的行是注释,shell 不会读取它们.它们在那里是为了方便人们阅读.
第一件有趣的事情发生在第四行,伴随着以下代码:</p>
<pre><code class="language-bash">if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
</code></pre>
<p>这叫做一个 <code>if</code> 复合命令,我们将会在第五部分详细地介绍它,现在我们对它翻译一下:</p>
<pre><code class="language-bash">If the file ~/.bashrc exists, then
read the ~/.bashrc file.
</code></pre>
<p>我们可以看到这一小段代码就是一个登录 shell 得到 <code>.bashrc</code> 文件内容的方式.
在我们启动文件中, 下一件有趣的事与 <code>PATH</code> 变量有关系.</p>
<p>曾经是否感到迷惑 shell 是怎样知道到哪里找到我们在命令行中输入的命令的?
例如,当我们输入 <code>ls</code> 后, shell不会查找整个计算机系统,来找到 <code>/bin/ls</code>(<code>ls</code> 命令的绝对路径名),
它将查找一个目录列表, 这些目录包含在 <code>PATH</code> 变量中.</p>
<p><code>PATH</code> 变量经常(但不总是,依赖于发行版)在<code>/etc/profile</code> 启动文件中设置,通过这些代码:</p>
<pre><code class="language-bash">PATH=$PATH:$HOME/bin
</code></pre>
<p>修改 <code>PATH</code> 变量,添加目录 <code>$HOME/bin</code> 到目录列表的末尾.这是一个参数展开的实例, 参数展开我们在第八章中提到过.</p>
<p>为了说明这是怎样工作的,试试下面的例子:</p>
<pre><code class="language-bash">$ foo=&quot;This is some&quot;
$ echo $foo
$ foo=&quot;$foo text.&quot;
$ echo $foo
</code></pre>
<p>使用这种技巧,我们可以把文本附加到一个变量值的末尾.</p>
<p>通过添加字符串 <code>$HOME/bin</code> 到 <code>PATH</code> 变量值 的末尾,则目录 <code>$HOME/bin</code> 就添加到了命令搜索目录列表中.
这意味着当我们想要在自己的家目录下, 创建一个目录来存储我们自己的私人程序时,shell 已经给我们准备好了.</p>
<p>我们所要做的事就是把创建的目录叫做 <code>bin</code>,赶快行动吧.注意:很多发行版默认地提供了这个 <code>PATH</code> 设置.
一些基于 Debian 的发行版,例如 Ubuntu,在登录 的时候,会检测目录 <code>~/bin</code> 是否存在,若找到目录则把它动态地加到 <code>PATH</code> 变量中.</p>
<p>最后,有下面一行代码:</p>
<pre><code class="language-bash">export PATH
</code></pre>
<p>这个 <code>export</code> 命令告诉 <code>shell</code> 让这个 <code>shell</code> 的子进程可以使用 PATH 变量的内容.</p>
<h3 id="修改-shell-环境"><a class="header" href="#修改-shell-环境">修改 shell 环境</a></h3>
<p>既然我们知道了启动文件所在的位置和它们所包含的内容,我们就可以修改它们来定制自己的 shell 环境.
我们应该修改哪个文件?</p>
<p>按照通常的规则,添加目录到你的 PATH 变量或者是定义额外的环境变量,要把这些更改放置到 <code>.bash_profile</code>文件中(或者其替代文件中,根据不同的发行版.例如,Ubuntu 使用 <code>.profile</code> 文件).</p>
<p>对于其它的更改,要放到 <code>.bashrc</code> 文件中.除非你是系统管理员,需要为系统中的所有用户修改默认设置,那么则限定你只能对自己家
目录下的文件进行修改.</p>
<p>当然,有可能会更改 <code>/etc</code> 目录中的文件,比如说 <code>profile</code> 文件,而且在许多情况下,修改这些文件也是明智的,但是现在,我们要 安全起见.</p>
<h3 id="文本编辑器"><a class="header" href="#文本编辑器">文本编辑器</a></h3>
<p>为了编辑(例如,修改)shell 的启动文件,还有系统中大多数其它配置文件,我们使用一个叫做文本编辑器的程序.</p>
<p>文件编辑器是一个,在某些方面,类似于文字处理器的程序,比如说随着鼠标的移动, 它允许你在屏幕上编辑文字.
只有一点,文本编辑器不同于文字处理器,就是它只能支持纯文本,并且 经常包含为便于写程序而设计的特性.</p>
<p>文本编辑器分为两种基本类型:图形化的和基于文本的编辑器.
GNOME 和 KDE 两者都包含一些流行的 图形编辑器.GNOME 自带了一个叫做 <code>gedit</code> 的编辑器,这个编辑器通常在 <code>GNOME</code> 菜单中称为<code>文本编辑器</code>.</p>
<p><code>KDE</code> 通常自带了三种编辑器,分别是(按照复杂度递增的顺序排列)<code>kedit</code>,<code>kwrite</code>,<code>kate</code>.
有许多基于文本的编辑器.你将会遇到一些流行的编辑器,它们是 <code>nano</code>,<code>vi</code>,和 <code>emacs</code>.</p>
<p>这个 <code>nano</code> 编辑器 是一个简单的,容易使用的编辑器,它是 <code>pico</code> 编辑器的替代物,<code>pico</code> 编辑器由 <code>PINE</code> 邮件套件提供.
<code>vi</code> 编辑器(在大多数 Linux 系统中被 <code>vim</code> 替代,<code>vim</code> 是 <code>Vi IMproved</code>的简写)是类 Unix 操作系统的传统编辑器.
<code>vim</code> 是我们下一章节的讨论对象.</p>
<p><code>emacs</code> 编辑器最初由 Richard Stallman 写成.
<code>emacs</code> 是一个庞大的,多用途的, 可做任何事情的编程环境.虽然 <code>emacs</code> 很容易获取,但是大多数 Linux 系统很少默认安装它.</p>
<h3 id="使用文本编辑器"><a class="header" href="#使用文本编辑器">使用文本编辑器</a></h3>
<p>所有的文本编辑器都可以通过在命令行中输入编辑器的名字,加上你所想要编辑的文件来唤醒.
如果所 输入的文件名不存在,编辑器则会假定你想要创建一个新文件.下面是一个使用 <code>gedit</code> 的例子:</p>
<pre><code class="language-bash">$ gedit some_file
</code></pre>
<p>这条命令将会启动 <code>gedit</code> 文本编辑器,同时加载名为 <code>some_file</code> 的文件,如果这个文件存在的话.</p>
<p>所有的图形文本编辑器都相当不言自明的,所以我们在这里不会介绍它们.
反之,我们将集中精力在 我们第一个基于文本的文本编辑器,<code>nano</code>.</p>
<p>让我们启动 <code>nano</code>,并且编辑文件<code>.bashrc</code>.但是在我们这样 做之前,先练习一些<code>安全准备</code>.</p>
<p>当我们编辑一个重要的配置文件时,首先创建一个这个文件的备份总是一个不错的主意.
这样能避免我们在编辑文件时弄乱文件.创建文件 <code>.bashrc</code> 的备份文件,这样做:</p>
<pre><code class="language-bash">$ cp .bashrc .bashrc.bak
</code></pre>
<p>备份文件的名字无关紧要,只要选择一个容易理解的文件名.
扩展名 <code>.bak</code>,<code>.sav</code>, <code>.old</code>,和<code>.orig</code> 都是用来指示备份文件的流行方法.
哦,记住 <code>cp</code> 命令会默默地重写存在的文件.现在我们有了一个备份文件,我们启动 <code>nano</code> 编辑器吧:</p>
<pre><code class="language-bash">$ nano .bashrc
</code></pre>
<p>一旦 <code>nano</code> 编辑器启动后,我们将会得到一个像下面一样的屏幕:</p>
<pre><code class="language-bash">GNU nano 2.0.3
....
</code></pre>
<p>注意:如果你的系统中没有安装 <code>nano</code> 编辑器,你可以用一个图形化的编辑器代替.</p>
<p>这个屏幕由上面的标头,中间正在编辑的文件文本和下面的命令菜单组成.
因为设计 nano 是为了 代替由电子邮件客户端提供的编辑器的,所以它相当缺乏编辑特性.</p>
<p>在任一款编辑器中,你应该 学习的第一个命令是怎样退出程序.
以 nano 为例,你输入 <code>Ctrl-x</code> 来退出 nano.在屏幕底层的菜单中 说明了这个命令.
<code>^X</code> 表示法意思是 <code>Ctrl-x</code>.这是控制字符的常见表示法,许多程序都使用它.</p>
<p>第二个我们需要知道的命令是怎样保存我们的劳动成果.对于 nano 来说是 <code>Ctrl-o</code>.
尽然我们 已经获得了这些知识,接下来我们准备做些编辑工作.</p>
<p>使用下箭头按键和 / 或下翻页按键,移动鼠标到文件的最后一行,然后添加以下几行到文件 <code>.bashrc</code> 中:</p>
<pre><code class="language-bash">umask 0002
export HISTCONTROL=ignoredups
export HISTSIZE=1000
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
</code></pre>
<p>注意:你的发行版可能已经包含其中的一些行,但是复制没有任何伤害.</p>
<p>下表是所添加行的意义:</p>
<hr />
<p>表12-4:
文本行 含义</p>
<ul>
<li><code>umask 0002</code> 设置掩码来解决共享目录的问题.</li>
<li><code>export HISTCONTROL=ignoredups</code> 使得 shell 的历史记录功能忽略一个命令,如果相同的命令已被记录.</li>
<li><code>export HISTSIZE=1000</code> 增加命令历史的大小,从默认的 <code>500</code> 行扩大到 <code>1000</code> 行.</li>
<li><code>alias l.='ls -d .* --color=auto'</code> 创建一个新命令,叫做<code>l.</code>,这个命令会显示所有以点开头的目录项.</li>
<li><code>alias ll='ls -l --color=auto'</code> 创建一个叫做<code>ll</code>的命令,这个命令会显示长格式目录列表.</li>
</ul>
<p>正如我们所看到的,我们的许多附加条目意思直觉上并不是明显的,所以添加注释到我们的文件 <code>.bashrc</code> 中是 一个好主意,可以帮助人们理解.
使用编辑器,更改我们的附加条目,让它们看起来像这样:</p>
<pre><code class="language-bash"># Change umask to make directory sharing easier
umask 0002
# Ignore duplicates in command history and increase
# history size to 1000 lines
export HISTCONTROL=ignoredups
export HISTSIZE=1000
# Add some helpful aliases
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
</code></pre>
<p>啊,看起来好多了! 当我们完成修改后,输入 <code>Ctrl-o</code> 来保存我们修改的 <code>.bashrc</code> 文件,输入 <code>Ctrl-x</code> 退出 nano.
为什么注释很重要?</p>
<p>不管什么时候你修改配置文件时,给你所做的更改加上注释都是一个好主意.
的确,明天你会记得你修改了的内容,但是六个月之后会怎样呢?帮自己一个忙,加上一些注释吧.
<code>Shell</code> 脚本和 <code>bash</code> 启动文件都使用 <code>#</code> 符号来开始注释.其它配置文件可能使用其它的符号.
大多数配置文件都有注释.把它们作为指南.
你会经常看到配置文件中的一些行被注释掉,以此防止它们被受影响的程序使用.</p>
<p>这样做 是为了给读者在可能的配置选项方面一些建议,或者给出正确的配置语法实例.
例如,Ubuntu 8.04 中的 <code>.bashrc </code>文件包含这些行:</p>
<pre><code class="language-bash"># some more ls aliases
#alias ll='ls -l'
#alias la='ls -A'
#alias l='ls -CF'
</code></pre>
<p>最后三行是有效的被注释掉的别名定义.如果你删除这三行开头的 <code>#</code> 符号,此技术程称为 <code>uncommenting</code> (不注释),这样你就会激活这些别名.
相反地,如果你在一行的开头加上 <code>#</code> 符号, 你可以注销掉这一行,但会保留它所包含的信息.</p>
<h3 id="激活我们的修改"><a class="header" href="#激活我们的修改">激活我们的修改</a></h3>
<p>我们对于文件 <code>.bashrc</code> 的修改不会生效,直到我们关闭终端会话,再重新启动一个新的会话,
因为 <code>.bashrc</code> 文件只是在刚开始启动终端会话时读取.</p>
<p>然而,我们可以强迫 bash 重新读取修改过的 <code>.bashrc</code> 文件,使用下面的命令:</p>
<pre><code class="language-bash">$ source .bashrc
</code></pre>
<p>运行上面命令之后,我们就应该能够看到所做修改的效果了.试试其中一个新的别名:</p>
<pre><code class="language-bash">$ ll
</code></pre>
<p>总结</p>
<p>在这一章中,我们学到了用文本编辑器来编辑配置文件的必要技巧.
随着继续学习,当我们 读到命令的手册页时,记录下命令所支持的环境变量.可能会有一个或两个宝贝.</p>
<p>在随后的章节里面,我们将会学习 shell 函数,一个很强大的特性,你可以把它包含在 bash 启动文件里面,以此来添加你自定制的命令宝库.</p>
<p>拓展阅读</p>
<p>bash 手册页的 INVOCATION 部分非常详细地讨论了 bash 启动文件.</p>
<h2 id="第十三章vi简介"><a class="header" href="#第十三章vi简介">第十三章:VI简介</a></h2>
<p>有一个古老的笑话,说是一个在纽约的游客向行人打听这座城市中著名古典音乐场馆的方向:</p>
<p>游客: 请问一下,我怎样去卡内基音乐大厅?
行人: 练习,练习,练习!</p>
<p>学习 Linux 命令行,就像要成为一名造诣很深的钢琴家一样,它不是我们一下午就能学会的技能.
这需要 经历几年的勤苦练习.在这一章中,我们将介绍 vi(发音<code>vee eye</code>)文本编辑器,它是 Unix 传统中核心程序之一.</p>
<p>vi 因它难用的用户界面而有点声名狼藉,但是当我们看到一位大师坐在钢琴前开始演奏时,我们的确成了 伟大艺术的见证人.
虽然我们在这里不能成为 vi 大师,但是当我们学完这一章后, 我们会知道怎样在 vi 中玩<code>筷子</code>.</p>
<h3 id="为什么我们应该学习-vi"><a class="header" href="#为什么我们应该学习-vi">为什么我们应该学习 vi</a></h3>
<p>在现在这个图形编辑器和易于使用的基于文本编辑器的时代,比如说 <code>nano</code>,为什么我们还应该学习 <code>vi</code> 呢? 下面有三个充分的理由:</p>
<ol>
<li><code>vi</code> 很多系统都预装.如果我们的系统没有图形界面,比方说一台远端服务器或者是一个 <code>X</code> 配置损坏了的本地系统,那么 <code>vi</code> 就成了我们的救星.
虽然 <code>nano</code> 逐渐流行起来,但是它 还没有普及.<code>POSIX</code>,这套 Unix 系统中程序兼容的标准,就要求系统要预装<code>vi</code>.</li>
<li><code>vi</code> 是轻量级且执行快速的编辑器.
对于许多任务来说,启动 <code>vi</code> 比起在菜单中找到一个图形化文本编辑器,再等待编辑器数倍兆字节的数据加载而言,要容易的多.
另外,<code>vi</code> 是为了加快输入速度而设计的. 我们将会看到,当一名熟练的 <code>vi</code> 用户在编辑文件时,他或她的手从不需要移开键盘.</li>
<li>我们不希望其他 Linux 和 Unix 用户把我们看作胆小鬼.</li>
</ol>
<p>好吧,可能只有两个充分的理由.</p>
<h3 id="一点儿背景介绍"><a class="header" href="#一点儿背景介绍">一点儿背景介绍</a></h3>
<p>第一版 <code>vi</code> 是在1976由 <code>Bill Joy</code> 写成的,当时他是加州大学伯克利分校的学生, 后来他共同创建了 <code>Sun</code> 微系统公司.</p>
<p><code>vi</code> 这个名字 来源于单词<code>visual</code>,因为它打算在带有可移动光标的视频终端上编辑文本.
在发明可视化编辑器之前, 有一次只能操作一行文本的行编辑器.
为了指定一个修改,我们告诉行编辑器到一个特殊行并且说明做什么修改,比方说添加或删除文本.</p>
<p>视频终端(而不是基于打印机的终端,像电传打印机)的出现 ,可视化编辑成为可能.
<code>vi</code> 实际上整合了一个强大的叫做 <code>ex</code> 行编辑器, 所以我们在使用 <code>vi</code> 时能运行行编辑命令.</p>
<p>大多数 Linux 发行版不包含真正的 <code>vi</code>;而是自带一款高级替代版本,叫做 <code>vim</code>(它是<code>vi improved</code>的简写)由 Bram Moolenaar 开发的.<code>vim</code> 相对于传统的 Unix vi 来说,取得了实质性进步.
通常,<code>vim</code> 在 Linux 系统中是<code>vi</code>的符号链接(或别名). 在随后的讨论中,我们将会假定我们有一个叫做<code>vi</code>的程序,但它其实是<code>vim</code>.</p>
<h3 id="启动和停止-vi"><a class="header" href="#启动和停止-vi">启动和停止 vi</a></h3>
<p>要想启动 <code>vi</code>,只要简单地输入以下命令:</p>
<pre><code>$ vi
</code></pre>
<p>一个像这样的屏幕应该出现:</p>
<pre><code class="language-bash">VIM - Vi Improved
....
</code></pre>
<p>正如我们之前操作 <code>nano</code> 时,首先要学的是怎样退出 <code>vi</code>.要退出 <code>vi</code>,输入下面的命令(注意冒号是命令的一部分):</p>
<pre><code class="language-bash">:q
</code></pre>
<p>shell 提示符应该返回.如果由于某种原因,<code>vi</code> 不能退出(通常因为我们对文件做了修改,却没有保存文件).
通过给命令加上叹号,我们可以告诉 <code>vi</code> 我们真要退出 <code>vi</code>.</p>
<pre><code class="language-bash">:q!
</code></pre>
<p>小贴示:如果你在 vi 中<code>迷失</code>了,试着按下 Esc 键两次来找到路(回到普通模式).</p>
<h3 id="vi模式"><a class="header" href="#vi模式">vi模式</a></h3>
<h4 id="兼容模式"><a class="header" href="#兼容模式">兼容模式</a></h4>
<p>上面实例中的启动屏幕(来自于 Ubuntu 8.04),我们看到一行文字<code>以 Vi 兼容的模式运行</code>.
这意味着vim 将以近似于 vi 常规的模式 运行,而不是 vim 的高级规范.
为了这章的目的,我们想要使用 vim 的高级规范.要想这样做, 你有几个选择:
用 <code>vim</code> 来代替 <code>vi</code>.
如果命令生效,考虑在你的<code>.bashrc</code> 文件中添加别名 <code>vi='vim'</code>.
或者,使用这个命令在你的 <code>vim</code> 配置文件中添加一行:</p>
<pre><code class="language-bash">echo `set nocp` &gt;&gt; ~/.vimrc
</code></pre>
<p>不同的 Linux 发行版其 vim 软件包也迥然不同.一些发行版只是安装了 vim 的最小版本, 其默认只支持有限的 vim 特性.
当练习随后的课程时,你可能会遇到缺失的功能. 如果是这种情况,就安装 vim 的完整版.</p>
<h4 id="编辑模式"><a class="header" href="#编辑模式">编辑模式</a></h4>
<p>再次启动 <code>vi</code>,这次传递给 <code>vi</code> 一个不存在的文件名.这也是用 <code>vi</code> 创建新文件的方法.</p>
<pre><code class="language-bash">$ rm -f foo.txt
$ vi foo.txt
</code></pre>
<p>如果一切运行正常,我们应该获得一个像这样的屏幕:</p>
<pre><code class="language-bash">....
&quot;foo.txt&quot; [New File]
</code></pre>
<p>每行开头的波浪号(<code>~</code>)指示那一行不存在文本.这表示我们有一个空文件.还没有输入任何字符?
学习 vi 时,要知道的第二件非常重要的事情是(知道了如何退出 vi 后)vi 是一个模式编辑器,当 vi 启动后,进入 的是命令模式.
这种模式下,几乎每个按键都是一个命令,所以如果我们打算输入字符,vi 会发疯,弄得一团糟.</p>
<h4 id="插入模式"><a class="header" href="#插入模式">插入模式</a></h4>
<p>为了在文件中添加文本,首先我们必须进入插入模式.
按下<code>i</code>按键进入插入模式.之后,我们应该 在屏幕底部看到下面一行,如果 vi 运行在高级模式下(这不会出现在 vi 兼容模式下):</p>
<pre><code class="language-bash">-- INSERT --
</code></pre>
<p>现在我们能输入一些文本了.试着输入这些文本:<code>The quick brown fox jumped over the lazy dog.</code>
按下 <code>Esc</code> 按键,退出插入模式并返回命令模式.</p>
<h4 id="保存我们的工作"><a class="header" href="#保存我们的工作">保存我们的工作</a></h4>
<p>为了保存我们刚才对文件所做的修改,我们必须在命令模式下输入一个 <code>ex</code> 命令.
通过按下<code>:</code>键,这很容易完成.按下冒号键之后,一个冒号字符应该出现在屏幕的底部:</p>
<pre><code class="language-bash">:
</code></pre>
<p>为了写入我们修改的文件,我们在冒号之后输入<code>w</code>字符,然后按下回车键:</p>
<pre><code class="language-bash">:w
</code></pre>
<p>文件将会写入到硬盘,并且我们应该在屏幕底部得到一个确认信息,就像这样:</p>
<pre><code class="language-bash">&quot;foo.txt&quot; [New] 1L, 46C written
</code></pre>
<p>小贴示:如果你阅读 vim 的文档,你注意到(混淆地)命令模式被叫做普通模式,<code>ex</code> 命令 叫做命令模式.当心.</p>
<h4 id="移动光标"><a class="header" href="#移动光标">移动光标</a></h4>
<p>当在 vi 命令模式下时,vi 提供了大量的移动命令,其中一些是与 <code>less</code> 阅读器共享的.这里 列举了一些:</p>
<hr />
<p>表13-1: 光标移动按键
按键 移动光标</p>
<ul>
<li><code>l</code> or 右箭头 向右移动一个字符</li>
<li><code>h</code> or 左箭头 向左移动一个字符</li>
<li><code>j</code> or 下箭头 向下移动一行</li>
<li><code>k</code> or 上箭头 向上移动一行</li>
<li><code>0</code> (零按键) 移动到当前行的行首.</li>
<li><code>^</code> 移动到当前行的第一个非空字符.</li>
<li><code>$</code> 移动到当前行的末尾.</li>
<li><code>w</code> 移动到下一个单词或标点符号的开头.</li>
<li><code>W</code> 移动到下一个单词的开头,忽略标点符号.</li>
<li><code>b</code> 移动到上一个单词或标点符号的开头.</li>
<li><code>B</code> 移动到上一个单词的开头,忽略标点符号.</li>
<li><code>Ctrl -f </code> or <code>Page Down</code> 向下翻一页</li>
<li><code>Ctrl -b</code> or <code>Page Up</code> 向上翻一页</li>
<li><code>numberG</code> 移动到第 <code>number</code> 行.例如,<code>1G</code> 移动到文件的第一行.<code>G</code> 移动到文件末尾.</li>
</ul>
<p>为什么 <code>h</code>,<code>j</code>,<code>k</code>,和 <code>l</code> 按键被用来移动光标呢?
因为在开发 vi 之初,并不是所有的视频终端都有箭头按键,
熟练的打字员可以使用规则的键盘按键来移动光标,他们的手从不需要移开键盘.</p>
<p><code>vi</code> 中的许多命令都可以在前面加上一个数字,比方说上面提到的<code>G</code>命令.
在命令之前加上一个 数字,我们就可以指定命令执行的次数.例如,命令<code>5j</code>导致 vi 向下移动5行.</p>
<h3 id="基本编辑"><a class="header" href="#基本编辑">基本编辑</a></h3>
<p>大多数编辑工作由一些基本的操作组成,比如说插入文本,删除文本和通过剪切和粘贴来移动文本.</p>
<p>vi,当然,以它自己的独特方式来支持所有的操作.vi 也提供了有限的撤销形式.
如果我们按下<code>u</code> 按键,当在命令模式下,vi 将会撤销你所做的最后一次修改.
当我们试着执行一些基本的 编辑命令时,这会很方便.</p>
<h4 id="追加文本"><a class="header" href="#追加文本">追加文本</a></h4>
<p>vi 有几种不同进入插入模式的方法.我们已经使用了 <code>i</code> 命令来插入文本.
让我们返回到我们的 <code>foo.txt</code> 文件中,呆一会儿:<code>The quick brown fox jumped over the lazy dog.</code></p>
<p>如果我们想要在这个句子的末尾添加一些文本,我们会发现 <code>i</code> 命令不能完成任务,因为我们不能把 光标移到行尾.</p>
<p>vi 提供了追加文本的命令,明智地命名为<code>a</code>命令.
如果我们把光标移动到行尾,输入<code>a</code>, 光标就会越过行尾,vi 进入插入模式.这样就允许我们添加更多的文本:
<code>The quick brown fox jumped over the lazy dog. It was cool.</code>
记住按下 <code>Esc</code> 按键来退出插入模式.</p>
<p>因为我们几乎总是想要在行尾附加文本,所以 vi 提供了一种快捷方式来移动到当前行的末尾,并且能添加文本.
它是<code>A</code>命令.试着用一下它,给文件添加更多行.</p>
<p>首先,使用<code>0</code>(零)命令,将光标移动到行首.现在我们输入<code>A</code>,来添加以下文本行:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
</code></pre>
<p>再一次,按下 <code>Esc</code> 按键退出插入模式.</p>
<p>正如我们所看到的,大 <code>A</code> 命令非常有用,因为在启动插入模式之前,它把光标移到了行尾.</p>
<h3 id="打开一行"><a class="header" href="#打开一行">打开一行</a></h3>
<p>我们插入文本的另一种方式是<code>打开</code>一行.这会在存在的两行之间插入一个空白行,并且进入插入模式.
这种方式有两个变体:</p>
<hr />
<p>表13-2: 文本行打开按键
命令 打开行</p>
<ul>
<li><code>o</code> 当前行的下方打开一行.</li>
<li><code>O</code> 当前行的上方打开一行.</li>
</ul>
<p>我们可以演示一下:把光标放到<code>Line 3</code>上,按下小 <code>o</code> 按键.</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
</code></pre>
<p>在第三行之下打开了新的一行,并且进入插入模式.按下 <code>Esc</code>,退出插入模式.按下 <code>u</code> 按键,撤销我们的修改.
按下大 <code>O</code> 按键在光标之上打开新的一行:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
</code></pre>
<p>按下 <code>Esc</code> 按键,退出插入模式,并且按下 <code>u</code> 按键,撤销我们的更改.</p>
<h3 id="删除文本"><a class="header" href="#删除文本">删除文本</a></h3>
<p>正如我们期望的,vi 提供了各种各样的方式来删除文本,所有的方式包含一个或两个按键.</p>
<p>首先, <code>x</code> 按键会删除光标位置的一个字符.可以在 <code>x</code> 命令之前带上一个数字,来指明要删除的字符个数.
<code>d</code> 按键更通用一些.类似 <code>x</code>命令,<code>d</code> 命令之前可以带上一个数字,来指定要执行的删除次数.
另外, <code>d</code> 命令之后总是带上一个移动命令,用来控制删除的范围.这里有些实例:</p>
<hr />
<p>表13-3: 文本删除命令
命令 删除的文本</p>
<ul>
<li><code>x</code> : 当前字符</li>
<li><code>3x</code> : 当前字符及其后的两个字符.</li>
<li><code>dd</code> : 当前行.</li>
<li><code>5dd</code> : 当前行及随后的四行文本.</li>
<li><code>dW</code> : 从光标位置开始到下一个单词的开头.</li>
<li><code>d$</code> : 从光标位置开始到当前行的行尾.</li>
<li><code>d0</code> : 从光标位置开始到当前行的行首.</li>
<li><code>d^</code> : 从光标位置开始到文本行的第一个非空字符.</li>
<li><code>dG</code> : 从当前行到文件的末尾.</li>
<li><code>d20G</code>: 从当前行到文件的第20行.</li>
</ul>
<p>把光标放到第一行单词<code>It</code>之上.重复按下 <code>x</code> 按键直到删除剩下的部分.下一步,重复按下 <code>u</code> 按键 直到恢复原貌.</p>
<p>注意:真正的 vi 只是支持单层面的 <code>undo</code> 命令.vim 则支持多个层面的.</p>
<p>我们再次执行删除命令,这次使用 <code>d</code> 命令.还是移动光标到单词<code>fox</code>之上,按下的 <code>dW</code> 来删除单词,
按下 <code>d$</code>删除从光标位置到行尾的文本.按下 <code>dG</code> 按键删除从当前行到文件末尾的所有行.</p>
<p>连续按下 <code>u</code> 按键三次,来恢复删除部分.</p>
<h3 id="剪切复制和粘贴文本"><a class="header" href="#剪切复制和粘贴文本">剪切,复制和粘贴文本</a></h3>
<p>这个 <code>d</code> 命令不仅删除文本,它还<code>剪切</code>文本.每次我们使用 <code>d</code> 命令,删除的部分被复制到一个 粘贴缓冲区中(看作剪切板).
过后我们执行小 <code>p</code> 命令把剪切板中的文本粘贴到光标位置之后, 或者是大 <code>P</code> 命令把文本粘贴到光标之前.</p>
<p><code>y</code> 命令用来<code>拉</code>(复制)文本,和 <code>d</code> 命令剪切文本的方式差不多.这里有些把 <code>y</code> 命令和各种移动命令结合起来使用的实例:</p>
<hr />
<p>表13-4: 复制命令
命令 复制的内容</p>
<ul>
<li><code>yy</code> 当前行.</li>
<li><code>5yy</code> 当前行及随后的四行文本.</li>
<li><code>yw</code>从当前光标位置到下一个单词的开头.</li>
<li><code>y$</code> 从当前光标位置到当前行的末尾.</li>
<li><code>y0</code> 从当前光标位置到行首.</li>
<li><code>y^</code> 从当前光标位置到文本行的第一个非空字符.</li>
<li><code>yG</code> 从当前行到文件末尾.</li>
<li><code>y20G</code> 从当前行到文件的第20行.</li>
</ul>
<p>我们试着做些复制和粘贴工作.把光标放到文本第一行,输入 <code>yy</code> 来复制当前行.
下一步,把光标移到 最后一行(<code>G</code>),输入小写的 <code>p</code> 把复制的一行粘贴到当前行的下面:</p>
<p>和以前一样,<code>u</code> 命令会撤销我们的修改.光标仍然位于文件的最后一行,输入大写的 <code>P</code> 命令把 所复制的文本粘贴
到当前行之上</p>
<p>试着执行上表中一些其他的 <code>y</code> 命令,了解小写 <code>p</code> 和大写 <code>P</code> 命令的行为.当你完成练习之后,把文件 恢复原样.</p>
<h4 id="连接行"><a class="header" href="#连接行">连接行</a></h4>
<p><code>vi</code> 对于行的概念相当严格.通常,不可能把光标移到行尾,再删除行尾结束符(回车符)来连接当前行和它下面的一行.</p>
<p>由于这个原因,vi 提供了一个特定的命令,大写的 <code>J</code>(不要与小写的 <code>j</code> 混淆了, <code>j</code> 是用来移动光标的)把行与行之间连接起来.
如果我们把光标放到 <code>line 3</code>上,输入大写的 <code>J</code> 命令,看看发生什么情况:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3 Line 4
Line 5
</code></pre>
<h3 id="查找和替换"><a class="header" href="#查找和替换">查找和替换</a></h3>
<p>vi 有能力把光标移到搜索到的匹配项上.vi 可以在单一行或整个文件中运用这个功能.
它也可以在有或没有用户确认的情况下实现文本替换.</p>
<h4 id="查找一行"><a class="header" href="#查找一行">查找一行</a></h4>
<p><code>f</code> 命令查找一行,移动光标到下一个所指定的字符上.例如,命令 <code>fa</code> 会把光标定位到同一行中下一个出现的<code>a</code>字符上.
在一行中执行了字符的查找命令之后,通过输入分号来重复这个查找.</p>
<h4 id="查找整个文件"><a class="header" href="#查找整个文件">查找整个文件</a></h4>
<p>移动光标到下一个出现的单词或短语上,使用 <code>/</code> 命令.这个命令和我们之前在 <code>less</code> 程序中学到 的一样.</p>
<p>当你输入<code>/</code>命令后,一个<code>/</code>字符会出现在屏幕底部.下一步,输入要查找的单词或短语后, 按下回车.
光标就会移动到下一个包含所查找字符串的位置.通过 <code>n</code> 命令来重复先前的查找. 这里有个例子:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
</code></pre>
<p>把光标移动到文件的第一行.输入:<code>/Line</code>然后键入回车.光标会移动到第二行.</p>
<p>下一步,输入 <code>n</code>,光标移到第三行.重复这个 <code>n</code> 命令,光标会 继续向下移动直到遍历了所有的匹配项.</p>
<p>虽然目前,我们只是使用了单词和短语来作为我们的查找 模式,但是 vi 允许使用正则表达式,一种强大的用来表示复杂文本模式的方法.</p>
<p>我们将会在随后 的章节里面详尽地介绍正则表达式.</p>
<h4 id="全局查找和替代"><a class="header" href="#全局查找和替代">全局查找和替代</a></h4>
<p>vi 使用 <code>ex</code> 命令来执行查找和替代操作(vi 中叫做<code>替换</code>).</p>
<p>把整个文件中的单词<code>Line</code>更改为<code>line</code>,我们输入以下命令:</p>
<pre><code class="language-bash">:%s/Line/line/g
</code></pre>
<p>我们把这个命令分解为几个单独的部分,看一下每部分的含义:</p>
<hr />
<p>条目 含义</p>
<ul>
<li><code>:</code>: 冒号字符运行一个 <code>ex</code> 命令.指定要操作的行数.</li>
<li><code>%</code> :是一个快捷方式,表示从第一行到最后一行.
另外,操作范围也 可以用 <code>1,5</code> 来代替(因为我们的文件只有<code>5</code>行文本),或者用 <code>1,$</code>来代替,意思是 从第一行到文件的最后一行.`如果省略了文本行的范围,那么操作只对当前行生效.</li>
<li><code>s</code> :指定操作.在这种情况下是,替换(查找与替代).</li>
<li><code>/Line/line</code> :查找类型与替代文本.</li>
<li><code>g</code> :这是<code>全局</code>的意思,意味着对文本行中所有匹配的字符串执行查找和替换操作.如果省略 g,则 只替换每个文本行中第一个匹配的字符串.</li>
</ul>
<p>执行完查找和替代命令之后,我们的文件看起来像这样:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
line 2
line 3
line 4
line 5
</code></pre>
<p>我们也可以指定一个需要用户确认的替换命令.通过添加一个<code>c</code>字符到这个命令的末尾,来完成 这个替换命令.例如:</p>
<pre><code class="language-bash">:%s/line/Line/gc
</code></pre>
<p>这个命令会把我们的文件恢复先前的模样;然而,在执行每个替换命令之前,vi 会停下来, 通过下面的信息,来要求我们确认这个替换:
<code>replace with Line (y/n/a/q/l/^E/^Y)?</code></p>
<p>括号中的每个字符都是一个可能的选择,如下所示:</p>
<hr />
<p>表13-5: 替换确认按键
按键 行为</p>
<ul>
<li><code>y</code> 执行替换操作</li>
<li><code>n</code> 跳过这个匹配的实例</li>
<li><code>a</code> 对这个及随后所有匹配的字符串执行替换操作.</li>
<li><code>q</code> or <code>esc</code> 退出替换操作.</li>
<li><code>l</code> 执行这次替换并退出.l 是 <code>last</code> 的简写.</li>
</ul>
<p><code>Ctrl-e</code>, <code>Ctrl-y </code>分别是向下滚动和向上滚动.用于查看建议替换的上下文.
如果你输入 <code>y</code>,则执行这个替换,输入 <code>n</code> 则会导致 <code>vi</code> 跳过这个实例,而移到下一个匹配项上.</p>
<h3 id="编辑多个文件"><a class="header" href="#编辑多个文件">编辑多个文件</a></h3>
<p>同时能够编辑多个文件是很有用的.你可能需要更改多个文件或者从一个文件复制内容到 另一个文件.
通过 vi,我们可以打开多个文件来编辑,只要在命令行中指定要编辑的文件名.</p>
<pre><code class="language-bash">vi file1 file2 file3...
</code></pre>
<p>我们先退出已经存在的 vi 会话,然后创建一个新文件来编辑.输入<code>:wq</code> 来退出 vi 并且保存了所做的修改.
下一步,我们将在家目录下创建一个额外的用来玩耍的文件.通过获取从 ls 命令的输出,来创建这个文件.</p>
<pre><code class="language-bash">$ ls -l /usr/bin &gt; ls-output.txt
</code></pre>
<p>用 vi 来编辑我们的原文件和新创建的文件:</p>
<pre><code class="language-bash">$ vi foo.txt ls-output.txt
</code></pre>
<p>vi 启动,我们会看到第一个文件显示出来.</p>
<h4 id="文件之间转换"><a class="header" href="#文件之间转换">文件之间转换</a></h4>
<p>从这个文件转到下一个文件,使用这个 ex 命令:</p>
<pre><code class="language-bash">:n
</code></pre>
<p>回到先前的文件使用:</p>
<pre><code class="language-bash">:N
</code></pre>
<p>当我们从一个文件移到另一个文件时,如果当前文件没有保存修改,vi 会阻止我们转换文件, 这是 vi 强制执行的政策.
在命令之后添加感叹号,可以强迫 vi 放弃修改而转换文件.</p>
<p>另外,上面所描述的转换方法,vim(和一些版本的 vi)也提供了一些 ex 命令,这些命令使 多个文件更容易管理.</p>
<p>我们可以查看正在编辑的文件列表,使用<code>:buffers</code> 命令.运行这个 命令后,屏幕顶部就会显示出一个文件列表:</p>
<pre><code class="language-bash">:buffers
1 # &quot;foo.txt&quot; line 1
2 %a &quot;ls-output.txt&quot; line 0
Press ENTER or type command to continue
</code></pre>
<p>注意:你不能通过<code>:n</code> 或<code>:N</code> 命令在由<code>:e</code> 命令加载的文件之间进行切换.
这时要使用<code>:buffer</code> 命令, 其后加上缓冲区号码,来转换文件.</p>
<p>从一个文件复制内容到另一个文件当我们编辑多个文件时,经常地要复制文件的一部分到另一个正在编辑的文件.
使用之前我们学到的 拉(<code>yank</code>)和粘贴命令,这很容易完成.说明如下.</p>
<p>以打开的两个文件为例,首先转换到缓冲区1(foo.txt) ,输入:</p>
<pre><code class="language-bash">:buffer 1
</code></pre>
<p>我们应该得到以下输出:</p>
<pre><code class="language-bash">The quick brown fox jumped over the lazy dog. It was cool.
Line 2
Line 3
Line 4
Line 5
</code></pre>
<p>下一步,把光标移到第一行,并且输入 <code>yy</code> 来复制这一行.
转换到第二个缓冲区,输入:</p>
<pre><code class="language-bash">:buffer 2
</code></pre>
<p>现在屏幕会包含一些文件列表,移动光标到第一行,输入 <code>p</code> 命令把我们从前面文件中复制的一行粘贴到这个文件中.</p>
<h3 id="插入整个文件到另一个文件"><a class="header" href="#插入整个文件到另一个文件">插入整个文件到另一个文件</a></h3>
<p>也有可能把整个文件插入到我们所编辑的文件中.
看一下实际操作,结束 vi 会话,重新 启动一个只打开一个文件的 vi 会话:</p>
<pre><code class="language-bash">$ vi ls-output.txt
</code></pre>
<p>移动光标到第三行,然后输入以下 <code>ex</code> 命令:</p>
<pre><code class="language-bash">:r foo.txt
</code></pre>
<p>这个<code>:r</code> 命令(是<code>read</code>的简称)把指定的文件插入到光标位置之前.</p>
<h3 id="保存工作"><a class="header" href="#保存工作">保存工作</a></h3>
<p>像 vi 中的其它操作一样,有几种不同的方法来保存我们所修改的文件,我们已经研究了<code>:w</code> 这个 ex 命令, 但还有几种方法,可能我们也觉得有帮助.</p>
<p>在命令模式下,输入 <code>ZZ</code> 就会保存并退出当前文件.同样地,<code>ex</code> 命令<code>:wq</code> 把<code>:w</code> 和<code>:q</code> 命令结合到 一起,来完成保
存和退出任务.</p>
<p>这个<code>:w </code>命令也可以指定可选的文件名.这个的作用就如<code>Save As...</code>.</p>
<p>例如,如果我们 正在编辑 <code>foo.txt</code> 文件,想要保存一个副本,叫做 <code>foo1.txt</code>,那么我们可以执行以下命令:</p>
<pre><code class="language-bash">:w foo1.txt
</code></pre>
<p>注意:当上面的命令以一个新名字保存文件时,但它并没有更改你正在编辑的文件的名字.
如果你继续编辑的话,你还是在编辑文件 <code>foo.txt</code>,而不是 <code>foo1.txt</code>.</p>
<h3 id="拓展阅读"><a class="header" href="#拓展阅读">拓展阅读</a></h3>
<p>即使把这章所学的内容都加起来,我们也只是学了 vi 和 vim 的一点儿皮毛而已.这里 有一些在线的资料,你可
以用来继续 vi 学习之旅.</p>
<ul>
<li><a href="http://en.wikibooks.org/wiki/Vi">学习 vi 编辑器</a>:一本来自于 Wikipedia 的 Wikibook,是一本关于 vi 的简要指南,并介绍了几个类似 vi 的程序,其中包括 vim.</li>
<li>[The Vim Book-vim 项目][], 一本570页的书籍,包含了(几乎)所有的 vim 特性.你能在下面链接中找到它:</li>
<li>Wikipedia 上关于 <a href="http://en.wikipedia.org/wiki/Bill_Joy">Bill Joy</a> 的文章,<code>vi</code> 的创始人.http://en.wikipedia.org/wiki/Bill_Joy</li>
<li>Wikipedia 上关于 <a href="http://en.wikipedia.org/wiki/Bram_Moolenaar">Bram Moolenaar</a> 的文章,vim 的作者</li>
</ul>
<h2 id="第十四章自定制shell提示符"><a class="header" href="#第十四章自定制shell提示符">第十四章:自定制shell提示符</a></h2>
<p>在这一章中,我们将会看一下表面上看来很琐碎的细节-shell 提示符.但这会揭示一些内部 shell 和 终端仿真器的工作方式.</p>
<p>和 Linux 内的许多程序一样,shell 提示符是可高度配置的,虽然我们大多时候把它看作是理所当然的, 但是我们一旦学会了怎样控制它,shell 提示符是一个真正有用的设备.</p>
<h3 id="解剖一个提示符"><a class="header" href="#解剖一个提示符">解剖一个提示符</a></h3>
<p>我们默认的提示符看起来像这样:</p>
<pre><code class="language-bash">$
</code></pre>
<p>注意它包含我们的用户名,主机名和当前工作目录,但是它又是怎样得到这些东西的呢? 结果证明非常简单.
提示符是由一个环境变量定义的,叫做 PS1(是<code>prompt string one</code> 的简写).</p>
<p>我们可以通过 <code>echo</code> 命令来查看 <code>PS1</code> 的内容.</p>
<pre><code class="language-bash">$ echo $PS1
[\u@\h \W]\$
</code></pre>
<p>注意:如果你 <code>shell</code> 提示符的内容和上例不是一模一样,也不必担心.
每个 <code>Linux</code> 发行版 定义的提示符稍微有点不同,其中一些相当异乎寻常.</p>
<p>从输出结果中,我们看到那个 <code>PS1</code> 环境变量包含一些这样的字符,比方说<code>中括号</code>,<code>@</code>符号,和<code>$</code>符号, 但是剩余部分就是个谜.
我们中一些机敏的人会把这些看作是由反斜杠转义的特殊字符,就像我们在第八章中看到的一样.
这里是一部分字符列表,在 <code>shell</code> 中会受到特殊对待:</p>
<hr />
<p>表14-1: Shell 提示符中用到的转义字符
序列 显示值</p>
<ul>
<li><code>\a</code> 以 ASCII 格式编码的铃声 . 当遇到这个转义序列时,计算机会发出嗡嗡的响声.</li>
<li><code>\d</code> 以日,月,天格式来表示当前日期.例如,<code>Mon May 26.</code></li>
<li><code>\h</code> 本地机的主机名,但不带末尾的域名.</li>
<li><code>\H</code> 完整的主机名.</li>
<li><code>\j</code> 运行在当前 shell 会话中的工作数.</li>
<li><code>\l</code> 当前终端设备名.</li>
<li><code>\n</code> 一个换行符.</li>
<li><code>\r</code> 一个回车符.</li>
<li><code>\s</code> shell 程序名.</li>
<li><code>\t</code> 以24小时制,<code>hours:minutes:seconds</code>的格式表示当前时间.</li>
<li><code>\T</code> 以12小时制表示当前时间.</li>
<li><code>@ </code>以12小时制,<code>AM/PM</code> 格式来表示当前时间.</li>
<li><code>\A</code> 以24小时制,<code>hours:minutes</code> 格式表示当前时间.</li>
<li><code>\u</code> 当前用户名.</li>
<li><code>\v</code> shell 程序的版本号.</li>
<li><code>\V</code> Version and release numbers of theshell.</li>
<li><code>\w</code> 当前工作目录名.</li>
<li><code>\W</code> 当前工作目录名的最后部分.</li>
<li><code>!</code> 当前命令的历史号.</li>
<li><code>#</code> 当前 <code>shell</code> 会话中的命令数.</li>
<li><code>\$</code> 这会显示一个<code>$</code>字符,除非你拥有超级用户权限.在那种情况下, 它会显示一个<code>#</code>字符.</li>
<li><code>\[</code> 标志着一系列一个或多个非打印字符的开始.这被用来嵌入非打印 的控制字符,这些字符以某种方式来操作终端仿真器,比方说移动光标或者是更改文本颜色.</li>
<li><code>\]</code> 标志着非打印字符序列结束.</li>
</ul>
<h3 id="试试一些可替代的提示符设计"><a class="header" href="#试试一些可替代的提示符设计">试试一些可替代的提示符设计</a></h3>
<p>参照这个特殊字符列表,我们可以更改提示符来看一下效果.首先, 我们把原来提示符字符串的内容备份一下,以备之后恢复原貌.</p>
<p>为了完成备份, 我们把已有的字符串复制到另一个 shell 变量中,这个变量是我们自己创造的.</p>
<pre><code class="language-bash">$ ps1_old=&quot;$PS1&quot;
</code></pre>
<p>我们新创建了一个叫做 <code>ps1_old</code> 的变量,并把变量 PS1的值赋 <code>ps1_old</code>.通过 <code>echo</code> 命令可以证明 我们的确复制了 PS1的值.</p>
<pre><code class="language-bash">$ echo $ps1_old
[\u@\h \W]\$
</code></pre>
<p>在终端会话中,我们能在任一时间复原提示符,只要简单地反向操作就可以了.</p>
<pre><code class="language-bash">$ PS1=&quot;$ps1_old&quot;
</code></pre>
<p>现在,我们准备开始,让我们看看如果有一个空的字符串会发生什么:</p>
<pre><code class="language-bash">$ PS1=
</code></pre>
<p>如果我们没有给提示字符串赋值,那么我们什么也得不到.
根本没有提示字符串!提示符仍然在那里, 但是什么也不显示,正如我们所要求的那样.我们将用一个最小的提示符来代替它:</p>
<pre><code class="language-bash">PS1=&quot;\$ &quot;
</code></pre>
<p>这样要好一些.至少能看到我们在做什么.注意双引号中末尾的空格.当提示符显示的时候, 这个空格把美元符号和光标分离开.
在提示符中添加一个响铃:</p>
<pre><code class="language-bash">$ PS1=&quot;\a\$ &quot;
</code></pre>
<p>现在每次提示符显示的时候,我们应该能听到嗡嗡声.这会变得很烦人,但是它可能会 很有用,特别是当一个需要运行很长时间的命令执行完后,我们要得到通知.</p>
<p>下一步,让我们试着创建一个信息丰富的提示符,包含主机名和当天时间的信息.</p>
<pre><code class="language-bash">$ PS1=&quot;\A \h \$ &quot;
17:33 linuxbox $
</code></pre>
<p>试试其他上表中列出的转义序列,看看你能否想出精彩的新提示符.</p>
<h3 id="添加颜色"><a class="header" href="#添加颜色">添加颜色</a></h3>
<p>大多数终端仿真器程序支持一定的非打印字符序列来控制,比方说字符属性(像颜色,黑体和可怕的闪烁) 和光标位置.我们会更深入地讨论光标位置,但首先我们要看一下字体颜色.</p>
<h4 id="混乱的终端时代"><a class="header" href="#混乱的终端时代">混乱的终端时代</a></h4>
<p>回溯到终端连接到远端计算机的时代,有许多竞争的终端品牌,它们各自工作不同.它们有着不同的键盘,以不同的方式来解释控制信息.</p>
<p><code>Unix</code> 和类 <code>Unix</code> 的系统有两个 相当复杂的子系统来处理终端控制领域的混乱局面(称为 termcap 和 <code>terminfo</code>).
如果你 查看一下终端仿真器最底层的属性设置,可能会找到一个关于终端仿真器类型的设置.</p>
<p>为了努力使所有的终端都讲某种通用语言,美国国家标准委员会(<code>ANSI</code>)制定了 一套标准的字符序列集合来控制视频终端.
原先 <code>DOS</code> 用户会记得 <code>ANSI.SYS</code> 文件, 这是一个用来使这些编码解释生效的文件.</p>
<p>字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 <code>ANSI</code> 转义编码来控制的.
这个控制编码不会<code>打印</code>到屏幕上,而是被终端解释为一个指令.正如我们在上表看到的字符序列, <code>\[</code> 和 <code>\]</code> 被用来封装这些非打印字符.</p>
<p>一个 <code>ANSI</code> 转义编码以一个八进制<code>033</code>(这个编码由<code>退出按键</code>产生)开头,其后跟着一个可选的字符属性,在之后是一个指令.</p>
<p>例如,把文本颜色 设为正常(<code>attribute = 0</code>),黑色文本的编码如下:</p>
<pre><code class="language-bash">\033[0;30m
</code></pre>
<p>这里是一个可用的文本颜色列表.
注意这些颜色被分为两组,由应用程序粗体字符属性(<code>1</code>) 分化开来,这个属性可以描绘出<code>浅</code>色文本.</p>
<hr />
<p>表14-2: 用转义序列来设置文本颜色
序列 文本颜色 序列 文本颜色</p>
<ul>
<li><code>\033[0;30m</code> 黑色 <code>\033[1;30m</code> 深灰色</li>
<li><code>\033[0;31m</code> 红色 <code>\033[1;31m</code> 浅红色</li>
<li><code>\033[0;32m</code> 绿色 <code>\033[1;32m</code> 浅绿色</li>
<li><code>\033[0;33m</code> 棕色 <code>\033[1;33m</code> 黄色</li>
<li><code>\033[0;34m</code> 蓝色 <code>\033[1;34m</code> 浅蓝色</li>
<li><code>\033[0;35m</code> 粉红 <code>\033[1;35m</code> 浅粉色</li>
<li><code>\033[0;36m</code> 青色 <code>\033[1;36m</code> 浅青色</li>
<li><code>\033[0;37m</code> 浅灰色 <code>\033[1;37m</code> 白色</li>
</ul>
<p>可以用<code>echo</code>探索这些效果,<code>echo -e</code>: enable interpretation of backslash escapes
<code>\033[0;36m</code>可以缩写成<code>\033[36m</code>,<code>\033[0;0m</code>代表默认颜色</p>
<pre><code class="language-bash">echo  -e &quot;\033[36m Testing output...  \033[0;36m Testing output... \033[0m Testing output... \033[0,0m Testing output...&quot;
echo  -e &quot;  \033[0;30m Testing output... \033[1;30m Testing output... &quot;
echo  -e &quot;\033[0;36m Testing output...  \033[0;37m Testing output...&quot;
echo  -e &quot;\033[1;36m Testing output...  \033[0m Testing output...&quot;
</code></pre>
<p>让我们试着制作一个红色提示符.我们将在开头加入转义编码:</p>
<pre><code class="language-bash">&lt;me@linuxbox ~&gt;$ PS1='\[\033[0;31m\]&lt;\u@\h \W&gt;\$'
&lt;me@linuxbox ~&gt;$
</code></pre>
<p>我们的提示符生效了,但是注意我们在提示符之后输入的文本也是红色的.
为了修改这个问题, 我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色.</p>
<pre><code class="language-bash">&lt;me@linuxbox ~&gt;$ PS1='\[\033[0;31m\]&lt;\u@\h \W&gt;\$\[\033[0m\]'
&lt;me@linuxbox ~&gt;$
</code></pre>
<p>这看起来要好些!</p>
<p>也有可能要设置文本的背景颜色,使用下面列出的转义编码.这个背景颜色不支持黑体属性.
在<code>zsh</code>中,支持<code>echo  -e &quot;\033[1;47m \033[1;32m Testing output... &quot;</code></p>
<hr />
<p>表14-3: 用转义序列来设置背景颜色
序列 文本颜色 序列 文本颜色</p>
<ul>
<li><code>\033[0;40m</code> 蓝色 <code>\033[1;44m</code> 黑色</li>
<li><code>\033[0;41m</code> 红色 <code>\033[1;45m</code> 粉红</li>
<li><code>\033[0;42m</code> 绿色 <code>\033[1;46m</code> 青色</li>
<li><code>\033[0;43m</code> 棕色 <code>\033[1;47m</code> 浅灰色</li>
</ul>
<p>我们可以创建一个带有红色背景的提示符,只是对第一个转义编码做个简单的修改.</p>
<pre><code class="language-bash">&lt;me@linuxbox ~&gt;$ PS1='\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\] '
&lt;me@linuxbox ~&gt;$
</code></pre>
<p>试试这些颜色编码,看看你能定制出怎样的提示符~</p>
<p>注意:除了正常的 (<code>0</code>) 和黑体 (<code>1</code>) 字符属性之外,文本也可以具有下划线 (<code>4</code>),闪烁 (<code>5</code>), 和反向 (<code>7</code>) 属性.
为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性.</p>
<h3 id="移动光标-1"><a class="header" href="#移动光标-1">移动光标</a></h3>
<p>转义编码也可以用来定位光标.</p>
<p>这些编码被普遍地用来,每次当提示符出现的时候,会在屏幕的不同位置比如说上面一个角落,显示一个时钟或者其它一些信息.
这里是一系列用来定位光标的转义编码:</p>
<hr />
<p>表14-4: 光标移动转义序列
转义编码 行动</p>
<ul>
<li><code>\033[l;cH</code>: 把光标移到第 <code>l</code> 行,第 <code>c</code> 列.</li>
<li><code>\033[nA</code>: 把光标向上移动 <code>n</code> 行.</li>
<li><code>\033[nB</code>: 把光标向下移动 <code>n</code> 行.</li>
<li><code>\033[nC</code>: 把光标向前移动 <code>n</code> 个字符.</li>
<li><code>\033[nD</code>: 把光标向后移动 <code>n</code> 个字符.</li>
<li><code>\033[2J</code>: 清空屏幕,把光标移到左上角(第零行,第零列).</li>
<li><code>\033[K</code>: 清空从光标位置到当前行末的内容.</li>
<li><code>\033[s</code>: 存储当前光标位置.</li>
<li><code>\033[u</code>: 唤醒之前存储的光标位置.</li>
</ul>
<p>使用上面的编码,我们将构建一个提示符,每次当这个提示符出现的时候,会在屏幕的上方画出一个包含时钟(由黄色文本渲染)的红色长条.
提示符的编码就是这个看起来令人敬畏的字符串:</p>
<pre><code class="language-bash">$ PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$ '
</code></pre>
<p>让我们分别看一下这个字符串的每一部分所表示的意思:</p>
<hr />
<p>序列 行动</p>
<ul>
<li><code>\[</code> 开始一个非打印字符序列.其真正的目的是为了让 bash 能够正确地计算提示符的大小.
如果没有这个转义字符的话,命令行编辑 功能会弄错光标的位置.</li>
<li><code>\033[s</code> 存储光标位置.这个用来使光标能回到原来提示符的位置, 当长条和时钟显示到屏幕上方之后.
当心一些终端仿真器不推崇这个编码.</li>
<li><code>\033[0;0H</code> 把光标移到屏幕左上角,也就是第零行,第零列的位置.</li>
<li><code>\033[0;41m</code> 把背景设置为红色.</li>
<li><code>\033[K</code> 清空从当前光标位置到行末的内容.因为现在 背景颜色是红色,则被清空行背
景成为红色,以此来创建长条.注意虽然一直清空到行末, 但是不改变光标位置,它仍然在屏幕左上角.</li>
<li><code>\033[1;33m</code> 把文本颜色设为黄色.</li>
<li><code>\t</code> 显示当前时间.虽然这是一个可<code>打印</code>的元素,但我们仍把它包含在提示符的非打印部分,
因为我们不想 bash在计算可见提示符的真正大小时包括这个时钟在内.</li>
<li><code>\033[0m</code> 关闭颜色设置.这对文本和背景都起作用.</li>
<li><code>\033[u</code> 恢复到之前保存过的光标位置处.</li>
<li><code>\]</code> 结束非打印字符序列.</li>
<li><code>\$</code> 提示符字符串.</li>
</ul>
<h3 id="保存提示符"><a class="header" href="#保存提示符">保存提示符</a></h3>
<p>显然地,我们不想总是敲入那个怪物,所以我们将要把这个提示符存储在某个地方.
通过把它 添加到我们的.bashrc 文件,可以使这个提示符永久存在.为了达到目的,把下面这两行添加到<code>.bashrc</code> 文件中.</p>
<pre><code class="language-bash">PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$ '
export PS1
</code></pre>
<p>总结归纳</p>
<p>不管你信不信,还有许多事情可以由提示符来完成,涉及到我们在这里没有论及的 shell 函数和脚本, 但这是一个好的开始.</p>
<p>并不是每个人都会花心思来更改提示符,因为通常默认的提示符就很让人满意.
但是对于我们这些喜欢思考的人们来说,shell 却提供了许多制造琐碎乐趣的机会.</p>
<p>拓展阅读</p>
<p>The Bash Prompt HOWTO 来自于 Linux 文档工程,对 shell 提示符的用途进行了相当 完备的论述.可在以下链接中得到:
http://tldp.org/HOWTO/Bash-Prompt-HOWTO/</p>
<p>Wikipedia 上有一篇关于 ANSI Escape Codes 的好文章:
http://en.wikipedia.org/wiki/ANSI_escape_code</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-6"><a class="header" href="#linux-6">linux-6</a></h1>
<h2 id="第十七章网络系统"><a class="header" href="#第十七章网络系统">第十七章:网络系统</a></h2>
<p>几乎网络系统层面的任何东西都能由 Linux 来实现.
<code>Linux</code> 被用来创建各式各样的网络系统和装置, 包括防火墙,路由器,名称服务器,网络连接式存储设备等等.</p>
<p>被用来配置和操作网络系统的命令数目,就如网络系统一样巨大.我们仅仅关注一些最经常使用到的命令.
我们要研究的命令包括监测网络和传输文件的命令.另外,我们还会探讨用来远端登录的 <code>ssh</code> 程序.</p>
<p>这章会介绍:</p>
<ul>
<li><code>ping</code> - 发送 <code>ICMP ECHO_REQUEST</code> 软件包到网络主机</li>
<li><code>traceroute</code> - 打印到一台网络主机的路由数据包</li>
<li><code>netstat</code> - 打印网络连接,路由表,接口统计数据,伪装连接,和多路广播成员</li>
<li><code>ftp</code> - 因特网文件传输程序</li>
<li><code>wget</code> - 非交互式网络下载器</li>
<li><code>ssh</code> - OpenSSH SSH 客户端(远程登录程序)</li>
</ul>
<p><code>pint ifconfig netstat traceroute</code> 等在软件包 <code>gnome-nettool</code> 里面</p>
<p>假定你已经知道了一些网络系统背景知识.在因特网时代,每个计算机用户都需要理解基本的网络系统概念.
为了能够充分利用这一章节的内容,我们应该熟悉以下术语:</p>
<ul>
<li><code>IP</code> (网络协议)地址</li>
<li><code>主机</code>和<code>域名</code></li>
<li><code>URI</code>(统一资源标识符)</li>
</ul>
<p>请查看下面的<code>拓展阅读</code>部分,有几篇关于这些术语的有用文章.</p>
<p>注意:一些将要讲到的命令可能(取决于系统发行版)需要从系统发行版的仓库中安装额外的软件包, 并且一些
命令可能需要超级用户权限才能执行.</p>
<h3 id="检查和监测网络"><a class="header" href="#检查和监测网络">检查和监测网络</a></h3>
<p>即使你不是一名系统管理员,检查一个网络的性能和运作情况也很有帮助, 最基本的网络命令是 <code>ping</code>:</p>
<pre><code class="language-bash">ping
</code></pre>
<p>这个 <code>ping</code> 命令发送一个特殊的网络数据包,叫做<code>IMCP ECHO_REQUEST</code>,到 一台指定的主机.
大多数接收这个包的网络设备将会回复它,来允许网络连接验证.</p>
<p>注意:大多数网络设备(包括 Linux 主机)都可以被配置为忽略这些数据包.
通常,这样做是出于网络安全原因,部分地遮蔽一台主机免受一个潜在攻击者地侵袭.配置防火墙来阻塞 <code>IMCP</code> 流量也很普遍.</p>
<p>例如,看看我们能否连接到网站 <code>linuxcommand.org</code>(我们最喜欢的网站之一), 我们可以这样使用 <code>ping</code> 命令:</p>
<pre><code class="language-bash">$ ping linuxcommand.org
</code></pre>
<p>一旦启动,<code>ping</code> 命令会按特定间隔(默认是一秒)持续发送数据包,直到它被中断:</p>
<pre><code class="language-bash">$ ping linuxcommand.org
PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.
...
</code></pre>
<p>按下组合键 <code>Ctrl-c</code>,中断这个命令之后,<code>ping</code> 打印出运行统计信息.一个正常工作的网络会报告零个数据包丢失.
一个成功执行的<code>ping</code>命令会意味着网络的各个部件(网卡,电缆,路由,网关) 都处于正常的工作状态.</p>
<hr />
<p>一些概念介绍:</p>
<p><code>Maximum Transmission Unit</code>,缩写<code>MTU</code>,中文名是: 最大传输单元.它是哪一层网络的概念?</p>
<p>从下面这个表格中可以看到,在<code>7</code>层网络协议中,<code>MTU</code>是数据链路层的概念.<code>MTU</code>限制的是数据链路层的<code>payload</code>,也就是上层协议的大小,例如<code>IP</code>,<code>ICMP</code>等.</p>
<hr />
<p><code>OSI</code>中的层  功能  <code>TCP/IP</code>协议族</p>
<ul>
<li>应用层  文件传输,电子邮件,文件服务,虚拟终端  <code>TFTP</code>,<code>HTTP</code>,<code>SNMP</code>,<code>FTP</code>,<code>SMTP</code>,<code>DNS</code>,<code>Telnet</code></li>
<li>表示层  <code>数据格式化</code>,<code>代码转换</code>,<code>数据加密</code>  <code>没有协议</code></li>
<li>会话层  解除或建立与别的接点的联系  <code>没有协议</code></li>
<li>传输层  提供端对端的接口  <code>TCP</code>,<code>UDP</code></li>
<li>网络层  为数据包选择路由  <code>IP</code>,<code>ICMP</code>,<code>RIP</code>,<code>OSPF</code>,<code>BGP</code>,<code>IGMP</code></li>
<li>数据链路层  传输有地址的帧以及错误检测功能  <code>SLIP</code>,<code>CSLIP</code>,<code>PPP</code>,<code>ARP</code>,<code>RARP</code>,<code>MTU</code></li>
<li>物理层  以二进制数据形式在物理媒体上传输数据  <code>ISO2110</code>,<code>IEEE802</code>,<code>IEEE802.2</code></li>
</ul>
<hr />
<p><code>tracepath</code>, <code>tracepath6</code> - traces path to a network host discovering MTU along this path</p>
<p><code>traceroute</code> 程序(<code>ubuntu</code> 使用相似的 <code>tracepath</code> 程序来代替)会显示从本地到指定主机 要经过的所有<code>跳数</code>的网络流量列表.</p>
<p>例如,看一下到达 <code>soso.com</code> 网站,需要经过的路由 器,我们将这样做:</p>
<pre><code>$ traceroute soso.com
traceroute to soso.com (216.34.181.45), 30 hops max, 40 bytepackets
1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms
2 * * *
...
...
</code></pre>
<p>从输出结果中,我们可以看到连接测试系统到 <code>soso.com</code> 网站需要经由<code>30</code>个路由器.
对于那些 提供标识信息的路由器,我们能看到它们的主机名,<code>IP</code> 地址和性能数据,这些数据包括三次从本地到 此路由器的往返时间样
本.</p>
<p>对于那些没有提供标识信息的路由器(由于路由器配置,网络拥塞,防火墙等 方面的原因),我们会看到几个星号,正如行中所示.</p>
<p><a href="https://developer.aliyun.com/article/222535">什么是MTU? 为什么MTU值普遍都是1500? </a></p>
<h3 id="netstat"><a class="header" href="#netstat">netstat</a></h3>
<p><code>netstat</code> 程序被用来检查各种各样的网络设置和统计数据.通过此命令的许多选项,我们 可以看看网络设置中的各种特性.
使用<code>-ie</code>选项,我们能够查看系统中的网络接口:</p>
<pre><code class="language-bash">$ netstat -ie
enp0s31f6: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.218.191  netmask 255.255.255.0  broadcast 192.168.218.255
        inet6 xxxx:xxxx:1:2218:8eec:4bff:fe91:d65b  prefixlen 64  scopeid 0x0&lt;global&gt;
        ...
lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
    inet 127.0.0.1  netmask 255.0.0.0
    inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
    ...
</code></pre>
<p>在上述实例中,我们看到我们的测试系统有两个网络接口.
第一个,叫做<code>enp0s31f6</code>,是 因特网接口,和第二个,叫做 <code>lo</code>,是内部回环网络接口,它是一个虚拟接口,系统用它来 <code>自言自语</code>.</p>
<p>当执行日常网络诊断时,要查看的重要信息是每个网络接口第一行开头出现的单词 <code>UP</code>,
说明这个网络接口已经生效,还要查看第二行中 <code>inet</code> 字段出现的有效 <code>IP</code> 地址.</p>
<p>对于使用 <code>DHCP</code>(动态主机配置协议)的系统,在这个字段中的一个有效 <code>IP</code> 地址则证明了 <code>DHCP</code> 工作正常.
使用这个<code>-r</code>选项会显示内核的网络路由表.这展示了系统是如何配置网络之间发送数据包的.</p>
<pre><code class="language-bash">$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask             Flags   MSS     Window          irtt Iface
192.168.1.1         *             255.255.255.0         U        0         0          0 enp0s31f6
default             192.168.1.1         0.0.0.0                 UG          0       0 enp0s31f6
...
</code></pre>
<p>在这个简单的例子里面,我们看到了,位于防火墙之内的局域网中,一台客户端计算机的典型路由表.</p>
<p>第一行显示了目的地 <code>192.168.1.0</code>.IP 地址以零结尾是指网络,而不是个人主机, 所以这个目的地意味着局域网中的任何一台主机.
下一个字段,<code>Gateway</code>, 是网关(路由器)的名字或 <code>IP</code> 地址,用它来连接当前的主机和目的地的网络.
若这个字段显示一个星号,则表明不需要网关.</p>
<p>最后一行包含目的地 <code>default</code>.指的是发往任何表上没有列出的目的地网络的流量.
在我们的实例中,我们看到网关被定义为地址 <code>192.168.1.1</code> 的路由器,它应该能 知道怎样来处理目的地流量.
<code>netstat</code> 程序有许多选项,我们仅仅讨论了几个.查看 <code>netstat</code> 命令的手册,可以 得到所有选项的完整列表.</p>
<h3 id="网络中传输文件"><a class="header" href="#网络中传输文件">网络中传输文件</a></h3>
<p>网络有什么用处呢?除非我们知道了怎样通过网络来传输文件.
有许多程序可以用来在网络中传送数据.我们先讨论两个命令,随后的章节里再介绍几个命令.</p>
<h4 id="ftp"><a class="header" href="#ftp">ftp</a></h4>
<p><code>ftp</code> 命令属于真正的<code>经典</code>程序之一,它的名字来源于其所使用的协议,就是文件传输协议.</p>
<p><code>FTP</code> 被广泛地用来从因特网上下载文件.
大多数,并不是所有的,网络浏览器都支持 <code>FTP</code>, 你经常可以看到它们的 URI 以协议<code>ftp://</code>开头.</p>
<p>在出现网络浏览器之前,<code>ftp</code> 程序已经存在了.
<code>ftp</code> 程序可用来与 <code>FTP</code> 服务器进行通信,<code>FTP</code> 服务器就是存储文件的计算机,这些文件能够通过 网络下载和上传.</p>
<p><code>FTP</code>(它的原始形式)并不是安全的,因为它会以明码形式发送帐号的姓名和密码.
这就意味着 这些数据没有加密,任何嗅探网络的人都能看到.
由于此种原因,几乎因特网中所有 <code>FTP</code> 服务器 都是匿名的.
一个匿名服务器能允许任何人使用注册名<code>anonymous</code>和无意义的密码登录系统.</p>
<p>在下面的例子中,我们将展示一个典型的会话,
从匿名 <code>FTP</code> 服务器-- <code>fileserver</code>的<code>/pub/_images/Ubuntu-8.04</code>的目录下,
使用 ftp 程序下载一个 Ubuntu 系统映像文件.</p>
<pre><code class="language-bash">$ ftp fileserver
Connected to fileserver.localdomain.
...
Password:
...
ftp&gt; cd pub/cd\_images/Ubuntu-8.04
250 Directory successfully changed.
ftp&gt; ls
200 PORT command successful. Consider using PASV.
...
ftp&gt; lcd Desktop
Local directory now /home/me/Desktop
ftp&gt; get ubuntu-8.04-desktop-i386.iso
local: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-
i386.iso
...
ftp&gt; bye
</code></pre>
<p>这里是对会话期间所输入命令的解释说明:</p>
<hr />
<p>表17-1:
命令 意思</p>
<ul>
<li><code>ftp fileserver</code> 唤醒 <code>ftp</code> 程序,让它连接到 FTP 服务器,<code>fileserver</code> .</li>
<li><code>anonymous</code> 登录名.输入登录名后,将出现一个密码提示.一些服务器将会接受空密码,其它一些则会要求一个邮件地址形式的密码.如果是这种情况,试着输入<code>user@example.com</code>.</li>
<li><code>cd pub/cd_images/Ubuntu-8.04</code> 跳转到远端系统中,要下载文件所在的目录下, 注意在大多数匿名的 FTP 服务器中,支持公共下载的文件都能在目录 <code>pub</code> 下找到</li>
<li><code>ls</code> 列出远端系统中的目录.</li>
<li><code>lcd Desktop</code> 跳转到本地系统中的 <code>~/Desktop</code> 目录下.在实例中,<code>ftp</code> 程序在工作目录 <code>~</code>下被唤醒. 这个命令把工作目录改为<code>~/Desktop</code></li>
<li><code>get ubuntu-8.04-desktop-i386.iso</code> 告诉远端系统传送文件到本地.因为本地系统的工作目录 已经更改到了<code>~/Desktop</code>,所以文件会被下载到此目录.</li>
<li><code>bye</code> 退出远端服务器,结束 ftp 程序会话.也可以使用命令 <code>quit</code> 和 <code>exit</code> .</li>
</ul>
<p>在 <code>ftp&gt;</code> 提示符下,输入 <code>help</code>,会显示所支持命令的列表.
使用 <code>ftp</code> 登录到一台 授予了用户足够权限的服务器中,则可以执行很多普通的文件管理任务.虽然很笨拙, 但它真能工作.</p>
<h3 id="lftp---更好的-ftp"><a class="header" href="#lftp---更好的-ftp">lftp - 更好的 ftp</a></h3>
<p>ftp 并不是唯一的命令行形式的 FTP 客户端.
实际上,还有很多.其中比较好(也更流行的)是 <code>lftp</code> 程序, 由Alexander Lukyanov 编写完成.</p>
<p>虽然 <code>lftp</code> 工作起来与传统的 ftp 程序很相似,但是它带有额外的便捷特性,
包括 多协议支持(包括 HTTP),若下载失败会自动地重新下载,后台处理,用 tab 按键来补全路径名,还有很多.</p>
<h4 id="wget"><a class="header" href="#wget">wget</a></h4>
<p>另一个流行的用来下载文件的命令行程序是 <code>wget</code>.</p>
<p>若想从网络和 FTP 网站两者上都能下载数据,<code>wget</code> 是很有用处的.
不只能下载单个文件,多个文件,甚至整个网站都能下载.
下载 linuxcommand.org 网站的首页, 我们可以这样做:</p>
<pre><code class="language-bash">$ wget http://linuxcommand.org/index.php
--11:02:51-- http://linuxcommand.org/index.php
=&gt; `index.php'
Resolving linuxcommand.org... 66.35.250.210
...
11:02:51 (161.75 MB/s) - 'index.php' saved [3120]
</code></pre>
<p>这个程序的许多选项允许 <code>wget</code> 递归地下载,在后台下载文件(你退出后仍在下载),能完成未下载全的文件.
这些特性在命令手册,<code>better-than-average</code> 一节中有详尽地说明.</p>
<ul>
<li><code>-r</code> <code>--recursive</code>: Turn on recursive retrieving.    The default maximum depth is <code>5</code>.</li>
<li><code>-b</code> <code>--background</code>:  Go to background immediately after startup.
If no output file is specified via the <code>-o</code>, output is redirected to wget-log.</li>
<li><code>-c</code> <code>--continue</code> Continue getting a partially-downloaded file.
This is useful when you want to finish up a download started by a previous instance of Wget, or by another program.  For instance: <code>wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z</code></li>
</ul>
<h3 id="与远程主机安全通信"><a class="header" href="#与远程主机安全通信">与远程主机安全通信</a></h3>
<p>通过网络来远程操控类 Unix 的操作系统已经有很多年了.</p>
<p>早些年,在因特网普遍推广之前,有 一些受欢迎的程序被用来登录远程主机.它们是 rlogin 和 telnet 程序.
然而这些程序,拥有和 <code>ftp</code> 程序 一样的致命缺点;它们以明码形式来传输所有的交流信息(包括登录命令和密码).
这使它们完全不 适合使用在因特网时代.</p>
<h3 id="ssh协议"><a class="header" href="#ssh协议">ssh协议</a></h3>
<p>为了解决这个问题,开发了一款新的协议,叫做 SSH(Secure Shell). SSH 解决了这两个基本的和远端主机安全交流的问题.</p>
<p>首先,它要认证远端主机是否为它 所知道的那台主机(这样就阻止了所谓的<code>中间人</code>的攻击),
其次,它加密了本地与远程主机之间 所有的通讯信息.</p>
<p><code>SSH</code> 由两部分组成.</p>
<p><code>SSH </code><strong>服务器</strong>运行在远端主机上运行,在端口号<code>22</code>上监听将要到来的连接,而 <code>SSH</code> <strong>客户端</strong>用在本地系统中,用来和远端服务器通信.</p>
<p>大多数 Linux 发行版自带一个提供 SSH 功能的软件包,叫做 <code>OpenSSH</code>,来自于 <code>BSD</code> 项目.
一些发行版 默认包含客户端和服务器端两个软件包(例如,<code>Red Hat</code>),而另一些(比方说 <code>Ubuntu</code>)则只是提供客户端服务.
为了能让系统接受远端的连接,它必须安装 <code>OpenSSH-server</code> 软件包,配置运行它, 并且须允许它在 <code>TCP</code> 端口号上接收网络链接(如果系统运在防火墙之后) .</p>
<p>小贴示:如果你没有远端系统去连接,但还想试试这些实例,则确认安装了 <code>OpenSSH-server</code> 软件包 ,则可使用 <code>localhost</code> 作为远端主机的名字.这种情况下,计算机会和它自己创建网络连接.</p>
<p>用来与远端 <code>SSH</code> 服务器相连接的 <code>SSH</code> 客户端程序,顺理成章,叫做 <code>ssh</code>. 连接到远端名为 <code>remote-sys</code> 的主机,我们可以这样使用 <code>ssh</code> 客户端程序:</p>
<pre><code class="language-bash">$ ssh remote-sys
The authenticity of host 'remote-sys (192.168.1.4)' can't be
established.
RSA key fingerprint is
41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>第一次尝试连接,提示信息表明远端主机的真实性不能确立.这是因为客户端程序以前从没有看到过这个远端主机.
为了接受远端主机的身份验证凭据,输入<code>yes</code>.一旦建立了连接,会提示 用户输入他或她的密码:</p>
<pre><code class="language-bash">Warning: Permanently added 'remote-sys,192.168.1.4' (RSA) to the list
of known hosts.
me@remote-sys's password:
</code></pre>
<p>成功地输入密码之后,我们会接收到远端系统的 <code>shell</code> 提示符:</p>
<pre><code class="language-bash">Last login: Sat Aug 30 13:00:48 2008
[me@remote-sys ~]$
</code></pre>
<p>远端 <code>shell</code> 会话一直存在,直到用户输入 <code>exit</code> 命令后,则关闭了远程连接.这时候,本地的 shell 会话 恢复,本地 shell 提示符重新出现.</p>
<p>也有可能使用不同的用户名连接到远程系统.
例如,如果本地用户<code>me</code>,在远端系统中有一个帐号名<code>bob</code>,则用户 <code>me</code> 能够用 <code>bob</code> 帐号登录到远端系统,如下所示:</p>
<pre><code class="language-bash">$ ssh bob@remote-sys
bob@remote-sys's password:
Last login: Sat Aug 30 13:03:21 2008
[bob@remote-sys ~]$
</code></pre>
<p>正如之前所讲到的,<code>ssh</code> 验证远端主机的真实性.如果远端主机不能成功地通过验证,则会提示以下信息:</p>
<pre><code class="language-bash">$ ssh remote-sys
@@@@@@@@@@@@@@@@@@@@@...
WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
@
@@@@@@@@@@@@@@@@@...
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle
attack)!
...
</code></pre>
<p>有两种可能的情形会提示这些信息.第一,某个攻击者企图制造<code>中间人</code>袭击.
这很少见, 因为每个人都知道ssh 会针对这种状况发出警告.</p>
<p>最有可能的罪魁祸首是远端系统已经改变了; 例如,它的操作系统或者是 SSH服务器重新安装了.
然而,为了安全起见,第一个可能性不应该 被轻易否定.当这条消息出现时,总要与远端系统的管理员查对一下.</p>
<p>当确定了这条消息归结为一个良性的原因之后,那么在客户端更正问题就很安全了.
使用文本编辑器(可能是vim)从文件<code>~/.ssh/known_hosts</code> 中删除废弃的钥匙, 就解决了问题.
在上面的例子里,我们看到这样一句话:</p>
<pre><code class="language-bash">Offending key in /home/me/.ssh/known_hosts:1
</code></pre>
<p>这意味着文件 <code>known_hosts</code> 里面某一行包含攻击型的钥匙.
从文件中删除这一行,则 ssh 程序 就能够从远端系统接受新的身份验证凭据.</p>
<p>除了能够在远端系统中打开一个 shell 会话,ssh 程序也允许我们在远端系统中执行单个命令.
例如,在名为<code>remote-sys</code> 的远端主机上,执行 <code>free</code> 命令,并把输出结果显示到本地系统 shell 会话中.</p>
<pre><code class="language-bash">$ ssh remote-sys free
me@twin4's password:
...
$
</code></pre>
<p>有可能以更有趣的方式来利用这项技术,比方说下面的例子,我们在远端系统中执行 <code>ls</code> 命令, 并把命令输出重
定向到本地系统中的一个文件里面.</p>
<pre><code class="language-bash">$ ssh remote-sys 'ls *' &gt; dirlist.txt
me@twin4's password:
$
</code></pre>
<p>注意,上面的例子中使用了单引号.这样做是因为我们不想路径名展开操作在本地执行 ;而希望 它在远端系统中被执行.
同样地,如果我们想要把输出结果重定向到远端主机的文件中,我们可以 把重定向操作符和文件名都放到单引号里面.</p>
<pre><code class="language-bash">$ ssh remote-sys 'ls * &gt; dirlist.txt'
</code></pre>
<h3 id="ssh-通道"><a class="header" href="#ssh-通道">SSH 通道</a></h3>
<p>当你通过 SSH 协议与远端主机建立连接的时候,其中发生的事就是在本地与远端系统之间 创建了一条加密通道.
通常,这条通道被用来把在本地系统中输入的命令安全地传输到远端系统, 同样地,再把执行结果安全地发送回来.
除了这个基本功能之外,SSH 协议允许大多数网络流量类型通过这条加密通道来被传送,在本地与远端系统之间创建某种 VPN(虚拟专用网络).</p>
<p>可能这个特性的最普遍使用是允许传递 <code>X</code> 窗口系统流量.</p>
<p>在运行着 <code>X</code> 服务器(也就是, 能显示 GUI 的机器)的系统中,有可能在远端启动和运行一个 <code>X</code> 客户端程序(一个图形化应用程序), 而应用程序的显示结果出现在本地.</p>
<p>这很容易完成,这里有个例子:
假设我们正坐在一台装有 Linux 系统, 叫做 <code>linuxbox</code> 的机器之前,且系统中运行着 <code>X</code> 服务器,
现在我们想要在名为 <code>remote-sys</code> 的远端系统中运行 <code>xload</code> 程序,但是要在我们的本地系统中看到这个程序的图形化输出.
我们可以这样做:</p>
<pre><code class="language-bash">$ ssh -X remote-sys
me@remote-sys's password:
Last login: Mon Sep 08 13:23:11 2008
[me@remote-sys ~]$ xload
</code></pre>
<p>这个 <code>xload</code> 命令在远端执行之后,它的窗口就会出现在本地.
在某些系统中,你可能需要 使用 <code>-Y</code> 选项,而不是 <code>-X</code> 选项来完成这个操作.</p>
<h3 id="scp-和--sftp"><a class="header" href="#scp-和--sftp">scp 和  sftp</a></h3>
<p>这个 <code>OpenSSH</code> 软件包也包含两个程序,它们可以利用 <code>SSH</code> 加密通道在网络间复制文件. 第一个:<code>scp</code>(安全复制)被用来复制文件,与熟悉的 <code>cp</code> 程序非常相似.
最显著的区别就是源或者目标路径名要以远端主机的名字<code>remote-sys</code>开头,后跟一个<strong>冒号</strong>字符开头. 这里的<code>remote-sys</code>可以写在 <code>ssh</code> 的配置文件中,后面会讲如何配置 <code>~/.ssh/config</code>.
比如复制远程服务器<code>dell</code>下的<code>~/Desktop/draft.lyx</code>这个文件到当前目录<code>.</code>,下面的方法都是可以的</p>
<pre><code class="language-bash">scp tom@192.168.218.191:~/Desktop/draft.lyx .
scp tom@dell:~/Desktop/draft.lyx .
scp dell:~/Desktop/draft.lyx .
scp dell:document.txt . #不写明路径则默认是家目录下

</code></pre>
<p>和 <code>ssh</code> 命令一样,如果你所期望的远端主机帐户与你本地系统中的不一致, 则可以把用户名添加到远端主机名的开头.</p>
<pre><code class="language-bash">$ scp bob@remote-sys:document.txt .
</code></pre>
<p>第二个 <code>SSH</code> 文件复制命令是 <code>sftp</code>,正如其名字所示,它是 <code>ftp</code> 程序的安全替代品.
<code>sftp</code> 工作起来与我们 之前使用的 <code>ftp</code> 程序很相似;然而,它不用明码形式来传递数据,它使用加密的 <code>SSH</code> 通道.</p>
<p><code>sftp</code> 有一个 重要特性强于传统的 <code>ftp</code> 命令,就是 <code>sftp</code> 不需要远端系统中运行 <code>FTP</code> 服务器.它仅仅要求 <code>SSH</code> 服务器.
这意味着任何一台能用 <code>SSH</code> 客户端连接的远端机器,也可当作类似于 <code>FTP</code> 的服务器来使用. 这里是一个样本会话:</p>
<pre><code class="language-bash">$ sftp remote-sys
Connecting to remote-sys...
me@remote-sys's password:
sftp&gt; ls
ubuntu-8.04-desktop-i386.iso
sftp&gt; lcd Desktop
sftp&gt; get ubuntu-8.04-desktop-i386.iso
Fetching /home/me/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-
desktop-i386.iso
/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35
sftp&gt; bye
</code></pre>
<p>小贴示:这个 <code>SFTP</code> 协议被许多 <code>Linux</code> 发行版中的图形化文件管理器支持.
使用 <code>Nautilus</code> (GNOME), 或者是 <code>Konqueror</code> (KDE),我们都能在位置栏中输入以 <code>sftp://</code> 开头的 URI, 来操作存储在运行着 SSH 服务器的远端系统中的文件.</p>
<h3 id="windows-中的-ssh-客户端"><a class="header" href="#windows-中的-ssh-客户端">Windows 中的 SSH 客户端</a></h3>
<p>比方说你正坐在一台 Windows 机器前面,但是你需要登录到你的 Linux 服务器中,去完成 一些实际的工作,那该怎么办呢?
当然是得到一个 Windows 平台下的 SSH 客户端!有很多这样 的工具.</p>
<p>最流行的可能就是由 Simon Tatham 和他的团队开发的 <code>PuTTY</code> 了.
这个 <code>PuTTY</code> 程序 能够显示一个终端窗口,而且允许Windows 用户在远端主机中打开一个 SSH(或者 telnet)会话.
这个程序也提供了 <code>scp</code> 和 <code>sftp</code> 程序的类似物.</p>
<p><a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/">PuTTY链接</a></p>
<p>拓展阅读</p>
<p>Linux 文档项目提供了 Linux 网络管理指南,可以广泛地(虽然过时了)了解网络管理方面的知识.</p>
<p><a href="http://tldp.org/LDP/nag2/index.html">http://tldp.org/LDP/nag2/index.html</a></p>
<p><code>Wikipedia</code> 上包含了许多网络方面的优秀文章.这里有一些基础的:</p>
<p><a href="http://en.wikipedia.org/wiki/Internet_protocol_address">http://en.wikipedia.org/wiki/Internet_protocol_address</a>
<a href="http://en.wikipedia.org/wiki/Host_name">http://en.wikipedia.org/wiki/Host_name</a>
<a href="http://en.wikipedia.org/wiki/Uniform_Resource_Identifier">http://en.wikipedia.org/wiki/Uniform_Resource_Identifier</a></p>
<h3 id="ssh-ipv6"><a class="header" href="#ssh-ipv6">ssh ipv6</a></h3>
<p><a href="http://beanocean.github.io/tech/2014/10/17/scp_ipv6/">Linux下通过IPv6使用SSH和SCP</a></p>
<p>解决这个问题的主要思路有两个,第一个是在路由器上设置<code>NAT</code>,进行端口映射;
第二个便是利用<code>IPv6</code>登录. 其中,<code>IPv6</code>的方式最方便(Linux默认是开启<code>IPv6</code>服务的),无须多余设置,只需要知道<code>IPv6</code>地址即可.
具体方法如下: (假设<code>IPv6</code>地址为<code>2101:da8:a000:12:bc26:9915:4b1d:64cc</code>)</p>
<hr />
<p><code>ssh</code>远程登录服务器</p>
<pre><code class="language-bash"># 用法:
ssh [username]@[IPv6_Host] -p [port number]
# 例子:
ssh lg@2101:da8:a000:12:bc26:9915:4b1d:64cc -p 1234
</code></pre>
<hr />
<p><code>SCP</code>拷贝文件</p>
<pre><code class="language-bash"># 用法;
scp [username]@[IPv6_Host]:[file_path] [target_path]
# 例子:
scp lg@\[2101:da8:a000:12:bc26:9915:4b1d:64cc\]:/home/lg/example.c ~/home/lg/src
</code></pre>
<p>这里需要注意的是,由于<code>IPv6</code>地址中的冒号和<code>host</code>中的冒号有冲突,需要用中括号加转义字符的方式把<code>IPv6</code>的地址括起来.</p>
<h3 id="补充ssh的使用"><a class="header" href="#补充ssh的使用">补充:ssh的使用</a></h3>
<hr />
<p>连接服务器</p>
<p><a href="https://www.jianshu.com/p/e6d308e9162f">Linux SSH 使用</a></p>
<p>确认安装好<code>ssh</code>并启动后,我们在<code>windows</code>, <code>mac</code>上或者其他<code>linux</code>服务器上通过以下命令便可以连接到这台主机</p>
<pre><code class="language-bash">ssh root@192.168.0.105
</code></pre>
<p><code>root</code> 表示你连接改服务器的用户名</p>
<p><code>192.168.0.105</code> 是服务器<code>ip</code>.这个<code>ip</code>不能使用内网<code>ip</code>,如果是本地虚拟机的话,可以将连接方式改为<code>桥接</code>的方式.
然后用<code>ifconfig</code>查看本机公网<code>ip</code></p>
<hr />
<p><code>ssh</code> 的 <code>config</code> 文件</p>
<p>先展示一下<code>SSH config</code> 语法关键字,如下五个:</p>
<ul>
<li><code>Host</code> 别名</li>
<li><code>HostName</code> 主机名</li>
<li><code>Port</code> 端口</li>
<li><code>User</code> 用户名</li>
<li><code>IdentityFile</code> 密钥文件的路径</li>
</ul>
<p>这个<code>config</code>的路径在服务的位置是 <code>~/.ssh/config</code> 如果没有找到这个文件,就在<code>&gt;~/.ssh/config</code></p>
<p>那么说到这个文件我们怎么用呢?
实际上在平时的运维管理中,我们可能管理多台机器,可能是几台,十几台甚至上百台.
我们将这些服务器配置在<code>config</code>中,方便我们去连接和管理.</p>
<p>例如:(<code>IdentityFile</code>可以暂时不配置,<code>ssh</code>默认端口为<code>22</code>)</p>
<pre><code class="language-bash">host &quot;KatoUyi&quot;
    HostName 192.168.0.105
    User root
    Port 22
    IdentityFile  ~/.ssh/id_rsa
    IdentitiesOnly  yes

host &quot;NagaSiren&quot;
    HostName 192.168.0.106
    User root
    Port 22
</code></pre>
<p>在配置了这个文件之后,我们不需要再通过 <code>ssh root@192.168.0.105</code> 这个命令去连接服务器了,
我们可以这么写连接语句 <code>ssh KatoUyi</code> .这样管理方式在一定程度上简化了我们的操作.</p>
<hr />
<p>SSH免密登录ssh-keygen</p>
<p><a href="https://www.jb51.net/article/163093.htm">Linux 配置SSH免密登录<code>ssh-keygen</code></a></p>
<p>为了在不同平台/网络主机之间的通信安全, 很多时候我们都要通过<code>ssh</code>进行认证. <code>ssh</code>认证方式主要有2种:</p>
<ul>
<li>基于口令的安全认证: 每次登录的时候都要输入用户名和密码, 由于要在网络上传输密码, 可能存在中间人攻击的风险;</li>
<li>基于密钥的安全认证: 配置完成后就可以实现免密登录, 这种方式更加安全 -- 不需要在网络上传递口令, 只需要传输一次公钥.
常见的<code>git</code>的<code>ssh</code>方式就是通过公钥进行认证的.</li>
</ul>
<p>说明: 这里演示所用的服务器操作系统是<code>Cent OS 7</code>. 我们的目标是:
<code>A</code>服务器(<code>172.16.22.131</code>) 能免密登录<code>B</code>服务器 (<code>172.16.22.132</code>).</p>
<p>注意: <code>ssh</code>连接是单向的, <code>A</code>能免密登录<code>B</code>, 并不能同时实现<code>B</code>能免密登录<code>A</code>.</p>
<hr />
<p>安装必需的软件</p>
<p>在操作之前, 先确保所需要的软件已经正常安装.</p>
<p>这里我们需要安装<code>ssh-keygen</code>和<code>ssh-copy-id</code>,</p>
<hr />
<p><code>ssh-keygen</code>创建公钥-私钥对</p>
<ol>
<li>在指定目录下生成<code>rsa</code>密钥, 并指定注释为<code>xxx</code>, 实现示例:</li>
</ol>
<pre><code class="language-bash">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa -C &quot;xxxxx&quot;
#        ~密钥类型 ~密钥文件路径及名称 ~ 备注信息
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): # 输入密码, 若不输入则直接回车
Enter same passphrase again: # 再次确认密码, 若不输入则直接回车
...
</code></pre>
<p>注意: 密钥的文件名称必须是<code>id_xxx</code>, 这里的<code>xxx</code>就是<code>-t</code>参数指定的密钥类型.
比如密钥类型是<code>rsa</code>, 那么密钥文件名就必须是<code>id_rsa</code>.</p>
<hr />
<p><code>ssh-keygen</code>常用参数说明:</p>
<ul>
<li><code>-t</code>: 密钥类型, 可以选择 <code>dsa | ecdsa | ed25519 | rsa</code>;</li>
<li><code>-f</code>: 密钥目录位置, 默认为<code>/home/username/.ssh/</code>, 默认密钥文件名以<code>id_rsa</code>开头. 如果是<code>root</code>用户, 则在<code>/root/.ssh/id_rsa</code>.</li>
<li><code>-C</code>: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议补充;</li>
<li><code>-N</code>: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了.</li>
</ul>
<p>举例说明: 同时指定目录位置, 密码, 注释信息, 就不需要输入回车键即可完成创建:</p>
<pre><code class="language-bash">ssh-keygen -t rsa -f ~/.ssh/id_rsa -N shoufeng -C shoufeng
</code></pre>
<hr />
<p>前往<code>~/.ssh/</code>目录下查看生成的文件:</p>
<pre><code class="language-bash"># 生成的文件以test_rsa开头, test_rsa是私钥, test_rsa.pub是公钥:
$ ls
test_rsa test_rsa.pub

# 通过cat命令查看公钥文件:
$ cat id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC2...
# 可以看到最后有一个注释内容shoufeng
</code></pre>
<hr />
<p><code>ssh-copy-id</code> 把<code>A</code>的公钥发送给<code>B</code></p>
<p>默认用法是: <code>ssh-copy-id root@172.16.22.132</code>,</p>
<p><code>ssh-copy-id</code>命令连接远程服务器时的默认端口是<code>22,</code> 当然可以指定<code>文件</code>, 远程主机的<code>IP</code>, <code>用户</code>和<code>端口</code>:</p>
<pre><code class="language-bash"># 指定要拷贝的本地文件, 远程主机的IP+用户名+端口号:
$ ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 root@172.16.22.132
...
root@172.16.22.132's password: # 输入密码后, 将拷贝公钥
...
</code></pre>
<p><code>-i identity_file</code></p>
<hr />
<p>在A服务器上免密登录B服务器</p>
<pre><code class="language-bash">$ ssh root@172.16.22.132
Last login: Fri Jun 14 08:46:04 2019 from 192.168.34.16 # 登录成功
</code></pre>
<hr />
<p>也可以用<code>ssh-agent</code>和<code>ssh-add</code>命令</p>
<ul>
<li><code>ssh-agent</code>: a program to hold private keys used for public key authentication (RSA, DSA, ECDSA, Ed25519).</li>
<li><code>ssh-add</code>: adds private key identities to the authentication agent</li>
</ul>
<p>首先先将本机的 <code>rsa.pub</code>公钥追加到目标服务器的 <code>authorized_keys</code> 中.然后执行以下命令:</p>
<pre><code class="language-bash">ssh-agent bash
ssh-add  ~/.ssh/'私钥文件 '
</code></pre>
<p>完成了这个之后,就可以直接用 <code>ssh root@192.168.0.106</code>  直接连接服务器而不需要输入密码了</p>
<hr />
<p>扩展说明</p>
<p>其他方式发送公钥文件</p>
<p>上述步骤是通过<code>ssh-copy-id</code>工具发送公钥文件的, 当然我们也可以通过其他方式实现:</p>
<hr />
<p>将<code>A</code>的公钥文件发给<code>B</code>:</p>
<p>通过<code>scp</code>命令将A服务器的公钥文件发送到B服务器的用户目录下, 因为还没有配置成功免密登录,
所以期间需要输入B服务器对应用户的密码:</p>
<pre><code class="language-bash">$ scp id_rsa.pub root@172.16.22.132:/root/.ssh
root@172.16.22.132's password:
id_rsa.pub           100% 390  0.4KB/s 00:00
</code></pre>
<p>在B上创建<code>authorized_keys</code>文件:</p>
<pre><code class="language-bash">$ cd /root/.ssh/
$ ls
id_rsa.pub
# 通过A服务器的公钥生成&quot;authorized_keys&quot;文件:
$ cat id_rsa.pub &gt;&gt; authorized_keys
$ cat authorized_keys
...
</code></pre>
<p>注意: 上述重定向时使用<code>&gt;&gt;</code>进行追加, 不要用<code>&gt;</code>, 那会清空原有内容.</p>
<hr />
<p>文件权限</p>
<p>为了让私钥文件和公钥文件能够在认证中起作用, 需要确保权限的正确性:</p>
<ul>
<li>对于<code>.ssh</code>目录以及其内部的公钥, 私钥文件, 当前用户至少要有执行权限, 其他用户最多只能有执行权限.</li>
<li>不要图省事设置成<code>777</code>权限: 太大的权限不安全, 而且数字签名也不支持这种权限策略.</li>
<li>对普通用户, 建议设置成<code>600</code>权限: <code>chmod 600 authorized_keys id_rsa id_rsa.pub</code>;</li>
<li>对root用户, 建议设置成<code>644</code>权限: <code>chmod 644 authorized_keys id_rsa id_rsa.pub</code>.</li>
</ul>
<hr />
<p>windows 免密码登录</p>
<p><code>windows</code>中生成密钥: 可以在<code>Xshell</code>中也可以达到类似效果,这种方式生成了密钥之后,可以将之保存起来.
当然也可以通过其他方式例如<code>git bash</code>中用<code>linux</code>指令生成,在这里不详细描述了.</p>
<p>那么我们怎么使用这个生成好的<code>ssh key</code>呢.
为了达到免密码的登录过程,我们需要将公钥放置在<code>authorized_keys</code>这个文件中.</p>
<p>我们需要先进入linux服务器,将我们选择的这个 <code>id_rsa_2048.pub</code> 的内容放置到linux服务器的<code>authorized_keys</code>文件中.
这样的话我们再访问就可以无密码连接了.</p>
<hr />
<p>ssh 安全端口</p>
<p>端口安全指的是尽量避免服务器的远程连接端口被不法份子知道,为此而改变默认的服务端口号的操作.</p>
<p>在上一节中我们知道了<code>SSH</code>的默认端口是<code>22</code>.可以修改默认端口.
对应需要修改的文件是 <code>/etc/ssh/sshd_config</code>. 我们也可以同时监听多个端口.</p>
<h3 id="ssh连接ubuntu图形界面"><a class="header" href="#ssh连接ubuntu图形界面">SSH连接Ubuntu图形界面</a></h3>
<p><a href="https://www.jianshu.com/p/9279b2ed8821">SSH连接Ubuntu图形界面</a></p>
<p>在<code>Ubuntu</code>系统下, <code>ssh</code>客户端一般是自带的,<code>ssh</code>服务端一般需要自己安装: <code>$sudo apt-get install openssh-server</code>.</p>
<p>假设发起连接的主机被称为客户端主机, 用大写字母<code>A</code>表示, <code>IP</code>为<code>A.A.A.A</code>, 被连接的主机为服务端主机, 用大写字母<code>B</code>表示, <code>IP</code>为<code>B.B.B.B</code>.
<code>ssh</code>连接成功后, 如果想要显示图形界面, 需要做一些配置. 步骤如下:</p>
<hr />
<p>服务器端的<code>ssh</code>必须运行转发<code>X</code>界面, 在<code>ssh</code>服务器中, 也就是<code>B</code>中, 打开这个配置文件, 注意是<code>sshd_config</code>文件:</p>
<pre><code class="language-bash">$sudo vim /etc/ssh/sshd_config
</code></pre>
<p>找到这一行, 编辑如下:</p>
<pre><code class="language-bash">X11Forwarding yes
</code></pre>
<p>确保这个是<code>yes</code>(注意这个配置文件中的#是注释, 确保<code>X11Forwarding</code>前面没有<code>#</code>注释), 然后重启<code>ssh</code>服务:</p>
<pre><code class="language-bash">systemctl restart ssh.service
</code></pre>
<hr />
<p>客户端配置:打开配置文件, 注意是<code>ssh_config</code>文件:</p>
<pre><code class="language-bash">$sudo vim /etc/ssh/ssh_config
</code></pre>
<p>找到以下语句并编辑:</p>
<pre><code class="language-bash">ForwardAgent yes
ForwardX11 yes
ForwardX11Trusted yes
</code></pre>
<p>这<code>3</code>个确保是<code>yes</code>(注意这个配置文件中的<code>#</code>是注释, 确保你修改的行没有被<code>#</code>注释掉)</p>
<hr />
<p>配置完成后, 进入<code>A</code>主机终端. 设置允许其他主机的<code>ssh</code>服务器的<code>X</code>界面连接过来<code>xhost +</code>, 然后执行:</p>
<pre><code class="language-bash">$ssh -Y  username@192.168.3.102
</code></pre>
<p>注意<code>-Y</code>这个是大写的<code>Y</code>,接着会提示输入密码, 然后会连接到<code>B</code>服务器主机. 最后做个测试, 执行<code>$xclock</code>
如果这个时候在<code>A</code>主机<code>Ubuntu</code>界面中出现了一个时钟界面, 那么恭喜你成功了.</p>
<h3 id="ssh-选项"><a class="header" href="#ssh-选项">ssh 选项</a></h3>
<p><code>-X</code>:启用 <code>X11</code> 转发. 这也可以在配置文件中针对每个主机进行指定.
应谨慎启用 <code>X11</code> 转发. 能够绕过远程主机上的文件权限的用户(对于用户的X授权数据库)可以通过转发的连接访问本地的X11显示.
然后攻击者可能能够执行诸如按键监控之类的活动.
为此, <code>X11</code> 转发默认受 <code>X11 SECURITY</code> 扩展限制. 请参考 <code>ssh -Y </code>选项以及<code>ssh_config(5)</code>中的 <code>ForwardX11Trusted</code> 指令以获取更多信息.
(Debian-specific:<code>X11</code> 转发默认不受 <code>X11 SECURITY</code> 扩展限制, 因为当前太多程序在这种模式下崩溃.
将 <code>ForwardX11Trusted</code> 选项设置为<code>no</code>以恢复上游行为. 取决于客户端的改进这可能会在未来改变. )</p>
<p><code>-x</code>: 禁用 <code>X11</code> 转发.</p>
<p><code>-Y</code>: 启用受信任的 <code>X11</code> 转发. 受信任的 <code>X11</code> 转发不受 <code>X11</code> 安全扩展控制的约束.
(Debian-specific:在默认配置中, 此选项等效于<code>-X</code>, 如上所述, <code>ForwardX11Trusted</code>默认为<code>yes</code>.
将 <code>ForwardX11Trusted</code> 选项设置为<code>no</code>以恢复上游行为. 取决于客户端的改进这可能会在未来改变. )</p>
<p><code>-N</code>: 不执行远程命令.  这对于仅转发端口很有用.</p>
<p><code>-f</code>: 要求 <code>ssh</code>在执行<code>command</code>之前进入后台. 如果用户希望<code>ssh</code>在后台, 同时不错过输入<code>passwords</code>或<code>passphrases</code>, 这很有用.
这意味着 <code>-n</code>.  在远程站点启动 <code>X11</code> 程序的推荐方法是: <code>ssh -f host xterm</code>.</p>
<p>如果 <code>ExitOnForwardFailure</code> 配置选项设置为<code>yes</code>, 则以 <code>-f</code> 启动的客户端将等待所有远程端口转发建立成功之后, 再将自己置于后台.</p>
<p><code>-l login_name</code>: 指定在远程机器上登录的用户.  这也可以在配置文件中针对每个主机进行指定.</p>
<h3 id="sshfs"><a class="header" href="#sshfs">sshfs</a></h3>
<p><a href="https://github.com/libfuse/sshfs">A network filesystem client to connect to SSH servers </a>
<a href="https://www.linuxprobe.com/sshfs-linux-fires.html">使用 SSHFS 挂载远程的 Linux 文件系统及目录</a></p>
<p><code>SSHFS</code>(Secure SHell FileSystem)是一个客户端, 可以让我们通过 <code>SSH</code> 文件传输协议(<code>SFTP</code>)挂载远程的文件系统并且在本地机器上和远程的目录和文件进行交互.</p>
<p><code>SFTP</code> 是一种通过 <code>SSH</code> 协议提供文件访问, 文件传输和文件管理功能的安全文件传输协议. 因为 <code>SSH</code> 在网络中从一台电脑到另一台电脑传输文件的时候使用数据加密通道,
并且 <code>SSHFS</code> 内置在 <code>FUSE</code>(用户空间的文件系统)内核模块, 允许任何非特权用户在不修改内核代码的情况下创建他们自己的文件系统.</p>
<hr />
<p>在 Linux 系统上安装 <code>SSHFS</code>: 默认情况下, sshfs 包不存在所有的主流 <code>Linux</code> 发行版中, 你需要在你的 <code>Linux</code> 系统中启用 <code>epel</code>, 在 Yum 命令行的帮助下安装 <code>SSHFS</code> 及其依赖.</p>
<pre><code class="language-bash"># yum install sshfs
# dnf install sshfs              [在 Fedora 22+ 发行版上]
$ sudo apt-get install sshfs     [基于 Debian/Ubuntu 的系统]
</code></pre>
<hr />
<p>大概步骤为:</p>
<ul>
<li>创建 <code>SSHFS</code> 挂载目录</li>
<li>使用 <code>SSHFS</code> 挂载远程的文件系统</li>
<li>卸载远程的文件系统</li>
</ul>
<pre><code class="language-bash">$ sudo mkdir /mnt/tecmint     #创建一个挂载点目录
$ sudo sshfs -o allow_other tecmint@x.x.x.x:/home/tecmint/ /mnt/tecmint  #替换成你的 `IP` 地址和挂载点
$ sudo umount /mnt/tecmint # 和平常的卸载方式一样
</code></pre>
<p>如果你的 <code>Linux</code> 服务器配置为基于 <code>SSH</code> 密钥授权, 那么你将需要使用如下所示的命令行指定你的公共密钥的路径.</p>
<pre><code class="language-bash"># sshfs -o IdentityFile=~/.ssh/id_rsa tecmint@x.x.x.x:/home/tecmint/ /mnt/tecmint
$ sudo sshfs -o allow_other,IdentityFile=~/.ssh/id_rsa tecmint@x.x.x.x:/home/tecmint/ /mnt/tecmint     [基于 Debian/Ubuntu 的系统]
</code></pre>
<p>如果你已经成功的运行了上面的命令并且没有任何错误, 你将会看到挂载在 <code>/mnt/tecmint</code> 目录下的远程的文件和目录的列表. 运行 <code>df -hT</code>命令, 你将会看到远程文件系统的挂载点.</p>
<pre><code class="language-bash"># df -hT

Filesystem                          Type        Size  Used Avail Use% Mounted on
...
tecmint@192.168.0.102:/home/tecmint fuse.sshfs  324G   55G  253G  18% /mnt/tecmint
</code></pre>
<hr />
<p>永久挂载远程文件系统</p>
<p>为了永久的挂载远程的文件系统, 你需要修改一个叫 <code>/etc/fstab</code> 的文件, 打开文件, 在底部添加下面的一行, 保存文件并退出. 下面条目表示使用默认的设置挂载远程的文件系统.</p>
<pre><code>sshfs#tecmint@x.x.x.x:/home/tecmint/ /mnt/tecmint fuse.sshfs defaults 0 0
</code></pre>
<p>确保服务器之间允许 <code>SSH</code> 无密码登录, 这样系统重启之后才能自动挂载文件系统.  如果你的服务器配置为基于 <code>SSH</code> 密钥的认证方式, 请加入如下行:</p>
<pre><code>sshfs#tecmint@x.x.x.x:/home/tecmint/ /mnt/tecmint fuse.sshfs IdentityFile=~/.ssh/id_rsa defaults 0 0
</code></pre>
<p>接下来, 你需要更新 <code>fstab</code> 文件使修改生效.</p>
<pre><code class="language-bash">$ sudo mount -a   #基于 Debian/Ubuntu 的系统
</code></pre>
<h2 id="vnc-虚拟网络计算机"><a class="header" href="#vnc-虚拟网络计算机">vnc 虚拟网络计算机</a></h2>
<h3 id="archwiki"><a class="header" href="#archwiki">archwiki</a></h3>
<p><a href="https://wiki.archlinux.org/title/TigerVNC_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">TigerVNC</a></p>
<p><code>TigerVNC</code> 是 <code>Virtual Network Computing</code> (VNC) 的一种实现. 它向用户提供一些远程功能, 包括:</p>
<ul>
<li>直接控制本地 <code>X</code> 会话.</li>
<li>在一台机器上的后台并行 <code>X</code> 会话, 即并不显示在物理显示器上而是虚拟显示器. 即使用户断开连接, 在服务器上运行的所有程序依旧可以运行.</li>
</ul>
<hr />
<p><a href="https://unix.stackexchange.com/questions/315247/what-commands-are-needed-in-the-vnc-xstartup-file-to-run-kde-plasma-5-in-vn">run KDE Plasma 5 in VNC</a></p>
<p>在<code>manjaro</code>上使用时, 连接到<code>vnc</code>服务器之后, 桌面是黑的, 可以打开终端, 这时执行<code>dbus-launch startplasma-x11 # or startplasma-wayland</code>即可打开桌面.</p>
<hr />
<p><a href="https://wiki.archlinux.org/title/D-Bus">D-Bus</a></p>
<p><code>D-Bus</code> 是一个提供简便进程间通信的消息总线系统. 包含一个能以全系统或者针对一个用户会话运行的守护进程, 和一系列提供与 <code>D-Bus</code> 通信的库.
<code>dbus-launch</code>: 从 <code>shell</code> 脚本启动消息总线的程序</p>
<p><a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/device_model.html">Linux Device Model</a></p>
<p><code>bus</code>是处理器和输入/输出设备之间的通信通道.  为了确保模型是通用的, 所有输入/输出设备都通过<code>bus</code>连接到处理器(它可以是没有对应的物理硬件的虚拟设备).</p>
<p>添加系统总线时, 它会出现在 <code>sysfs</code> 文件系统中的<code>/sys/bus</code>中.  与 <code>kobjects</code> 一样, 总线可以组织成层次结构, 并在 <code>sysfs</code> 中表示.</p>
<h4 id="为虚拟无界面会话运行-vncserver"><a class="header" href="#为虚拟无界面会话运行-vncserver">为虚拟(无界面)会话运行 vncserver</a></h4>
<hr />
<p>初次设置
注意:  在物理内存允许的条件下, <code>Linux</code>系统可以拥有任意数量的VNC服务器 -- 它们同时并行运行, 互不干扰.</p>
<ol>
<li>用<code>vncpasswd</code>创建密码, 它会将哈希处理之后的密码存储在<code>~/.vnc/passwd</code>.</li>
<li>编辑<code>/etc/tigervnc/vncserver.users</code>来定义用户映射. 这文件中定义的用户都会拥有独有的端口来运行它的会话.
这文件中的数字对应的是<code>TCP</code>端口. 默认情况下, <code>:1</code> 是<code>TCP</code>端口<code>5901</code>(<code>5900+1</code>).
如果需要运行一个并行的服务器, 第二个实例可以运行在下一个最大的, 未被占用的端口, 即<code>5902</code>(<code>5900+2</code>).</li>
<li>创建<code>~/.vnc/config</code>, 至少要定义会话的类型, 比如<code>session=foo</code>(将<code>foo</code>替换为你想要运行的桌面环境).
你可以通过查看<code>/usr/share/xsessions/</code>里的<code>.desktop</code>文件来知道有哪些桌面环境在当前系统上可以使用. 比如:</li>
</ol>
<p>~/.vnc/config</p>
<pre><code class="language-bash">session=lxqt
geometry=1920x1080
localhost #这个配置会导致只能本地访问 vnc
alwaysshared
</code></pre>
<hr />
<p>权限: 像对待 <code>~/.ssh</code> 一样保护 <code>~/.vnc</code> 是很好的做法, 虽然并非必须. 执行下面的命令来达到该目的:</p>
<pre><code class="language-bash">$ chmod 700 ~/.vnc
</code></pre>
<hr />
<p>启动与停止<code>tigervnc</code></p>
<p><code>systemctl start  vncserver@.service</code>, 如果需要让它随系统启动, <code>enable</code>它.
注意<code>/etc/tigervnc/vncserver.users</code>中定义的编号需要在<code>@</code>符号后面指定, 比如启动<code>:1</code>的命令是:</p>
<pre><code class="language-bash"># systemctl start vncserver@:1
</code></pre>
<p>Note: 已经不再支持直接调用<code>/usr/bin/vncserver</code>了, 因为这样做不会建立完整可用的会话环境.
<code>systemd</code>服务是唯一受支持的使用<code>TigerVNC</code>的方式. 参见Issue #1096.</p>
<h3 id="在物理显示器上5900端口运行vnc服务"><a class="header" href="#在物理显示器上5900端口运行vnc服务">在物理显示器上(5900端口)运行VNC服务:</a></h3>
<hr />
<p>使用 <code>TigerVNC 的 x0vncserver</code> (推荐)</p>
<p><code>TigerVNC</code> 提供名为 <code>x0vncserver</code> 的二进制文件, 它具有和 <code>x11vnc</code> 相类似的功能. 例如:</p>
<pre><code class="language-bash">x0vncserver -display :0 -passwordfile ~/.vnc/passwd
</code></pre>
<p>欲获取更多信息, 执行<code>man x0vncserver</code></p>
<hr />
<p>使用 <code>x11vnc</code> (推荐)</p>
<p>如果需要远程控制物理显示, 使用 <code>x11vnc</code>. 参见 <code>X11vnc</code> 获取更多信息.</p>
<h3 id="连接-vnc-服务"><a class="header" href="#连接-vnc-服务">连接 VNC 服务</a></h3>
<p>一个 <code>VNC</code> 服务可允许任意数量的客户端来连接. 下面给出一个简单例子, 其中 <code>VNC</code> 服务运行在 <code>10.1.10.2</code> 的 <code>5901</code>(<code>:1</code>, 使用速记法)端口:</p>
<pre><code class="language-bash">$ vncviewer 10.1.10.2:1
</code></pre>
<h4 id="无密码验证"><a class="header" href="#无密码验证">无密码验证</a></h4>
<p><code>-passwd</code> 开关允许我们定义服务器上 <code>~/.vnc/passwd</code> 文件的位置. 在服务器方面(无论是通过 <code>SSH</code> 还是物理接触), 用户需要有权访问该文件.
在任一情况下, 都应将该文件放在客户端文件系统的一个安全位置(例如一个仅给期望用户<code>read</code>权限的位置).</p>
<pre><code class="language-bash">$ vncviewer -passwd /path/to/server-passwd-file
</code></pre>
<p>图形界面客户端示例</p>
<ul>
<li>gtk-vnc</li>
<li>krdc</li>
<li>rdesktop</li>
<li>vinagre</li>
<li>remmina</li>
<li>vncviewer-jarAUR</li>
</ul>
<h3 id="使用-ssh-隧道加密-vnc-服务"><a class="header" href="#使用-ssh-隧道加密-vnc-服务">使用 SSH 隧道加密 VNC 服务</a></h3>
<h4 id="服务端配置"><a class="header" href="#服务端配置">服务端配置</a></h4>
<p>若希望从 <code>LAN</code> 保护之外访问 <code>VNC</code> 服务, 你需要考虑明文密码及客户端与服务端之间未加密通信的问题.
<code>VNC</code> 服务可以很简单地使用 <code>SSH</code> 隧道进行加密. 另外, 不要使用此方法对外界打开另一个端口, 因为通信会沿用户之前对 <code>WAN</code> 打开的 <code>SSH</code> 端口在隧道中依次进行.
在这种情况下, 强烈推荐使用 <code>-localhost</code> 开关运行 <code>vncserver</code>.
该开关仅允许接收从本机发起的连接, 并顺理成章地仅允许物理 <code>SSH</code> 连接并认证到机器上的用户.</p>
<pre><code class="language-bash">$ vncserver -geometry 1440x900 -alwaysshared -dpi 96 -localhost :1
</code></pre>
<h4 id="客户端配置"><a class="header" href="#客户端配置">客户端配置</a></h4>
<p>既然服务器现在只接受本机的连接, 使用 <code>-L</code> 开关通过 <code>SSH</code> 连接到该机器来打开隧道. 例如:</p>
<pre><code class="language-bash">$ ssh 目标机器IP -L 8900:localhost:5901
</code></pre>
<p>该命令将服务器的 <code>5901</code> 端口转发到客户机的 <code>8900</code> 端口. 一旦已通过 <code>SSH</code> 连接, 请保持该 <code>xterm</code> 或 <code>shell</code> 窗口开启 -- 它会作为和服务器通信的加密隧道.
为了通过 <code>VNC</code> 连接, 打开第二个 <code>xterm</code> 并连接到客户机的加密隧道上(而不是远程服务器的 <code>IP</code> 地址):</p>
<pre><code class="language-bash">$ vncviewer localhost::8900
</code></pre>
<hr />
<p>以下来自 <code>SSH</code> 的手册页面:</p>
<pre><code>-L [bind_address:]port:host:hostport
-L [bind_address:]port:remote_socket
-L local_socket:host:hostport
-L local_socket:remote_socket
</code></pre>
<p>指定到本地<code>(client)</code>主机上给定 TCP 端口或 Unix 套接字的连接将被转发到给定远程端的<code>host</code>和<code>port</code>, 或 <code>Unix socket</code>.
通过分配一个<code>socket</code>来侦听本地端的 <code>TCP</code> 端口, 可选择绑定到指定的 <code>bind_address</code> 或 <code>Unix socket</code>.
每当<code>local port</code>或<code>socket</code>建立连接时, 连接通过安全通道转发(<code>forwarded</code>), 并连接到远程计算机上的口 <code>hostport</code> 或 <code>remote_socket</code>.</p>
<p>端口转发也可以在配置文件中指定. 只有超级用户才能转发特权端口.  <code>IPv6</code> 地址可以通过将地址括在方括号中来指定.</p>
<p>默认情况下, 根据<code>GatewayPorts</code>设置绑定本地端口. 显式的 <code>bind_address</code> 可用于将连接绑定到特定地址.
<code>bind_address</code>若为<code>localhost</code>, 表示绑定监听端口仅供本地使用, 而空地址或<code>*</code>表示该端口可以从所有<code>interfaces</code>使用.</p>
<h3 id="在-android-设备上通过-ssh-连接-vnc-服务器"><a class="header" href="#在-android-设备上通过-ssh-连接-vnc-服务器">在 Android 设备上通过 SSH 连接 VNC 服务器</a></h3>
<p>为了在 <code>Android</code> 设备上通过 <code>SSH</code> 连接到 <code>VNC</code> 服务器, 需要具备以下条件:</p>
<ol>
<li>在要连接的机器上运行 <code>SSH</code> 服务</li>
<li>在要连接的机器上运行 <code>VNC</code> 服务. (使用上面提到的 <code>-localhost </code>标志来运行服务)</li>
<li>在 <code>Android</code> 设备上安装 <code>SSH</code> 客户端. (<code>ConnectBot</code> 是一个常见选择, 并在本向导中用作例子. )</li>
<li>在 <code>Android</code> 设备上安装 <code>VNC</code> 客户端(<code>androidVNC</code>)</li>
</ol>
<p>考虑为目标使用一些动态 <code>DNS</code> 服务, 来解决无固定 <code>IP</code> 地址问题.
在 <code>ConnectBot</code> 中, 键入 <code>IP</code> 并连接到所期望的机器. 按选项键, 选择端口转发, 并增加一个新端口然后保存之:</p>
<pre><code>Nickname: vnc
Type: Local
Source port: 5901
Destination: 127.0.0.1:5901
</code></pre>
<p>在 <code>androidVNC</code> 中:</p>
<pre><code>Nickname: nickname
Password: 设置 VNC 服务器时使用的密码
Address: 127.0.0.1 (通过 ssh 连接之后, 我们在远程机器的&quot;本地&quot;)
Port: 5901
</code></pre>
<p>连接即可.</p>
<h3 id="在开关机时启动关闭-vnc-服务"><a class="header" href="#在开关机时启动关闭-vnc-服务">在开关机时启动关闭 VNC 服务</a></h3>
<p>如果是<code>arch</code>, <code>vncserver.service</code>可能安装在<code>/usr/lib/systemd/system/vncserver.service</code>.
如果是<code>ubuntu</code>, 默认似乎没有安装<code>vncserver.service</code>, 自己创建一个: <code>sudo vim /etc/systemd/system/vncserver@.service</code>,</p>
<pre><code class="language-.service"># nolisten=tcp 选项可以禁止使用`TCP`连接
# localhost 选项表示只能使用`ssh`隧道连接
# 详细查看 man vncviewer 的 &quot;-via&quot; 选项.

[Unit]
Description=Remote desktop service (VNC)
After=syslog.target network.target

[Service]
Type=forking
User=

# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=-/usr/bin/vncserver -kill %i
ExecStart=/usr/bin/vncserver %i
ExecStop=/usr/bin/vncserver -kill %i

[Install]
WantedBy=multi-user.target
</code></pre>
<h3 id="复制远程机器剪贴板内容到本地"><a class="header" href="#复制远程机器剪贴板内容到本地">复制远程机器剪贴板内容到本地</a></h3>
<p>如果从远程机器到本机的复制不工作, 如该参考下面所述, 在服务器上执行 <code>autocutsel</code>:</p>
<pre><code class="language-bash">$ autocutsel -fork
</code></pre>
<p>现在, 按下 <code>F8</code> 键显示 <code>VNC</code> 弹出菜单, 选择 <code>Clipboard: local -&gt; remote</code> 选项.</p>
<p>你可以将上述命令放在 <code>~/.vnc/xstartup</code> 中, 以使其在 <code>VNC</code> 服务启动时自动运行.</p>
<h3 id="解决无光标问题"><a class="header" href="#解决无光标问题">解决无光标问题</a></h3>
<p>如果使用 <code>x0vncserver</code> 时光标无法显示, 那么像下面这样启动 <code>vncviewer</code>:</p>
<pre><code class="language-bash">$ vncviewer DotWhenNoCursor=1 &lt;server&gt;
</code></pre>
<p>或者将 <code>DotWhenNoCursor=1</code> 写在 <code>tigervnc</code> 的配置文件(默认在 <code>~/.vnc/default.tigervnc</code>)中.</p>
<h3 id="ubuntu-2004"><a class="header" href="#ubuntu-2004">ubuntu 20.04</a></h3>
<p><a href="https://stackoverflow.com/questions/59709214/tigervncserver-crashes-unless-started-with-sudo">tigervncserver crashes unless started with sudo</a></p>
<p><code>ubuntu</code> 上安装完<code>tigervncserver</code>, 用<code>systemctl</code>启动时失败, 原因可能是没有<code> ~/.vnc/xstartup</code>文件. 创建<code>~/.vnc/xstartup</code>, 内容如下:</p>
<pre><code class="language-bash">#!/bin/bash

PATH=/usr/bin:/usr/sbin
unset SESSION_MANAGER
unset DBUS_SESSION_BUS_ADDRESS
exec cinnamon-session-cinnamon &amp;
</code></pre>
<p><code>exec</code>后面的值可以查看<code>/usr/share/xsessions/</code>中<code>.desktop</code>文件内的写法, 例如<code>cinnamon.desktop</code>中的值是<code>cinnamon-session-cinnamon</code>.</p>
<p>之后启动<code>vncserver</code>就不需要<code>sudo</code>了, 也不会<code>crash</code>.
我猜缺少可执行文件会阻止 <code>vncserver</code> 启动, 但是使用 <code>sudo</code> 权限, 它设法从某些文件中提取的默认设置开始, 这些文件只能由 <code>sudoers</code> 访问.
但在<code>ubuntu 20.04</code>上使用<code>gnome-session</code>能连接, 但是会有黑屏问题.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-6-1"><a class="header" href="#linux-6-1">linux-6</a></h1>
<h2 id="第十五章软件包管理"><a class="header" href="#第十五章软件包管理">第十五章:软件包管理</a></h2>
<p>如果我们花些时间在 Linux 社区里,我们会得知很多针对, 类如在众多 Linux 发行版中哪个是最好的(等问题的)看法.
这些集中在像这些事情上的讨论,比方说最漂亮的桌面背景(一些人不使用 Ubuntu, 只是因为 Ubuntu默认主题颜色是棕色的!)和其它的琐碎东西,经常变得非常无聊.</p>
<p>Linux 发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性.
随着我们 花更多的时间在Linux 上,我们会发现它的软件园地是非常动态的.软件不断变化.
大多数一线 Linux 发行版每隔六个月发布一个新版本,并且许多独立的程序每天都会更新.</p>
<p>为了能和这些 如暴风雪一般多的软件保持联系,我们需要一些好工具来进行软件包管理.
软件包管理是指系统中一种安装和维护软件的方法.今天,通过从 Linux 发行版中安装的软件包, 已能满足许多人所有需要的软件.
这不同于早期的 Linux,人们需要下载和编辑源码来安装软件.编辑源码没有任何问题,事实上,拥有对源码的访问权限是 Linux 的伟大奇迹.</p>
<p>它赋予我们( 其它每个人)才干来检测和提高系统性能.只是若有一个预先编译好的软件包处理起来要相对 容易快速些.</p>
<p>这章中,我们将查看一些用于包管理的命令行工具.
虽然所有主流 Linux 发行版都 提供了强大且精致的图形管理程序来维护系统,但是学习命令行程序也非常重要.
因为它们 可以完成许多让图形化管理程序处理起来困难(或者不可能)的任务.</p>
<h3 id="打包系统"><a class="header" href="#打包系统">打包系统</a></h3>
<p>不同的 Linux 发行版使用不同的打包系统,
一般而言,大多数发行版分别属于两大包管理技术阵营: <code>Debian的``.deb</code>,和<code>Red Hat</code>的<code>.rpm</code>.
也有一些重要的例外,比方说 <code>Gentoo</code>, <code>Slackware</code>,和 <code>Foresight</code>,但大多数会使用这两个基本系统中的一个.</p>
<hr />
<p>表15-1: 主要的包管理系统家族
包管理系统 发行版 (部分列表)</p>
<ul>
<li>Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire</li>
<li>Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</li>
</ul>
<h3 id="软件包管理系统是怎样工作的"><a class="header" href="#软件包管理系统是怎样工作的">软件包管理系统是怎样工作的</a></h3>
<p>在专有软件产业中找到的软件发布方法通常需要买一张安装媒介,比方说<code>安装盘</code>,然后运行 <code>安装向导</code>,来在系统中安装新的应用程序.
Linux 不是这样.Linux 系统中几乎所有的软件都可以在互联网上找到.</p>
<p>其中大多数软件由发行商以 包文件的形式提供,剩下的则以源码形式存在,可以手动安装.
在后面章节里,我们将会谈谈怎样 通过编译源码来安装软件.</p>
<h4 id="包文件"><a class="header" href="#包文件">包文件</a></h4>
<p>在包管理系统中软件的基本单元是包文件.
包文件是一个构成软件包的文件压缩集合.一个软件包可能由大量程序以及支持这些程序的数据文件组成.
除了安装文件之外,软件包文件也包括 关于这个包的元数据,如软件包及其内容的文本说明.
另外,许多软件包还包括预安装和安装后脚本, 这些脚本用来在软件安装之前和之后执行配置任务.</p>
<p>软件包文件是由软件包维护者创建的,他通常是(但不总是)一名软件发行商的雇员.
软件维护者 从上游提供商(程序作者)那里得到软件源码,然后编辑源码,创建软件包元数据以及所需要的 安装脚本.
通常,软件包维护者要把所做的修改应用到最初的源码当中,来提高此软件与 Linux 发行版其它部分的融合性.</p>
<p>资源库虽然某些软件项目选择执行他们自己的打包和发布策略,但是现在大多数软件包是由发行商和感兴趣 的第三方创
建的.
系统发行版的用户可以在一个中心资源库中得到这些软件包,这个资源库可能 包含了成千上万个软件包,每一个软件包都是专门为这个系统发行版建立和维护的.</p>
<p>因软件开发生命周期不同阶段的需要,一个系统发行版可能维护着几个不同的资源库.
例如,通常会 有一个<code>测试</code>资源库,其中包含刚刚建立的软件包,它们想要勇敢的用户来使用, 在这些软件包正式发布之前,让用户查
找错误.
系统发行版经常会有一个<code>开发</code>资源库, 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包.</p>
<p>一个系统发行版可能也会拥有相关第三方的资源库.</p>
<p>这些资源库需要支持一些因法律原因, 比如说专利或者是DRM 反规避问题,而不能被包含到发行版中的软件.
可能最著名的案例就是 那个加密的 DVD 支持,在美国这是不合法的.</p>
<p>第三方资源库在这些软件专利和反规避法案不 生效的国家中起作用.这些资源库通常完全地独立于
它们所支持的资源库,要想使用它们, 你必须了解它们,手动地把它们包含到软件包管理系统的配置文件中.</p>
<h3 id="依赖性"><a class="header" href="#依赖性">依赖性</a></h3>
<p>程序很少是<code>孤立的</code>,而是依赖于其它软件组件来完成它们的工作.
常见活动,以 输入/输出为例,就是由共享程序例程来处理的.这些程序例程存储在共享库中,共享库不只 为一个程序提供基本服务.</p>
<p>如果一个软件包需要共享资源,比如说共享库,据说就有一个依赖.
现代的软件包管理系统都提供了一些依赖项解析方法,以此来确保当安装软件包时,也安装了 其所有的依赖程序.</p>
<h3 id="上层和底层软件包工具"><a class="header" href="#上层和底层软件包工具">上层和底层软件包工具</a></h3>
<p>软件包管理系统通常由两种工具类型组成:底层工具用来处理这些任务,比方说安装和删除软件包文件, 和上层工具,完成元数据搜索和依赖解析.</p>
<p>在这一章中,我们将看一下由 Debian 风格的系统 (比如说 <code>Ubuntu</code>,还有许多其它系统)提供的工具,还有那些由 <code>Red Hat</code> 产品使用的工具.
虽然所有基于 <code>Red Hat</code> 风格的发行版都依赖于相同的底层程序(<code>rpm</code>), 但是它们却使用不同的上层工具.我们将研究上层程序 <code>yum</code> 供我们讨论,</p>
<p>Fedora, <code>Red Hat</code> 企业版,和 <code>CentOs</code> 都是使用 <code>yum</code>.其它基于 <code>Red Hat</code> 风格的发行版提供了带有可比较特性的上层工具.</p>
<hr />
<p>表15-2: 包管理工具
发行版 底层工具 上层工具</p>
<ul>
<li><code>Debian-Style</code> : <code>dpkg apt-get</code>, <code>aptitude</code></li>
<li><code>Fedora</code>, <code>Red Hat Enterprise Linux</code>,<code> CentOS</code> : <code>rpm yum</code></li>
</ul>
<h3 id="常见软件包管理任务"><a class="header" href="#常见软件包管理任务">常见软件包管理任务</a></h3>
<p>通过命令行软件包管理工具可以完成许多操作.我们将会看一下最常用的工具.
注意底层工具也 支持软件包文件的创建,这个话题超出了本书叙述的范围.
在以下的讨论中,<code>package_name</code> 这个术语是指软件包实际名称,而不是指<code>package_file</code>,它是包含在软件包中的文件名.</p>
<h4 id="查找资源库中的软件包"><a class="header" href="#查找资源库中的软件包">查找资源库中的软件包</a></h4>
<p>使用上层工具来搜索资源库元数据,可以根据软件包的名字和说明来定位它.</p>
<hr />
<p>表15-3: 软件包查找工具
风格 命令</p>
<ul>
<li>Debian : <code>apt-get update</code>; <code>apt-cache search search_string</code></li>
<li>Red Hat : <code>yum search search_string</code></li>
</ul>
<p>例如:搜索一个 <code>yum</code> 资源库来查找 <code>emacs</code> 文本编辑器,使用以下命令:</p>
<pre><code class="language-bash">yum search emacs
</code></pre>
<h4 id="从资源库中安装一个软件包"><a class="header" href="#从资源库中安装一个软件包">从资源库中安装一个软件包</a></h4>
<p>上层工具允许从一个资源库中下载一个软件包,并经过完全依赖解析来安装它.</p>
<hr />
<p>表15-4: 软件包安装命令
风格 命令</p>
<ul>
<li><code>Debian</code> : <code>apt-get update</code>; <code>apt-get install package_name</code></li>
<li><code>Red Hat</code> : <code>yum install package_name</code></li>
</ul>
<p>例如:从一个 <code>apt</code> 资源库来安装 <code>emacs</code> 文本编辑器:</p>
<pre><code class="language-bash">apt-get update; apt-get install emacs
</code></pre>
<h4 id="通过软件包文件来安装软件"><a class="header" href="#通过软件包文件来安装软件">通过软件包文件来安装软件</a></h4>
<p>如果从某处而不是从资源库中下载了一个软件包文件,可以使用底层工具来直接(没有经过依赖解析)安装它.</p>
<hr />
<p>表15-5: 底层软件包安装命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>dpkg --install package_file</code></li>
<li><code>Red Hat</code>: <code>rpm -i package_file</code></li>
</ul>
<p>例如:如果已经从一个并非资源库的网站下载了软件包文件 <code>emacs-22.1-7.fc7-i386.rpm</code>, 则可以通过这种方法来安装它:</p>
<pre><code class="language-bash">rpm -i emacs-22.1-7.fc7-i386.rpm
</code></pre>
<p>注意:因为这项技术使用底层的 <code>rpm</code> 程序来执行安装任务,所以没有运行依赖解析. 如果 <code>rpm</code> 程序发现缺少了一个依赖,则会报错并退出.</p>
<h4 id="卸载软件"><a class="header" href="#卸载软件">卸载软件</a></h4>
<p>可以使用上层或者底层工具来卸载软件.下面是可用的上层工具.</p>
<hr />
<p>表15-6: 软件包删除命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>apt-get remove package_name</code></li>
<li><code>Red Hat</code>: <code>yum erase package_name</code></li>
</ul>
<p>例如:从 <code>Debian</code> 风格的系统中卸载 <code>emacs</code> 软件包:</p>
<pre><code class="language-bash">apt-get remove emacs
</code></pre>
<h4 id="经过资源库来更新软件包"><a class="header" href="#经过资源库来更新软件包">经过资源库来更新软件包</a></h4>
<p>最常见的软件包管理任务是保持系统中的软件包都是最新的.上层工具仅需一步就能完成 这个至关重要的任务.</p>
<hr />
<p>表15-7: 软件包更新命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>apt-get update; apt-get upgrade</code></li>
<li><code>Red Hat</code>: <code>yum update</code></li>
</ul>
<p>例如:更新安装在 Debian 风格系统中的软件包:</p>
<pre><code class="language-bash">apt-get update; apt-get upgrade
</code></pre>
<h4 id="经过软件包文件来升级软件"><a class="header" href="#经过软件包文件来升级软件">经过软件包文件来升级软件</a></h4>
<p>如果已经从一个非资源库网站下载了一个软件包的最新版本,可以安装这个版本,用它来 替代先前的版本:</p>
<hr />
<p>表15-8: 底层软件包升级命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>dpkg --install package_file</code></li>
<li><code>Red Hat</code>: <code>rpm -U package_file</code></li>
</ul>
<p>例如:<code>把 Red Hat</code> 系统中所安装的 <code>emacs</code> 的版本更新到软件包文件 <code>emacs-22.1-7.fc7-i386.rpmz</code> 所包含的 <code>emacs</code> 版本.</p>
<pre><code class="language-bash">rpm -U emacs-22.1-7.fc7-i386.rpm
</code></pre>
<p>注意:<code>rpm</code> 程序安装一个软件包和升级一个软件包所用的选项是不同的,而 <code>dpkg</code> 程序所用的选项是相同的.</p>
<h4 id="列出所安装的软件包"><a class="header" href="#列出所安装的软件包">列出所安装的软件包</a></h4>
<p>下表中的命令可以用来显示安装到系统中的所有软件包列表:</p>
<hr />
<p>表15-9: 列出所安装的软件包命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>dpkg --list</code></li>
<li><code>Red Hat</code> : <code>rpm -qa</code></li>
</ul>
<h4 id="确定是否安装了一个软件包"><a class="header" href="#确定是否安装了一个软件包">确定是否安装了一个软件包</a></h4>
<p>这些底端工具可以用来显示是否安装了一个指定的软件包:</p>
<hr />
<p>表15-10: 软件包状态命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>dpkg --status package_name</code></li>
<li><code>Red Hat</code>: <code>rpm -q package_name</code></li>
</ul>
<p>例如:确定是否<code> Debian</code> 风格的系统中安装了这个 <code>emacs</code> 软件包:</p>
<pre><code class="language-bash">dpkg --status emacs
</code></pre>
<h4 id="显示所安装软件包的信息"><a class="header" href="#显示所安装软件包的信息">显示所安装软件包的信息</a></h4>
<p>如果知道了所安装软件包的名字,使用以下命令可以显示这个软件包的说明信息:</p>
<hr />
<p>表15-11: 查看软件包信息命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>apt-cache show package_name</code></li>
<li><code>Red Hat</code>: <code>yum info package_name</code></li>
</ul>
<p>例如:查看 Debian 风格的系统中 <code>emacs</code> 软件包的说明信息:</p>
<pre><code class="language-bash">apt-cache show emacs
</code></pre>
<h4 id="查找安装了某个文件的软件包"><a class="header" href="#查找安装了某个文件的软件包">查找安装了某个文件的软件包</a></h4>
<p>确定哪个软件包对所安装的某个特殊文件负责,使用下表中的命令:</p>
<hr />
<p>表15-12: 包文件识别命令
风格 命令</p>
<ul>
<li><code>Debian</code>: <code>dpkg --search file_name</code></li>
<li><code>Red Hat</code>: <code>rpm -qf file_name</code></li>
</ul>
<p>例如:在 <code>Red Hat</code> 系统中,查看哪个软件包安装了<code>/usr/bin/vim</code> 这个文件</p>
<pre><code class="language-bash">rpm -qf /usr/bin/vim
</code></pre>
<p>总结归纳</p>
<p>在随后的章节里面,我们将探讨许多不同的程序,这些程序涵盖了广泛的应用程序领域.</p>
<p>虽然 大多数程序一般是默认安装的,但是若所需程序没有安装在系统中,那么我们可能需要安装额外的软件包.
通过我们新学到的(和了解的)软件包管理知识,我们应该没有问题来安装和管理所需的程序.</p>
<h3 id="linux-软件安装谣言"><a class="header" href="#linux-软件安装谣言">Linux 软件安装谣言</a></h3>
<p>从其它平台迁移过来的用户有时会成为谣言的受害者,说是在 Linux 系统中,安装软件有些 困难,并且不同系统发行版所使用的各种各样的打包方案是一个障碍.</p>
<p>唉,它是一个障碍, 但只是针对于那些希望把他们的秘密软件只以二进制版本发行的专有软件供应商.Linux 软件生态系统是基于开放源代码理念.
如果一个程序开发人员发布了一款产品的 源码,那么与系统发行版相关联的开发人员可能就会把这款产品打包,并把它包含在 他们的资源库中.
这种方法保证了这款产品能很好地与系统发行版整合在一起,同时为用户 <code>一站式采购</code>软件提供了方便,从而用户不必去搜索每个产品的网站.</p>
<p>设备驱动差不多也以同样的方式来处理,但它们不是系统发行版资源库中单独的项目, 它们本身是 Linux 系统内核的一部分.
一般来说,在 Linux 当中没有一个类似于<code>驱动盘</code>的东西. 要不内核支持一个设备,要不不支持,反正 Linux 内核支持很多设备,事实上,多于 Windows 所支持的设备数目.</p>
<p>当然,如果你需要的特定设备不被支持,这里也没有安慰.当那种情况 发生时,你需要查找一下原因.
缺少驱动程序支持通常是由以下三种情况之一导致:</p>
<ol>
<li>设备太新. 因为许多硬件供应商没有积极地支持 Linux 的发展,那么编写内核 驱动代码的任务就由一些
Linux 社区来承担,而这需要花费时间.</li>
<li>设备太奇异. 不是所有的发行版都包含每个可能的设备驱动.每个发行版会建立 它们自己的内核,因为
内核是可以配置的(这使得从手表到主机的每台设备上运行 Linux 成为可能), 这样它们可能会忽略某
个特殊设备.通过定位和下载驱动程序的源码,可能需要你自己(是的,由你) 来编译和安装驱动.这
个过程不是很难,而是参与.我们将在随后的章节里来讨论编译软件.</li>
<li>硬件供应商隐藏信息. 他们既不发布应用于 Linux 系统的驱动程序代码, 也不发布技术文档来让某人创
建它.这意味着硬件供应商试图保密此设备的程序接口.因为我们 不想在计算机中使用保密的设备,所
以我建议删除这令人厌恶的软件, 把它和其它无用的项目都仍到垃圾桶里.</li>
</ol>
<p>拓展阅读</p>
<p>花些时间来了解你所用发行版中的软件包管理系统.每个发行版都提供了关于自带软件包管理工具的文档.
另外,这里有一些更普遍的资源:</p>
<p>Debian GNU/Linux FAQ 关于软件包管理一章对软件包管理进行了概述:
http://www.debian.org/doc/FAQ/ch-pkgtools.en.html</p>
<p>RPM 工程的主页:
http://www.rpm.org</p>
<p>杜克大学 YUM 工程的主页:
http://linux.duke.edu/projects/yum/</p>
<p>了解一点儿背景知识,Wikipedia 上有一篇关于 metadata 的文章:
http://en.wikipedia.org/wiki/Metadata</p>
<h2 id="第十六章存储媒介"><a class="header" href="#第十六章存储媒介">第十六章:存储媒介</a></h2>
<p>在前面章节中,我们已经从文件级别看了操作数据.在这章里,我们将从设备级别来考虑数据. <code>Linux</code> 有着令人惊奇的能力来处理存储设备,
不管是物理设备,比如说硬盘,还是网络设备,或者是虚拟存储设备,像 <code>RAID</code>(独立磁盘冗余阵列)和 <code>LVM</code>(逻辑卷管理器).</p>
<p>然而,这不是一本关于系统管理的书籍,我们不会试图深入地覆盖整个主题.我们将努力做的就是 介绍一些概念和用来管理存储设备的重要命令.
我们将会使用 <code>USB</code> 闪存,<code>CD-RW</code> 光盘(因为系统配备了 <code>CD-ROM</code> 烧写器)和一张软盘(若系统这样配备),来做这章的练习题.</p>
<p>我们将看看以下命令:</p>
<ul>
<li><code>mount</code> – 挂载一个文件系统</li>
<li><code>umount</code> – 卸载一个文件系统</li>
<li><code>fsck</code> – 检查和修复一个文件系统</li>
<li><code>fdisk</code> – 分区表控制器</li>
<li><code>mkfs</code> – 创建文件系统</li>
<li><code>fdformat</code> – 格式化一张软盘</li>
<li><code>dd</code> — 把面向块的数据直接写入设备</li>
<li><code>genisoimage</code> (<code>mkisofs</code>) – 创建一个 <code>ISO 9660</code> 的映像文件</li>
<li><code>wodim</code> (<code>cdrecord</code>) – 把数据写入光存储媒介</li>
<li><code>md5sum</code> – 计算 <code>MD5</code> 检验码</li>
</ul>
<h3 id="挂载和卸载存储设备"><a class="header" href="#挂载和卸载存储设备">挂载和卸载存储设备</a></h3>
<p><code>Linux</code> 桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易.大多数情况下,我们 只要把设备连接到系统中,它就能工作.在过去(比如说,2004年),这个工作必须手动完成.
在非桌面系统中(例如,服务器中),这仍然是一个主要地手动过程,因为服务器经常有极端的存储需求 和复杂的配置要求.
管理存储设备的第一步是把设备连接到文件系统树中.这个过程叫做挂载,允许设备参与到操作系统中.</p>
<p>回想一下第三章,类 Unix 的操作系统,像 <code>Linux</code>,维护单一文件系统树,设备连接到各个结点上.
这与其它操作系统形成对照,比如说 <code>MS-DOS</code> 和 <code>Windows</code> 系统中,每个设备(例如 <code>C:\</code>,<code>D:\</code>,等) 保持着单独的文件系统树.</p>
<p>有一个叫做<code>/etc/fstab</code> 的文件可以列出系统启动时要挂载的设备(典型地,硬盘分区). 下面是 来自于 <code>Fedora7</code> 系统的<code>/etc/fstab</code> 文件实例:</p>
<pre><code class="language-bash">LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
...
</code></pre>
<p>在这个实例中所列出的大多数文件系统是虚拟的,并不适用于我们的讨论.就我们的目的而言, 前三个是我们感兴趣的:</p>
<pre><code class="language-bash">LABEL=/12   /   ext3    defaults    1 1
LABEL=/home  /home   ext3    defaults    1 2
LABEL=/boot  /boot   ext3    defaults    1 2
</code></pre>
<p>这些是硬盘分区.每行由六个字段组成,如下所示:</p>
<hr />
<p>表16-1: <code>/etc/fstab</code> 字段
字段 内容 说明</p>
<ol>
<li><code>设备名</code>:
传统上,这个字段包含与物理设备相关联的设备文件的实际名字,比如说<code>/dev/hda1</code>(第一个IDE 通道上第一个主设备分区).
然而今天的计算机,有很多热插拔设备(像 USB 驱动设备),许多 现代的 Linux 发行版用一个文本标签和设备相关联.
当这个设备连接到系统中时, 这个标签(当储存媒介格式化时,这个标签会被添加到存储媒介中)会被操作系统读取.
那样的话,不管赋给实际物理设备哪个设备文件,这个设备仍然能被系统正确地识别.</li>
<li><code>挂载点</code>: 设备所连接到的文件系统树的目录.</li>
<li><code>文件系统类型</code> : Linux 允许挂载许多文件系统类型.大多数本地的Linux 文件系统是 <code>ext3</code>,但是也支持很多其它的,比方说 <code>FAT16</code> (msdos),<code>FAT32</code> (vfat),<code>NTFS</code>(ntfs),<code>CD-ROM</code>(iso9660),等等.</li>
<li><code>选项</code>:  文件系统可以通过各种各样的选项来挂载.例如,挂载只读的文件系统, 或者挂载阻止执行任何程序的文件系统(一个有用的安全特性,避免删除媒介.)</li>
<li><code>频率</code>: 一位数字,指定是否和在什么时间用 <code>dump</code> 命令来备份一个文件系统.</li>
<li><code>次序</code>: 一位数字,指定 <code>fsck</code> 命令按照什么次序来检查文件系统.</li>
</ol>
<h3 id="查看挂载的文件系统列表"><a class="header" href="#查看挂载的文件系统列表">查看挂载的文件系统列表</a></h3>
<p>这个 <code>mount</code> 命令被用来挂载文件系统.执行这个不带参数的命令,将会显示 一系列当前挂载的文件系统:</p>
<pre><code class="language-bash">$ mount
/dev/sda2 on / type ext3 (rw)
...
</code></pre>
<p>这个列表的格式是:<code>设备 on 挂载点 type 文件系统类型(可选的)</code>.</p>
<p>例如,第一行所示设备<code>/dev/sda2</code> 作为根文件系统被挂载,文件系统类型是 <code>ext3</code>,并且可读可写(这个<code>rw</code>选项).</p>
<p>在这个列表的底部有两个有趣的条目.
倒数第二行显示了在读卡器中的一张<code>2G</code> 的 SD 内存卡,挂载到了<code>/media/disk</code> 上.
最后一行 是一个网络设备,挂载到了<code>/misc/musicbox</code> 上.</p>
<p>第一次实验,我们将使用一张 <code>CD-ROM</code>.首先,在插入 <code>CD-ROM</code> 之前,我们将看一下系统:</p>
<pre><code class="language-bash">$ mount

/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
</code></pre>
<p>这个列表来自于 <code>CentOS 5</code>系统,使用 <code>LVM</code>(逻辑卷管理器)来创建它的根文件系统.
正如许多现在的 Linux 发行版一样,这个 系统试图自动挂载插入的 <code>CD-ROM</code>.当我们插入光盘后,我们看看下面的输出:</p>
<pre><code class="language-bash">$ mount
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
...
/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,
nodev,uid=500)
</code></pre>
<p>当我们插入光盘后,除了额外的一行之外,我们看到和原来一样的列表.</p>
<p>在列表的末尾,我们 看到 CD-ROM 已经挂载到了<code>/media/live-1.0.10-8</code>上,它的文件类型是 <code>iso9660(CD-ROM)</code>.
就我们的实验目的而言,我们对这个设备的名字感兴趣.当你自己进行这个实验时,这个 设备名字是最有可能不同的.</p>
<p>警告:在随后的实例中,至关重要的是你要密切注意用在你系统中的实际设备名,并且 不要使用此文本中使用的名字!
还要注意音频 CD 和 CD-ROM 不一样.音频 CD 不包含文件系统,这样在通常意义上,它就不能被挂载了.</p>
<p>现在我们拥有 CD-ROM 光盘的设备名字,让我们卸载这张光盘,并把它重新挂载到文件系统树 的另一个位置.
我们需要超级用户身份(使用系统相应的命令)来进行操作,并且用 <code>umount</code>(注意这个命令的拼写)来卸载光盘:</p>
<pre><code class="language-bash">$ su -
Password:
[root@linuxbox ~]# umount /dev/hdc
</code></pre>
<p>下一步是创建一个新的光盘挂载点.简单地说,一个挂载点就是文件系统树中的一个目录.它没有什么特殊的.
它甚至不必是一个空目录,即使你把设备挂载到了一个非空目录上,你也不能看到 这个目录中原来的内容,直到你卸载这个设备.
就我们的目的而言,我们将创建一个新目录:</p>
<pre><code class="language-bash">[root@linuxbox ~]# mkdir /mnt/cdrom
</code></pre>
<p>最后,我们把这个 CD-ROM 挂载到一个新的挂载点上.这个<code>-t</code> 选项用来指定文件系统类型:</p>
<pre><code class="language-bash">[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom
</code></pre>
<p>之后,我们可以通过这个新挂载点来查看 CD-ROM 的内容:</p>
<pre><code class="language-bash">[root@linuxbox ~]# cd /mnt/cdrom
[root@linuxbox cdrom]# ls
</code></pre>
<p>注意当我们试图卸载这个 CD-ROM 时,发生了什么事情.</p>
<pre><code class="language-bash">[root@linuxbox cdrom]# umount /dev/hdc
umount: /mnt/cdrom: device is busy
</code></pre>
<p>这是怎么回事呢?原因是我们不能卸载一个设备,如果某个用户或进程正在使用这个设备的话.
在这种 情况下,我们把工作目录更改到了 CD-ROM 的挂载点,这个挂载点导致设备忙碌.</p>
<p>我们可以很容易地修复这个问题 通过把工作目录改到其它目录而不是这个挂载点.</p>
<pre><code class="language-bash">[root@linuxbox cdrom]# cd
[root@linuxbox ~]# umount /dev/hdc
</code></pre>
<p>现在这个设备成功卸载了.</p>
<h4 id="为什么卸载重要"><a class="header" href="#为什么卸载重要">为什么卸载重要</a></h4>
<p>如果你看一下 <code>free</code> 命令的输出结果,这个命令用来显示关于内存使用情况的统计信息,你会看到一个统计值叫做<code>buffers</code>.
计算机系统旨在尽可能快地运行.系统运行速度的 一个阻碍是缓慢的设备.
打印机是一个很好的例子.即使最快速的打印机相比于计算机标准也 极其地缓慢.
一台计算机确实会运行地非常慢,如果它要停下来等待一台打印机打印完一页.
在早期的个人电脑时代(多任务之前),这真是个问题.</p>
<p>如果你正在编辑电子表格 或者是文本文档,每次你要打印文件时,计算机都会停下来而且变得不能使用.
计算机能以打印机可接受的最快速度把数据发送给打印机,但由于打印机不能快速地打印, 这个发送速度会非常慢.
这个问题被解决了,由于打印机缓存的出现,一个包含一些 RAM 内存 的设备,位于计算机和打印机之间.</p>
<p>通过打印机缓存,计算机把要打印的结果发送到这个缓存区, 数据会迅速地存储到这个 RAM 中,这样计算机就能回去工作,而不用等待.
与此同时,打印机缓存将会 以打印机可接受的速度把缓存中的数据缓慢地输出给打印机.
缓存被广泛地应用于计算机中,使其运行地更快.别让偶尔地需要读取或写入慢设备阻碍了系统的运行速度.</p>
<p>在实际与慢设备交互之前,操作系统会尽可能多的读取或写入数据到内存中的 存储设备里.
以 Linux 操作系统为例,你会注意到系统看似填充了多于它所需要的内存.
这不意味着 Linux 正在使用所有的内存,它意味着 Linux 正在利用所有可用的内存,来作为缓存区.</p>
<p>这个缓存区允许非常快速地写入存储设备,因为写入物理设备的操作被延迟到后面进行.
同时, 这些注定要传送到设备中的数据正在内存中堆积起来.时不时地,操作系统会把这些数据 写入物理设备.</p>
<p>卸载一个设备需要把所有剩余的数据写入这个设备,所以设备可以被安全地移除.
如果 没有卸载设备,就移除了它,就有可能没有把注定要发送到设备中的数据输送完毕.
在某些情况下, 这些数据可能包含重要的目录更新信息,这将导致文件系统损坏,这是发生在计算机中的最坏的事情之一.</p>
<h3 id="确定设备名称"><a class="header" href="#确定设备名称">确定设备名称</a></h3>
<p>有时很难来确定设备名称.在以前,这并不是很难.一台设备总是在某个固定的位置,也不会 挪动它.类 Unix的系统喜欢设备那样安排.
之前在开发 Unix 系统的时候,<code>更改一个磁盘驱动器</code>要用一辆 叉车从机房中移除一台如洗衣机大小的设备.</p>
<p>最近几年,典型的桌面硬件配置已经变得相当动态,并且 Linux 已经发展地比其祖先更加灵活.
在以上事例中,我们利用现代 Linux 桌面系统的功能来<code>自动地</code>挂载 设备,然后再确定设备名称
.
但是如果我们正在管理一台服务器或者是其它一些(这种自动挂载功能)不会 发生的环境,我们又如何能查清设备名呢?
首先,让我们看一下系统怎样来命名设备.如果我们列出目录<code>/dev</code>(所有设备的住所)的内容,我们 会看到许许多多的设备:</p>
<pre><code class="language-bash">$ ls /dev
</code></pre>
<p>这个列表的内容揭示了一些设备命名的模式.这里有几个:</p>
<hr />
<p>表16-2: Linux 存储设备名称
模式 设备</p>
<ul>
<li><code>/dev/fd*</code> 软盘驱动器</li>
<li><code>/dev/hd*</code>老系统中的<code>IDE(PATA)</code>磁盘.
典型的主板包含两个 IDE 连接器或者是通道,每个连接器 带有一根缆线,每根缆线上有两个硬盘驱动器连接点.
缆线上的第一个驱动器叫做主设备, 第二个叫做从设备.设备名称这样安排,<code>/dev/hdb</code> 是指第一通道上的主设备名;
<code>/dev/hdb</code>是第一通道上的从设备名;<code>/dev/hdc</code>是第二通道上的主设备名,等等.末尾的数字表示 硬盘驱动器上的分区.
例如,<code>/dev/hda1</code>是指系统中第一硬盘驱动器上的第一个分区,而 <code>/dev/hda</code> 则是指整个硬盘驱动器.</li>
<li><code>/dev/lp*</code> 打印机</li>
<li><code>/dev/sd*</code> <code>SCSI</code> 磁盘.在最近的 Linux 系统中,内核把所有类似于磁盘的设备
(包括<code>PATA/SATA</code> 硬盘, 闪存,和 <code>USB</code> 存储设备,比如说可移动的音乐播放器和数码相机)看作 <code>SCSI</code> 磁盘.
剩下的命名系统类似于上述所描述的旧的<code>/dev/hd*</code>命名方案.</li>
<li><code>/dev/sr*</code> 光盘(CD/DVD 读取器和烧写器)</li>
</ul>
<p>另外,我们经常看到符号链接比如说<code>/dev/cdrom</code>,<code>/dev/dvd</code> 和<code>/dev/floppy</code>,它们指向实际的设备文件,提供这些链接是为了方便使用.</p>
<p>如果你工作的系统不能自动挂载可移动的设备,你可以使用下面的技巧来决定当可移动设备连接后,它是怎样被命名的.</p>
<p>首先,启动一个实时查看文件<code>/var/log/messages</code> (你可能需要超级用户权限):</p>
<pre><code class="language-bash">sudo tail -f /var/log/messages
# or in ubuantu
sudo tail -f /var/log/kern.log
</code></pre>
<p>这个文件的最后几行会被显示,然后停止.下一步,插入这个可移动的设备.</p>
<p>在 这个例子里,我们将使用一个16MB 闪存.瞬间,内核就会发现这个设备, 并且探测它:</p>
<pre><code class="language-bash">Jul 23 10:07:59 linuxbox kernel:
...
sd 3:0:0:0: [sdb] 31263 512-byte
sd 3:0:0:0: [sdb] Write Protect is
...
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
</code></pre>
<p>显示再次停止之后,输入 <code>Ctrl-c</code>,重新得到提示符.</p>
<p>输出结果的有趣部分是一再提及<code>[sdb]</code>, 这正好符和我们期望的 <code>SCSI</code> 磁盘设备名称.
知道这一点后,有两行输出变得颇具启发性:</p>
<pre><code class="language-bash">Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
</code></pre>
<p>这告诉我们这个设备名称是<code>/dev/sdb</code> 指整个设备,<code>/dev/sdb1</code>是这个设备的第一分区.
正如我们所看到的,使用 Linux 系统充满了有趣的监测工作.</p>
<p>小贴士:使用这个 <code>tail -f /var/log/messages</code> 技巧是一个很不错的方法,可以实时观察系统的一举一动.</p>
<p>既然知道了设备名称,我们就可以挂载这个闪存驱动器了:</p>
<pre><code class="language-bash">$ sudo mkdir
$ sudo mount
$ df
</code></pre>
<p>这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动.</p>
<h3 id="创建新的文件系统"><a class="header" href="#创建新的文件系统">创建新的文件系统</a></h3>
<p>假若我们想要用 Linux 本地文件系统来重新格式化这个闪存驱动器,而不是它现用的 <code>FAT32</code>系统.这涉及到两个步骤:</p>
<ol>
<li>(可选的)创建一个新的分区布局,若已存在的分区不是我们喜欢的.</li>
<li>在这个闪存上创建一个新的空的文件系统.</li>
</ol>
<p>注意!在下面的练习中,我们将要格式化一个闪存驱动器.拿一个不包含有用数据的驱动器 作为实验品,因为它将会被擦除!
再次,请确定你指定了正确的系统设备名称.未能注意此警告可能导致你格式化(即擦除)错误的驱动器!</p>
<h3 id="用-fdisk-命令操作分区"><a class="header" href="#用-fdisk-命令操作分区">用 fdisk 命令操作分区</a></h3>
<p><a href="https://wiki.archlinux.org/title/Fdisk_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">util-linux fdisk</a></p>
<p><code>fdisk</code> 程序允许我们直接在底层与类似磁盘的设备(比如说硬盘驱动器和闪存驱动器)进行交互.
使用这个工具可以在设备上编辑,删除,和创建分区. 以我们的闪存驱动器为例, 首先我们必须卸载它(如果需要的话),然后调用 <code>fdisk</code> 程序,如下所示:</p>
<pre><code class="language-bash">$ sudo umount /dev/sdb1
$ sudo fdisk /dev/sdb
</code></pre>
<p>注意我们必须指定设备名称,必须是整个设备,而不是分区号.这个程序启动后,我们 将看到以下提示:</p>
<pre><code class="language-bash">Command (m for help):
输入`m`会显示程序菜单:
Command action
a toggle a bootable flag
....
</code></pre>
<p>我们想要做的第一件事情是检查已存在的分区布局.输入<code>p</code>会打印出这个设备的分区表:</p>
<pre><code class="language-bash">Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes

Device Boot   Start         End           Blocks            Id     System
/dev/sdb1          2             1008          15608+        b        w95 FAT32
</code></pre>
<p>在此例中,我们看到一个 <code>16MB</code> 的设备只有一个分区<code>(1)</code>,此分区占用了可用的<code>1008</code>个柱面中的1006个, 并被标识为 <code>Windows 95 FAT32</code>分区.</p>
<p>有些程序会使用这个标志符来限制一些可以对磁盘所做的操作, 但大多数情况下更改这个标志符没有危害.
然而,为了叙述方便,我们将会更改它, 以此来表明是个 <code>Linux</code> 分区.在更改之前,首先我们必须找到被用来识别一个 <code>Linux</code> 分区的 <code>ID</code> 号码.</p>
<p>在上面列表中,我们看到 <code>ID</code> 号码<code>b</code>被用来指定这个已存在的分区.
要查看可用的分区类型列表, 参考之前的程序菜单.我们会看到以下选项:</p>
<p><code>l list known partition types</code></p>
<p>如果我们在提示符下输入<code>l</code>,就会显示一个很长的可能类型列表.
在它们之中会看到<code>b</code>为已存在分区 类型的 <code>ID</code> 号,而<code>83</code>是针对 Linux 系统的 <code>ID</code> 号.
回到之前的菜单,看到这个选项来更改分区 <code>ID</code> 号:</p>
<p><code>t change a partition's system id</code></p>
<p>我们先输入<code>t</code>,再输入新的 <code>ID</code> 号:</p>
<pre><code class="language-bash">Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
</code></pre>
<p>这就完成了我们需要做得所有修改.
到目前为止,还没有实际接触这个设备(所有修改都存储在内存中, 而不是在此物理设备中),所以我们将会把修改过的分区表写入此设备,再退出.
为此,我们输入 在提示符下输入<code>w</code>:</p>
<pre><code class="language-bash">Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
partitions, please see the fdisk manual page for additional
information.
Syncing disks.
$
</code></pre>
<p>如果我们已经决定保持设备不变,可在提示符下输入<code>q</code>,这将退出程序而没有写更改.
我们 可以安全地忽略这些不祥的警告信息.</p>
<h3 id="gnu-parted"><a class="header" href="#gnu-parted">GNU Parted</a></h3>
<p><a href="https://wiki.archlinux.org/title/Parted_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Parted (简体中文)</a></p>
<p><code>GNU Parted</code> 是创建和处理分区表的程序.  <code>GParted</code>是<code>GUI</code>前端.</p>
<p><code>Parted</code> 有两种模式: 命令行和交互,请用下面命令启动: <code>#</code>表示超级用户模式</p>
<pre><code class="language-bash"># parted device  # device 是要编辑的硬盘设备,例如 /dev/sda
</code></pre>
<hr />
<p><code>命令行模式</code>: 在命令行模式下,可以同时执行一个或多个命令:</p>
<pre><code class="language-bash"># parted /dev/sda mklabel gpt mkpart P1 ext3 1MiB 8MiB
</code></pre>
<hr />
<p><code>交互模式</code>: 交互模式简化了分区过程,可以自动对设备执行分区操作. 打开需要新建分区表的设备:</p>
<pre><code class="language-bash">sudo parted /dev/sdx
</code></pre>
<p>命令提示符会从 (<code>#</code>) 变成 (<code>parted</code>): 要查看可用的命令: <code>(parted) help</code>
完成操作后,用下面命令退出: <code>(parted) quit</code>.</p>
<p>如果命令没带参数,<code>Parted</code> 会进行询问:</p>
<pre><code class="language-bash">(parted) mklabel
New disk label type? gpt
</code></pre>
<p><code>parted 2.4</code> 开始,当使用<code>MiB</code>, <code>GiB</code>, <code>TiB</code> 等 <code>IEC</code>(国际电工委员会)单位时,<code>parted</code> 会使用精确数值,不进行修正,它们是<code>2</code>次幂的容量单位.
而使用<code>4GB</code>这样的设置时,可能会有前后<code>500MB</code>的误差. 所以在创建分区时,应该指定比特(<code>B</code>),扇区(<code>s</code>)或<code>IEC</code>二进制单位<code>MiB</code>,不要使用<code>MB</code>,`GB.</p>
<hr />
<p><code>创建新分区表</code>: 如果设备没有分区,或者要改变分区表类型,重建分区结构,需要新建分区表.</p>
<ul>
<li>打开分区: <code># parted /dev/sdx</code>:</li>
<li>为 <code>BIOS</code> 系统创建 <code>MBR/msdos</code> 分区表: <code>(parted) mklabel msdos</code></li>
<li>为<code>UEFI</code>系统创建 <code>GPT</code> 分区表: <code>(parted) mklabel gpt</code></li>
</ul>
<h3 id="分区方案"><a class="header" href="#分区方案">分区方案</a></h3>
<p>您可以决定磁盘应该分为多少个区,每个分区如何映射至目录(一般称此为挂载点),取决于您的分区方案. 需要满足:</p>
<ul>
<li>至少需要创建一个 <code>/</code> (<code>root</code>) 目录,有些分区类型和<code>启动加载器</code>(<code>bootloader</code>)组合有额外的分区要求:</li>
<li><code>BIOS/GPT</code>+<code>GRUB</code>: 需要按照 <code>BIOS</code> 启动分区设置 的方式创建一个 <code>1M</code> 或 <code>2M</code> 的 <code>EF02</code> 类型分区.</li>
<li><code>UEFI</code> 的主板,需要一个 <code>EFI</code> 系统分区.</li>
<li>如果您需要加密磁盘,则必须加以调整分区方案. 系统安装后,也可以再配置加密文件夹,容器或 <code>home</code> 目录.</li>
</ul>
<p>系统需要需要 <code>/boot</code>, <code>/home</code> 等目录, <a href="https://man.archlinux.org/man/file-hierarchy.7">Arch 文件系统架构</a> 有各目录的详细介绍.
如果没有创建单独的<code>/boot</code> 或 <code>/home</code> 分区,这些目录直接放到了根分区下面</p>
<p>用下面命令打开 <code>parted</code> 交互模式:</p>
<pre><code class="language-bash"># parted /dev/sdx
</code></pre>
<p>用下面命令创建分区: <code>(parted) mkpart part-type fs-type start end</code></p>
<ul>
<li>
<p><code>part-type</code> 是分区类型,可以选择 <code>primary</code>, <code>extended</code> 或 <code>logical</code>,仅用于 <code>MBR </code>分区表.</p>
</li>
<li>
<p><code>fs-type</code> 是文件系统类型,支持的类型列表可以通过 <code>help mkpart</code> 查看.  <code>mkpart</code> 并不会实际创建文件系统, <code>fs-type</code> 参数仅是让 <code>parted</code> 设置一个 <code>1-byte</code> 编码,让启动管理器可以提前知道分区中有什么格式的数据. 参阅 Wikipedia:Disk partitioning#PC partition types.
Tips: 大多数 Linux native file systems 对应的分区码相同 (<code>0x83</code>), 所以对一个 ext4 格式的分区使用例如 ext2 类型是安全的.</p>
</li>
<li>
<p><code>start</code> 是分区的起始位置,可以带单位, 例如 <code>1M</code> 指 <code>1MiB</code>.</p>
</li>
<li>
<p><code>end</code> 是设备的结束位置(不是与 <code>start</code> 值的差),同样可以带单位,也可以用百分比,例如 <code>100%</code> 表示到设备的末尾.</p>
</li>
<li>
<p>为了不留空隙,分区的开始和结束应该首尾相连.</p>
</li>
</ul>
<p>Warning: 分区不相互重叠是很重要的: 如果您不想在设备中留下未使用的空间,请确保每个分区从上一个分区的结尾处开始. 如果看到下面警告:</p>
<pre><code class="language-bash">Warning: The resulting partition is not properly aligned for best performance.
Ignore/Cancel?
</code></pre>
<p>表示分区没对齐,请参照分区对齐进行修正.</p>
<p>下面命令设置 <code>/boot</code> 为启动目录:</p>
<pre><code class="language-bash">(parted) set &lt;partition&gt; boot on
</code></pre>
<p><code>&lt;partition&gt;</code> 是分区的编号,从 <code>print</code> 命令获取.</p>
<hr />
<p>UEFI/GPT 示例</p>
<p>首先需要一个<code>EFI</code>系统分区.如果是和 <code>Windows</code> 双系统启动,此分区已经存在,不要重新创建. 用下面命令创建分区 (建议大小是 <code>512MiB</code> ).</p>
<pre><code class="language-bash">(parted) mkpart ESP fat32 1M 513M
(parted) set 1 boot on
</code></pre>
<p>剩下的空间可以按需要创建. 可以<code>root</code> 占用全部 <code>100%</code> 剩余空间:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 513M 100%
</code></pre>
<p>也可以<code>/</code>(<code>20GiB</code>),剩下的给 <code>/home</code>:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 513M 20.5G
(parted) mkpart primary ext4 20.5G 100%
</code></pre>
<p>创建 <code>/</code> (<code>20GiB</code>), <code>swap</code> (<code>4Gib</code>), 剩下给 <code>/home</code>:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 513M 20.5G
(parted) mkpart primary linux-swap 20.5G 24.5G
(parted) mkpart primary ext4 24.5G 100%
</code></pre>
<hr />
<p><code>BIOS/MBR</code> 示例</p>
<p>单个<code>/</code>目录分区:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 1M 100%
(parted) set 1 boot on
</code></pre>
<p><code>/</code> (<code>20Gib</code>)分区,剩下的给 <code>/home</code>:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 1M 20G
(parted) set 1 boot on
(parted) mkpart primary ext4 20G 100%
</code></pre>
<p><code>/boot</code> (<code>100MiB</code>), <code>/</code> (<code>20Gib</code>), <code>swap</code> (<code>4GiB</code>) 剩下的给 <code>/home</code>:</p>
<pre><code class="language-bash">(parted) mkpart primary ext4 1M 100M
(parted) set 1 boot on
(parted) mkpart primary ext4 100M 20G
(parted) mkpart primary linux-swap 20G 24G
(parted) mkpart primary ext4 24G 100%
</code></pre>
<hr />
<p>双启动 Windows XP</p>
<p>如果您打算将一个同属于启动分区的 Windows XP 分区移动到另一块硬盘,只要将以下的注册表删除,之后就可以用 GParted 轻易地操作,Windows 不会出现任何问题:</p>
<pre><code>HKEY_LOCAL_MACHINE\SYSTEM\MountedDevices
</code></pre>
<h3 id="调整分区"><a class="header" href="#调整分区">调整分区</a></h3>
<p>警告:  若要调整分区,必须先停止使用并卸载它. 如果无法卸载(比如,它被挂载到 <code>/</code>,使用安装介质或者备用系统.  )</p>
<p>注意:</p>
<ul>
<li>使用 <code>parted</code>,你只能移动分区的末尾.</li>
<li>在 parted v4.2 <code>resizepart</code> 可能需要使用#Interactive <code>mode</code></li>
<li>这些说明适用于格式为<code>ext2</code>,<code>ext3</code>或 <code>ext4</code> 文件系统的分区.</li>
</ul>
<p>如果要扩展分区,则必须先调整<code>分区</code>的大小,然后再调整其上的<code>文件系统</code>的大小;
如果要缩小分区,必须先调整<code>文件系统</code>的大小,再调整<code>分区</code>,以避免数据丢失.</p>
<hr />
<p>扩展分区(在 <code>parted</code> 交互模式下):</p>
<pre><code class="language-bash">(parted) resizepart number end
</code></pre>
<p>其中 <code>number</code> 是您正在扩展的分区的编号,而 <code>end</code> 是该分区的新末端(需要大于旧的末端).</p>
<p>然后,扩展此分区上的文件系统:</p>
<pre><code class="language-bash"># resize2fs /dev/sdaX size
</code></pre>
<p><code>sdaX</code> 代表您正在扩展的分区,而 <code>size</code> 是分区的新大小.</p>
<hr />
<p>缩小分区上的文件系统:</p>
<pre><code class="language-bash"># resize2fs /dev/sdaX size
</code></pre>
<p>其中 <code>sdaX</code> 代表您要缩小的分区,而 <code>size</code> 是该分区的新大小.</p>
<p>然后缩小分区(在 <code>parted</code> 交互模式下):</p>
<pre><code class="language-bash">(parted) resizepart number end
</code></pre>
<p>其中 <code>number</code> 是您要缩小的分区的编号,而 <code>end</code> 是该分区的新末端(需要小于旧末端).</p>
<p>完成后,使用 <code>util-linux</code> 中的 <code>resizepart</code> 命令告诉内核新的分区大小:</p>
<pre><code class="language-bash"># resizepart device number size
</code></pre>
<p>其中 <code>device</code> 是保存分区的设备,<code>number</code> 是分区的编号, <code>size</code> 是分区的新大小.</p>
<h3 id="用mkfs命令创建一个新的文件系统"><a class="header" href="#用mkfs命令创建一个新的文件系统">用mkfs命令创建一个新的文件系统</a></h3>
<p>完成了分区编辑工作(它或许是轻量级的),是时候在我们的闪存驱动器上创建一个新的文件系统了.</p>
<p>为此,我们会使用 <code>mkfs</code>(make file system 的简写),它能创建各种格式的文件系统.
在此设备上创建一个 <code>ext3</code>文件系统,我们使用<code>-t</code> 选项来指定这个<code>ext3</code>系统类型,随后是我们要格式化的设备分区名称:</p>
<p>创建<code>ext4</code>格式的文件系统,可以使用<code>mkfs.ext4 </code></p>
<pre><code class="language-bash">$ sudo mkfs -t ext3 /dev/sdb1
mke2fs 1.40.2 (12-Jul-2007)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
...
</code></pre>
<p>当 <code>ext3</code> 被选为文件系统类型时,这个程序会显示许多信息.
若把这个设备重新格式化为它最初的<code>FAT32</code>文件系统,指定<code>vfat</code>作为文件系统类型:</p>
<pre><code class="language-bash">$ sudo mkfs -t vfat /dev/sdb1
</code></pre>
<p>任何时候添加额外的存储设备到系统中时,都可以使用这个分区和格式化的过程.
虽然我们只以一个小小的闪存驱动器为例,同样的操作可以被应用到内部硬盘和其它可移动的存储设备上像 USB 硬盘驱动器.</p>
<h3 id="测试和修复文件系统"><a class="header" href="#测试和修复文件系统">测试和修复文件系统</a></h3>
<p>在之前讨论文件<code>/etc/fstab</code> 时,我们会在每行的末尾看到一些神秘的数字.
每次系统启动时, 在挂载系统之前,都会按照惯例检查文件系统的完整性.</p>
<p>这个任务由 fsck 程序(是<code>file system check</code>的简写)完成.每个 <code>fstab</code> 项中的最后一个数字指定了设备的检查顺序.
在上面的实例中,我们看到首先检查根文件系统,然后是 <code>home</code> 和 <code>boot</code> 文件系统. 若最后一个数字 是零则相应设备不会被检查.</p>
<p>除了检查文件系统的完整性之外,<code>fsck</code> 还能修复受损的文件系统,其成功度依赖于损坏的数量.
在类 Unix 的文件系统中,文件恢复的部分被放置于 <code>lost+found</code> 目录里面,位于每个文件系统的根目录下面.</p>
<p>检查我们的闪存驱动器(首先应该卸载),我们能执行下面的操作:</p>
<pre><code class="language-bash">$ sudo fsck /dev/sdb1
fsck 1.40.8 (13-Mar-2008)
e2fsck 1.40.8 (13-Mar-2008)
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks
</code></pre>
<p>以我的经验,文件系统损坏情况相当罕见,除非硬件存在问题,如磁盘驱动器故障.
在大多数系统中,系统启动阶段若探测到文件系统已经损坏了,则会导致系统停止下来, 在系统继续执行之前,会指导你运行 <code>fsck</code> 程序.</p>
<h4 id="什么是-fsck"><a class="header" href="#什么是-fsck">什么是 fsck?</a></h4>
<p>在 Unix 文化中,<code>fsck</code>这个单词往往会被用来代替一个流行的词,<code>fsck</code>和这个词共享了三个字母.
尤其适用于,当你不得不使用 <code>fsck</code> 命令时,你可能会说出这个词汇.</p>
<h3 id="格式化软盘"><a class="header" href="#格式化软盘">格式化软盘</a></h3>
<p>对于那些还在使用配备了软盘驱动器的计算机的用户,我们也能管理这些设备.</p>
<p>准备一 张可用的空白软盘要分两个步骤.首先,对这张软盘执行低级格式化,然后创建一个文件系统.
为了完成格式化,我们使用 <code>fdformat</code> 程序,同时指定软盘设备名称(通常为<code>/dev/fd0</code>):</p>
<pre><code class="language-bash">$ sudo fdformat /dev/fd0
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
</code></pre>
<p>接下来,通过 <code>mkfs</code> 命令,给这个软盘创建一个 <code>FAT</code> 文件系统:</p>
<pre><code class="language-bash">$ sudo mkfs -t msdos /dev/fd0
</code></pre>
<p>注意我们使用这个<code>msdos</code>文件系统类型来得到旧(小的)风格的文件分配表.
当一个软磁盘被准备好之后,则可能像其它设备一样挂载它.</p>
<h3 id="直接把数据移入出设备"><a class="header" href="#直接把数据移入出设备">直接把数据移入/出设备</a></h3>
<p>虽然我们通常认为计算机中的数据以文件形式来组织数据,但也可以按<code>原始的</code>形式来考虑数据.</p>
<p>如果我们能看到磁盘驱动器上的数据,我们会发现它由大量的<code>数据块</code>组成,而操作系统把这些数据块看作目录和文件.
然而,如果把磁盘驱动器简单地看成一个数据块大集合,我们就能执行有用的任务,如克隆设备.</p>
<p><code>dd</code> 程序能执行此任务.它可以把数据块从一个地方复制到另一个地方.它使用独特的语法(由于历史原因):</p>
<pre><code class="language-bash">dd if=input_file of=output_file [bs=block_size [count=blocks]]
</code></pre>
<p>比方说我们有两个相同容量的 USB 闪存驱动器,并且要精确地把第一个驱动器(中的内容) 复制给第二个.
如果连接两个设备到计算机上,它们各自被分配到设备<code>/dev/sdb</code> 和 <code>/dev/sdc </code>上,
这样我们就能通过下面的命令把第一个驱动器中的所有数据复制到第二个驱动器中.</p>
<pre><code class="language-bash">dd if=/dev/sdb of=/dev/sdc
</code></pre>
<p>或者,如果只有第一个驱动器被连接到计算机上,我们可以把它的内容复制到一个普通文件中供以后恢复或复制数据:</p>
<pre><code class="language-bash">dd if=/dev/sdb of=flash_drive.img
</code></pre>
<p>警告!这个 <code>dd</code> 命令非常强大.
虽然它的名字来自于<code>数据定义</code>,有时候也把它叫做<code>清除磁盘</code> 因为用户经常会误输入 <code>if</code> 或 <code>of</code> 的规范.
在按下回车键之前,要再三检查输入与输出规范!</p>
<h3 id="创建-cd-rom-映像"><a class="header" href="#创建-cd-rom-映像">创建 CD-ROM 映像</a></h3>
<p>写入一个可记录的 CD-ROM(一个 CD-R 或者是 CD-RW)由两步组成:
首先,构建一个 iso 映像文件, 这就是一个 CD-ROM 的文件系统映像,
第二步,把这个映像文件写入到 CD-ROM 媒介中.</p>
<h4 id="创建一个-cd-rom-的映像拷贝"><a class="header" href="#创建一个-cd-rom-的映像拷贝">创建一个 CD-ROM 的映像拷贝</a></h4>
<p>如果想要制作一张现有 CD-ROM 的 iso 映像,我们可以使用 dd 命令来读取 CD-ROM 中的所有数据块, 并把它们复制到本地文件中.</p>
<p>比如说我们有一张 Ubuntu CD,用它来制作一个 iso 文件,以后我们可以用它来制作更多的拷贝.
插入这张 CD 之后,确定 它的设备名称(假定是<code>/dev/cdrom</code>),然后像这样来制作 iso 文件:</p>
<pre><code class="language-bash">dd if=/dev/cdrom of=ubuntu.iso
</code></pre>
<p>这项技术也适用于 DVD 光盘,但是不能用于音频 CD,因为它们不使用文件系统来存储数据.
对于音频 CD,看一下 <code>cdrdao</code> 命令.</p>
<h4 id="从文件集合中创建一个映像"><a class="header" href="#从文件集合中创建一个映像">从文件集合中创建一个映像</a></h4>
<p>创建一个包含目录内容的 iso 映像文件,我们使用 <code>genisoimage</code> 程序.</p>
<p>为此,我们首先创建 一个目录,这个目录中包含了要包括到此映像中的所有文件,然后执行这个 <code>genisoimage</code> 命令 来创建映像文件.</p>
<p>例如,如果我们已经创建一个叫做<code>~/cd-rom-files</code> 的目录,
然后用文件 填充此目录,再通过下面的命令来创建一个叫做 <code>cd-rom.iso</code> 映像文件:</p>
<pre><code class="language-bash">genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
</code></pre>
<p><code>-R</code>选项添加元数据为 Rock Ridge 扩展,这允许使用长文件名和 POSIX 风格的文件权限.
同样地,这个<code>-J</code>选项使 Joliet 扩展生效,这样 Windows 中就支持长文件名了.</p>
<h4 id="一个有着其它名字的程序"><a class="header" href="#一个有着其它名字的程序">一个有着其它名字的程序...</a></h4>
<p>如果你看一下关于创建和烧写光介质如 CD-ROMs 和 DVD 的在线文档,你会经常碰到两个程序 叫做 <code>mkisofs</code> 和 <code>cdrecord</code> .
这些程序是流行软件包<code>cdrtools</code>的一部分,<code>cdrtools</code>由 Jorg Schilling 编写成.</p>
<p>在2006年春天,Schilling 先生更改了部分 cdrtools 软件包的协议,Linux 社区许多人的看法是, 这创建了一个与 <code>GNU GPL</code> 不相兼容的协议.
结果,就 <code>fork</code> 了这个 <code>cdrtools</code> 项目, 目前新项目里面包含了 <code>cdrecord</code> 和 <code>mkisofs</code> 的替代程序,分别是 <code>wodim</code> 和 <code>genisoimage</code> .</p>
<h3 id="写入-cd-rom-镜像"><a class="header" href="#写入-cd-rom-镜像">写入 CD-ROM 镜像</a></h3>
<p>有了一个映像文件之后,我们可以把它烧写到光盘中.下面讨论的大多数命令对可 记录的 CD-ROM 和 DVD 媒
介都适用.</p>
<h4 id="直接挂载一个-iso-镜像"><a class="header" href="#直接挂载一个-iso-镜像">直接挂载一个 ISO 镜像</a></h4>
<p>有一个诀窍,我们可以用它来挂载 <code>iso</code> 映像文件,虽然此文件仍然在我们的硬盘中,但我们当作它已经在光盘中了.</p>
<p>添加 <code>-o loop</code> 选项来挂载(同时带有必需的 <code>-t iso9660</code> 文件系统类型), 挂载这个映像文件就好像它是一台设备,把它连接到文件系统树上:</p>
<pre><code class="language-bash">mkdir /mnt/iso_image
mount -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre>
<p>上面的示例中,我们创建了一个挂载点叫做<code>/mnt/iso_image</code>,然后把此映像文件 <code>image.iso</code> 挂载到挂载点上.</p>
<p>映像文件被挂载之后,可以把它当作,就好像它是一张 真正的 CD-ROM 或者 DVD.当不再需要此映像文件后,记得卸载它.</p>
<h4 id="清除一张可重写入的-cd-rom"><a class="header" href="#清除一张可重写入的-cd-rom">清除一张可重写入的 CD-ROM</a></h4>
<p>可重写入的 CD-RW 媒介在被重使用之前需要擦除或清空.为此,我们可以用 <code>wodim</code> 命令,指定 设备名称和清空的类型.
<code>wodim</code> 程序提供了几种清空类型.最小(且最快)的是 <code>fast</code> 类型:</p>
<pre><code class="language-bash">wodim dev=/dev/cdrw blank=fast
</code></pre>
<h4 id="写入镜像"><a class="header" href="#写入镜像">写入镜像</a></h4>
<p>写入一个映像文件,我们再次使用 <code>wodim</code> 命令,指定光盘设备名称和映像文件名:</p>
<pre><code class="language-bash">wodim dev=/dev/cdrw image.iso
</code></pre>
<p>除了设备名称和映像文件之外,<code>wodim</code> 命令还支持非常多的选项.
常见的两个选项是,<code>-v</code> 可详细输出, 和<code>-dao</code> 以 <code>disk-at-once</code> 模式写入光盘.</p>
<p>如果你正在准备一张光盘为的是商业复制,那么应该使用这种模式.
<code>wodim</code> 命令的默认模式是 track-at-once,这对于录制音乐很有用.</p>
<p>拓展阅读</p>
<p>我们刚才谈到了很多方法,可以使用命令行管理存储介质.看看我们所讲过命令的手册页. 一些命令支持大量的选项和操作.
此外,寻找一些如何添加硬盘驱动器到 Linux 系统(有许多)的在线教程, 这些教程也要适用于光介质存储设备.</p>
<p>友情提示</p>
<p>通常验证一下我们已经下载的 iso 映像文件的完整性很有用处.
在大多数情况下,iso 映像文件的贡献者也会提供 一个 <code>checksum</code> 文件.
一个 <code>checksum</code> 是一个神奇的数学运算的计算结果,这个数学计算会产生一个能表示目标文件内容的数字.
如果目标文件的内容即使更改一个二进制位,<code>checksum</code> 的结果将会非常不一样.</p>
<p><code>生成checksum</code> 数字的最常见方法是使用 <code>md5sum</code> 程序.当你使用 <code>md5sum</code> 程序的时候, 它会产生一个独一无二的十六进制数字:</p>
<pre><code class="language-bash">md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece
image.iso
</code></pre>
<p>当你下载完映像文件之后,你应该对映像文件执行 <code>md5sum</code> 命令,然后把运行结果与发行商提供的 <code>md5sum</code> 数值作比较.</p>
<p>除了检查下载文件的完整性之外,我们也可以使用 <code>md5sum</code> 程序验证新写入的光学存储介质.</p>
<p>为此,首先我们计算映像文件的 <code>checksum</code> 数值,然后计算此光学存储介质的 <code>checksum</code> 数值.
这种验证光学介质的技巧是限定只对 光学存储介质中包含映像文件的部分计算 checksum 数值.
通过确定映像文件所包含的 2048 个字节块的数目(光学存储介质总是以 2048 个字节块的方式写入) 并从存储介质中读取那么多的字节块,我们就可以完成操作.</p>
<p>某些类型的存储介质,并不需要这样做.一个以 disk-at-once 模式写入的 CD-R,可以用下面的方式检验:</p>
<pre><code class="language-bash">md5sum /dev/cdrom
34e354760f9bb7fbf85c96f6a3f94ece
/dev/cdrom
</code></pre>
<p>许多存储介质类型,如 DVD 需要精确地计算字节块的数目.</p>
<p>在下面的例子中,我们检验了映像文件 <code>dvd-image.iso </code>以及 DVD 光驱中磁盘 <code>/dev/dvd</code> 文件的完整性.
你能弄明白这是怎么回事吗?</p>
<pre><code class="language-bash">md5sum dvd-image.iso
dd if=/dev/dvd bs=2048 count=$(( $(stat -c &quot;%s&quot; dvd-image.iso) / 2048 )) |  md5sum
</code></pre>
<h2 id="第十八章查找文件"><a class="header" href="#第十八章查找文件">第十八章:查找文件</a></h2>
<p>因为我们已经浏览了 Linux 系统,所以一件事已经变得非常清楚:一个典型的 Linux 系统包含很多文件!
这就引发了一个问题,<code>我们怎样查找东西?</code>.</p>
<p>虽然我们已经知道 Linux 文件系统良好的组织结构,是源自 类 Unix的操作系统代代传承的习俗.
但是仅文件数量就会引起可怕的问题.</p>
<p>在这一章中,我们将察看 两个用来在系统中查找文件的工具.这些工具是:</p>
<ul>
<li><code>locate</code> – 通过名字来查找文件</li>
<li><code>find</code> – 在目录层次结构中搜索文件</li>
</ul>
<p>我们也将看一个经常与文件搜索命令一起使用的命令,它用来处理搜索到的文件列表:</p>
<ul>
<li><code>xargs</code> – 从标准输入生成和执行命令行</li>
</ul>
<p>另外,我们将介绍两个命令来协助我们探索:</p>
<ul>
<li><code>touch</code> – 更改文件时间</li>
<li><code>stat</code> – 显示文件或文件系统状态</li>
</ul>
<h3 id="locate---查找文件的简单方法"><a class="header" href="#locate---查找文件的简单方法">locate - 查找文件的简单方法</a></h3>
<p>这个 <code>locate</code> 程序快速搜索路径名数据库,并且输出每个与给定字符串相匹配的文件名.
比如说, 例如,我们想要找到所有名字以<code>zip</code>开头的程序.
因为我们正在查找程序,可以假定包含 匹配程序的目录以<code>bin/</code>结尾.
因此,我们试着以这种方式使用 <code>locate</code> 命令,来找到我们的文件:</p>
<pre><code class="language-bash">$ locate bin/zip
</code></pre>
<p><code>locate</code> 命令将会搜索它的路径名数据库,输出任一个包含字符串<code>bin/zip</code>的路径名:</p>
<pre><code class="language-bash">/usr/bin/zip
/usr/bin/zipcloak
...
</code></pre>
<p>如果搜索要求没有这么简单,<code>locate</code> 可以结合其它工具,比如说 <code>grep</code> 命令,来设计更加 有趣的搜索:</p>
<pre><code class="language-bash">$ locate zip | grep bin
/bin/bunzip2
/bin/bzip2
...
</code></pre>
<p>这个 <code>locate</code> 程序已经存在了很多年了,它有几个不同的变体被普遍使用着.</p>
<p>在现在 Linux 发行版中发现的两个最常见的变体是 <code>slocate</code> 和 <code>mlocate</code>,但是通常它们被名为 <code>locate</code> 的 符号链接访问.
不同版本的 locate 命令拥有重复的选项集合.
一些版本包括正则表达式 匹配(我们会在下一章中讨论)和通配符支持.
查看 locate 命令的手册,从而确定安装了 哪个版本的 locate 程序.</p>
<h3 id="locate-数据库来自何方"><a class="header" href="#locate-数据库来自何方">locate 数据库来自何方</a></h3>
<p>你可能注意到了,在一些发行版中,仅仅在系统安装之后,<code>locate</code> 不能工作, 但是如果你第二天再试一下,它就工作正常了.</p>
<p>怎么回事呢?<code>locate</code> 数据库由另一个叫做 <code>updatedb</code> 的程序创建.
通常,这个程序作为一个 <code>cron</code> 工作例程周期性运转;也就是说,一个任务 在特定的时间间隔内被 <code>cron</code> 守护进程执行.
大多数装有<code>locate</code> 的系统会每隔一天运行一回 <code>updatedb</code> 程序.
因为数据库不能被持续地更新,所以当使用 <code>locate</code> 时,你会发现 目前最新的文件不会出现.
为了克服这个问题,可以手动运行 <code>updatedb</code> 程序, 更改为超级用户身份,在提示符下运行 <code>updatedb</code> 命令.</p>
<h3 id="find-查找文件"><a class="header" href="#find-查找文件">find 查找文件</a></h3>
<p><code>locate</code> 程序只能依据文件名来查找文件,而 <code>find</code> 程序能基于各种各样的属性, 搜索一个给定目录(以及它的子目录),来查找文件.
我们将要花费大量的时间学习 <code>find</code> 命令,因为 它有许多有趣的特性,当我们开始在随后的章节里面讨论编程概念的时候,我们将会重复看到这些特性.
<code>find</code> 命令的最简单使用是,搜索一个或多个目录.例如,输出我们的家目录列表.</p>
<pre><code class="language-bash">$ find ~
</code></pre>
<p>对于最活跃的用户帐号,这将产生一张很大的列表.因为这张列表被发送到标准输出, 我们可以把这个列表管道到其它的程序中.
让我们使用 <code>wc</code> 程序来计算出文件的数量:</p>
<pre><code class="language-bash">$ find ~ | wc -l
47068
</code></pre>
<p>哇,我们一直很忙!<code>find</code> 命令的美丽所在就是它能够被用来识别符合特定标准的文件.
它通过 (有点奇怪)应用选项,测试条件,和操作来完成搜索.我们先看一下测试条件.</p>
<h3 id="find-测试"><a class="header" href="#find-测试">find 测试</a></h3>
<p>比如说我们想要目录列表.我们可以添加以下测试条件:</p>
<pre><code class="language-bash">$ find ~ -type d | wc -l
1695
</code></pre>
<p>添加测试条件 <code>-type d</code> 限制了只搜索目录.相反地,我们使用这个测试条件来限定搜索普通文件:</p>
<pre><code class="language-bash">$ find ~ -type f | wc -l
38737
</code></pre>
<p>这里是 <code>find</code> 命令支持的普通文件类型测试条件:</p>
<hr />
<p>表18-1: find 文件类型
文件类型 描述</p>
<ul>
<li><code>b</code> 块设备文件</li>
<li><code>c</code> 字符设备文件</li>
<li><code>d</code> 目录</li>
<li><code>f</code> 普通文件</li>
<li><code>l</code> 符号链接</li>
</ul>
<p>我们也可以通过加入一些额外的测试条件,根据文件大小和文件名来搜索:
让我们查找所有文件名匹配 通配符模式<code>*.JPG</code>和文件大小大于<code>1M</code> 的文件:</p>
<pre><code class="language-bash">$ find ~ -type f -iname &quot;\*.JPG&quot; -size +1M | wc -l
840
</code></pre>
<p>在这个例子里面,我们加入了 <code>-iname</code> 测试条件,后面跟通配符模式.
注意,我们把它用双引号引起来, 从而阻止 shell 展开路径名.</p>
<p>紧接着,我们加入 <code>-size</code> 测试条件,后跟字符串<code>+1M</code>.
开头的加号表明 我们正在寻找文件大小大于指定数的文件.
若字符串以减号开头,则意味着查找小于指定数的文件.
若没有符号意味着<code>精确匹配这个数</code>.
结尾字母<code>M</code>表明测量单位是兆字节.</p>
<p>下面的字符可以 被用来指定测量单位:</p>
<hr />
<p>表18-2: find 大小单位
字符 单位</p>
<ul>
<li><code>b</code> <code>512</code> 个字节块.如果没有指定单位,则这是默认值.</li>
<li><code>c</code> 字节</li>
<li><code>w</code> 两个字节的字</li>
<li><code>k</code> 千字节(<code>1024</code>个字节单位)</li>
<li><code>M</code> 兆字节(<code>1048576</code>个字节单位)</li>
<li><code>G</code> 千兆字节(<code>1073741824</code>个字节单位)</li>
</ul>
<p><code>find</code> 命令支持大量不同的测试条件.下表是列出了一些常见的测试条件.
请注意,在需要数值参数的情况下,可以应用以上讨论的<code>+</code>和<code>-</code>符号表示法:</p>
<hr />
<p>表18-3: <code>find</code> 测试条件
测试条件 描述</p>
<ul>
<li><code>-cmin n</code> ; 匹配的文件和目录的内容或属性最后修改时间正好在 <code>n</code> 分钟之前. 指定少于<code>n</code> 分钟之前,使用 <code>-n</code>,指定多于 <code>n</code> 分钟之前,使用 <code>+n</code>.</li>
<li><code>-cnewer file</code> ; 匹配的文件和目录的内容或属性最后修改时间早于那些文件.</li>
<li><code>-ctime n</code> ; 匹配的文件和目录的内容和属性最后修改时间在 <code>n*24</code> 小时之前.</li>
<li><code>-empty</code> ; 匹配空文件和目录.</li>
<li><code>-group name</code> ; 匹配的文件和目录属于一个组.组可以用组名或组 ID 来表示.</li>
<li><code>-iname pattern</code> ; 就像<code>-name</code> 测试条件,但是不区分大小写.</li>
<li><code>-inum n</code> ; 匹配的文件的 <code>inode</code> 号是 <code>n</code>.这对于找到某个特殊 <code>inode</code> 的所有硬链接很有帮助.</li>
<li><code>-mmin n</code> ; 匹配的文件或目录的内容被修改于 <code>n</code> 分钟之前.</li>
<li><code>-mtime n</code> ; 匹配的文件或目录的内容被修改于<code>n*24</code>小时之前.</li>
<li><code>-name pattern</code> ; 用指定的通配符模式匹配的文件和目录.</li>
<li><code>-newer file</code> ; 匹配的文件和目录的内容早于指定的文件.当编写 <code>shell</code> 脚本,做文件备份时,非常有帮助.
每次你制作一个备份,更新文件(比如说日志),然后使用 <code>find</code> 命令来决定自从上次更新,哪一个文件已经更改了.</li>
<li><code>-nouser</code> ; 匹配的文件和目录不属于一个有效用户.这可以用来查找 属于删除帐户的文件或监测攻击行为.</li>
<li><code>-nogroup</code> ; 匹配的文件和目录不属于一个有效的组.</li>
<li><code>-perm mode</code> ; 匹配的文件和目录的权限已经设置为指定的 <code>mode</code>.<code>mode</code> 可以用 八进制或符号表示法.</li>
<li><code>-samefile name</code> ; 相似于<code>-inum</code> 测试条件.匹配和文件 <code>name</code> 享有同样 <code>inode</code> 号的文件.</li>
<li><code>-size n</code> ; 匹配的文件大小为 <code>n</code>. <code>+n</code>大于, <code>-n</code>小于</li>
<li><code>-type c</code> ; 匹配的文件类型是 <code>c</code>.</li>
<li><code>-user name</code> ; 匹配的文件或目录属于某个用户.这个用户可以通过用户名或用户 ID 来表示.</li>
<li><code>-maxdepth 0 </code> 表示只应用在<code>开始点</code>列表本身.</li>
<li><code>-mindepth  1</code> 表示排除开始点列表,测试其余</li>
</ul>
<p>这不是一个完整的列表.<code>find</code> 命令手册有更详细的说明.</p>
<ul>
<li><code>-size n[cwbkMG]</code>: 文件占据的体积, 可以大于, 小于, 和精确等于, <code>n</code>个单位的空间, 向上取整.  后缀可以是:
<ul>
<li><code>b</code> ;   for 512-byte blocks (this is the default if no suffix is used)</li>
<li><code>c</code> ;   for bytes</li>
<li><code>w</code> ;   for two-byte words</li>
<li><code>k</code> ;   for kibibytes (KiB, units of 1024 bytes)</li>
<li><code>M</code> ;   for mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes)</li>
<li><code>G</code> ;   for gibibytes (GiB, units of 1024 * 1024 * 1024 = 1073741824 bytes)</li>
</ul>
</li>
</ul>
<h3 id="find-操作符"><a class="header" href="#find-操作符">find 操作符</a></h3>
<p>即使拥有了 <code>find</code> 命令提供的所有测试条件,我们还需要一个更好的方式来描述测试条件之间的逻辑关系.</p>
<p>例如,如果我们需要确定是否一个目录中的所有的文件和子目录拥有安全权限,怎么办呢?
我们可以查找权限不是<code>0600</code>的文件和权限不是<code>0700</code>的目录.</p>
<p>幸运地是,<code>find</code> 命令提供了 一种方法来结合测试条件,通过使用逻辑操作符来创建更复杂的逻辑关系.
为了表达上述的测试条件,我们可以这样做:</p>
<pre><code class="language-bash">$ find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
</code></pre>
<p>呀!这的确看起来很奇怪.这些是什么东西?实际上,这些操作符没有那么复杂,一旦你知道了它们的原理.
这里是操作符列表:</p>
<hr />
<p>表18-4: find 命令的逻辑操作符</p>
<ul>
<li><code>-and</code> 如果操作符两边的测试条件都是真,则匹配.可以简写为 <code>-a</code>. 注意若没有使用操作符,则默认使用 <code>-and</code>.</li>
<li><code>-or</code> 若操作符两边的任一个测试条件为真,则匹配.可以简写为 <code>-o</code>.</li>
<li><code>-not</code> 若操作符后面的测试条件是真,则匹配.可以简写为一个感叹号(<code>!</code>).</li>
<li><code>()</code> 把测试条件和操作符组合起来形成更大的表达式.这用来控制逻辑计算的优先级.</li>
</ul>
<p>默认情况下,<code>find</code> 命令按照从左到右的顺序计算.经常有必要重写默认的求值顺序,以得到期望的结果.
即使没有必要,有时候括住组合起来的字符,对提高命令的可读性是很有帮助的.</p>
<p>注意 因为圆括号<code>()</code>字符对于 shell 来说有特殊含义,所以在命令行中使用它们的时候,它们必须 用引号引起来,才能作为实参传递给 <code>find</code> 命令. 通常反斜杠字符被用来转义圆括号字符.</p>
<p>通过这张操作符列表,我们重建 <code>find</code> 命令.从最外层看,我们看到测试条件被分为两组,由一个 <code>-or</code> 操作符分
开:</p>
<pre><code class="language-bash">( expression 1 ) -or ( expression 2 )
</code></pre>
<p>这很有意义,因为我们正在搜索具有不同权限集合的文件和目录.
如果我们文件和目录两者都查找, 那为什么要用 <code>-or</code> 来代替 <code>-and</code> 呢?
因为 <code>find</code> 命令扫描文件和目录时,会计算每一个对象,看看它是否 匹配指定的测试条件.</p>
<p>我们想要知道它是具有错误权限的文件还是有错误权限的目录.
它不可能同时符合这 两个条件.所以如果展开组合起来的表达式,我们能这样解释它:</p>
<pre><code class="language-bash">( file with bad perms ) -or ( directory with bad perms )
</code></pre>
<p>下一个挑战是怎样来检查<code>错误权限</code>,这个怎样做呢?我们不从这个角度做.</p>
<p>我们将测试 <code>不是正确权限</code>,因为我们知道什么是<code>正确权限</code>.
对于文件,我们定义正确权限为<code>0600</code>, 目录则为<code>0711</code>.测试具有<code>不正确</code>权限的文件表达式为:</p>
<pre><code class="language-bash">-type f -and -not -perms 0600
</code></pre>
<p>对于目录,表达式为:</p>
<pre><code class="language-bash">-type d -and -not -perms 0700
</code></pre>
<p>正如上述操作符列表中提到的,这个<code>-and</code> 操作符能够被安全地删除,因为它是默认使用的操作符.</p>
<p>所以如果我们把这两个表达式连起来,就得到最终的命令:</p>
<pre><code class="language-bash">find ~ \( -type f -not -perms 0600 \) -or \( -type d -not -perms 0700 \)
</code></pre>
<p>然而,因为圆括号对于 shell 有特殊含义,我们必须转义它们,来阻止 shell 解释它们.
在圆括号字符 之前加上一个反斜杠字符来转义它们.</p>
<p>逻辑操作符的另一个特性要重点理解.比方说我们有两个由逻辑操作符分开的表达式:</p>
<pre><code class="language-bash">expr1 -operator expr2
</code></pre>
<p>在所有情况下,总会执行表达式 <code>expr1</code>;然而由操作符来决定是否执行表达式 <code>expr2</code>.
这里 列出了它是怎样工作的:</p>
<hr />
<p>表18-5: find AND/OR 逻辑
<code>expr1</code> 的结果 操作符 <code>expr2</code> is...</p>
<ul>
<li><code>真</code> <code>-and</code> 总要执行</li>
<li><code>假</code> <code>-and</code> 从不执行</li>
<li><code>真</code> <code>-or</code> 从不执行</li>
<li><code>假</code> <code>-or</code> 总要执行</li>
</ul>
<p>为什么这会发生呢?这样做是为了提高性能.
以 <code>-and</code> 为例,我们知道表达式 <code>expr1 -and expr2</code> 不能为真,如果表达式 <code>expr1</code> 的结果为假,所以没有必要执行 <code>expr2</code>.</p>
<p>为什么这个很重要? 它很重要是因为我们能依靠这种行为来控制怎样来执行操作.我们会很快看到...</p>
<h3 id="find-预定义的操作"><a class="header" href="#find-预定义的操作">find 预定义的操作</a></h3>
<p>从 <code>find</code> 命令得到的结果列表很有用处,但是我们真正想要做的事情是操作列表中的某些条目.
幸运地是,<code>find</code> 命令允许基于搜索结果来执行操作.有许多预定义的操作和几种方式来 应用用户定义的操作.</p>
<p>首先,让我们看一下几个预定义的操作:</p>
<hr />
<p>表18-6: 几个预定义的 <code>find</code> 命令操作</p>
<ul>
<li><code>-delete</code> 删除当前匹配的文件.</li>
<li><code>-ls</code> 对匹配的文件执行等同的 <code>ls -dils</code> 命令.并将结果发送到标准输出.</li>
<li><code>-print</code> 把匹配文件的全路径名输送到标准输出.如果没有指定其它操作,这是 默认操作.</li>
<li><code>-quit</code> 一旦找到一个匹配,退出.</li>
</ul>
<p>和测试条件一样,还有更多的操作.</p>
<p>查看 <code>find</code> 命令手册得到更多细节.在第一个例子里, 我们这样做:</p>
<pre><code class="language-bash">find ~
</code></pre>
<p>这个命令输出了我们家目录中包含的每个文件和子目录.
它会输出一个列表,因为会默认使用<code>-print</code> 操作 ,如果没有指定其它操作的话.
因此我们的命令也可以这样表述:</p>
<pre><code class="language-bash">find ~ -print
</code></pre>
<p>我们可以使用 <code>find</code> 命令来删除符合一定条件的文件.
例如,来删除扩展名为<code>.BAK</code>(这通常用来指定备份文件) 的文件,我们可以使用这个命令:</p>
<pre><code class="language-bash">find ~ -type f -name '*.BAK' -delete
</code></pre>
<p>在这个例子里面,用户家目录(和它的子目录)下搜索每个以<code>.BAK</code> 结尾的文件名.
当找到后,就删除它们.警告:当使用<code> -delete</code> 操作时,不用说,你应该格外小心.
首先测试一下命令, 用 <code>-print</code> 操作代替<code> -delete</code>,来确认搜索结果.</p>
<p>在我们继续之前,让我们看一下逻辑运算符是怎样影响操作的.考虑以下命令:</p>
<pre><code class="language-bash">find ~ -type f -name '*.BAK' -print
</code></pre>
<p>正如我们所见到的,这个命令会查找每个文件名以<code>.BAK</code> (<code>-name '*.BAK' </code>) 结尾的普通文件 (<code>-type f</code>), 并把每个匹配文件的相对路径名输出到标准输出 (<code>-print</code>).</p>
<p>然而,此命令按这个方式执行的原因,是 由每个测试和操作之间的逻辑关系决定的.
记住,在每个测试和操作之间会默认应用 <code>-and</code> 逻辑运算符. 我们也可以这样表达这个命令,使逻辑关系更容易看出:</p>
<pre><code class="language-bash">find ~ -type f -and -name '*.BAK' -and -print
</code></pre>
<p>当命令被充分表达之后,让我们看看逻辑运算符是如何影响其执行的:</p>
<p><code>-print</code> 只有 <code>-type f and -name '*.BAK'</code>为真的时候
<code>-name *.BAK</code> 只有<code>-type f</code>为真的时候
<code>-type f </code>总是被执行,因为它是与 <code>-and</code> 关系中的第一个测试/行为.</p>
<p>因为测试和行为之间的逻辑关系决定了哪一个会被执行,我们知道测试和行为的顺序很重要.
例如, 如果我们重新安排测试和行为之间的顺序,让 <code>-print</code> 行为是第一个,那么这个命令执行起来会截然不同:</p>
<pre><code class="language-bash">find ~ -print -and -type f -and -name '*.BAK'
</code></pre>
<p>这个版本的命令会打印出每个文件(<code>-print</code> 行为总是为真),然后测试文件类型和指定的文件扩展名.</p>
<h3 id="find-自定义操作"><a class="header" href="#find-自定义操作">find 自定义操作</a></h3>
<p>除了预定义的行为之外,我们也可以唤醒随意的命令.传统方式是通过 <code>-exec</code> 行为.这个行为像这样工作:<code>-exec command {} ;</code></p>
<p>这里的 <code>command</code> 就是指一个命令的名字,<code>{}</code>是当前路径名的符号表示,<code>分号</code>是要求的界定符表明命令结束.
这里是一个使用 <code>-exec</code> 行为的例子,其作用如之前讨论的 <code>-delete</code> 行为:</p>
<pre><code class="language-bash">-exec rm '{}' ';'
</code></pre>
<p>重述一遍,因为花括号<code>{}</code>和分号<code>;</code>对于 <code>shell</code> 有特殊含义,所以它们必须被引起来或被转义.
也有可能交互式地执行一个用户定义的行为.通过使用 <code>-ok</code> 行为来代替 <code>-exec</code>,在执行每个指定的命令之前, 会提示用户:</p>
<pre><code class="language-bash">find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
&lt; ls ... /home/me/bin/foo &gt; ? y
...
</code></pre>
<p>在这个例子里面,我们搜索以字符串<code>foo</code>开头的文件名,并且对每个匹配的文件执行 <code>ls -l</code> 命令.
使用 <code>-ok </code>行为,会在 <code>ls</code> 命令执行之前提示用户.</p>
<h3 id="find-提高效率"><a class="header" href="#find-提高效率">find 提高效率</a></h3>
<p>当 <code>-exec</code> 行为被使用的时候,若每次找到一个匹配的文件,它会启动一个新的指定命令的实例.我们可能更愿意把所有的搜索结果结合起来,再运行一个命令的实例.例如,而不是像这样执行命令:</p>
<pre><code class="language-bash">ls -l file1
ls -l file2
</code></pre>
<p>我们更喜欢这样执行命令:</p>
<pre><code class="language-bash">ls -l file1 file2
</code></pre>
<p>这样就导致命令只被执行一次而不是多次.有两种方法可以这样做.传统方式是使用外部命令 <code>xargs</code>,另一种方法是,使用 <code>find</code> 命令自己的一个新功能.我们先讨论第二种方法.</p>
<p>通过把末尾的分号改为加号,就激活了 <code>find</code> 命令的一个功能,把搜索结果结合为一个参数列表, 然后执行一次所期望的命令.</p>
<pre><code class="language-bash">find ~ -type f -name 'foo*' -exec ls -l '{}' +
-rwxr-xr-x 1 me
</code></pre>
<p>虽然我们得到一样的结果,但是系统只需要执行一次 <code>ls</code> 命令.</p>
<h3 id="find-补充"><a class="header" href="#find-补充">find 补充</a></h3>
<p>find 有一些称为<code>Global option</code>(全局选项)的选项,对于出现在前面的Test,它们仍然会产生影响.
如果你把它放在别的位置,<code>find</code>会报出警告. 它应该被放在<code>star points...</code>后面,也就是文件列表的后面.</p>
<p><code>...</code>表示一个参数可以有多个</p>
<p>诸如 <code>-maxdepth levels</code>,<code>-mindepth levels</code>都是全局参数.</p>
<p><code>-maxdepth 0 </code> 表示只应用在<code>开始点</code>列表本身
<code>-mindepth  1</code> 表示排除开始点列表,测试其余</p>
<p>因为经常遇到文件名中包含空格,所以有一个常用操作<code>-print0</code>.</p>
<p><code>-print0</code>: <code>True</code>;在标准输出上打印完整的文件名, 后面是一个<code>null</code>字符(而不是<code>-print</code>使用的<code>newline</code>字符).
这使得包含换行符或其他类型的空白的文件名, 能够被处理<code>find</code>输出的程序正确解释.  这个选项与<code>xargs</code>的<code>-0</code>选项相对应.</p>
<pre><code class="language-bash">find ./ -mindepth 1 -maxdepth 1 -type f -iname '*.jpg' -print0 | xargs --null ls -l
</code></pre>
<p>通过指定分隔符为<code>null</code>(ASCII<code>0</code>),来构建参数列表</p>
<hr />
<p><code>man find</code>中有一个例子,解释了<code>-printf</code>操作的<code>％f</code>和<code>％h</code>格式指令:</p>
<pre><code class="language-bash">$ find . .. / /tmp /tmp/TRACE compile compile/64/tests/find -maxdepth 0 -printf '[%h][%f]\n'
[.][.]
[.][..]
[][/]
[][tmp]
[/tmp][TRACE]
[.][compile]
[compile/64/tests][find]
</code></pre>
<hr />
<p>只打印文件名称:</p>
<pre><code class="language-bash">find ./opentype ./truetype -mindepth 1 -printf '%f\n'
</code></pre>
<p>即可列出<code>./opentype ./truetype</code>两个目录下所有文件的名称, 不包括前面的路径.</p>
<pre><code class="language-bash">gfind /usr/local/texlive/2020/texmf-dist/fonts/{opentype/,truetype/} -mindepth 1 '(' -iname '*.ttf' -or -iname '*.otf' ')' &gt; ~/test/fontname.txt
</code></pre>
<hr />
<p>按照<code>fontname.txt</code>文件中给出的地址,批量生成符号链接.</p>
<pre><code class="language-bash">for font in $(cat fontname.txt); do
  ln -s  ${font} ${font##*/}
done
</code></pre>
<hr />
<p>不寻常的文件名</p>
<p>查找的许多<code>操作</code>会导致打印其他用户使用的数据.  这包括文件名, 大小, 修改时间等等.  文件名是一个潜在的问题, 因为它们可以包含任何字符, 除了<code>\0</code>和<code>/</code>.
文件名中的不寻常的字符可以对你的终端做意想不到的事情, 而且往往是不可取的(例如, 改变你在某些终端上的功能键的设置).
不同的<code>操作</code>对不寻常的字符有不同的处理方式, 如下所述.</p>
<ul>
<li>
<p><code>-print0, -fprint0</code>:始终打印准确的文件名, 不改变, 即使输出到终端.</p>
</li>
<li>
<p><code>-ls, -fls</code>:不寻常的字符总是被转义.  <code>White space</code>, 反斜杠和双引号字符使用C-风格的转义来打印(例如<code>\f</code>,<code>\&quot;</code>).
其他不寻常的字符使用八进制转义来打印. 其他可打印的字符(对于<code>-ls</code>和<code>-fls</code>, 这些是八进制<code>041</code>和<code>0176</code>之间的字符)按原样打印.</p>
</li>
<li>
<p><code>-printf, -fprintf</code>:如果输出不进入终端, 则按原样打印.
否则, 其结果取决于使用的是哪条指令.  指令<code>%D</code>,<code> %F</code>, <code>%g</code>, <code>%G</code>, <code>%H</code>, <code>%Y</code>, 和<code> %y</code>要展开的值不受文件所有者的控制, 所以会按原样打印.
指令<code>%a</code>,<code>%b</code>, <code>%c</code>, <code>%d</code>, <code>%i</code>, <code>%k</code>, <code>%m</code>, <code>%M</code>, <code>%n</code>, <code>%s</code>, <code>%t</code>, <code>%u</code>和<code>%U</code>的值在文件所有者的控制之下, 但不能用来向终端发送任意数据,因此这些数据被原样打印.
指令<code>%f</code>, <code>%h</code>, <code>%l</code>, <code>%p</code>和<code>%P</code>用引号括起来.  这种加引号的方式与GNU <code>ls</code>的方式相同, 这与用于<code>-ls</code>和<code>-fls</code>的机制不同.
如果你能决定对<code>find</code>的输出使用什么格式, 那么通常使用<code>0</code>作为结束符比使用换行符更好, 因为文件名可以包含空白和换行符.
<code>LC_CTYPE</code>环境变量的设置被用来决定哪些字符需要被引号.</p>
</li>
<li>
<p><code>-print, -fprint</code>: <code>Quoting</code>的处理方式与<code>-printf</code>和<code>-fprintf</code>的处理方式相同.
如果你在脚本中使用<code>find</code>, 或者在匹配的文件可能有任意名称的情况下, 你应该考虑使用<code>-print0</code>而不是而不是<code>-print</code>.</p>
</li>
<li>
<p><code>-ok</code>和<code>-okdir</code>动作是按原样打印当前文件名.  这在未来的版本中可能会改变.</p>
</li>
</ul>
<h3 id="xargs"><a class="header" href="#xargs">xargs</a></h3>
<p>这个 <code>xargs</code> 命令会执行一个有趣的函数.它从标准输入接受输入,并把输入转换为一个特定命令的 参数列表.
对于我们的例子,我们可以这样使用它:</p>
<pre><code class="language-bash">find ~ -type f -name 'foo\*' -print | xargs ls -l
-rwxr-xr-x 1 me
</code></pre>
<p>这里我们看到 <code>find</code> 命令的输出被管道到 <code>xargs</code> 命令,反过来,<code>xargs</code> 会为 <code>ls</code> 命令构建 参数列表,然后执行 <code>ls</code> 命令.</p>
<p>注意:当被放置到命令行中的参数个数相当大时,参数个数是有限制的.
有可能创建的命令 太长以至于 shell 不能接受.
当命令行超过系统支持的最大长度时,<code>xargs</code> 会执行带有最大 参数个数的指定命令,然后重复这个过程直到耗尽标准输入.
执行带有 <code>–show–limits</code> 选项 的 <code>xargs</code> 命令,来查看命令行的最大值.</p>
<p><a href="https://blog.csdn.net/Jerry_1126/article/details/85009615">Shell中去掉文件中的换行符简单方法</a></p>
<pre><code class="language-bash">cat FileName | xargs echo -n   # 连文件末尾换行符也去掉
# 或者
cat FileName | xargs           # 会保留文件末尾的换行符
</code></pre>
<h4 id="处理古怪的文件名"><a class="header" href="#处理古怪的文件名">处理古怪的文件名</a></h4>
<p><a href="https://segmentfault.com/a/1190000023219453">Shell 截取文件名和后缀</a>.
类 Unix 的系统允许在文件名中嵌入空格(甚至换行符).</p>
<p>这就给一些程序,如为其它 程序构建参数列表的<code>xargs</code> 程序,造成了问题.
一个嵌入的空格会被看作是一个界定符,生成的 命令会把每个空格分离的单词解释为单独的参数.
为了解决这个问题,<code>find</code> 命令和 <code>xarg</code> 程序 允许可选择的使用一个 <code>null</code> 字符作为参数分隔符.</p>
<p>一个 <code>null</code> 字符被定义在 <code>ASCII</code> 码中,由数字 <code>0</code>来表示(相反的,例如,<code>空格字符</code>在 <code>ASCII</code> 码中由数字<code>32</code>表示).
<code>find</code> 命令提供的 <code>-print0</code> 行为, 则会产生由 <code>null</code> 字符分离的输出,并且 <code>xargs</code> 命令有一个 <code>--null</code> 选项,这个选项会接受由 <code>null</code> 字符 分离的输入.这里有一个例子:</p>
<pre><code class="language-bash">find ~ -iname '*.jpg' -print0 | xargs --null ls -l
</code></pre>
<p>使用这项技术,我们可以保证所有文件,甚至那些文件名中包含空格的文件,都能被正确地处理.
例如在latex 编译脚本里,可以这么用</p>
<pre><code>find . -iname '*.tex' -printf '%f\0' | xargs --null echo
</code></pre>
<p>其中 <code>-printf '%f\0'</code> 指定输出格式为 不带路径的文件名,然后用ASCII<code>null</code>分隔.</p>
<p>所有可以用的格式指定为</p>
<p>\a     Alarm bell.</p>
<p>\b     Backspace.
\c     Stop printing from this format immediately and flush the output.
\f     Form feed.
\n     Newline.
\r     Carriage return.
\t     Horizontal tab.
\v     Vertical tab.
\0     ASCII NUL.
\     A literal backslash (<code>\'). \NNN   The character whose ASCII code is NNN (octal). A </code>' character followed by any other character is treated as an ordinary character, so they both are printed.
%%     A literal percent sign.
%a     File's last access time in the format returned by the C <code>ctime' function. %Ak    File's last access time in the format specified by k, which is either </code>@' or a directive for the C <code>strftime' function.  The possible values for  k are listed below; some of them might not be available on all systems, due to differences in </code>strftime' between systems.
%c     File's last status change time in the format returned by the C <code>ctime' function. %Ck    File's last status change time in the format specified by k, which is the same as for %A. %d     File's depth in the directory tree; 0 means the file is a starting-point. %D     The device number on which the file exists (the st_dev field of struct stat), in decimal. %f     File's name with any leading directories removed (only the last element). %F     Type of the filesystem the file is on; this value can be used for -fstype. %g     File's group name, or numeric group ID if the group has no name. %G     File's numeric group ID. %h     Leading directories of file's name (all but the last element).  If the file name contains no slashes (since it is in the current directory) the  %h specifier expands to </code>.'.
%H     Starting-point under which file was found.
%i     File's inode number (in decimal).
%k     The  amount of disk space used for this file in 1K blocks.  Since disk space is allocated in multiples of the filesystem block size this is usually
greater than %s/1024, but it can also be smaller if the file is a sparse file.
%l     Object of symbolic link (empty string if file is not a symbolic link).
%m     File's permission bits (in octal).  This option uses the <code>traditional' numbers which most Unix implementations use, but if your  particular  imple‐ mentation  uses an unusual ordering of octal permissions bits, you will see a difference between the actual value of the file's mode and the output of %m.   Normally you will want to have a leading zero on this number, and to do this, you should use the # flag (as in, for example, </code>%#m').
%M     File's permissions (in symbolic form, as for ls).  This directive is supported in findutils 4.2.5 and later.
%n     Number of hard links to file.
%p     File's name.
%P     File's name with the name of the starting-point under which it was found removed.
%s     File's size in bytes.
%S     File's sparseness.  This is calculated as (BLOCKSIZE*st_blocks / st_size).  The exact value you will get for an ordinary file of a  certain  length
is  system-dependent.  However, normally sparse files will have values less than 1.0, and files which use indirect blocks may have a value which is
greater than 1.0.   The value used for BLOCKSIZE is system-dependent, but is usually 512 bytes.   If the file size is zero, the  value  printed  is
undefined.  On systems which lack support for st_blocks, a file's sparseness is assumed to be 1.0.
%t     File's last modification time in the format returned by the C `ctime' function.
%Tk    File's last modification time in the format specified by k, which is the same as for %A.
%u     File's user name, or numeric user ID if the user has no name.
%U     File's numeric user ID.
%y     File's type (like in ls -l), U=unknown type (shouldn't happen)
%Y     File's type (like %y), plus follow symlinks: L=loop, N=nonexistent
%Z     (SELinux only) file's security context.</p>
<p>如果要使用通配符,需要用括号包住,或者进行转义(escape),否则shell 会将路径名展开,find 会接受到错误的参数列表.</p>
<p>比如<code>find . -name *.c  -print</code>会被shell 展开为类似于: <code>find . -name frcode.c locate.c word_io.c -print</code>
这将会使<code>find</code>报错.
Instead of doing things this way, you should enclose the pattern in quotes or escape the wildcard:</p>
<ul>
<li><code>$ find . -name '*.c' -print</code></li>
<li><code>$ find . -name \*.c -print</code></li>
</ul>
<p><code>escape</code>:逃脱,逃离,避开,即避免<code>shell</code>对提供的字符串进行各种处理.</p>
<hr />
<p>例子: 抽取所有子文件,即把子目录的所有文件复制到当前目录下</p>
<p><code>find ./  -type f -print0 | xargs -0 cp -t . --backup=t </code></p>
<h3 id="返回操练场"><a class="header" href="#返回操练场">返回操练场</a></h3>
<p>到实际使用 <code>find</code> 命令的时候了.我们将会创建一个操练场,来实践一些我们所学到的知识.</p>
<p>首先,让我们创建一个包含许多子目录和文件的操练场:</p>
<pre><code class="language-bash">$ mkdir -p playground/dir-{00{1..9},0{10..99},100}
$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
</code></pre>
<p>惊叹于命令行的强大功能!只用这两行,我们就创建了一个包含一百个子目录,每个子目录中 包含了<code>26</code>个空文件的操练场.
试试用 <code>GUI</code> 来创建它!</p>
<p>我们用来创造这个奇迹的方法中包含一个熟悉的命令(<code>mkdir</code>),一个奇异的 <code>shell</code> 扩展(大括号) 和一个新命令,<code>touch</code>.
通过结合 <code>mkdir</code> 命令和<code>-p</code> 选项(导致 <code>mkdir</code> 命令创建指定路径的父目录),以及 大括号展开,我们能够创建一百个目录.</p>
<p>这个 <code>touch</code> 命令通常被用来设置或更新文件的访问,更改,和修改时间.
然而,如果一个文件名参数是一个 不存在的文件,则会创建一个空文件.</p>
<p>在我们的操练场中,我们创建了一百个名为 <code>file-A</code> 的文件实例.让我们找到它们:</p>
<pre><code class="language-bash">$ find playground -type f -name 'file-A'
</code></pre>
<p>注意不同于 <code>ls</code> 命令,<code>find</code> 命令的输出结果是无序的.其顺序由存储设备的布局决定.
为了确定实际上 我们拥有一百个此文件的实例,我们可以用这种方式来确认:</p>
<pre><code class="language-bash">$ find playground -type f -name 'file-A' | wc -l
</code></pre>
<p>下一步,让我们看一下基于文件的修改时间来查找文件.
当创建备份文件或者以年代顺序来 组织文件的时候,这会很有帮助.为此,首先我们将创建一个参考文件,我们将与其比较修改时间:</p>
<pre><code class="language-bash">$ touch playground/timestamp
</code></pre>
<p>这个创建了一个空文件,名为 <code>timestamp</code>,并且把它的修改时间设置为当前时间.
我们能够验证 它通过使用另一个方便的命令,<code>stat</code>,是一款加大马力的 <code>ls</code> 命令版本.
这个 stat 命令会展示系统对 某个文件及其属性所知道的所有信息:</p>
<pre><code class="language-bash">$ stat playground/timestamp
File: 'playground/timestamp'
Size: 0 Blocks: 0 IO Block: 4096 regular empty file
...
</code></pre>
<p>下一步,让我们使用 find 命令来更新一些操练场中的文件:</p>
<pre><code class="language-bash">$ find playground -type f -name 'file-B' -exec touch '{}' ';'
</code></pre>
<p>这会更新操练场中所有名为 <code>file-B</code> 的文件.
接下来我们会使用 find 命令来识别已更新的文件, 通过把所有文件与参考文件 <code>timestamp</code> 做比较:</p>
<pre><code class="language-bash">$ find playground -type f -newer playground/timestamp
</code></pre>
<p>搜索结果包含所有一百个文件 <code>file-B</code> 的实例.
因为我们在更新了文件 <code>timestamp</code> 之后, <code>touch</code> 了操练场中名为 <code>file-B</code> 的所有文件,
所以现在它们&quot;新于&quot;<code>timestamp</code> 文件,因此能被用 <code>-newer</code> 测试条件识别出来.</p>
<p>最后,让我们回到之前那个错误权限的例子中,把它应用于操练场里:</p>
<pre><code class="language-bash">$ find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
</code></pre>
<p>这个命令列出了操练场中所有一百个目录和二百六十个文件(还有 <code>timestamp</code> 和操练场本身,共 <code>2702</code> 个) ,
因为没有一个符合我们<code>正确权限</code>的定义.</p>
<p>通过对运算符和行为知识的了解,我们可以给这个命令添加行为,对实战场中的文件和目录应用新的权限.</p>
<pre><code class="language-bash">$ find playground \( -type f -not -perm 0600 -exec chmod 0600 '{}' ';' \) -or \( -type d -not -perm 0711 -exec chmod 0700 '{}' ';' \)
</code></pre>
<p>在日常的基础上,我们可能发现运行两个命令会比较容易一些,一个操作目录,另一个操作文件,
而不是这一个长长的复合命令,但是很高兴知道,我们能这样执行命令.</p>
<p>这里最重要的一点是要 理解怎样把操作符和行为结合起来使用,来执行有用的任务.</p>
<h3 id="选项"><a class="header" href="#选项">选项</a></h3>
<p>最后,我们有这些选项.这些选项被用来控制 <code>find</code> 命令的搜索范围.
当构建 <code>find</code> 表达式的时候, 它们可能被其它的测试条件和行为包含:</p>
<hr />
<p>表 18-7: find 命令选项
选项 描述</p>
<ul>
<li><code>-depth</code> 指导 <code>find</code> 程序先处理目录中的文件,再处理目录自身.当指定<code>-delete</code> 行为时,会自动 应用这个选项.</li>
<li><code>-maxdepth levels</code> 当执行测试条件和行为的时候,设置 <code>find</code> 程序陷入目录树的最大级别数</li>
<li><code>-mindepth levels</code> 在应用测试条件和行为之前,设置 <code>find</code>程序陷入目录数的最小级别数.</li>
<li><code>-mount 指导 find</code> 程序不要搜索挂载到其它文件系统上的目录.</li>
<li><code>-noleaf 指导 find</code> 程序不要基于搜索类 Unix 的文件系统做出的假设,来优化它的搜索.</li>
</ul>
<p>拓展阅读</p>
<p>程序 locate,<code>updatedb</code>,find 和 xargs 都是 GNU 项目 findutils 软件包的一部分.
这个 GUN 项目提供了大量的在线文档,这些文档相当出色,如果你在高安全性的 环境中使用这些程序,你应该读读这些文档.
<a href="http://www.gnu.org/software/findutils/">http://www.gnu.org/software/findutils/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-7"><a class="header" href="#linux-7">linux-7</a></h1>
<h2 id="第十九章归档和备份"><a class="header" href="#第十九章归档和备份">第十九章:归档和备份</a></h2>
<p>计算机系统管理员的一个主要任务就是保护系统的数据安全,其中一种方法是通过定时备份系统文件,来保护数据.
即使你不是一名系统管理员,像做做拷贝或者在各个位置和设备之间移动大量的文件,通常也是很有帮助的.</p>
<p>在这一章中,我们将会看看几个经常用来管理文件集合的程序.它们就是文件压缩程序:</p>
<ul>
<li><code>gzip</code> – 压缩或者展开文件</li>
<li><code>bzip2</code> – 块排序文件压缩器</li>
</ul>
<p>归档程序:</p>
<ul>
<li><code>tar</code> – 磁带打包工具</li>
<li><code>zip</code> – 打包和压缩文件</li>
</ul>
<p>还有文件同步程序:</p>
<ul>
<li><code>rsync</code> – 同步远端文件和目录</li>
</ul>
<h3 id="压缩文件"><a class="header" href="#压缩文件">压缩文件</a></h3>
<p>纵观计算领域的发展历史,人们努力想把最多的数据存放到到最小的可用空间中,不管是内存,存储设备 还是网络带宽.
诸如便携式音乐播放器, 高清电视,或宽带网络之类的存在都应归功于高效的数据压缩技术.</p>
<p>数据压缩就是一个删除冗余数据的过程.</p>
<p>比方说我们有一张<code>100*100</code>像素的 纯黑的图片文件,假定每个像素占<code>24</code>位,或者<code>3</code>个字节,那么这张图像将会占用 <code>30,000</code> 个字节的存储空间:</p>
<pre><code class="language-bash">100 * 100 * 3 = 30,000
</code></pre>
<p>一张单色图像包含的数据全是多余的.我们只要简单地描述这个事实,我们有3万个黑色的像素数据块.
所以,我们不存储包含<code>3万</code>个<code>0</code> (通常在图像文件中,黑色由<code>0</code>来表示)的数据块,
相反,我们把这些数据压缩为数字<code>30,000</code>, 后跟一个<code>0</code>.
这种数据压缩方案被称为游程编码,是一种最基本的压缩技术.</p>
<p>压缩算法(数学技巧被用来执行压缩任务)分为两大类,无损压缩和有损压缩.</p>
<p>无损压缩保留了原始文件的所有数据.还原出的文件与原文件一模一样.</p>
<p>而另一方面,有损压缩,执行压缩操作时会删除数据,允许更大的压缩.
有损文件被还原后, 与原文件不相匹配, 而是一个近似值.
有损压缩的例子有 <code>JPEG</code>(图像)文件和 <code>MP3</code>(音频)文件.</p>
<p>在我们的讨论中,我们将看看完全无损压缩,因为计算机中的大多数数据是不能容忍丢失任何数据的.</p>
<h3 id="gzip"><a class="header" href="#gzip">gzip</a></h3>
<p><code>gzip</code> 程序被用来压缩一个或多个文件.当执行 <code>gzip</code> 命令时,原始文件的压缩版会替代原始文件.
相对应的 <code>gunzip</code> 程序用来把压缩文件复原.这里有个例子:</p>
<pre><code class="language-bash">$ ls -l /etc &gt; foo.txt
$ gzip foo.txt
$ gunzip foo.txt.gz
</code></pre>
<p>在这个例子里,我们创建了一个名为 <code>foo.txt</code> 的文本文件,其内容是一个目录的列表.
接下来,我们运行 <code>gzip</code> 命令,它会把原始文件替换为一个叫做 <code>foo.txt.gz</code> 的压缩文件.
在 <code>foo.*</code> 文件列表中,我们看到原始文件已经被压缩文件替代了,这个压缩文件大约是原始文件的十五分之一.
我们也能看到压缩文件与原始文件有着相同的权限和时间戳.</p>
<p>接下来,我们运行 <code>gunzip</code> 程序来解压缩文件.
随后,我们见到压缩文件已经被原始文件替代了, 同样地保留了相同的权限和时间戳.</p>
<p><code>gzip</code> 命令有许多选项.这里列出了一些:
表19-1: gzip 选项</p>
<hr />
<p>选项 说明</p>
<ul>
<li><code>-c</code> 把输出写入到标准输出,并且保留原始文件.也能用 <code>--stdout</code> 和 <code>--to-stdout</code> 选项来指定.</li>
<li><code>-d</code> 解压缩.正如 <code>gunzip</code> 命令一样.也可以用<code>--decompress</code> 或者<code>--uncompress</code> 选项来指定.</li>
<li><code>-f</code> 强制压缩,即使原始文件的压缩文件已经存在了,也要执行.也可以用<code>--force</code>选项来指定.</li>
<li><code>-h</code> 显示用法信息.也可用<code>--help</code> 选项来指定.</li>
<li><code>-l</code> 列出每个被压缩文件的压缩数据.也可用<code>--list</code> 选项.</li>
<li><code>-r</code> 若命令的一个或多个参数是目录,则递归地压缩目录中的文件.也可用<code>--recursive</code> 选项来指定.</li>
<li><code>-t</code> 测试压缩文件的完整性.也可用<code>--test</code>选项来指定.</li>
<li><code>-v</code> 显示压缩过程中的信息.也可用<code>--verbose</code> 选项来指定.</li>
<li><code>-number</code> 设置压缩指数.<code>number</code> 是一个在<code>1</code>(最快,最小压缩)到<code>9</code>(最慢,最大压缩)之间的整数.
数值<code>1</code>和<code>9</code>也可以用<code>--fast</code>和<code>--best</code> 选项来表示.默认值是整数6.</li>
</ul>
<p>返回到我们之前的例子中:</p>
<pre><code class="language-bash">$ gzip foo.txt
$ gzip -tv foo.txt.gz
foo.txt.gz: OK
$ gzip -d foo.txt.gz
</code></pre>
<p>这里,我们用压缩文件来替代文件 <code>foo.txt</code>,压缩文件名为 <code>foo.txt.gz</code>. 下一步,我们测试了压缩文件 的完整性,使用了<code>-t</code> 和 <code>-v</code> 选项.</p>
<pre><code class="language-bash">$ ls -l /etc | gzip &gt; foo.txt.gz
</code></pre>
<p>这个命令创建了一个目录列表的压缩文件.
<code>gunzip</code> 程序,会解压缩 <code>gzip</code> 文件,假定那些文件名的扩展名是<code>.gz</code>,所以没有必要指定它, 只要指定的名字与现有的未压缩文件不冲突就可以:</p>
<pre><code class="language-bash">$ gunzip foo.txt
</code></pre>
<p>如果我们的目标只是为了浏览一下压缩文本文件的内容,我们可以这样做:</p>
<pre><code class="language-bash">$ gunzip -c foo.txt | less
</code></pre>
<p>另外,对应于 <code>gzip</code> 还有一个程序,叫做 <code>zcat</code>,它等同于带有<code>-c</code> 选项的 <code>gunzip</code> 命令.
它可以被用来如 <code>cat</code> 命令作用于 <code>gzip</code> 压缩文件:</p>
<pre><code class="language-bash">$ zcat foo.txt.gz | less
</code></pre>
<p>小贴士: 还有一个 <code>zless</code> 程序.它与上面的管道线有相同的功能.</p>
<h3 id="bzip2"><a class="header" href="#bzip2">bzip2</a></h3>
<p><code>bzip2</code> 程序,由 Julian Seward 开发,与 <code>gzip</code> 程序相似,但使用了不同的压缩算法, 舍弃了压缩速度,从而实现了更高的压缩级别. 在大多数情况下,它的工作模式等同于 <code>gzip</code> .
由 <code>bzip2</code> 压缩的文件,用扩展名 <code>.bz2</code>来表示:</p>
<pre><code class="language-bash">$ ls -l /etc &gt; foo.txt
$ ls -l foo.txt
$ bzip2 foo.txt
$ ls -l foo.txt.bz2
$ bunzip2 foo.txt.bz2
</code></pre>
<p>正如我们所看到的, <code>bzip2</code> 程序用起来和 <code>gzip</code> 程序一样.</p>
<p>我们之前讨论的 <code>gzip</code> 程序的所有选项(除了<code>-r</code>) ,<code>bzip2</code> 程序同样也支持.
注意,然而,压缩级别选项(<code>-number</code>)对于 <code>bzip2</code> 程序来说,含义有稍许不同.</p>
<p>伴随着 <code>bzip2</code> 程序,有 <code>bunzip2</code> 和 <code>bzcat</code> 程序用来解压缩文件.
还有 <code>bzip2recover</code> 程序,可以用来尝试恢复受损的 <code>.bz2</code> 文件.</p>
<h4 id="不要强迫性压缩"><a class="header" href="#不要强迫性压缩">不要强迫性压缩</a></h4>
<p>偶尔会有人试图用高效的压缩算法,来压缩一个已经被压缩过的文件:</p>
<pre><code class="language-bash">$ gzip picture.jpg
</code></pre>
<p>不要这样,  你可能只是在浪费时间和空间.
如果你再次压缩已经压缩过的文件,实际上你会得到一个更大的文件.
这是因为所有的压缩技术都会涉及一些开销,文件中会被添加描述此次压缩过程的信息.
如果你试图压缩一个已经不包含多余信息的文件,那么再次压缩不会节省空间,以抵消额外的开销.</p>
<h3 id="归档文件"><a class="header" href="#归档文件">归档文件</a></h3>
<p>一个常见的,与文件压缩结合一块使用的文件管理任务是归档.归档就是收集许多文件,并把它们 捆绑成一个大文件的过程.</p>
<p>归档经常作为系统备份的一部分来使用.当把旧数据从一个系统移到某种类型的长期存储设备中时,也会用到归档程序.</p>
<h3 id="tar"><a class="header" href="#tar">tar</a></h3>
<p>在类 <code>Unix</code> 的软件世界中,这个 <code>tar</code> 程序是用来归档文件的经典工具.它是 <code>tape archive</code> 的简称,揭示了它的起源是一款制作磁带备份的工具.
虽然仍被用来完成传统任务, 它也同样适用于其它类型的存储设备.</p>
<p>我们经常看到扩展名为 <code>.tar</code> 或者 <code>.tgz</code> 的文件,它们各自表示<code>普通</code> 的 <code>tar</code> 包和被 <code>gzip</code> 程序压缩过的 <code>tar</code> 包.
一个 <code>tar</code> 包可以由一组独立的文件,一个或者多个目录,或者 两者混合体组成. 命令语法如下:</p>
<pre><code class="language-bash">tar mode[options] pathname...
</code></pre>
<p>这里的 <code>mode</code> 是指以下操作模式之一(这里只展示了一部分,查看 <code>tar</code> 的手册来得到完整列表):</p>
<hr />
<p>表19-2: <code>tar</code> 模式
模式 说明</p>
<ul>
<li><code>c</code> 为文件和/或目录列表创建归档文件.</li>
<li><code>x</code> 抽取归档文件.</li>
<li><code>r</code> 追加具体的路径到归档文件的末尾.</li>
<li><code>t</code> 列出归档文件的内容.</li>
</ul>
<p><code>tar</code> 命令使用了稍微有点奇怪的方式来表达它的选项,所以我们需要一些例子来展示它是怎样工作的.
首先,让我们重新创建之前我们用过的操练场:</p>
<pre><code class="language-bash">$ mkdir -p playground/dir-{00{1..9},0{10..99},100}
$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
</code></pre>
<p>下一步,让我们创建整个操练场的 <code>tar</code> 包:</p>
<pre><code class="language-bash">$ tar cf playground.tar playground
</code></pre>
<p>这个命令创建了一个名为 <code>playground.tar</code> 的 tar 包,其包含整个 <code>playground</code> 目录层次结果.
我们 可以看到模式 <code>c</code> 和选项 <code>f</code>,其被用来指定这个 <code>tar</code> 包的名字,模式和选项可以写在一起,而且不需要开头的短横线.</p>
<p>注意,必须首先指定模式,然后才是其它的选项. 要想列出归档文件的内容,我们可以这样做:</p>
<pre><code class="language-bash">$ tar tf playground.tar
</code></pre>
<p>为了得到更详细的列表信息,我们可以添加选项 <code>v</code>:</p>
<pre><code class="language-bash">$ tar tvf playground.tar
</code></pre>
<p>现在,抽取 <code>tar</code> 包 <code>playground</code> 到一个新位置.我们先创建一个名为 <code>foo</code> 的新目录,更改目录, 然后抽取 <code>tar</code> 包中的文件:</p>
<pre><code class="language-bash">$ mkdir foo
$ cd foo
$ tar xf ../playground.tar
$ ls playground
</code></pre>
<p>如果我们检查 <code>~/foo/playground</code> 目录中的内容,会看到这个已经成功创建了原始文件的精确副本.
然而有个警告:除非你是超级用户,否则从归档文件中抽取的文件和目录的所有权在执行复原操作的用户手里,而不属于原始所有者.</p>
<hr />
<p><code>tar</code> 命令另一个有趣的行为是它处理归档文件路径名的方式.
默认情况下,路径名是相对的,而不是绝对路径.当创建归档文件的时候,<code>tar</code> 命令会简单地删除路径名开头的斜杠.
为了说明问题,我们将重新创建我们的归档文件,这次指定一个绝对路径:</p>
<pre><code class="language-bash">$ cd
$ tar cf playground2.tar ~/playground
</code></pre>
<p>记住,当按下回车键后,<code>~/playground</code> 会展开成 <code>/home/me/playground</code>,所以我们会得到一个绝对路径.
接下来和之前一样, 我们抽取归档文件,观察发生了什么:</p>
<pre><code class="language-bash">$ cd foo
$ tar xf ../playground2.tar
$ ls
home playground
$ ls home
me
$ ls home/me
playground
</code></pre>
<p>我们看到, 当抽取第二个归档文件时,它重新创建了 <code>home/me/playground</code> 目录.
并且是相对于当前的工作目录<code>~/foo</code>,而不是相对于 <code>root</code>.
这看起来似乎是一种奇怪的工作方式,但事实上这种方式很有用,因为这样就允许我们抽取文件到任意位置,
而不是强制地把抽取的文件放置到原始目录下.</p>
<p>加上 <code>verbose</code>(<code>v</code>)选项,重做 这个练习,将会展现更加详细的信息.</p>
<hr />
<p>让我们展示一个<code>tar</code>命令的实际应用. 假定我们想要复制家目录及其内容到另一个系统中, 并且有一个大容量的 <code>USB</code> 硬盘,可以作为传输工具.</p>
<p>在现代 <code>Linux</code> 系统中, 这个硬盘会被<code>自动地</code>挂载到 <code>/media</code> 目录下. 我们也假定硬盘中有一个名为 <code>BigDisk</code> 的逻辑卷. 为了制作 <code>tar</code> 包,我们可以这样做:</p>
<pre><code class="language-bash">$ sudo tar cf /media/BigDisk/home.tar /home
</code></pre>
<p><code>tar</code> 包制作完成之后,我们卸载硬盘,然后把它连接到第二个计算机上.
再一次,此硬盘被挂载到<code>/media/BigDisk</code> 目录下.为了抽取归档文件,我们这样做:</p>
<pre><code class="language-bash">$ cd /
$ sudo tar xf /media/BigDisk/home.tar
</code></pre>
<p>值得注意的一点是,因为归档文件中的所有路径名都是相对的,所以首先我们必须更改目录到根目录下, 这样抽取的文件路径是相对于根目录的.
当抽取一个归档文件时,可以限制从归档文件中抽取的内容. 例如抽取单个文件, 可以这样实现:</p>
<pre><code class="language-bash">tar xf archive.tar pathname
</code></pre>
<p>通过给命令添加末尾的路径名,<code>tar</code> 命令就只会恢复指定的文件.可以指定多个路径名.
注意:路径名必须是精准的相对路径名,和存储在归档文件中的完全一样.</p>
<p>当指定路径名的时候, 通常不支持通配符.
然而,<code>GNU</code> 版本的 <code>tar</code> 命令(在 Linux 发行版中最常出现)可以通过 <code>--wildcards</code> 选项来支持通配符.
这个例子使用了之前的 <code>playground.tar</code> 文件:</p>
<pre><code class="language-bash">$ cd foo
$ tar xf ../playground2.tar --wildcards 'home/me/playground/dir-*/file-A'
</code></pre>
<p>这个命令将只会抽取路径名匹配 <code>dir-*</code>的文件.</p>
<p><code>tar</code> 命令经常结合 <code>find</code> 命令一起来制作归档文件.
我们可以使用 <code>find</code>来产生一个文件集合,然后把它们加入到归档文件中.</p>
<pre><code class="language-bash">$ find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
</code></pre>
<p>这里我们使用 <code>find</code> 命令来匹配 <code>playground</code> 目录中所有名为 <code>file-A</code> 的文件,
然后使用 <code>-exec</code> 行为,来唤醒带有追加模式(<code>r</code>)的 <code>tar</code> 命令,把匹配的文件添加到归档文件 <code>playground.tar</code> 中.</p>
<p>使用 <code>tar</code> 和 <code>find</code> 命令,来创建逐渐增加的目录树, 或者整个系统的备份,是个不错的方法.
通过 <code>find</code> 命令匹配新于某个时间戳的文件,我们就能够创建一个归档文件,
令其只包含新于上一个 <code>tar</code> 包的文件(假定这个时间戳文件恰好在每个归档文件创建之后被更新了).</p>
<p><code>tar</code> 命令也可以利用标准输出和输入.这里是一个完整的例子:</p>
<pre><code class="language-bash">$ cd
$ find playground -name 'file-A' | tar cf - --files-from=- | gzip &gt; playground.tgz
</code></pre>
<p>在这个例子里面,我们使用 <code>find</code> 程序产生了一个匹配文件列表,然后把它们管道到 <code>tar</code> 命令中.</p>
<p>如果指定了文件名<code>-</code>,则其被看作是标准输入或标准输出.
在上面的例子中<code>tar cf -</code>中的是标准输出,<code>--files-from=-</code>中的是标准输入.
(顺便说一下,使用<code>-</code>来表示 标准输入/输出的惯例,也被大量的其它程序使用).</p>
<p>这个 <code>--file-from</code> 选项(也可以用 <code>-T</code> 来指定) 导致 <code>tar</code> 命令从一个文件而不是命令行来读入它的路径名列表.</p>
<p>最后,这个由 <code>tar</code> 命令产生的归档 文件被管道到 <code>gzip</code> 命令中,然后创建了压缩归档文件 <code>playground.tgz</code>.
<code>.tgz</code> 扩展名是被<code>gzip</code> 压缩过的 <code>tar</code> 文件的常规扩展名.有时候也会使用 <code>.tar.gz</code>这个扩展名.</p>
<h3 id="顺便压缩"><a class="header" href="#顺便压缩">顺便压缩</a></h3>
<p>在这里我们手动调用了<code>gzip</code>来制作归档文件的压缩版本.
实际上现在 GUN 版本的 <code>tar</code> 命令 ,可以直接在归档的同时进行压缩,<code>gzip</code>压缩对应选项<code>z</code>, <code>bzip2</code> 压缩对应选项<code>j</code>.
之前的例子可以简化为:</p>
<pre><code class="language-bash"># 创建一个由 gzip 压缩的归档文件,可以这样做:
$ find playground -name 'file-A' | tar czf playground.tgz -T -
# 创建一个由 bzip2 压缩的归档文件,可以这样做:
$ find playground -name 'file-A' | tar cjf playground.tbz -T -
</code></pre>
<hr />
<p>另一个 <code>tar</code> 命令与标准输入和输出的有趣使用,涉及到在系统之间经过 网络传输文件.</p>
<p>假定我们有两台机器,每台都运行着类 Unix,且装备着 <code>tar</code> 和 <code>ssh</code> 工具的操作系统.
在这种情景下,我们可以把一个目录从远端系统(名为 <code>remote-sys</code>)传输到我们的本地系统中:</p>
<pre><code class="language-bash">$ mkdir remote-stuff
$ cd remote-stuff
$ ssh remote-sys 'tar cf - Documents' | tar xf -
me@remote-sys' s password:
$ ls Documents
</code></pre>
<p>这里我们能够从远端系统 <code>remote-sys</code> 中复制目录 <code>Documents</code> 到本地系统名为 <code>remote-stuff</code> 目录中.</p>
<p>我们怎样做的呢?首先,通过使用 <code>ssh</code> 命令在远端系统中启动 <code>tar</code> 程序.
你可记得 <code>ssh</code> 允许我们在远程联网的计算机上执行程序,并将远端系统中产生的输出结果被发送到本地系统中查看.
然后在本地系统中,我们执行 <code>tar xf -</code> 命令, 抽取标准输出中的文件.</p>
<h3 id="zip"><a class="header" href="#zip">zip</a></h3>
<p><code>zip</code> 程序既是压缩工具,也是一个打包工具. 它读取和写入 <code>.zip</code> 文件, <code>Windows</code> 用户比较熟悉这种文件格式.
然而,在 Linux 中 <code>gzip</code> 是主要的压缩程序, <code>bzip2</code>则排第二.</p>
<p>在 <code>zip</code> 命令的基本用法为:</p>
<pre><code class="language-bash">zip options zipfile file...
</code></pre>
<p>例如,制作一个 <code>playground</code> 的 <code>zip</code> 版本的文件包,这样做:</p>
<pre><code class="language-bash">$ zip -r playground.zip playground
</code></pre>
<p>我们需要包含 <code>-r</code> 选项,不然只有 <code>playground</code> 目录(没有任何它的内容)被存储.
虽然程序会自动添加 <code>.zip</code> 扩展名,但为了清晰起见,我们还是手动加上.</p>
<p>在创建 <code>zip</code> 版本的文件包时,<code>zip</code> 命令通常会显示一系列的信息:</p>
<pre><code class="language-bash">adding: playground/dir-020/file-Z (stored 0%)
adding: playground/dir-020/file-Y (stored 0%)
</code></pre>
<p>这些信息显示了添加到文件包中每个文件的状态.</p>
<p><code>zip</code> 命令会选用两种存储方法之一,来添加文件到文件包中:
一种是<code>store</code>,没有经过压缩的文件,正如这里所示,
另一种是<code>deflate</code>, 执行压缩操作.
在存储方法之后显示的数值表明了压缩量.</p>
<p>因为我们的 <code>playground</code> 目录只包含空文件,没有对它的内容执行压缩操作.</p>
<hr />
<p>使用 <code>unzip</code> 程序,来直接抽取一个 <code>zip</code> 文件的内容.</p>
<pre><code class="language-bash">$ cd foo
$ unzip ../playground.zip
</code></pre>
<p>对于 <code>zip</code> 命令(与 <code>tar</code> 命令相反)要注意一点,就是如果指定了的文件包已经存在,那么它会被更新而不是被替代.
这意味着会保留此文件包,但是会添加新文件,同时替换匹配的文件.</p>
<p>可以列出 文件或者有选择地从一个 <code>zip</code> 文件包中抽取文件,只要给 <code>unzip</code> 命令指定文件名:</p>
<pre><code class="language-bash">$ unzip -l playground.zip playground/dir-087/file-Z
$ cd foo
$ unzip ./playground.zip playground/dir-087/file-Z
</code></pre>
<p>使用 <code>-l</code> 选项,导致 <code>unzip</code> 命令只是列出文件包中的内容而没有抽取文件.</p>
<p>如果没有指定文件, <code>unzip</code> 程序将会列出文件包中的所有文件.
添加这个 <code>-v</code> 选项会增加列表的冗余信息.注意当抽取的文件与已经存在的文件冲突时,会在替代此文件之前提醒用户.</p>
<p>像 <code>tar</code> 命令一样,<code>zip</code> 命令能够利用标准输入和输出,虽然它的实施不大有用.
通过<code>-@</code>选项,有可能把一系列的文件名管道到 <code>zip</code> 命令.</p>
<pre><code class="language-bash">$ cd
$ find playground -name &quot;file-A&quot; | zip -@ file-A.zip
</code></pre>
<p>这里我们使用 <code>find</code> 命令产生一系列与<code>file-A</code>相匹配的文件列表,并且把此列表管道到 <code>zip</code> 命令,然后创建包含所选文件的文件包 <code>file-A.zip</code>.</p>
<p><code>zip</code> 命令也支持把它的输出写入到标准输出,但是它的使用是有限的,因为很少的程序能利用输出.
不幸地是,<code>unzip</code> 程序不接受标准输入.这就阻止了 <code>zip</code> 和 <code>unzip</code> 一块使用,像 <code>tar</code> 命令那样, 来复制网络上的文件.</p>
<p>然而<code>zip</code> 命令可以接受标准输入,所以它可以被用来压缩其它程序的输出:</p>
<pre><code class="language-bash">$ ls -l /etc/ | zip ls-etc.zip -
adding: - (deflated 80%)
</code></pre>
<p>在这个例子里,我们把 <code>ls</code> 命令的输出管道到 <code>zip</code> 命令.
像 <code>tar</code> 命令,<code>zip</code> 命令把末尾的<code>横杠</code>解释为 <code>使用标准输入作为输入文件</code></p>
<p>通过指定<code>-p</code>选项,<code>unzip</code> 程序允许把它的结果发送到标准输出:</p>
<pre><code class="language-bash">$ unzip -p ls-etc.zip | less
</code></pre>
<p>我们讨论了一些 <code>zip</code>/<code>unzip</code> 可以完成的基本操作.
它们两个都有许多选项,其增加了 命令的灵活性,虽然一些选项只针对于特定的平台.</p>
<p><code>zip</code> 和 <code>unzip</code> 命令的说明手册都相当不错, 并且包含了有用的实例.
然而,这些程序的主要用途是为了和 <code>Windows</code> 系统交换文件,
而不是在 <code>Linux</code> 系统中执行压缩和打包操作,<code>tar</code> 和 <code>gzip</code> 程序在Linux 系统中更受欢迎.</p>
<h3 id="7z解压缩"><a class="header" href="#7z解压缩">7z解压缩</a></h3>
<p>支持的格式</p>
<p><code>LZMA2</code>, <code>XZ</code>, <code>ZIP</code>, <code>Zip64</code>, <code>CAB</code>, <code>RAR</code> (如果安装了 non-free <code>p7zip-rar</code>包),
<code>ARJ</code>,  <code>GZIP</code>, <code>BZIP2</code>, <code>TAR</code>, <code>CPIO</code>, <code>RPM</code>, <code>ISO</code></p>
<p>用法: <code>7z &lt;command&gt; [&lt;switches&gt;...] &lt;archive_name&gt; [&lt;file_names&gt;...] [&lt;@listfiles...&gt;]</code></p>
<p>解压缩,输入密码,并保持目录结构:</p>
<p><code>7z x -p1234 filename</code></p>
<p>压缩单个文件</p>
<p><code>7z a -t7z archive_name filename</code></p>
<p>压缩txt中的文件</p>
<p><code>7z a -t7z configrc.win.7z @tom.rc_list.win</code>
<code>7z a -t7z configrc.linux.7z @tom.rc_list.linux</code></p>
<p><code>&lt;Commands&gt;</code></p>
<ul>
<li><code>a</code> : 添加文件到归档中</li>
<li><code>b</code> : Benchmark</li>
<li><code>d</code> : 从归档中删除</li>
<li><code>e</code> : 从归档中提取(不使用目录名)</li>
<li><code>h</code> : 计算文件的 hash 值</li>
<li><code>i</code> : 展示支持的格式</li>
<li><code>l</code> : 列出归档的内容</li>
<li><code>rn</code> : 重命名归档中的文件</li>
<li><code>t</code> : 检查归档的完整性</li>
<li><code>u</code> : 把文件更新到归档</li>
<li><code>x</code> : 提取文件, 使用全路径(也就是保持文件结构)</li>
</ul>
<p><code>&lt;Switches&gt;</code></p>
<ul>
<li><code>--</code> : Stop switches parsing</li>
<li><code>-o{Directory}</code> : 设置输出目录</li>
<li><code>-p{Password}</code> : 设置密码</li>
<li><code>-r[-|0]</code> : 递归子目录</li>
<li><code>-y</code> : 所有 queries 回答 yes</li>
<li><code>-t{Type}</code>设置归档的 type</li>
</ul>
<h3 id="同步文件和目录"><a class="header" href="#同步文件和目录">同步文件和目录</a></h3>
<p>维护系统备份的常见策略是保持一个或多个目录与另一个本地系统(通常是某种可移动的存储设备), 或者远端系统中的目录(或多个目录)同步.
例如我们有一个在开发中的网站, 需要经常将它的本地备份与远端网络服务器保持同步. 在类 <code>Unix</code> 系统的世界里,能完成此任务且备受人们喜爱的工具是 <code>rsync</code>.</p>
<p>这个程序能同步本地与远端的目录,通过使用 <code>rsync</code> 远端更新协议,此协议允许 <code>rsync</code> 快速地检测两个目录的差异,执行最小量的复制来达到目录间的同步.
比起其它种类的复制程序, 这就使得<code>rsync</code> 命令非常快速和高效.唤醒<code>rsync</code>:</p>
<pre><code class="language-bash">rsync 选项 src dest
</code></pre>
<p>这里 <code>src</code> 和 <code>dest</code> 是下列选项之一:</p>
<ul>
<li>本地文件或目录一个远端文件或目录,以 <code>[user@]host:path</code> 的形式存在</li>
<li>远端 <code>rsync</code> 服务器,由 <code>rsync://[user@]host[:port]/path</code> 指定</li>
</ul>
<p>注意 <code>源</code> 和 <code>目标</code> 两者之一必须是本地文件,<code>rsync</code> 不支持远端到远端的复制.</p>
<p>让我们试着对一些本地文件使用 <code>rsync</code> 命令.首先,清空我们的 <code>foo</code> 目录:</p>
<pre><code class="language-bash">$ rm -rf foo/*
</code></pre>
<p>下一步,我们同步 <code>playground</code> 目录和它在 <code>foo</code> 目录中对应的副本</p>
<pre><code class="language-bash">$ rsync -av playground foo
</code></pre>
<p>我们使用了<code>-a</code> 选项(<code>递归</code>和<code>保护文件属性</code>)和 <code>-v</code> 选项(冗余输出), 从而同步<code>playground</code> 目录的内容到 <code>foo</code> 目录.
当这个命令执行的时候, 我们将会看到一系列的文件和目录被复制.在最后,我们将看到一条像这样的总结信息:</p>
<pre><code class="language-bash">sent 135759 bytes received 57870 bytes 387258.00 bytes/sec
total size is 3230 speedup is 0.02
...
</code></pre>
<p>它说明了复制的数量.</p>
<p>如果再次运行这个命令,我们将会看到不同的结果:</p>
<pre><code class="language-bash">$ rsync -av playgound foo
building file list ... done
sent 22635 bytes received 20 bytes
total size is 3230 speedup is 0.14
45310.00 bytes/sec
</code></pre>
<p>注意到这一次的输出没有文件列表.
这是因为 <code>rsync</code> 程序检测到目录<code>~/playground</code> 和 <code>~/foo/playground</code> 之间不存在差异,因此它不需要复制任何数据.
如果我们在 <code>playground</code> 目录中修改一个文件,然后 再次运行 <code>rsync</code> 命令:</p>
<pre><code class="language-bash">$ touch playground/dir-099/file-Z
$ rsync -av playground foo
building file list ... done
playground/dir-099/file-Z
</code></pre>
<p>我们看到 <code>rsync</code> 命令检测到更改,并且只复制了更新的文件.</p>
<p>考虑之前<code>tar</code> 命令中的例子, 我们再次把此硬盘连接到系统,
它被挂载到<code>/media/BigDisk</code> 目录下,我们可以执行一个有用的系统备份了.</p>
<p>首先在外部硬盘上创建一个目录,名为<code>/backup</code>,然后使用 <code>rsync</code> 程序从我们的系统中复制最重要的数据到外部硬盘上:</p>
<pre><code class="language-bash">$ mkdir /media/BigDisk/backup
$ sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup
</code></pre>
<p>在这个例子里,我们把<code>/etc</code>,<code>/home</code>,和<code>/usr/local</code> 目录从我们的系统中复制到外部硬盘的<code>/media/BigDisk/backup</code>目录上.</p>
<p>我们使用了<code>--delete</code> 这个选项,来删除可能在备份设备中已经存在但却不再存在于源设备中的文件,
(这与我们第一次创建备份无关,但是会在随后的复制操作中发挥作用).</p>
<p>挂载外部驱动器,运行 <code>rsync</code> 命令,不断重复这个过程,是一个不错的系统(虽然不理想)备份方式.
当然,别名会对这个操作更有帮助些.我们创建一个别名,并把它添加到<code>.bashrc</code> 文件中, 来提供这个特性:</p>
<pre><code class="language-bash">alias backup='sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup'
</code></pre>
<p>现在我们只需要连接外部驱动器,然后运行 <code>backup</code> 命令来完成工作.</p>
<h3 id="在网络间使用-rsync-命令"><a class="header" href="#在网络间使用-rsync-命令">在网络间使用 rsync 命令</a></h3>
<p><code>rsync</code> 程序的真正好处之一,是它可以被用来在网络间复制文件.毕竟,<code>rsync</code> 中的<code>r</code>象征着<code>remote</code>.
远程复制可以通过两种方法完成.</p>
<hr />
<p>第一个方法要求另一个系统已经安装了 <code>rsync</code> 程序,还安装了远程 <code>shell</code> 程序,比如 <code>ssh</code>.
比方说我们本地网络中的某系统有大量可用的硬盘空间,我们用这个远程系统代替外部驱动器,来执行文件备份操作.</p>
<p>假定远程系统中有一个名为<code>/backup</code> 的目录, 其用来存放我们传送的文件,我们这样做:</p>
<pre><code class="language-bash">$ sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup
</code></pre>
<p>我们对命令做了两处修改,来方便网络间文件复制.</p>
<ul>
<li>首先,我们添加了<code>--rsh=ssh</code> 选项,其指示 <code>rsync</code> 使用 <code>ssh</code>程序作为它的远程 <code>shell</code>.
这样我们就能使用 <code>ssh</code> 加密通道,来把数据安全地传送到远程主机中.</li>
<li>其次,在目标路径名前面指定了远端主机的名字(此例中远端主机名为 <code>remote-sys</code>),.</li>
</ul>
<hr />
<p>第二种方式是通过使用 <code>rsync</code> 服务器.
<code>rsync</code> 可以被配置为一个 守护进程,监听即将到来的同步请求.
这样做通常是为了方便一个远程系统的镜像.</p>
<p>例如, <code>Red Hat</code> 软件中心为它的 <code>Fedora</code> 发行版,维护着一个巨大的开发中软件包的仓库.
对于软件测试人员, 在发行周期的测试阶段,镜像这些软件集合是非常有帮助的.
因为仓库中的这些文件会频繁地 (通常每天不止一次)改动,定期同步本地镜像更加合理, 而不是大量地拷贝软件仓库.</p>
<p>这些软件库之一被维护在 <code>Georgia Tech</code>.
我们可以使用本地<code>rsync</code> 程序和<code>Georgia Tech</code>的 <code>rsync</code> 服务器来镜像它.</p>
<pre><code class="language-bash">$ mkdir fedora-devel
$ rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linux-core/development/i386/os fedora-devel
</code></pre>
<p>在这个例子里,我们使用了远端 <code>rsync</code> 服务器的 <code>URI</code>.
<code>URI</code>由协议(<code>rsync://</code>),远端主机名(<code>rsync.gtlib.gatech.edu</code>),和软件仓库的路径名组成.</p>
<p>拓展阅读</p>
<p>在这里讨论的所有命令的手册文档都相当清楚明白,并且包含了有用的例子.
另外, <code>GNU</code> 版本的 <code>tar</code> 命令有一个不错的<a href="http://www.gnu.org/software/tar/manual/index.html">在线文档</a>.</p>
<h3 id="rsync-帮助页面"><a class="header" href="#rsync-帮助页面">rsync 帮助页面</a></h3>
<h4 id="说明"><a class="header" href="#说明">说明</a></h4>
<pre><code>    rsync [选项...]     源...     [目标]
</code></pre>
<ul>
<li>
<p>通过远程 shell 访问.</p>
<pre><code>   Pull: rsync [选项...]   [用户@]主机:源...      [本机目标]
   Push: rsync [选项...]   本机源...      [用户@]主机:目标
</code></pre>
</li>
<li>
<p>通过 <code>rsync</code> 守护程序访问.</p>
<pre><code>  Pull: rsync [选项...]       [用户@]主机::源...      [本机目录]
              rsync [选项...]       rsync://[用户@]主机[:PORT]/源...      [本机目标]
  Push: rsync [选项...]       本机源...       [用户@]主机::目标
              rsync [选项...]       本机源...       rsync://[用户@]主机[:PORT]/目标
</code></pre>
</li>
</ul>
<p>只有一个 <code>SRC</code> 参数而没有 <code>DEST</code> 参数的用法将列出源文件而不是复制.</p>
<p>源文件上的尾部<code>/</code>会阻止在<code>目的地</code>创建额外的目录级别.
源文件上的尾部<code>/</code>相当于 <code>复制这个目录的内容</code>, 而不是 <code>按名称复制目录</code>,</p>
<h4 id="描述"><a class="header" href="#描述">描述</a></h4>
<p><code>Rsync</code> 是一个快速的, 非常通用的文件复制工具.  它可以在本地复制, 通过任何远程 <code>shell</code> 同步到/从另一个主机.
或者从远程<code>rsync</code>守护进程复制.   它提供了大量的选项, 允许非常灵活地指定要复制的文件集.
它因<code>delta-transfer</code>算法而闻名, 它只发送源文件和目的地文件之间的差异, 来减少网络数据的使用量.
<code>Rsync</code> 被广泛用于备份和镜像, 并可作为进阶的复制命令用于日常.</p>
<p><code>Rsync</code> 使用 <code>quick check</code> 算法(默认情况下)寻找需要传输的文件, 该算法寻找在体积或最后修改时间上有变化的文件.
当快速检查表明文件的数据不需要更新时, 指定追踪的其他文件属性若有变化(根据选项), 会直接应用到目的地文件上.</p>
<p><code>rsync</code>的一些附加功能是:</p>
<ul>
<li>支持复制<code>links</code>, <code>devices</code>, <code>owners</code>, <code>groups</code>和<code>permissions</code></li>
<li>类似于<code>GNU tar</code> 的<code>exclude</code>和<code>exclude-from</code>选项</li>
<li><code>CVS exclude</code> 模式, 忽略和 <code>CVS</code> 相同的文件</li>
<li>可以使用任何透明的远程 <code>shell</code>, 包括 <code>ssh</code> 或 <code>rsh</code></li>
<li>不需要<code>超级用户</code>权限</li>
<li>文件传输的管道化, 以减少延迟</li>
<li>支持匿名或需要认证的<code>rsync</code>守护程序(非常适合做镜像)</li>
</ul>
<h4 id="general"><a class="header" href="#general">general</a></h4>
<p><code>Rsync</code>可以复制文件到远程主机, 或从远程主机复制文件, 或在当前主机上复制文件(它不支持在两个远程主机之间复制文件).</p>
<p>有两种不同的方式让<code>rsync</code>连接远程系统: 使用远程<code>shell</code>程序作为传输方式(如 <code>ssh</code> 或 <code>rsh</code>), 或通过<code>TCP</code>直连<code>rsync</code>守护进程.
当源文件或目标文件的路径含有一个冒号(<code>:</code>)的分隔符时, 就会使用远程<code>shell</code>传输.
当源文件或目标文件路径包含双冒号(<code>::</code>), 或指定<code>rsync:// URL</code>时, 直连<code>rsync</code>守护进程.
参见 <code>USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION</code>一节, 了解后一条规则的例外情况).</p>
<ul>
<li>作为特殊情况, 如果指定了单一的源参数而没有目的地, 文件将以类似于 <code>ls -l</code> 的输出格式列出.</li>
<li>正如预期的那样, 如果源路径和目标路径都没有指定一个远程主机, 那么复制就发生在本地(也见 <code>--list-only</code>选项).</li>
<li><code>Rsync</code> 将本地端称为 <code>客户端</code>, 将远程端称为 <code>服务器</code>.  不要把 <code>服务器</code> 和 <code>rsync守护进程</code>混淆起来
守护进程总是一个<code>服务器</code>, 但<code>服务器</code>既可以是<code>守护进程</code>也可以是远程<code>shell</code>生成的<code>进程</code>.</li>
</ul>
<h4 id="安装设置"><a class="header" href="#安装设置">安装设置</a></h4>
<p>参见 <code>README</code> 文件中的安装说明.
你可以通过使用 <code>-e</code> 选项或设置 <code>RSYNC_RSH</code> 环境变量来指定你喜欢的任何远程 <code>shell</code>.
注意<code>rsync</code>必须同时安装在源机器和目的机器上.</p>
<h4 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h4>
<p>使用<code>rsync</code>的方式与使用<code>rcp</code>相同. 你需要指定一个源和一个目的地, 其中一个可能是远程的. 也许用一些例子来解释最好.</p>
<pre><code class="language-bash">rsync -t *.c foo:src/
</code></pre>
<p>这将把所有与模式 <code>*.c</code> 匹配的文件从当前目录转移到机器<code>foo</code>上的目录<code>src</code>.
如果文件已经存在于远程系统中, 那么将使用<code>rsync</code>远程更新协议, 只发送数据的差异.
请注意, 通配符(<code>*.c</code>)的展开是由<code>shell</code>控制的, 发生在运行<code>rsync</code>, 而不是由<code>rsync</code>本身处理(与所有其他<code>posix</code>风格的程序完全一样).</p>
<pre><code class="language-bash">rsync -avz foo:src/bar /data/tmp
</code></pre>
<p>以上递归地将<code>foo</code>机器上<code>src/bar</code>目录下的所有文件传输到本地机器上的<code>/data/tmp/bar</code>目录.
文件是以 <code>归档</code>模式传输的, 这就确保了<code>符号链接</code>, <code>设备</code>, <code>属性</code>, <code>权限</code>, <code>所有权</code>等在传输过程中被保留下来.  此外, 压缩被用来减少传输的数据部分的大小.</p>
<pre><code class="language-bash">rsync -avz foo:src/bar/ /data/tmp
</code></pre>
<p>源文件上的尾部<code>/</code>会改变这一行为, 阻止在<code>目的地</code>创建额外的目录级别.
你可以把源文件上的尾部<code>/</code>看作是 <code>复制这个目录的内容</code>, 而不是 <code>按名称复制目录</code>,
但在两种情况下, <code>包裹目录</code>的属性都会被转移到目的地的<code>包裹目录</code>中.
换句话说, 下面两个命令效果相同, 将 <code>/src/foo</code>整个复制到<code>/dest</code>下面, 包括对<code>/dest/foo</code>的属性设置.</p>
<pre><code class="language-bash">rsync -av /src/foo /dest
rsync -av /src/foo/ /dest/foo
</code></pre>
<p>还要注意的是, 主机和<code>module</code>引用, 不需要尾部的<code>/</code>来指定复制默认目录的内容.  例如, 以下都将远程目录的内容复制到<code>/dest</code>.</p>
<pre><code class="language-bash">rsync -av host: /dest
rsync -av host::module /dest
</code></pre>
<ul>
<li>你也可以在纯本地模式下使用<code>rsync</code>, 即源文件和目标文件的名称中都没有<code>:</code>. 在这种情况下, 它就像增强的拷贝命令.</li>
<li>最后, 你可以通过省略<code>module</code>名称来列出某个<code>rsync</code>守护进程中所有可用的<code>模块</code>.</li>
</ul>
<pre><code class="language-bash">rsync somehost.mydomain.com::
</code></pre>
<p>更多细节请看下面的章节.</p>
<h4 id="举例说明"><a class="header" href="#举例说明">举例说明</a></h4>
<p>下面是一些我如何使用<code>rsync</code>的例子:</p>
<ul>
<li>为了备份我妻子的<code>home</code>目录, 其中包括许多<code>MS Word</code>文件和邮件文件夹, 我建立一个<code>cron</code> 任务, 它执行 :</li>
</ul>
<pre><code class="language-bash">rsync -Cavz . arvidsjaur:backup
# -C:cvs 忽略规则, a : 归档模式, -v: 增加详细程度, -z: 传输过程中压缩
</code></pre>
<p>每天晚上它通过<code>PPP</code>连接到我机器<code>arvidsjaur</code>上的一个备份目录 .</p>
<ul>
<li>为了同步我的<code>samba</code>源文件树, 我使用下面的<code>Makefile</code> targets:</li>
</ul>
<pre><code class="language-bash">get:
    rsync -avuzb --exclude '*~' samba:samba/ .
    # -u, --update ; 跳过接收方较新的文件, -b, --backup ; 进行备份
put:
    rsync -Cavuzb . samba:samba/
sync: get put
</code></pre>
<p>它将与连接另一端的<code>CVS</code>目录同步. 然后我在远程机器上进行<code>CVS</code>操作, 这节省了很多时间, 因为远程<code>CVS</code>协议不是很有效.</p>
<ul>
<li>在我的 <code>旧</code> 和 <code>新</code> ftp 站点之间镜像目录:</li>
</ul>
<pre><code class="language-bash">rsync -az -e ssh --delete ~ftp/pub/samba nimbus:&quot;~ftp/pub/tridge&quot;
# --delete: 删除源中不存在的文件. -e: 指定要使用的远程 shell
</code></pre>
<p>每隔几个小时它从<code>cron</code>启动.</p>
<h4 id="高级用法"><a class="header" href="#高级用法">高级用法</a></h4>
<p>从远程主机请求多个文件的语法, 是通过指定额外的远程主机参数来完成的, 样式与第一个相同, 但可以省略主机名.  例如, 以下这些都可以</p>
<pre><code class="language-bash">rsync -av host:file1 :file2 host:file{3,4} /dest/
rsync -av host::modname/file{1,2} host::modname/file3 /dest/
rsync -av host::modname/file1 ::modname/file{3,4}
</code></pre>
<p>旧版本的<code>rsync</code>要求在<code>SRC</code>中使用带引号的空格, 比如这些例子:</p>
<pre><code class="language-bash">rsync -av host:'dir1/file1 dir2/file2' /dest
rsync host::'modname/dir1/file1 modname/dir2/file2' /dest
</code></pre>
<p>这种分词法在最新的<code>rsync</code>中仍然有效(默认情况下), 但不像第一种方法那样容易使用.</p>
<p>如果你需要传输一个含有空格的文件名, 你可以指定 <code>--protect-args</code> (<code>-s</code>) 选项, 或者你需要以远程<code>shell</code>能够理解的方式来转义空格.  比如说</p>
<pre><code class="language-bash">rsync -av host:'file\ name\ with\ spaces' /dest
</code></pre>
<h4 id="连接到一个rsync守护进程"><a class="header" href="#连接到一个rsync守护进程">连接到一个rsync守护进程</a></h4>
<p>也可以使用<code>rsync</code>而不使用远程<code>shell</code>作为传输工具.  在这种情况下, 你将直接连接到一个远程<code>rsync</code>守护进程, 通常使用<code>TCP 873</code>端口.
(这显然需要在远程系统上运行守护进程, 所以请参考下面的<code>STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS</code>一节来了解这方面的信息).</p>
<p>以这种方式使用<code>rsync</code>, 与在远程<code>shell</code>使用<code>rsync</code>是一样的, 除了:</p>
<ul>
<li>使用双冒号<code>::</code> 而不是单冒号来分隔主机名和路径, 或者使用<code>rsync:// URL</code>.</li>
<li><code>路径</code> 的第一个词实际上是<code>模块</code>的名字.</li>
<li>当你连接时, 远程守护进程可能会打印当天的信息.</li>
<li>如果您在远程守护进程中没有指定路径名称, 那么将显示守护进程中的可访问路径列表.</li>
<li>如果你没有指定本地目标, 那么将打印指定的远程文件列表.</li>
<li>你不能使用<code>--rsh</code> (<code>-e</code>) 选项.</li>
</ul>
<p>拷贝远程模块 <code>src</code> 中所有文件的例子.</p>
<pre><code class="language-bash">rsync -av host::src /dest
</code></pre>
<p>远程守护程序上的某些模块可能需要认证. 如果是这样, 你在连接时将会收到一个密码提示.
您可以通过设置环境变量 <code>RSYNC_PASSWORD</code> 为密码来省略密码提示.或使用<code>--password-file</code>选项来避免密码提示.
这在编写<code>rsync</code>脚本时可能很有用.</p>
<p>警告: 在某些系统中, 环境变量对所有用户都是可见的. 在这些系统中, 建议使用<code>--password-file</code>.</p>
<ul>
<li>你可以通过设置环境变量<code>RSYNC_PROXY</code>指向你的网络代理的<code>主机名:端口</code>对来建立连接.  注意, 你的网络代理的配置必须支持代理连接到<code>873</code>端口.</li>
<li>你也可以通过设置环境变量<code>RSYNC_CONNECT_PROG</code>为你想运行的命令, 使用程序作为代理来建立连接, 以代替<code>socket</code>直连.
这个字符串可以包含转义字符 <code>%H</code> 来表示在<code>rsync</code>命令中指定的主机名(所以如果你需要在字符串中使用单个<code>%</code>, 就使用<code>%%</code>).  比如说</li>
</ul>
<pre><code class="language-bash">export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
rsync -av targethost1::module/src/ /dest/
rsync -av rsync:://targethost2/module/src/ /dest/
</code></pre>
<p>以上命令使用<code>ssh</code>在<code>proxyhost</code>上运行<code>nc</code>(<code>netcat</code>), <code>nc</code>将所有数据转发到目标主机(<code>%H</code>)上的<code>873</code>端口(<code>rsync</code>守护程序).</p>
<h4 id="通过远程shell连接使用rsync-daemon功能"><a class="header" href="#通过远程shell连接使用rsync-daemon功能">通过远程shell连接使用rsync-daemon功能</a></h4>
<p>有时使用<code>rsync</code>守护进程的各种功能(如命名模块)而不允许任何新的<code>socket</code>连接到系统中是很有用的(除了允许远程<code>shell</code> 访问).
<code>Rsync</code>支持使用远程<code>shell</code>连接到主机, 然后生成一次性的 <code>daemon</code>服务器, 并期望在远程用户的家目录中读取其配置文件.</p>
<p>如果你想加密一个<code>守护进程式</code>的传输数据, 但由于<code>守护进程</code>是由远程用户重新启动的, 你可能无法使用<code>chroot</code> 或改变守护进程的<code>UID</code>等功能,.
(对于另一种加密<code>守护进程</code>的方法, 考虑使用<code>ssh</code>隧道将<code>本地端口</code>连接到<code>远程主机</code>. 并在<code>远程主机</code>上配置普通的<code>rsync</code>守护进程, 只允许<code>rsync</code>连接到 <code>localhost</code>).</p>
<p>从用户的角度来看, 通过<code>远程shell</code>连接进行的<code>守护进程</code>传输, 使用的命令行语法与普通 <code>rsync-daemon传输</code>几乎相同,
唯一的例外是你需要用选项 <code>--rsh=COMMAND</code> 明确地设置远程<code>shell</code>程序.  (在环境中设置<code>RSYNC_RSH</code>不会开启这个功能).  比如说</p>
<pre><code class="language-bash">rsync -av --rsh=ssh host::module /dest
</code></pre>
<p>如果你需要指定不同的<code>远程shell</code>用户, 请在<code>host</code>前面使用<code>user@</code>前缀来指定<code>rsync-user</code>(对于需要使用用户认证的<code>模块</code>).
这意味着你必须在指定<code>远程shell</code>时给<code>ssh</code>提供<code>-l user</code>选项, 例如下面的例子, 其中使用<code>--rsh</code>选项的缩写<code>-e</code></p>
<pre><code class="language-bash">rsync -av -e &quot;ssh -l ssh-user&quot; rsync-user@host::module /dest
</code></pre>
<p><code>ssh-user</code> 将在<code>ssh</code>级别使用;<code>rsync-user</code>将用于登录 <code>模块</code>.</p>
<h4 id="启动rsync守护进程以接受连接"><a class="header" href="#启动rsync守护进程以接受连接">启动rsync守护进程以接受连接</a></h4>
<p>为了连接到<code>rsync</code>守护进程, 远程系统需要有一个已经运行的守护进程
(或者它需要配置像<code>inetd</code>这样的东西来生成<code>rsync</code>守护进程, 以便为特定端口上传入的连接 spawn <code>rsync</code>守护进程).</p>
<p>关于如何启动处理 incoming <code>socket</code>连接的守护进程的完整信息, 请参见<code>rsyncd.conf(5)</code>手册页 -- 它是守护进程的配置文件,
它包含如何运行守护进程的全部细节(包括<code>独立的</code>和<code>inetd</code>的配置).</p>
<p>如果你使用其中远程<code>shell</code>传输工具进行传输, 就不需要手动启动<code>rsync</code>守护进程.</p>
<h4 id="排序的传输顺序"><a class="header" href="#排序的传输顺序">排序的传输顺序</a></h4>
<p><code>Rsync</code>总是将指定的文件名排序到它的内部传输列表.  这可以处理同名目录内容的合并, 使其容易删除重复的文件名.
当文件的传输顺序与命令行上给出的顺序不同时, 可能会使某人感到困惑.</p>
<p>如果你需要一个特定的文件先于其他文件传输, 可以使用独立的<code>rsync</code>调用, 也可以考虑使用<code>--delay-updates</code>.
这不会影响排序的传输顺序, 但会使最后的<code>文件更新</code>阶段更快发生).</p>
<h4 id="选项总结"><a class="header" href="#选项总结">选项总结</a></h4>
<p>这里是<code>rsync</code>中可用选项的简短总结. 请参考下面的详细说明以获得完整的描述.</p>
<ul>
<li><code>-v, --verbose</code> ;  增加详细程度.
<ul>
<li><code>--info=FLAGS</code> ; 详细的, 较多信息的 verbosity.</li>
<li><code>--debug=FLAGS</code>; 详细的, debug verbosity.</li>
<li><code>--msgs2stderr</code> ; 用于调试的特殊输出处理</li>
</ul>
</li>
<li><code>--q, --quiet</code> ; 抑制非错误信息
<ul>
<li><code>--no-motd</code> ; 抑制守护进程模式的<code>MOTD</code>(见注意事项).</li>
</ul>
</li>
<li><code>-c, --checksum</code> ;  根据校验和跳过, 而不是根据<code>mod-time</code>和<code>size</code>.</li>
<li><code>-a, --archive</code> ; 归档模式;等于<code>-rlptgoD</code>(没有<code>-H</code>,<code>-A</code>,<code>-X</code>)
<ul>
<li><code>--no-OPTION</code> 关掉一个隐含的<code>OPTION</code>(例如: <code>--no-D</code>)</li>
</ul>
</li>
</ul>
<p><code>-r</code>; 递归. <code>-l</code>; 符号连接. <code>-p</code>; 保留权限. <code>-t</code>; 保留修改时间. <code>-go</code>; 组和所有者. <code>-D</code>; 设备文件和特殊文件.</p>
<ul>
<li>
<p><code>-r, --recursive</code> ; 递归到目录中去.</p>
</li>
<li>
<p><code>-R, --relative</code> ; 使用相对路径名</p>
<ul>
<li><code>--no-implied-dirs</code> ; 不发送带有<code>--relative</code>的隐含目录.</li>
</ul>
</li>
<li>
<p><code>-b, --backup</code>; 进行备份 (见 <code>--suffix</code> &amp; <code>--backup-dir</code>).</p>
<ul>
<li><code>--backup-dir=DIR</code> ; 在<code>DIR</code>的基础上进行备份, 使其成为层次结构.</li>
<li><code>--suffix=SUFFIX</code> ; 备份后缀. (默认<code>~</code> without <code>--backup-dir</code>).</li>
</ul>
</li>
<li>
<p><code>-u, --update</code> ; 跳过<code>接收方</code>较新的文件</p>
<ul>
<li><code>--inplace</code> ; 就地更新目标文件</li>
<li><code>--append</code> ; 将数据附加到较短的文件上</li>
<li><code>--append-verify</code> ; --append w/old data in file checksum.</li>
</ul>
</li>
<li>
<p><code>-d, --dirs</code> ; 传输目录, 不进行递归.</p>
</li>
<li>
<p><code>-l, --links</code> ; 将<code>符号链接</code>复制为<code>符号链接</code></p>
</li>
<li>
<p><code>-L, --copy-links</code> ; 将符号链接转换成指向的<code>文件</code>/<code>目录</code></p>
<ul>
<li><code>--copy-unsafe-links</code> ; 只有 <code>不安全</code> 的符号链接转换成文件.</li>
<li><code>--safe-links</code> ; 忽略指向树外的<code>符号链接</code></li>
<li><code>--munge-links</code> ; 对符号链接进行整合, 使其更加安全.</li>
</ul>
</li>
<li>
<p><code>-k, --copy-dirlinks</code> ; 将指向<code>dir</code>的符号链接转化为<code>dir</code>.</p>
</li>
<li>
<p><code>-K, --keep-dirlinks</code> ; 将<code>接收方</code>的符号链接<code>dir</code>视为真实的<code>dir</code>.</p>
</li>
<li>
<p><code>-H, --hard-links</code> ; 保留硬链接</p>
</li>
<li>
<p><code>-p, --perms</code> ; 保留权限</p>
</li>
<li>
<p><code>-E, --executability</code> ; 保留可执行性</p>
<ul>
<li><code>--chmod=CHMOD</code> 影响文件和/或目录权限</li>
</ul>
</li>
<li>
<p><code> -A, --acls</code> ; 保留 <code>ACLs</code> (暗示 <code>-p</code>)</p>
</li>
<li>
<p><code>-X, --xattrs</code> ; 保留扩展属性</p>
</li>
<li>
<p><code>-o, --owner</code> ; 保留所有者(仅超级用户).</p>
</li>
<li>
<p><code>-g, --group</code> ;  保留组</p>
<ul>
<li><code>--devices</code> ; 保留设备文件(仅超级用户)</li>
<li><code>--specials</code> ; 保留特殊文件</li>
</ul>
</li>
<li>
<p><code>-D</code> ; 与<code>--devices --specials</code>相同</p>
</li>
<li>
<p><code>-t, --times</code> ; 保留修改时间</p>
</li>
<li>
<p><code>-O, --omit-dir-times</code> ; 从 <code>--times</code> 中省略目录.</p>
</li>
<li>
<p><code>-J, --omit-link-times</code> ; 从<code>--times</code>中省略符号链接</p>
<ul>
<li><code>--super</code> ; 接收方尝试超级用户活动</li>
<li><code>--fake-super</code> 使用<code>xattrs</code>存储/恢复特权属性</li>
</ul>
</li>
<li>
<p><code>-S, --sparse</code> ; 将<code>null</code>序列转换成<code>稀疏块</code></p>
<ul>
<li><code>--preallocate</code> ; 在写入前分配目标文件</li>
</ul>
</li>
<li>
<p><code>-n, --dry-run</code> ; 执行试运行, 不做任何修改</p>
</li>
<li>
<p><code>--W, --whole-file</code> ; 完整复制文件(不采用<code>delta-xfer</code>算法).</p>
<ul>
<li><code>--checksum-choice=STR</code> ; 选择校验算法</li>
</ul>
</li>
<li>
<p><code>-x, --one-file-system</code> ; 不跨越文件系统的边界</p>
</li>
<li>
<p><code>-B, --block-size=SIZE</code> ; 强制采用固定的校验块大小</p>
</li>
<li>
<p><code>-e, --rsh=COMMAND</code> ; 指定要使用的远程 <code>shell</code></p>
<ul>
<li><code>--rsync-path=PROGRAM</code> ; 指定要在远程机器上运行的<code>rsync</code></li>
<li><code>--existing</code> ; 跳过在接收器上创建新文件</li>
<li><code>--ignore-existing</code> ; 跳过更新接收方存在的文件</li>
<li><code>--remove-source-files</code> ; 发送方删除同步过的文件(非目录)</li>
<li><code>--del</code> ; 是 <code>--delete-during</code> 的别名</li>
<li><code>--delete</code> ; 删除目的地目录中不相干的文件</li>
<li><code>--delete-before</code> ; 接收方在发送前删除, 而不是在发送过程中删除.</li>
<li><code>--delete-during</code> ; 接收者在传输过程中删除文件</li>
<li><code>--delete-delay</code> ; 在传输过程中找出删除, 在传输后删除</li>
<li><code>--delete-after</code> ; 接收者在转移后删除, 而不是在转移过程中.</li>
<li><code>--delete-excluded</code> ; 从目的地目录中删除被排除的文件</li>
<li><code>--ignore-missing-args</code> ; 忽略丢失的源参数, 不报错</li>
<li><code>--delete-missing-args</code> ; 从目的地删除缺失的源文件<code>args</code></li>
<li><code>--ignore-errors</code> ; 即使有<code>I/O</code>错误, 也删除.</li>
<li><code>--force</code> ; 强制删除目录, 即使不是空的.</li>
<li><code>--max-delete=NUM</code> ; 不删除超过<code>NUM</code>的文件</li>
<li><code>--max-size=SIZE</code> ; 不传输任何大于<code>SIZE</code>的文件</li>
<li><code>--min-size=SIZE</code> ; 不传输任何小于<code>SIZE</code>的文件</li>
<li><code>--partial</code> ; 保留部分传输的文件</li>
<li><code>--partial-dir=DIR</code> ; 将部分传输的文件放入<code>DIR</code>中</li>
<li><code>--delay-updates</code> ; 最后再把所有更新的文件放到地方</li>
</ul>
</li>
<li>
<p><code>--m, --prune-empty-dirs</code> ; 从文件列表中删去空目录链</p>
<ul>
<li><code>--numeric-ids</code> ; 不按<code>用户</code>/<code>组</code>名映射<code>uid</code>/<code>gid</code>值.</li>
<li><code>--usermap=STRING</code> ; 自定义用户名映射</li>
<li><code>--groupmap=STRING</code> ; 自定义组名映射</li>
<li><code>--chown=USER:GROUP</code> ; 简单的用户名/组名映射</li>
<li><code>--timeout=SECONDS</code> ; 设置<code>I/O</code>超时, 单位为<code>秒</code></li>
<li><code>--contimeout=SECONDS</code> ; 设置守护程序连接超时, 单位为<code>秒</code></li>
</ul>
</li>
<li>
<p><code>--I, --ignore-times</code> ; 不跳过大小和时间相符的文件</p>
<ul>
<li><code>--size-only</code> ; 跳过大小一致的文件</li>
</ul>
</li>
<li>
<p><code>-@, --modify-window=NUM</code> ;  设置<code>mod-time</code>比较的准确性</p>
</li>
<li>
<p><code>-T, --temp-dir=DIR</code> 在目录DIR中创建临时文件</p>
</li>
<li>
<p><code>-y, --fuzzy</code> ; 在没有目标文件的情况下为<code>basis</code>找到类似的文件</p>
<ul>
<li><code>--compare-dest=DIR</code> ; also compare received files relative to <code>DIR</code>.</li>
<li><code>--copy-dest=DIR</code> ; ... and include copies of unchanged files</li>
<li><code>--link-dest=DIR</code> ; 当未改变时, 硬链接到<code>DIR</code>中的文件</li>
</ul>
</li>
<li>
<p><code>-z, --compress</code> ; 在传输过程中压缩文件数据</p>
<ul>
<li><code>--compress-level=NUM</code> ; 明确设置压缩级别</li>
<li><code>--skip-compress=LIST</code> ; 跳过压缩后缀为<code>LIST</code>的文件</li>
</ul>
</li>
<li>
<p><code>--C, --cvs-exclude</code> ; 以<code>CVS</code>的方式自动忽略文件</p>
</li>
<li>
<p><code>-f, --filter=RULE</code> ; 添加一个文件过滤规则.</p>
</li>
<li>
<p><code>-F</code> ; 与 <code>--filter='dir-merge /.rsync-filter'</code>相同</p>
<ul>
<li><code>repeated</code>: <code>--filter='- .rsync-filter'</code>.</li>
<li><code>--exclude=PATTERN</code> ; 排除匹配<code>PATTERN</code>的文件</li>
<li><code>--exclude-from=FILE</code> ; 从<code>FILE</code>读取排除模式</li>
<li><code>--include=PATTERN</code> ; 不排除匹配<code>PATTERN</code>的文件</li>
<li><code>--include-from=FILE</code> ; 从<code>FILE</code>中读取包含模式</li>
<li><code>--files-from=FILE</code> ; 从<code>FILE</code>中读取源文件名的列表</li>
</ul>
</li>
<li>
<p><code>-0, --from0</code> ; 所有的<code>*from/filter</code>文件都以<code>0</code>为界.</p>
</li>
<li>
<p><code>-s, --protect-args</code> ; 不按空格分词;只有通配符.</p>
</li>
<li>
<p><code>--address=ADDRESS</code> ; 绑定出站<code>socket</code>的地址给守护进程.</p>
<ul>
<li><code>--port=PORT</code> ; 指定双冒号的备用端口号</li>
<li><code>--sockopts=OPTIONS</code> ; 指定自定义<code>TCP</code>选项</li>
<li><code>--blocking-io</code> ; 对远程<code>shell</code>使用阻塞式<code>I/O</code></li>
<li><code>--outbuf=N|L|B</code> ; 设置输出缓冲为<code>无</code>, <code>行</code>或<code>块</code>.</li>
<li><code>--stats</code> ; 提供一些文件传输的统计信息.</li>
</ul>
</li>
<li>
<p><code>--8, --8-bit-output</code> ; 在输出中不对高位字符进行转义.</p>
</li>
<li>
<p><code>-h,--human-readable</code> ; 以人类可读的格式输出数字</p>
<ul>
<li><code>--progress</code> ; 显示传输过程中的进度</li>
</ul>
</li>
<li>
<p><code>-P</code> ; 与 <code>--partial --progress</code> 相同</p>
</li>
<li>
<p><code>-i, --itemize-changes</code>; 输出所有更新的变化摘要</p>
</li>
<li>
<p><code>-M, --remote-option=OPTION</code> ; 只向远端发送<code>OPTION</code></p>
<ul>
<li><code>--out-format=FORMAT</code> ; 使用指定的<code>FORMAT</code>输出更新信息</li>
<li><code>--log-file=FILE</code> ; 在<code>FILE</code>中记录我们正在做的事情</li>
<li><code>--log-file-format=FMT</code> ; 使用指定的<code>FMT</code>记录更新信息</li>
<li><code>--password-file=FILE</code> ; 从<code>FILE</code>读取 daemon-access 的访问密码</li>
<li><code>--list-only</code> ; 列出文件而不是复制它们</li>
<li><code>--bwlimit=RATE</code> ; 限制 socket <code>I/O</code>带宽</li>
<li><code>--stop-at=y-m-dTh:m</code> ; 在<code>year-month-dayThour:minute</code>停止<code>rsync</code></li>
<li><code>--time-limit=MINS</code> ; 在<code>MINS</code>分钟后停止<code>rsync</code>的运行</li>
<li><code>--write-batch=FILE</code> ; 将批量更新写入<code>FILE</code>中</li>
<li><code>--only-write-batch=FILE</code> ; 类似<code>--write-batch</code> 但不更新<code>dest</code></li>
<li><code>--read-batch=FILE</code> ; 从<code>FILE</code>中读取一个批处理的更新</li>
<li><code>--protocol=NUM</code> ; 强制使用一个较早的协议版本</li>
<li><code>--iconv=CONVERT_SPEC</code> ; 要求转换文件名的字符集</li>
<li><code>--checksum-seed=NUM</code> ; 设置<code>块</code>/<code>文件</code>checksum seed(高级).</li>
<li><code>--noatime</code> ; 打开源文件时不改变<code>atime</code></li>
</ul>
</li>
<li>
<p><code>--4, --ipv4</code> ; 偏好<code>IPv4</code></p>
</li>
<li>
<p><code>-6, --ipv6</code> ; 偏好<code>IPv6</code></p>
</li>
<li>
<p><code>--version</code> ;  打印版本号</p>
</li>
<li>
<p><code>(-h) --help</code> 显示此帮助(关于<code>-h</code>的注释见下文).</p>
</li>
</ul>
<p><code> </code>也可以作为一个守护进程运行, 在这种情况下, 可以接受以下选项.</p>
<ul>
<li>
<p><code>--daemon</code> ; 作为<code>rsync</code>守护进程运行</p>
<ul>
<li><code>--address=ADDRESS</code> ; 绑定到指定地址</li>
<li><code>--bwlimit=RATE</code> ; 限制 socket <code>I/O</code> 带宽</li>
<li><code>--config=FILE</code> ; 指定备用的<code>rsyncd.conf </code>文件</li>
</ul>
</li>
<li>
<p><code>--M, --dparam=OVERRIDE</code> ; 覆盖全局守护进程配置参数</p>
<ul>
<li><code>--no-detach</code> ; 不从parent中分离出来</li>
<li><code>--port=PORT</code> ; 在备用端口号上监听</li>
<li><code>--log-file=FILE</code> ; 覆盖 <code>日志文件</code> 设置</li>
<li><code>--log-file-format=FMT</code> ; 覆盖 <code>日志格式</code> 的设置</li>
<li><code>--sockopts=OPTIONS</code> ; 指定自定义<code>TCP</code>选项</li>
</ul>
</li>
<li>
<p><code>-v, --verbose</code> ; 增加 verbosity</p>
</li>
<li>
<p><code>-4, --ipv4</code> ; 优先选择<code>IPv4</code></p>
</li>
<li>
<p><code>-6, --ipv6</code> ; 偏好<code>IPv6</code></p>
</li>
<li>
<p><code>-h, --help</code> ; 显示此帮助(如果在 <code>--daemon</code> 之后使用).</p>
</li>
</ul>
<h4 id="选项-1"><a class="header" href="#选项-1">选项</a></h4>
<p><code>Rsync</code>接受长(双破折号+字)和短(单破折号+字母)选项.  可用选项的完整列表在下面描述.
如果<code>选项</code>可以用多种方式指定, 则选择应该用<code>逗号</code>隔开.   有些选项只有<code>长选项</code>, 没有<code>短选项</code>.</p>
<p>如果选项需要参数, 则参数说明只列在长选项后面, 尽管也必须为短选项指定.  当指定一个参数时, 你可以使用 <code>--option=param</code> 的形式, 或者用空格代替<code>=</code>.
该参数可能需要以某种方式加<code>引号</code>, 以避免被<code>shell</code>命令行解析掉.
请记住文件名的领头<code>~</code>会被你的<code>shell</code>替换掉, 所以<code>--option=~/foo</code>不会把<code>tilde</code>改成你的家目录(要想跳转到家目录的话, 请去掉<code>=</code>).</p>
<p><code>--help</code> 打印一个简短的帮助页面, 描述<code>rsync</code>中可用的选项并退出.  为了向后兼容旧版本的<code>rsync</code>, 如果你使用<code>-h</code>选项而不使用任何其他参数, 也会输出帮助.</p>
<ul>
<li><code>--delete</code>;</li>
</ul>
<p>这告诉<code>rsync</code>从接收端删除不相干的文件(那些不在发送端上的文件), 但只针对被同步的目录.
你必须要求<code>rsync</code>发送整个目录(例如 <code>dir</code>或 <code>dir/</code>), 而不是用目录内容的通配符(例如 <code>dir/*</code>),
因为通配符会被<code>shell</code>展开, 因此<code>rsync</code>会得到一个传输单个文件的请求, 而不是文件的父目录.</p>
<p>被排除在传输之外的文件也不会被删除, 除非你使用 <code>--delete-excluded</code> 选项或将规则标记为只在发送方匹配(见<code>FILTER RULES</code>部分的<code>include/exclude modifiers</code>).</p>
<p>在<code>rsync 2.6.7</code>之前, 除非启用 <code>--recursive</code>, 否则该选项没有任何作用.
从<code>2.6.7</code>开始, 当启用<code>--dirs</code> (<code>-d</code>)时, 删除也会发生, 但只对内容被复制的目录被复制的目录.
如果使用不当, 这个选项可能会很危险!  首先尝试使用 <code>--dry-run</code> 选项(<code>-n</code>)进行运行, 看看哪些文件将被删除.</p>
<p>如果发送方检测到任何<code>I/O</code>错误, 那么将自动禁止删除目的地的任何文件. 这是为了防止发送方的临时文件系统故障(如<code>NFS</code>错误)导致目的地的文件被大量删除.
你可以用<code>--ignore-errors</code>选项来覆盖这一点.</p>
<p><code>--delete</code>选项可以和<code>--delete-WHEN</code>选项以及<code>--delete-excluded</code>选项结合使用, 不会发生冲突.
然而, 如果没有指定<code>--delete-WHEN</code>选项, 当使用<code>rsync 3.0.0</code>或更新的版本时, <code>rsync</code>将选择<code>--delete-during</code>算法,
而使用较早版本的<code>rsync</code>时, 将选择<code>--delete-before</code>算法.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-7-1"><a class="header" href="#linux-7-1">linux-7</a></h1>
<h2 id="第二十章正则表达式"><a class="header" href="#第二十章正则表达式">第二十章:正则表达式</a></h2>
<p>追溯到 <code>Unix</code> 刚刚开发的时候,它只知道 <code>ASCII</code> 字符. 在 <code>ASCII</code> 中,前<code>32</code>个字符 (数字<code>0-31</code>)都是控制码(如 <code>tabs</code>,<code>backspaces</code>,和<code>回车</code>).
随后的<code>32</code>个字符(<code>32-63</code>)包含可打印的字符, 包括大多数的标点符号和数字<code>0</code>到<code>9</code>.
再随后的<code>32</code>个字符(<code>64-95</code>)包含大写字符和一些更多的标点符号.  最后的<code>31</code>个字符(<code>96-127</code>)包含小写字母和更多的标点符号.
基于这种安排方式,系统使用这种排序规则 的 <code>ASCII</code>:</p>
<pre><code class="language-bash">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
</code></pre>
<p>而普通的字典顺序像这样:</p>
<pre><code class="language-bash">aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
</code></pre>
<p>随着 <code>Unix</code> 系统的知名度在美国之外的国家传播开来,就需要支持不在 U.S.英语范围内的字符.
于是就扩展了<code>ASCII</code> 字符表,使用了整个<code>8</code>位,添加了字符(数字<code>128-255</code>),这样就 容纳了更多的语言.
为了支持这种能力,<code>POSIX</code> 标准介绍了一种叫做 <code>locale</code> 的概念,其可以被调整,来为某个特殊的区域, 选择所需的字符集. 通过使用下面这个命令,我们能够查看到我们系统的语言设置:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo $LANG
en_US.UTF-8
</code></pre>
<p>通过这个设置,<code>POSIX</code> 相容的应用程序将会使用字典排列顺序而不是 <code>ASCII</code> 顺序. 当<code>[A-Z]</code>字符区域按照字典顺序解释的时候,包含除了小写字母<code>a</code>之外的所有字母.
为了部分地解决这个问题,<code>POSIX</code> 标准包含了大量的字符集,其提供了有用的字符区域.  下表中描述了它们:</p>
<p>表20-2: POSIX 字符集
字符集 说明</p>
<ul>
<li><code>[:alnum:]</code>:   字母数字字符. 在 <code>ASCII</code> 中,等价于:<code>[A-Za-z0-9]</code></li>
<li><code>[:word:]</code>:   与<code>[:alnum:]</code>相同, 但增加了下划线字符.</li>
<li><code>[:alpha:]</code>:   字母字符. 在 <code>ASCII</code> 中,等价于:<code>[A-Za-z]</code></li>
<li><code>[:blank:]</code>:   包含<code>空格</code>和 <code>tab</code> 字符.</li>
<li><code>[:cntrl:]</code>:   <code>ASCII</code> 的控制码. 包含了<code>0</code>到<code>31</code>,和<code>127</code>的 <code>ASCII</code> 字符.</li>
<li><code>[:digit:]</code>:   数字<code>0</code>到<code>9</code></li>
<li><code>[:graph:]</code>: 可视字符. 在 <code>ASCII</code> 中,它包含<code>33</code>到<code>126</code>的字符.</li>
<li><code>[:lower:]</code>:   小写字母.</li>
<li><code>[:punct:]</code>:   标点符号字符. 在 <code>ASCII</code> 中</li>
<li><code>[:print:]</code>:   可打印的字符. 在<code>[:graph:]</code>中的所有字符,再加上<code>空格</code>字符.</li>
<li><code>[:space:]</code>:   空白字符,包括<code>空格</code>,<code>tab</code>,<code>回车</code>,<code>换行</code>,<code>vertical tab</code>, 和 <code>form feed</code>.在<code>ASCII</code> 中, 等价于:<code>[ \t\r\n\v\f]</code></li>
<li><code>[:upper:]</code>:   大写字母.</li>
<li><code>[:xdigit:]</code>: 用来表示十六进制数字的字符. 在<code>ASCII</code> 中,等价于:<code>[0-9A-Fa-f]</code></li>
</ul>
<h3 id="用-find-筛选不规范文件名"><a class="header" href="#用-find-筛选不规范文件名">用 find 筛选不规范文件名</a></h3>
<p><code>find</code> 命令支持一个基于正则表达式的测试.
当某一行包含的字符串匹配上了一个表达式的时候,<code>grep</code> 命令会打印出这一行,然而 <code>find</code> 命令要求路径名精确地匹配这个正则表达式.
在下面的例子里面,我们将使用带有一个正则表达式的 <code>find</code> 命令,来查找每个路径名,其包含的任意字符都不是以下字符集中的一员.</p>
<pre><code class="language-bash">[-\_./0-9a-zA-Z]
</code></pre>
<p>这样一种扫描会发现包含空格和其它潜在不规范字符的路径名:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ find . -regex '.*[^-\_./0-9a-zA-Z].*'
</code></pre>
<p>由于要精确地匹配整个路径名,所以我们在表达式的两端使用了<code>.*</code>来匹配零个或多个字符.  在表达式中间,我们使用了否定的中括号表达式,其包含了我们一系列可接受的路径名字符.</p>
<h3 id="用-locate-查找文件"><a class="header" href="#用-locate-查找文件">用 locate 查找文件</a></h3>
<p><code>locate</code> 程序支持基本的(<code>--regexp</code> 选项)和扩展的(<code>--regex</code> 选项)正则表达式.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ locate --regex 'bin/(bz|gz|zip)'
</code></pre>
<p>通过使用 <code>alternation</code>,我们搜索包含 <code>bin/bz</code>,<code>bin/gz</code>,或<code>/bin/zip</code> 字符串的路径名.</p>
<h2 id="第二十一章文本处理"><a class="header" href="#第二十一章文本处理">第二十一章:文本处理</a></h2>
<h3 id="cat"><a class="header" href="#cat">cat</a></h3>
<p><code>cat</code> 程序具有许多有趣的选项. 其中许多选项用来帮助更好的可视化文本内容.
一个例子是<code>cat -A</code>可以用来显示文本中的非打印字符.
<code>tab</code> 字符在我们的文本中由 <code>^I</code> 字符来表示. 这是一种常见的表示方法,意思是<code>Control-I</code>,结果证明,它和 <code>tab</code>字符是一样的</p>
<p><code>cat</code> 程序也包含用来修改文本的选项.
最著名的两个选项是<code>-n</code>,其给文本行添加行号. 以及<code>-s</code>, 禁止输出多行空白.</p>
<h3 id="sort"><a class="header" href="#sort">sort</a></h3>
<p><code>sort</code> 程序对标准输入或命令行中指定的一个或多个文件进行排序,然后把排序结果发送到标准输出.
<code>sort</code> 程序能接受命令行中的多个文件作为参数,所以有可能把多个文件合并成一个有序的文件. 例如:</p>
<pre><code class="language-bash">sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt
</code></pre>
<p><code>sort</code> 程序有几个有趣的选项. 这里只是一部分列表:
表21-1: 常见的 sort 程序选项
选项 长选项 描述</p>
<p><code>-b</code>,<code>--ignore-leading-blanks</code>:默认情况下,排序从每行的第一个字符开始. 这个选项导致 <code>sort</code> 程序忽略空格,从第一个非空白字符开始排序.
<code>-f</code>,<code>--ignore-case</code>:让排序不区分大小写.
<code>-n</code>:<code>--numeric-sort</code>:默认基于字符串的长度来排序. 使用此选项允许根据数字值执行排序,而不是字母值.
<code>-r</code>,<code>--reverse</code>:  按相反顺序排序. 结果按照降序排列,而不是升序.
<code>-k</code>,<code>--key=field1[,field2]</code> 对从 <code>field1</code> 到 <code>field2</code> 之间的字符排序,而不是整个文本行. 看下面的讨论.
<code>-m</code>,<code>--merge</code>: 把每个参数看作是一个预先排好序的文件. 把多个文件合并成一个排好序的文件,而没有执行额外的排序.
<code>-o</code>,<code>--output=file</code>: 把排好序的输出结果发送到文件,而不是标准输出.
<code>-t</code>,<code>--field-separator=char</code>: 定义域分隔字符. 默认情况下,域由空格或制表符分隔.</p>
<p>首先,让我们看一下 <code>-n</code> 选项,被用做数值排序. 通过这个选项,可以基于数值进行排序. <code>du</code> 命令可以确定最大的磁盘空间用户. 通常 <code>du</code> 命令列出的输出结果按照路径名来排序:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ du -s /usr/share/* | head
68K  /usr/share/a11y-profile-manager
28K  /usr/share/accounts
40K  /usr/share/accountsservice
...
</code></pre>
<p>我们能够产生一个按数值排序的列表,来显示 <code>10</code> 个最大的空间占据者:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ du -s /usr/share/* | sort -nr | head
1020K  /usr/share/speech-dispatcher
1008K  /usr/share/rubygems-integration
972K  /usr/share/pandoc
...
</code></pre>
<p>通过使用<code>-nr</code> 选项,我们产生了一个反向的数值排序,最大数值排列在第一位. 这种排序起作用是因为数值出现在每行的开头.
但是如果我们想要基于文件行中的某个数值排序,又会怎样呢? 例如,命令 <code>ls -l</code> 的输出结果:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls -lh /usr/bin | head
-rwxr-xr-x 1 root   root      59K 9月   5  2019 [
-rwxr-xr-x 1 root   root       96 3月   8 21:02 2to3-2.7
-rwxr-xr-x 1 root   root     9.9K 4月  23  2016 411toppm
...
</code></pre>
<p>此刻,忽略 <code>ls</code> 程序也能按照文件大小排序,我们使用 <code>sort</code> 程序来完成此任务:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls -l /usr/bin | sort -nr -k 5 | head
-rwxr-xr-x 1 root   root    1023K 3月  26  2020 x86_64-linux-gnu-gcc-7
-rwxr-xr-x 1 root   root     1019 4月  20  2020 wine-stable
-rwxr-xr-x 1 root   root     1007 8月  22  2020 dvipdf
...
</code></pre>
<p><code>sort</code> 程序的许多用法都涉及到处理表格数据,例如上面 <code>ls</code> 命令的输出结果.
如果我们把数据库的术语应用到上面的表格中,每行是一条记录,并且每条记录由多个字段组成, 例如文件属性,链接数,文件名,文件大小等等.
<code>sort</code> 程序能够处理独立的字段. 在数据库术语中, 我们能够指定一个或者多个关键字段,来作为排序的关键值.
在上面的例子中,我们指定 <code>n</code> 和 <code>r</code> 选项来执行相反的数值排序,并且指定 <code>-k 5</code>,让 <code>sort</code> 程序使用第五字段作为排序的关键值.</p>
<p><code>sort</code> 程序允许多个 <code>-k</code> 选项的实例,所以可以指定多个排序关键值. 下面是多键值排序的语法:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sort --key=1,1 --key=2n distros.txt
</code></pre>
<p>虽然为了清晰,我们使用了选项的长格式,但是 <code>-k 1,1 -k 2n</code> 格式是等价的. <code>1,1</code>意味着始于并且结束于第一个字段.
在第二个实例中,我们指定了 <code>2n</code>,表示按第二个字段排序, 并且按照数值排序. 键值说明符的末尾可以附上一个选项字母, 用来指定排序的种类.
这些选项字母和 <code>sort</code> 程序的全局选项一样:<code>b</code>(忽略开头的空格),<code>n</code>(数值排序),<code>r</code>(逆向排序),等等.</p>
<p>对于日期格式, 在计算机中,日期通常设置为 <code>YYYY-MM-DD</code> 格式, 这样按时间顺序排序变得容易,但有时我们的日期为<code>MM/DD/YYYY</code>的格式.
幸运地是, <code>key</code> 选项允许在字段中指定偏移量,所以我们能在字段中定义键值.</p>
<p>[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt</p>
<p>通过指定 <code>-k 3.7</code>,我们指示 <code>sort</code> 程序使用一个排序键值,其始于第三个字段中的第七个字符,对应于年的开头.
同样地,我们指定 <code>-k 3.1</code> 和 <code>-k 3.4</code> 来分离日期中的月和日.  我们也添加了 <code>n</code> 和 <code>r</code> 选项来实现一个逆向的数值排序.
<code>b</code> 选项用来删除日期字段中开头的空格( 行与行之间的空格数迥异,因此会影响 <code>sort</code> 程序的输出结果).</p>
<p>一些文件不会使用 <code>tabs</code> 和<code>空格</code>做为字段界定符;例如, <code>/etc/passwd</code> 文件.<code>sort</code> 程序提供 了一个 <code>-t</code> 选项来定义分隔符.
按照第七个字段(帐户的默认 <code>shell</code>)来排序此 <code>passwd</code> 文件,我们可以这样做:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sort -t ':' -k 7 /etc/passwd | head
</code></pre>
<h3 id="uniq"><a class="header" href="#uniq">uniq</a></h3>
<p>与 <code>sort</code> 程序相比,<code>uniq</code> 程序是个轻量级程序.  <code>uniq</code> 执行一个看似琐碎的认为. 当给定一个排好序的文件(包括标准输出),<code>uniq</code> 会删除任意重复行,并且把结果发送到标准输出.
它常常和 <code>sort</code> 程序一块使用,来清理重复的输出.
<code>uniq</code> 程序是一个传统的 <code>Unix</code> 工具,经常与 <code>sort</code> 程序一块使用, <code>GNU</code> 版本的 <code>sort</code> 程序支持一个 <code>-u</code> 选项,其可以从排好序的输出结果中删除重复行.  <code>uniq</code> 只会删除相邻的重复行.</p>
<p>表21-2: 常用的 <code>uniq</code> 选项
选项 说明</p>
<ul>
<li><code>-c</code> 输出所有的重复行,并且每行开头显示重复的次数.</li>
<li><code>-d</code> 只输出重复行,而不是特有的文本行.</li>
<li><code>-f n</code> 忽略每行开头的 <code>n</code> 个字段,字段之间由空格分隔, 不同于 <code>sort</code> 程序, <code>uniq</code> 没有选项来设置备用的字段分隔符.</li>
<li><code>-i</code> 在比较文本行的时候忽略大小写.</li>
<li><code>-s n</code> 跳过(忽略)每行开头的 <code>n</code> 个字符.</li>
<li><code>-u</code> 只是输出独有的文本行. 这是默认的</li>
</ul>
<h3 id="切片和切块"><a class="header" href="#切片和切块">切片和切块</a></h3>
<p>下面我们将要讨论的三个程序用来从文件中获得文本列,并且以有用的方式重组它们.</p>
<h3 id="cut"><a class="header" href="#cut">cut</a></h3>
<p><code>cut</code> 程序被用来从文本行中抽取文本,并把其输出到标准输出. 它能够接受多个文件参数或者 标准输入. 从文本行中指定要抽取的文本有些麻烦,使用以下选项:</p>
<p>表21-3: cut 程序选择项
选项 说明</p>
<ul>
<li><code>-c char_list</code> 从文本行中抽取由 <code>char_list</code> 定义的文本. 这个列表由一个或多个逗号分隔开的数值区间组成.</li>
<li><code>-f field_list</code> 从文本行中抽取一个或多个由 <code>field_list</code>定义的字段. 列表包括一个或多个字段,或由逗号分隔开的字段区间.</li>
<li><code>-d delim_char</code> 当指定<code>-f</code> 选项之后,使用 <code>delim_char</code>做为字段分隔符. 默认情况下, 字段之间必须由单个 <code>tab</code> 字符分隔开.</li>
<li><code>--complement</code> 抽取整个文本行,除了那些由<code>-c</code> 和/或<code>-f</code> 选项指定的文本.</li>
</ul>
<p>正如我们所看到的,<code>cut</code> 程序抽取文本的方式相当不灵活. <code>cut</code> 命令最好用来从其它程序产生的文件中抽取文本,而不是从人们直接输入的文本中抽取, 例子为:</p>
<pre><code class="language-bash">cut -f 3 distros.txt #抽取第三个字段
cut -f 3 distros.txt | cut -c 7-10 # 再抽取位置为7到10的字符
</code></pre>
<p><code>Coreutils</code> 软件包有一个工具<code>expand</code>可以将<code>tab</code>转换成相应数目的空格, <code>unexpand</code>把空格替换成<code>tab</code>. 使用 <code>-d</code> 选项,我们能够指定冒号做为字段分隔符.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ cut -d ':' -f 1 /etc/passwd | head
</code></pre>
<h3 id="paste"><a class="header" href="#paste">paste</a></h3>
<p><code>paste</code> 命令的功能正好与 <code>cut</code> 相反. 它会添加一个或多个文本列到文件中. 它通过读取多个文件,然后把每个文件中顺序对应的行合并, 写入标准输出.</p>
<h3 id="join"><a class="header" href="#join">join</a></h3>
<p>在某些方面,<code>join</code> 命令类似于 <code>paste</code>,它会往文件中添加列,但是它使用了独特的方法来完成.
<code>join</code>会合并具有相同<code>key</code>的条目. 例如下面两个文件</p>
<pre><code class="language-bash">[me@linuxbox ~]$ head distros-key-names.txt
11/25/2008 Fedora
10/30/2008 Ubuntu
06/19/2008 SUSE

[me@linuxbox ~]$ head distros-key-vernums.txt
11/25/2008 10
10/30/2008 8.10
06/19/2008 11.0
</code></pre>
<p>使用<code>join</code>可以把它们连接起来:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ join distros-key-names.txt distros-key-vernums.txt | head
11/25/2008 Fedora 10
10/30/2008 Ubuntu 8.10
06/19/2008 SUSE 11.0
</code></pre>
<p>现在我们有两个具有共享<code>key</code>( <code>发行日期</code> )的文件. 有必要指出,为了使 <code>join</code> 命令 能正常工作, 所有文件必须按照<code>key</code>排序.
默认情况下,<code>join</code> 命令使用空白字符做为输入字段的界定符,<code>一个空格</code>作为输出字段的界定符.</p>
<h3 id="比较文本"><a class="header" href="#比较文本">比较文本</a></h3>
<p>通常比较文本文件的版本很有帮助. 对于系统管理员和软件开发者来说,这个尤为重要.  一名系统管理员可能需要拿现有的配置文件与先前的版本做比较,来诊断一个系统错误.
同样的,一名程序员经常需要查看程序的修改.</p>
<h3 id="comm"><a class="header" href="#comm">comm</a></h3>
<p><code>comm</code> 程序会比较两个文本文件,并且会显示每个文件特有的文本行和共有的文本行.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ comm file1.txt file2.txt
</code></pre>
<p><code>comm</code> 命令产生三列输出. 第一列包含第一个文件独有的文本行;第二列是第二个文件独有的;第三列包含两个文件共有的文本行.
<code>comm</code> 支持 <code>-n</code> 形式的选项,这里 <code>n</code> 代表 <code>1</code>,<code>2</code> 或 <code>3</code>. 这些选项使用的时候,指定了要隐藏的列.
例如,如果我们只想输出两个文件共享的文本行, 我们将隐藏第一列和第二列的输出结果:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ comm -12 file1.txt file2.txt
</code></pre>
<h3 id="diff"><a class="header" href="#diff">diff</a></h3>
<p>类似于 <code>comm</code> 程序,<code>diff</code> 程序被用来监测文件之间的差异. 然而,<code>diff</code> 是一款更加复杂的工具,它支持许多输出格式,并且一次能处理许多文本文件.
软件开发员经常使用 <code>diff</code> 程序来检查不同程序源码版本之间的更改,<code>diff</code> 能够递归地检查源码目录,经常称之为源码树.
<code>diff</code> 程序的一个常见用例是创建 <code>diff</code> 文件或者补丁,它会被其它程序使用,例如 <code>patch</code> 程序(我们一会儿讨论),来把文件从一个版本转换为另一个版本.
如果我们使用 <code>diff</code> 程序,来查看我们之前的文件实例:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ diff file1.txt file2.txt
1d0
&lt; a
4a4
&gt; e
</code></pre>
<p>我们看到 <code>diff</code> 程序的默认输出风格:对两个文件之间差异的简短描述. 在默认格式中, 每组的更改之前都是一个更改命令,其形式为 <code>range operation range</code> ,
用来描述要求更改的位置和类型,从而把第一个文件转变为第二个文件:</p>
<p>表21-4: <code>diff</code> 更改命令
改变 说明</p>
<ul>
<li><code>r1ar2</code>: <code>add</code>, 把第二个文件中位置 <code>r2</code> 处的文件行添加到第一个文件中的 <code>r1</code> 处,</li>
<li><code>r1cr2</code>: <code>cover</code>, 用第二个文件中位置 <code>r2</code> 处的文本行覆盖位置 <code>r1</code> 处的文本行</li>
<li><code>r1dr2</code>:<code>delete</code>, 删除第一个文件中位置 <code>r1</code> 处的文本行,这些文本行对应第二个文件中位置 <code>r2</code> 处</li>
</ul>
<p>在这种格式中,一个范围就是由逗号分隔开的开头行和结束行的列表.
然这种格式是默认情况(主要是为了服从 <code>POSIX</code> 标准且向后与传统的 <code>Unix diff</code> 命令兼容), 但是它并不像其它可选格式一样被广泛地使用.
最流行的两种格式是上下文模式和统一模式. 当使用上下文模式(带上<code> -c</code> 选项),我们将看到这些:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ diff -c file1.txt file2.txt
*** file1.txt 2008-12-23 06:40:13.000000000 -0500
--- file2.txt 2008-12-23 06:40:34.000000000 -0500
...
</code></pre>
<p>这个输出结果以两个文件名和它们的时间戳开头. 第一个文件用<code>星号</code>做标记,第二个文件用<code>短横线</code>做标记.
这些标记将象征它们各自代表的文件. 下一步,我们看到几组修改, 包括默认的周围上下文行数. 在第一组中,我们看到:
<code>*** 1,4 ***</code>其表示第一个文件中从第一行到第四行的文本行. <code>--- 1,4 ---</code>这表示第二个文件中从第一行到第四行的文本行.
在更改组内,文本行以四个指示符之一开头:</p>
<p>表21-5: <code>diff</code> 上下文模式更改指示符
指示符 意思</p>
<ul>
<li><code>blank</code>:  上下文显示行, 表示没有差异</li>
<li><code>-</code>:  删除行. 第一个文件中有, 第二个没有.</li>
<li><code>+</code>:  添加行. 第一个文件中没有, 第二个有. 这一行将会出现在第二个文件内,而不是第一个文件中.</li>
<li><code>!</code>:  更改行. 两个文件的本行的内容不同.</li>
</ul>
<p>统一模式相似于上下文模式,但是更加简洁. 通过 <code>-u</code> 选项来指定它:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ diff -u file1.txt file2.txt
--- file1.txt 2008-12-23 06:40:13.000000000 -0500
+++ file2.txt 2008-12-23 06:40:34.000000000 -0500
@@ -1,4 +1,4 @@
</code></pre>
<p>上下文模式和统一模式之间最显著的差异就是重复上下文的消除,这就使得统一模式的输出结果要比上下文模式的输出结果简短.
在我们上述实例中,我们看到类似于上下文模式中的文件时间戳,其紧紧跟随字符串 <code>@@ -1,4+1,4 @@</code>.
这行字符串表示了在更改组中描述的第一个文件中的文本行和第二个文件中的文本行.  这行字符串之后就是文本行本身,与三行默认的上下文. 每行以可能的三个字符中的一个开头:</p>
<p>表21-6: <code>diff</code> 统一模式更改指示符
字符 意思</p>
<ul>
<li><code>空格</code>:  两个文件都包含这一行.</li>
<li><code>-</code>:  在第一个文件中删除这一行.</li>
<li><code>+</code>:  添加这一行到第一个文件中.</li>
</ul>
<h3 id="patch"><a class="header" href="#patch">patch</a></h3>
<p><code>patch</code> 程序被用来把更改应用到文本文件中. 它接受从 <code>diff</code> 程序的输出,并且通常被用来把较老的文件版本转变为较新的文件版本.</p>
<p>让我们考虑一个著名的例子. <code>Linux</code> 内核是由一个 大型的,组织松散的贡献者团队开发而成,这些贡献者会提交固定的少量更改到源码包中.
<code>Linux</code> 内核由几百万行代码组成,虽然每个贡献者每次所做的修改相当少. 对于一个贡献者来说,每做一个修改就给每个开发者发送整个的内核源码树,这是没有任何意义的.
相反, 提交一个 diff 文件. 一个 <code>diff</code> 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异.
然后一个接受者使用 <code>patch</code> 程序,把这些更改应用到他自己的源码树中. 使用 <code>diff/patch</code> 组合提供了 两个重大优点:</p>
<ol>
<li>一个 diff 文件非常小,与整个源码树的大小相比较而言.</li>
<li>一个 diff 文件简洁地显示了所做的修改,从而允许程序补丁的审阅者能快速地运算它.</li>
</ol>
<p>当然,<code>diff/patch</code> 能工作于任何文本文件,不仅仅是源码文件. 它同样适用于配置文件或任意其它文本.
准备一个 <code>diff</code> 文件供 <code>patch</code> 程序使用,<code>GNU</code> 文档(查看下面的拓展阅读部分)建议这样使用 <code>diff</code> 命令:</p>
<pre><code class="language-bash">diff -Naur 旧文件 新文件 &gt; 补丁文件
</code></pre>
<p><code>旧文件</code> 和 <code>新文件</code> 可以是单个文件也可以是包含文件的目录. <code>r</code> 选项支持递归目录树. 一旦创建了 <code>diff</code> 文件,我们就能应用它,把旧文件修补成新文件.</p>
<pre><code class="language-bash">patch &lt; 补丁文件
</code></pre>
<p>我们不需要指定要修补的目标文件,因为 <code>diff</code> 文件(在统一模式中)已经 在标题行中包含了文件名.
<code>patch</code> 程序有大量的选项,而且还有额外的实用程序可以被用来分析和编辑补丁.</p>
<ul>
<li><code>-N, --new-file</code>:  认为缺失文件为空.</li>
<li><code>-a, --text</code>: 将所有文件当成文本格式</li>
<li><code>-u, -U NUM, --unified[=NUM]</code>: 在统一模式下, 共同内容的行数(默认为<code>3</code>)</li>
<li><code>-r, --recursive</code>:  递归地比较子文件夹</li>
</ul>
<h3 id="tr"><a class="header" href="#tr">tr</a></h3>
<p>一般的文本编辑器是交互式的,意思是我们手动移动光标,然后输入我们的修改.  然而,也有非交互式的方法来编辑文本. 有可能,例如,通过单个命令把一系列修改应用到多个文件中.</p>
<p><code>tr</code> 程序被用来更改字符. 我们可以把它看作是一种基于字符的查找和替换操作. 换字是一种把字符从一个字母转换为另一个字母的过程. 例如,把小写字母转换成大写字母就是换字.
我们可以通过 <code>tr</code> 命令来执行这样的转换,如下所示:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;lowercase letters&quot; | tr a-z A-Z
LOWERCASE LETTERS
</code></pre>
<p>正如我们所见,<code>tr</code> 命令操作标准输入,并把结果输出到标准输出. <code>tr</code> 命令接受两个参数:要被转换的字符集以及相对应的转换后的字符集. 字符集可以用三种方式来表示:</p>
<ol>
<li>一个枚举列表. 例如, <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></li>
<li>一个字符域. 例如,<code>A-Z</code> . 注意这种方法有时候面临与其它命令相同的问题,归因于语系的排序规则,因此应该谨慎使用.</li>
<li><code>POSIX</code> 字符类. 例如,<code>[:upper:]</code></li>
</ol>
<p>大多数情况下,两个字符集应该长度相同;然而,有可能第一个集合大于第二个,尤其如果我们想要把多个字符转换为单个字符:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;lowercase letters&quot; | tr [:lower:] A
AAAAAAAAA AAAAAAA
</code></pre>
<p>除了换字之外,<code>tr</code> 命令能允许字符从输入流中简单地被删除. 在之前的章节中,我们讨论了转换 <code>MS-DOS</code> 文本文件为 <code>Unix</code> 风格文本的问题.
为了执行这个转换,每行末尾的回车符需要被删除.  这个可以通过 <code>tr</code> 命令来执行,如下所示:</p>
<pre><code class="language-bash">tr -d '\r' &lt; dos_file &gt; unix_file
</code></pre>
<p>这里的 <code>dos_file</code> 是需要被转换的文件,<code>unix_file</code> 是转换后的结果. 这种形式的命令使用转义序列 <code>\r </code>来代表回车符. 查看 <code>tr</code> 命令所支持地完整的转义序列和字符类别列表,试试下面的命令:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ tr --help
</code></pre>
<hr />
<p>ROT13: 不那么秘密的加密</p>
<p><code>tr</code> 命令的一个有趣的用法是执行 <code>ROT13</code> 文本编码. 把 ROT13称为<code>加密</code>有点夸张, <code>文本模糊处理</code>更准确些.
这个方法就是简单地把每个字符在字母表中向前移动<code>13</code>位. 因为移动的位数是可能的<code>26</code>个字符的一半, 所以对文本再次执行这个算法,就恢复到了它最初的形式.
通过 <code>tr</code> 命令来执行这种编码:</p>
<pre><code class="language-bash">echo  &quot;secret text&quot;  | tr a-zA-Z n-za-mN-ZA-M |
frperg grkg
</code></pre>
<p>再次执行相同的过程,得到翻译结果:</p>
<pre><code class="language-bash">echo &quot;frperg grkg&quot; | tr a-zA-Z n-za-mN-ZA-M+ |
secret text
</code></pre>
<p><code>tr</code> 也可以完成另一个技巧. 使用 <code>-s</code> 选项,<code>tr</code> 命令能&quot;挤压&quot;(删除)重复的字符实例:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | tr -s ab
abccc
</code></pre>
<p>这里我们有一个包含重复字符的字符串. 通过给 <code>tr</code> 命令指定字符集<code>ab</code>,我们能够消除字符集中字母的重复实例,对字符集之外字符(<code>c</code>)不作用.
注意重复的字符必须是相邻的.  如果它们不相邻,那么挤压会没有效果.</p>
<h3 id="sed"><a class="header" href="#sed">sed</a></h3>
<p><code>sed</code> 是 <code>stream editor</code>(流编辑器)的简称. 它对文本流进行编辑,或是一系列指定的文件,或是标准输入.
<code>sed</code> 是一款强大的,并且有些复杂的程序(有整本内容都是关于 <code>sed</code> 程序的书籍), 所以在这里我们不会详尽的讨论它.
总之, <code>sed</code> 的工作方式可以是给出单个编辑命令(在命令行中), 也可以是包含多个命令的脚本文件名, 然后它就按行来执行这些命令. 这里有一个非常简单的 <code>sed</code> 实例:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;front&quot; | sed 's/front/back/'
back
</code></pre>
<p>在这个例子中,我们使用 <code>echo</code> 命令产生了一个单词的文本流,然后把它管道给 <code>sed</code> 命令. <code>sed</code>依次对流文本执行指令 <code>s/front/back/</code>,随后输出<code>back</code>.
我们也能够把这个命令认为是相似于 <code>vi</code> 中的<code>替换</code> (查找和替代)命令.</p>
<p><code>sed</code> 中的命令开始于单个字符. 在上面的例子中,这个替换命令由字母 <code>s</code> 来代表,其后跟着<code>查找</code>和<code>替代</code>字符串,<code>斜杠</code>字符做为分隔符.
分隔符的选择是随意的. 按照惯例,经常使用斜杠字符, 但是 <code>sed</code> 将会接受紧随命令之后的任意字符做为分隔符. 我们可以按照这种方式来执行相同的命令:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;front&quot; | sed 's_front_back_'
back
</code></pre>
<p>通过紧跟命令之后使用<code>下划线</code>字符,则它变成界定符. <code>sed</code> 可以设置界定符的能力,使命令的可读性更强, 正如我们将看到的.
<code>sed</code> 中的大多数命令之前都会带有一个地址,其指定了输入流中要被编辑的文本行. 如果省略了地址, 然后会对输入流的每一行执行编辑命令.
最简单的地址形式是一个行号. 我们能够添加一个地址 到我们例子中:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;front&quot; | sed '1s/front/back/'
back
</code></pre>
<p>给我们的命令添加地址 <code>1</code>,就导致只对仅有一行文本的输入流的第一行执行替换操作. 如果我们指定另一 个数字:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;front&quot; | sed '2s/front/back/'
front
</code></pre>
<p>我们看到没有执行这个编辑命令,因为我们的输入流没有第二行. 地址可以用许多方式来表达. 这里是最常用的:</p>
<p>表21-7: <code>sed</code> 地址表示法
地址 说明</p>
<ul>
<li><code>n</code>: 行号,<code>n</code> 是一个正整数.</li>
<li><code>$</code>: 最后一行.</li>
<li><code>/regexp/</code>: 所有匹配一个 <code>POSIX</code> 基本正则表达式的文本行, 表达式通过斜杠界定. 正则表达式可以有备用字符界定,例如<code>\cregexpc</code>,这里 <code>c</code> 就是一个备用的字符.</li>
<li><code>addr1,addr2</code>: 从 <code>addr1</code> 到 <code>addr2</code> 范围内的文本行,包含地址 <code>addr2</code> 在内. 地址可能是上述任意单独的地址形式.</li>
<li><code>first~step</code>: 匹配由数字 <code>first</code> 代表的文本行,然后随后的每个在 <code>step</code> 间隔处的文本行. 例如 <code>1~2</code> 是指每个位于奇数行号的文本行,<code>5~5</code> 则指第五行和之后每五行位置的文本行.</li>
<li><code>addr1,+n</code>: 匹配地址 <code>addr1</code> 和随后的 <code>n</code> 个文本行.</li>
<li><code>addr!</code>: 匹配所有的文本行,除了 <code>addr</code> 之外,<code>addr</code> 可能是上述任意的地址形式.</li>
</ul>
<p>例如打印<code>1</code>到<code>5</code>行,</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sed -n '1,5p' distros.txt
</code></pre>
<p>一般为了高效,我们必须指定选项 <code>-n</code>(不自动打印选项), 让 <code>sed</code> 不要默认地打印每一行, <code>p</code> 命令, 其就是简单地把匹配的文本行打印出来.</p>
<pre><code class="language-bash">$ sed -n '/SUSE/p' distros.txt
</code></pre>
<p>通过包含由斜杠界定的正则表达式 <code>/SUSE/</code>,我们能够孤立出包含它的文本行,和 <code>grep</code> 程序的功能是相同的.
最后,我们将试着否定上面的操作,通过给这个地址添加一个感叹号:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sed -n '/SUSE/!p' distros.txt
</code></pre>
<p>目前为止,我们已经知道了两个 sed 的编辑命令,<code>s</code> 和 <code>p</code>. 这里是一个更加全面的基本编辑命令列表:</p>
<p>表21-8: <code>sed</code> 基本编辑命令
命令 说明</p>
<ul>
<li><code>=</code>: 输出当前的行号.</li>
<li><code>a</code>: 在当前行之后追加文本.</li>
<li><code>d</code>: 删除当前行.</li>
<li><code>i</code>: 在当前行之前插入文本.</li>
<li><code>p</code>: 打印当前行. 默认情况下,<code>sed</code> 程序打印每一行. 通过指定 <code>-n</code> 选项,这个默认的行为能够被忽略.</li>
<li><code>q</code>: 退出 <code>sed</code>,不再处理更多的文本行. 如果不指定 <code>-n</code> 选项,输出当前行.</li>
<li><code>Q</code>: 退出 <code>sed</code>,不再处理更多的文本行.</li>
<li><code>s/regexp/replacement/</code>: 只要找到一个 <code>regexp</code> 匹配项,就替换为 <code>replacement</code> 的内容. <code>replacement</code>可以是<code>&amp;</code>, 就是<code>regexp</code>匹配到的文本.
另外, <code>replacement</code> 可能包含序列 <code>\1</code>到<code>\9</code>,也就是反向引用. 在 <code>replacement</code> 末尾的斜杠之后,可以指定一个 可选的标志,来修改 <code>s</code> 命令的行为.</li>
<li><code>y/set1/set2</code>:  执行字符转写操作,通过把 <code>set1</code> 中的字符转变为相对应的 <code>set2</code> 中的字符. 注意不同于 <code>tr</code> 程序,<code>sed</code> 要求两个字符集合具有相同的长度.</li>
</ul>
<p>到目前为止,<code>s</code> 命令是最常使用的编辑命令. 例如 文件中的日期格式是<code>MM/DD/YYYY</code>,但如果格式是 <code>YYYY-MM-DD</code> 会更好一些(利于排序).
手动修改 日期格式不仅浪费时间而且易出错,但是有了 <code>sed</code>,只需一步就能完成修改:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
</code></pre>
<p>哇!这个命令看起来很丑陋. 但是它起作用了. 仅用一步,我们就更改了文件中的日期格式.  它也是一个例子: 有时候我们会开玩笑地把正则表达式称为是&quot;只写&quot;的.
我们能写正则表达式,但是有时候我们不能读它们. 在我们恐惧地忍不住要逃离此命令之前,让我们看一下 怎样来构建它.</p>
<p>因为日期是 <code>MM/DD/YYYY</code> 格式,并且出现在文本行的末尾,我们可以使用这样的表达式:</p>
<pre><code class="language-bash">([0-9]{2})/([0-9]{2})/([0-9]{4})$
</code></pre>
<p>此表达式匹配两位数字,一个斜杠,两位数字,一个斜杠,四位数字,以及行尾. 圆括号包围的是子表达式, 稍后可以使用反向引用,现在我们就可以构建<code>replacement</code>,如下所示:</p>
<pre><code class="language-bash">\3-\1-\2
</code></pre>
<p>此表达式给出了<code>年份-月份-日期</code>.合起来就是 <code>sed 's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt</code>.</p>
<p>我们还有两个问题. 第一个是在我们表达式中额外的斜杠将会迷惑 <code>sed</code>.第二个是在默认情况下,<code>sed</code>只接受基本的正则表达式,在表达式中的几个字符会 被当作文字字面值,而不是元字符.
我们能够通过反斜杠的自由应用来转义令人不快的字符:<code>sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt</code>. 你掌握了吧!</p>
<p><code>s</code> 命令的另一个功能是使用可选标志,其跟随替代字符串. 一个最重要的可选标志是 <code>g</code> 标志,其 指示 <code>sed</code> 对某个文本行全范围地执行查找和替代操作,不仅仅是对第一个实例,例如:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | sed 's/b/B/'
aaaBbbccc
</code></pre>
<p>我们看到虽然执行了替换操作,但是只针对第一个字母 <code>b</code> 实例,然而剩余的实例没有更改.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | sed 's/b/B/g'
aaaBBBccc
</code></pre>
<p>目前为止,通过命令行我们只让 <code>sed</code> 执行单个命令. 使用 <code>-f</code> 选项,也有可能在一个脚本文件中构建更加复杂的命令.
我们需要编写一个脚本,所以我们将打开文本编辑器,然后输入以下文字:</p>
<pre><code class="language-bash"># sed script to produce Linux distributions report
1 i\
\
Linux Distributions Report\
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
</code></pre>
<p>我们将把 <code>sed</code> 脚本保存为 <code>distros.sed</code> 文件,然后像这样运行它:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ sed -f distros.sed distros.txt
</code></pre>
<p>让我们分析一下脚本文件. 我们将使用 <code>cat</code> 来给每行文本编号:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ cat -n distros.sed
1 # sed script to produce Linux distributions report
2
3 1 i\
4 \
5 Linux Distributions Report\
6
7 s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
</code></pre>
<p>我们脚本文件的第一行是一条注释. 如同 <code>Linux</code> 系统中的许多配置文件和编程语言一样,注释以<code>#</code>字符开始, 然后是人类可读的文本.
第二行是一个空行. 正如注释一样,添加空白行是为了提高程序的可读性.</p>
<p>许多 <code>sed</code> 命令支持行地址. 这些行地址被用来指定对输入文本的哪一行执行操作. 行地址可能被 表示为单独的行号,行号范围,以及特殊的行号<code>$</code>,它表示输入文本的最后一行.
从第三行到第六行所包含地文本要被插入到地址 <code>1</code> 处,也就是输入文本的第一行中. 这个 <code>i</code> 命令 之后是反斜杠回车符,来产生一个转义的回车符,或者就是所谓的连行符.
这个序列能够 被用在许多环境下,包括 <code>shell</code> 脚本,从而允许把回车符嵌入到文本流中,而没有通知解释器(在这是指 <code>sed</code> 解释器)已经到达了文本行的末尾.
<code>i</code> 命令,同样地,命令 <code>a</code>(追加文本, 而不是插入文本)和 <code>c</code>(取代文本)命令都允许多个文本行,只要每个文本行,除了最后一行,以一个 连行符结束.
实际上,脚本的第六行是插入文本的末尾,它以一个普通的回车符结尾,而不是一个 连行符,通知解释器 <code>i</code> 命令结束了.</p>
<p>注意:一个连行符由一个<code>斜杠字符</code>其后紧跟一个<code>回车符</code>组成. 它们之间不允许有空白字符.</p>
<p>第七行是我们的查找和替代命令. 因为命令之前没有添加地址,所以输入流中的每一行文本 都得服从它的操作.
第八行执行小写字母到大写字母的字符替换操作. 注意不同于 <code>tr</code> 命令,这个 <code>sed</code> 中的 <code>y</code> 命令不 支持字符区域(例如,<code>[a-z]</code>),也不支持 <code>POSIX</code> 字符集.
因为 <code>y</code> 命令之前不带地址, 所以它会操作输入流的每一行.</p>
<p><code>sed</code> 是一款非常强大的程序,它能够针对文本流完成相当复杂的编辑任务. 它最常用于简单的行任务,而不是长长的脚本.
许多用户喜欢使用其它工具,来执行较大的工作.  在这些工具中最著名的是 <code>awk</code> 和 <code>perl</code> .
它们不仅仅是工具,像这里介绍的程序,且延伸到 完整的编程语言领域. 特别是 <code>perl</code>,经常被用来代替 <code>shell</code>脚本,来完成许多系统管理任务, 同时它也是一款非常流行网络开发语言.
<code>awk</code> 更专用一些. 其具体优点是其操作表格数据的能力.  虽然关于 <code>awk</code> 和 <code>perl</code> 的内容都超出了本书所讨论的范围, 但是对于 Linux 命令行用户来说,它们都是非常好的技能.</p>
<h3 id="aspell"><a class="header" href="#aspell">aspell</a></h3>
<p>我们要查看的最后一个工具是 <code>aspell</code>,一款交互式的拼写检查器. <code>aspell</code> 程序是早先 <code>ispell</code> 程序的继承者,大多数情况下,它可以被用做一个替代品.
虽然 <code>aspell</code> 程序大多被其它需要拼写检查能力的 程序使用,但它也可以作为一个独立的命令行工具使用.
它能够智能地检查各种类型的文本文件, 包括 <code>HTML</code> 文件,<code>C/C++</code>程序,电子邮件和其它种类的专业文本. 拼写检查一个包含简单的文本文件,可以这样使用 <code>aspell</code>:</p>
<pre><code class="language-bash">aspell check textfile
</code></pre>
<p>这里的 <code>textfile</code> 是要检查的文件名. 作为一个实际例子,让我们创建一个简单的文本文件,叫做 <code>foo.txt</code>, 包含一些故意的拼写错误:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ cat &gt; foo.txt
The quick brown fox jimped over the laxy dog.
</code></pre>
<p>下一步我们将使用 <code>aspell</code> 来检查文件:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ aspell check foo.txt
</code></pre>
<p><code>aspell</code> 在检查模式下是交互的,在显示屏的顶部,我们看到我们的文本中有一个拼写可疑且高亮显示的单词. 在中间部分,我们看到 十个拼写建议,序号从 <code>0</code> 到 <code>9</code>,然后是一系列其它可能的操作.
最后,在最底部,我们看到一个提示符, 准备接受我们的选择. 如果我们按下 <code>1</code> 按键,<code>aspell</code> 会用单词 <code>jumped</code> 代替错误单词,然后移动到下一个拼写错的单词,就是<code>laxy</code>.
一旦 aspell 结束操作,我们 可以检查我们的文件,会看到拼写错误的单词已经更正了.</p>
<p>[me@linuxbox ~]$ cat foo.txt
The quick brown fox jumped over the lazy dog.</p>
<p>除非由命令行选项 <code>--dont-backup</code> 告诉 <code>aspell</code>,否则通过追加扩展名<code>.bak</code> 到文件名中, <code>aspell</code> 会创建一个包含原始文本的备份文件.</p>
<p>对于<code>HTML</code>文件, 使用<code>-H(HTML)</code>检查模式选项,能够避免<code>aspell</code>认为<code>&lt;HTML&gt;</code>这样的标签是错误拼写.</p>
<h3 id="总结归纳"><a class="header" href="#总结归纳">总结归纳</a></h3>
<p>在这一章中,我们已经查看了一些操作文本的命令行工具. 我们将在随后的章节中发现这些工具组成 了解决实际问题的基本工具箱.
这将是确定无疑的,当我们学习 shell 脚本的时候, 到时候这些工具将真正体现出它们的价值.</p>
<p>还有一些更有趣的文本操作命令:<code>split</code>(把文件分割成碎片), <code>csplit</code>(基于上下文把文件分割成碎片),和 <code>sdiff</code>(并排合并文件差异).</p>
<h2 id="第二十二章-格式化输出"><a class="header" href="#第二十二章-格式化输出">第二十二章: 格式化输出</a></h2>
<p>在这章中, 我们继续着手于文本相关的工具, 关注那些用来格式化输出的程序, 而不是改变文本自身.
这些工具通常让文本准备就绪打印, 这是我们在下一章会提到的. 我们在这章中会提到的工具有:</p>
<ul>
<li>nl – 添加行号</li>
<li>fold – 限制文件列宽</li>
<li>fmt – 一个简单的文本格式转换器</li>
<li>pr – 让文本为打印做好准备</li>
<li>printf – 格式化数据并打印出来</li>
<li>groff – 一个文件格式系统</li>
</ul>
<h3 id="简单的格式化工具"><a class="header" href="#简单的格式化工具">简单的格式化工具</a></h3>
<p>我们将先着眼于一些简单的格式工具. 他们都是功能单一的程序, 并且做法有一点单纯,
但是他们能被用于小任务并且作为脚本和管道的一部分 .</p>
<h3 id="nl---添加行号"><a class="header" href="#nl---添加行号">nl - 添加行号</a></h3>
<p>nl 程序是一个相当神秘的工具, 用作一个简单的任务. 它添加文件的行数.
在它最简单的用途中, 它相当于 <code>cat -n</code>:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ nl distros.txt | head
</code></pre>
<p>像 cat, nl 既能接受多个文件作为命令行参数, 也能标准输出.
然而, nl 有一个相当数量的选项并支持一个简单的标记方式去允许更多复杂的方式的计算.</p>
<p>nl 在计算文件行数的时候支持一个叫&quot;逻辑页面&quot;的概念 . 这允许nl在计算的时候去重设(再一次开始)可数的序列.
用到那些选项 的时候, 可以设置一个特殊的开始值, 并且在某个可限定的程度上还能设置它的格式.
一个逻辑页面被进一步分为 header,body 和 footer 这样的元素. 在每一个部分中, 数行数可以被重设,
并且/或被设置成另外一个格式.
如果nl同时处理多个文件, 它会把他们当成一个单一的 文本流. 文本流中的部分被一些相当古怪的标记的存在加进了文本:
每一个上述的标记元素肯定在自己的行中独自出现. 在处理完一个标记元素之后, nl 把它从文本流中删除.</p>
<p>这里有一些常用的 nl 选项:</p>
<p>表格 22-2: 常用 nl 选项
选项 含义</p>
<p>把 body 按被要求方式数行, 可以是以下方式: a = 数所有行 t = 数非空行.这是默认设置. n = 无 pregexp = 只数那些匹配了正则表达式的行</p>
<p>-f style 将 footer 按被要求设置数. 默认是无
-h style 将 header 按被要求设置数. 默认是
-i number 将页面增加量设置为数字. 默认是一.
-n format 设置数数的格式, 格式可以是: ln = 左偏, 没有前导零. rn = 右偏, 没有前导零. rz = 右偏, 有前导零.</p>
<p>-p 不要在没一个逻辑页面的开始重设页面数.
-s string 在没一个行的末尾加字符作分割符号.默认是单个的 tab.
-v number 将每一个逻辑页面的第一行设置成数字. 默认是一.
-w width 将行数的宽度设置, 默认是六.</p>
<p>坦诚的说, 我们大概不会那么频繁地去数行数, 但是我们能用 nl 去查看我们怎么将多个工具结合在一个去完成更复杂的任务.
我们将在之前章节的基础上做一个 Linux 发行版的报告. 因为我们将使用 nl, 包含它的header/body/footer 标记将会十分有用.
我们将把它加到上一章的 sed 脚本来做这个. 使用我们的文本编辑器, 我们将脚本改成一下并且把它保存成 distros-nl.sed:</p>
<pre><code class="language-bash"># sed script to produce Linux distributions report
1 i\
\\:\\:\\:\
\
Linux Distributions Report\
\
Name
Ver. Released\
----
---- --------\
\\:\\:
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
$ i\
\\:\
\
End Of Report
</code></pre>
<p>这个脚本现在加入了 nl 的逻辑页面标记并且在报告的最后加了一个 footer.
记得我们在我们的标记中必须两次使用反斜杠,  因为他们通常被 sed 解释成一个转义字符.
下一步, 我们将结合 sort, sed, nl 来生成我们改进的报告:</p>
<pre><code class="language-bash">$ sort -k 1,1 -k 2n distros.txt | sed -f distros-nl.sed | nl

Linux Distributions Report
Name    Ver.    Released
----        ----         --------
1       Fedora      5       2006-03-20
2       Fedora      6       2006-10-24
...
</code></pre>
<p>我们的报告是一串命令的结果, 首先, 我们给名单按发行版本和版本号(表格1和2处)进行排序,
然后我们用sed 生产结果,  增加了 header(包括了为 nl 增加的逻辑页面标记)和 footer.
最后, 我们按默认用 nl 生成了结果, 只数了属于逻辑页面的 body 部分的 文本流的行数.
我们能够重复命令并且实验不同的 nl 选项. 一些有趣的方式:</p>
<pre><code class="language-bash">nl -n rz
# 和
nl -w 3 -s ' '
</code></pre>
<h3 id="fold---限制文件行宽"><a class="header" href="#fold---限制文件行宽">fold - 限制文件行宽</a></h3>
<p>折叠是将文本的行限制到特定的宽的过程. 像我们的其他命令, fold 接受一个或多个文件及标准输入.
如果我们将一个简单的文本流 fold, 我们可以看到它工具的方式:</p>
<pre><code class="language-bash">$ echo &quot;The quick brown fox jumped over the lazy dog.&quot; | fold -w 12
</code></pre>
<p>这里我们看到了 fold 的行为. 这个用 echo 命令发送的文本用 -w 选项分解成块.
在这个例子中, 我们设定了行宽为12个字符.  如果没有字符设置, 默认是80.
注意到文本行不会因为单词边界而不会被分解. 增加的 -s 选项将让 fold 分解到最后可用的空白 字符, 即会考虑单词边界.</p>
<pre><code class="language-bash">$ echo &quot;The quick brown fox jumped over the lazy dog.&quot; | fold -w 12 -s
</code></pre>
<h3 id="fmt---一个简单的文本格式器"><a class="header" href="#fmt---一个简单的文本格式器">fmt - 一个简单的文本格式器</a></h3>
<p><code>fmt</code> 程序同样折叠文本, 外加很多功能.
它接受文本或标准输入并且在文本流上呈现照片转换. 基础来说, 他填补并且将文本粘帖在 一起并且保留了空白符和缩进.
为了解释, 我们将需要一些文本. 让我们抄一些 fmt 主页上的东西吧:
我们将把这段文本复制进我们的文本编辑器并且保存文件名为 fmt-info.txt.
现在, 让我们重新格式这个文本并且让它成为一个50 个字符宽的项目.
我们能用 -w 选项对文件进行处理:</p>
<pre><code class="language-bash">$ fmt -w 50 fmt-info.txt | head
</code></pre>
<p>好, 这真是一个奇怪的结果. 大概我们应该认真的阅读这段文本, 因为它恰好解释了发生了什么:
默认来说, 空白行, 单词间距, 还有缩进都会在输出中保留;
持续输入不同的缩进的流不会被结合; tabs被用来扩展 输入并且引入输出.
所以, fmt 保留了第一行的缩进. 幸运的是, fmt 提供一个修正这个的选项:
好多了. 通过加了 -c 选项, 我们现在有了我们想要的结果.</p>
<p>fmt 有一些有趣的选项:
-p 选项特别有趣. 通过它, 我们可以格式文件选中的部分, 通过在开头使用一样的符号.
很多编程语言使用锚标记(#)去提醒注释的开始, 而且它可以通过这个选项来被格式.
让我们创建一个有用到注释的程序.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ cat &gt; fmt-code.txt
# This file contains code with comments.
# This line is a comment.
# Followed by another comment line.
# And another.
This, on the other hand, is a line of code.
And another line of code.
And another.
</code></pre>
<p>我们的示例文件包含了用 &quot;#&quot; 开始的注释(一个 # 后跟着一个空白符)和代码. 现在, 使用 fmt, 我们能格式注释, 并且不让代码被触及.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-8"><a class="header" href="#linux-8">linux-8</a></h1>
<h2 id="第二十三章-打印"><a class="header" href="#第二十三章-打印">第二十三章: 打印</a></h2>
<ul>
<li><code>pr</code>: 转换需要打印的文本文件</li>
<li><code>lpr</code>: 打印文件</li>
<li><code>lp</code>: 打印文件(<code>System V</code>)</li>
<li><code>a2ps</code>: 为 <code>PostScript</code> 打印机格式化文件</li>
<li><code>lpstat</code>: 显示打印机状态信息</li>
<li><code>lpq</code>: 显示打印机队列状态</li>
<li><code>lprm</code>: 取消打印任务</li>
<li><code>cancel</code>: 取消打印任务(<code>System V</code>)</li>
</ul>
<h3 id="基于字符的打印机"><a class="header" href="#基于字符的打印机">基于字符的打印机</a></h3>
<p>80年代的打印机技术有两方面的不同.首先,那时的打印机基本上都是打击式打印机.打击式打印机使用撞针打击色带的机械结构在纸上形成字符.这种流行的技术造就了当时的菊轮式打印和点阵式打印.
其次,更重要的是,早期打印机的特点是它使用设备内部固定的一组字符集.比如,一台菊轮式打印机只能打印固定在其菊花轮花瓣上的字符,就这点而言打印机更像是高速打字机.
大部分打字机都使用等宽字体,意思是说每个字符的宽度相等,页面上只有固定的区域可供打印,而这些区域只能容纳固定的字符数.
大部分打印机采用横向<code>10</code>字符每英寸(CPI)和纵向<code>6</code>行每英寸(LPI)的规格打印,这样一张美式信片纸就有横向85字符宽纵向<code>66</code>行高,加上两侧的页边距,一行的最大宽度可达<code>80</code>字符.
据此,使用等宽字体就能提供所见即所得(WYSIWYG,What You See Is What You Get)的打印预览.</p>
<p>接着,一台类打字机的打印机会收到以简单字节流的形式传送来的数据,其中就包含要打印的字符.
例如要打印一个字母<code>a</code>,计算机就会发送 <code>ASCII</code> 码<code>97</code>,如果要移动打印机的滑动架和纸张,就需要使用回车, 换行, 换页等的小编号 <code>ASCII</code> 控制码.
使用控制码,还能实现一些之前受限制的字体效果,比如粗体,就是让打印机先打印一个字符,然后退格再打印一遍来得到颜色较深的效果的.
用 <code>nroff</code> 来产生一个手册页然后用 <code>cat -A</code> 检查输出,我们就能亲眼看看这种效果了:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | nroff -man | cat -A | head
LS(1) User Commands LS(1)
$
...
l^Hls^Hs [_^HO_^HP_^HT_^HI_^HO_^HN]... [_^HF_^HI_^HL_^HE]...$
</code></pre>
<p><code>^H</code>(<code>ctrl-H</code>)字符是用于打印粗体效果的退格符.同样,我们还可以看到用于打印下划线效果的<code>[退格/下划线]</code>序列.
<code>groff</code>是一种文本格式化系统,类似轻量版的<code>LaTeX</code>. 参考<a href="https://linux.cn/article-9122-1.html">使用 groff 编写 man 手册页 </a></p>
<h3 id="图形化打印机"><a class="header" href="#图形化打印机">图形化打印机</a></h3>
<p>一台 <code>PostScript</code> 打印机接受 <code>PostScript</code> 程序作为输入.打印机有自己的处理器和内存(通常这让打印机比连接它的计算机更为强大),
能执行一种叫做 <code>PostScript</code> 解析器的特殊程序, 用于读取输入的 <code>PostScript</code> 程序并生成结果导入打印机的内存, 这样就形成了要转移到纸上的位(点)图.
这种将页面渲染成大型位图(<code>bitmap</code>)的过程有个通用名称作光栅图像处理器(<code>raster image processor</code>),又叫 <code>RIP</code>.
多年之后,电脑和网络都变得更快了.这使得 <code>RIP</code> 技术从打印机转移到了主机上,还让高品质打印机变得更便宜了.</p>
<p>现在的许多打印机仍能接受基于字符的字节流,但很多廉价的打印机却不支持,因为它们依赖于主机的 <code>RIP</code> 提供的比特流来作为点阵打印.当然也有不少仍旧是 <code>PostScript</code> 打印机.</p>
<h3 id="在-linux-下打印"><a class="header" href="#在-linux-下打印">在 Linux 下打印</a></h3>
<p>当前 <code>Linux</code> 系统采用两套软件配合显示和管理打印.
第一,<code>CUPS</code>(<code>Common Unix Printing System</code>,一般<code>Unix</code> 打印系统),用于提供打印驱动和打印任务管理;
第二,<code>Ghostscript</code>,一种 <code>PostScript</code> 解析器,作为 <code>RIP</code>使用.</p>
<p><code>CUPS</code> 通过创建并维护打印队列来管理打印机.如前所述,<code>Unix</code> 下的打印原本是设计成多用户共享中央打印机的管理模式的.
由于打印机本身比连接到它的电脑要慢,打印系统就需要对打印任务进行调度使其保持顺序.</p>
<p><code>CUPS</code> 还能识别出不同类型的数据(在合理范围内)并转换文件为可打印的格式.</p>
<h3 id="为打印准备文件"><a class="header" href="#为打印准备文件">为打印准备文件</a></h3>
<p>作为命令行用户,尽管打印各种格式的文本都能实现,不过打印最多的,还是文本.</p>
<h4 id="pr---转换需要打印的文本文件"><a class="header" href="#pr---转换需要打印的文本文件">pr - 转换需要打印的文本文件</a></h4>
<p>前面的章节我们也有提到过 <code>pr</code> 命令,现在我们来探讨一下这条命令结合打印使用的一些选项.
我们知道,在打印的历史上,基于字符的打印机曾经用过等宽字体,致使每页只能打印固定的行数和字符数,而 pr 命令则能够根据不同的页眉和页边距排列文本使其适应指定的纸张.
表<code>23-1</code>总结了最常用的选项.
选项 描述</p>
<ul>
<li><code>+first[:last]</code>:  输出从 <code>first</code> 到 <code>last</code>(默认为最后)范围内的页面.</li>
<li><code>-columns</code>:  根据 <code>columns</code> 指定的列数排版页面内容.</li>
<li><code>-a</code> 默认多列输出为垂直,用 <code>-a</code> (<code>across</code>)可使其水平输出.</li>
<li><code>-d</code> 双空格输出.</li>
<li><code>-D</code> <code>format</code> 用 <code>format</code> 指定的格式修改页眉中显示的日期,日期命令中 <code>format</code> 字符串的描述详见参考手册.</li>
<li><code>-f</code> 改用换页替换默认的回车来分割页面.</li>
<li><code>-h header</code> 在页眉中部用 <code>header</code> 参数替换打印文件的名字.</li>
<li><code>-l length</code> 设置页长为 <code>length</code>,默认为<code>66</code>行(每英寸<code>6</code>行的美国信纸).</li>
<li><code>-n</code> 输出行号.</li>
<li><code>-o offset</code> 创建一个宽 <code>offset</code> 字符的左页边.</li>
<li><code>-w width</code> 设置页宽为 <code>width</code>,默认为<code>72</code>字符.</li>
</ul>
<p>我们通常用管道配合 <code>pr</code> 命令来做筛选.下面的例子中我们会列出目录 <code>/usr/bin</code> 并用 <code>pr</code> 将其格式化为<code>3</code>列输出的标题页:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | pr -3 -w 65 | head
2012-02-18 14:00
...
</code></pre>
<h3 id="将打印任务送至打印机"><a class="header" href="#将打印任务送至打印机">将打印任务送至打印机</a></h3>
<p><code>CUPS</code> 打印体系支持两种曾用于类 <code>Unix</code> 系统的打印方式.一种,叫 <code>Berkeley</code> 或 <code>LPD</code>(用于 <code>Unix</code> 的 <code>Berkeley</code>软件发行版),使用 <code>lpr</code> 程序;
另一种,叫 <code>SysV</code>(源自 <code>System V</code> 版本的 <code>Unix</code>),使用 <code>lp</code> 程序.</p>
<p>这两个程序的功能大致相同.具体使用哪个完全根据个人喜好.</p>
<h4 id="lpr---打印文件berkeley-风格"><a class="header" href="#lpr---打印文件berkeley-风格">lpr - 打印文件(Berkeley 风格)</a></h4>
<p><code>lpr</code> 程序可以用来把文件传送给打印机.由于它能接收标准输入,所以能用管道来协同工作.例如,要打印刚才多列目录列表的结果,我们只需这样:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | pr -3 | lpr
</code></pre>
<p>报告会送到系统默认的打印机,如果要送到别的打印机,可以使用 <code>-P</code> 参数: <code>lpr -P printer_name</code></p>
<p><code>printer_name</code> 表示这台打印机的名称.若要查看系统已知的打印机列表:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ lpstat -a
</code></pre>
<p>注意: 许多 <code>Linux</code> 发行版允许你定义一个输出 <code>PDF</code> 文件但不执行实体打印的<code>打印机</code>,这可以用来很方便的检验你的打印命令.
在某些发行版中,你可能要自己安装额外的软件包(如<code> cups-pdf</code>)来使用这项功能. <code>Ubuntu</code> 中需要安装<code>printer-driver-cups-pdf</code></p>
<p>表23-2: 常用 <code>lpr</code> 选项
选项 描述</p>
<ul>
<li><code>-# number</code>:  设定打印份数为 <code>number</code>.</li>
<li><code>-p</code>: 使每页页眉标题中带有日期, 时间, 工作名称和页码.这种所谓的<code>美化打印</code>选项可用于打印文本文件.</li>
<li><code>-P printer</code>: 指定输出打印机的名称.未指定则使用系统默认打印机.</li>
<li><code>-r</code>: 打印后删除文件.对程序产生的临时打印文件较为有用.</li>
<li><code>lp</code>: 打印文件(<code>System V</code> 风格)</li>
</ul>
<p>和 <code>lpr</code> 一样,<code>lp</code> 可以接收文件或标准输入为打印内容.与 <code>lpr</code> 不同的是 <code>lp</code> 支持不同的选项(略为复杂)</p>
<p>表23-3: 常用 lp 选项
选项 描述</p>
<ul>
<li><code>-d printer</code> 设定目标(打印机)为 <code>printer</code>.若<code>d</code>选项未指定,则使用系统默认打印机.</li>
<li><code>-n number</code> 设定的打印份数为 <code>number</code>.</li>
<li><code>-o landscape</code> 设置输出为横向.</li>
<li><code>-o fitplot</code> 缩放文件以适应页面.打印图像时较为有用,如 <code>JPEG</code> 文件.</li>
<li><code>-o scaling=number</code>: 缩放文件至 <code>number</code>.<code>100</code>表示填满页面,小于<code>100</code>表示缩小,大于<code>100</code>则会打印在多页上.</li>
<li><code>-o cpi=number</code>: 设定输出为 <code>number</code> 字符每英寸.默认为<code>10</code>.</li>
<li><code>-o lpi=number</code>: 设定输出为 <code>number</code> 行每英寸,默认为<code>6</code>.</li>
<li><code>-o page-bottom=points</code>:</li>
<li><code>-o page-left=points</code>:</li>
<li><code>-o page-right=points</code>:</li>
<li><code>-o page-top=points</code>: 这些选项用来设置页边距,单位为<code>点</code>,一种印刷上的单位.一英寸 <code>=72点</code>.</li>
<li><code>-P pages</code>: 指定打印的页面.<code>pages</code> 可以是逗号分隔的列表或范围--例如 <code>1,3,5,7-10</code>.</li>
</ul>
<p>再次打印我们的目录列表,这次我们设置<code>12 CPI</code>, <code>8 LPI</code> 和一个半英寸的左边距.注意这里我必须调整 <code>pr</code> 选项来适应新的页面大小:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | pr -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8
</code></pre>
<p>这条命令用小于默认的格式产生了一个四列的列表.增加 <code>CPI</code> 可以让我们在页面上打印更多列.</p>
<h4 id="另一种选择-a2ps"><a class="header" href="#另一种选择-a2ps">另一种选择: a2ps</a></h4>
<p><code>a2ps</code> 程序很有趣.单从名字上看,这是个格式转换程序,但它的功能不止于此.程序名字的本意为 <code>ASCII toPostScript</code>,它是用来为 <code>PostScript</code> 打印机准备要打印的文本文件的.
多年后,程序的功能得到了提升,名字的含义也变成了 <code>Anything to PostScript</code>.尽管名为格式转换程序,但它实际的功能却是打印.
它的默认输出不是标准输出,而是系统的默认打印机.程序的默认行为被称为<code>漂亮的打印机</code>,这意味着它可以改善输出的外观.
我们能用程序在桌面上创建一个 <code>PostScript</code> 文件:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | pr -3 -t | a2ps -o ~/Desktop/ls.ps -L 66
[stdin (plain): 11 pages on 6 sheets]
</code></pre>
<p>这里我们用带 <code>-t</code> 参数(忽略页眉和页脚)的 <code>pr</code> 命令过滤数据流,然后用 <code>a2ps</code> 指定一个输出文件(<code>-o</code> 参数),并设定每页<code>66</code>行(<code>-L</code> 参数)来匹配 <code>pr</code> 的输出分页.
用合适的文件查看器查看我们的输出文件, 可以看到,默认的输出布局是一面两页的,这将导致两页的内容被打印到一张纸上.<code>a2ps</code> 还能利用页眉和页脚.</p>
<p><code>a2ps</code> 有很多选项,总结在表23-4中.
选项 描述</p>
<ul>
<li><code>--center-title text </code>:设置中心页标题为 <code>text</code>.</li>
<li><code>--columns number</code>: 将所有页面排列成 <code>number</code> 列.默认为<code>2</code>.</li>
<li><code>--footer text</code>: 设置页脚为 <code>text</code>.</li>
<li><code>--guess</code>: 报告参数中文件的类型.由于 <code>a2ps</code> 会转换并格式化所有类型的数据,所以当给定文件类型后,这个选项可以很好的用来判断 <code>a2ps</code> 应该做什么.</li>
<li><code>--left-footer text</code>: 设置左页脚为 <code>text</code>.</li>
<li><code>--left-title text</code>: 设置页面左标题为 <code>text</code>.</li>
<li><code>--line-numbers=interval</code>: 每隔 <code>interval</code> 行输出行号.</li>
<li><code>--list=defauls</code>: 显示默认设置.</li>
<li><code>--list=topic</code>:  显示 <code>topic</code> 设置,<code>topic</code> 表示下列之一:
代理程序(用来转换数据的外部程序),编码,特征,变量,媒介(页面大小等),<code>ppd</code>(<code>PostScript</code> 打印机描述信息),打印机,起始程序(为常规输出添加前缀的代码部分),样式表,或用户选项.</li>
<li><code>--pages range</code>: 打印 <code>range</code> 范围内的页面.</li>
<li><code>--right-footer text</code>: 设置右页脚为 <code>text</code>.</li>
<li><code>--right-title text</code>: 设置页面右标题为 <code>text</code>.</li>
<li><code>--rows number</code>: 将所有页面排列成 <code>number</code> 排.默认为<code>1</code>.</li>
<li><code>-B</code>: 没有页眉.</li>
<li><code>-b text</code>: 设置页眉为 <code>text</code>.</li>
<li><code>-f size</code>: 使用字体大小为 <code>size</code> 号.</li>
<li><code>-l number</code>: 设置每行字符数为 <code>number</code>.此项和 <code>-L</code>选项(见下方)可以给文件用其他程序来更准确的分页,如 <code>pr</code>.</li>
<li><code>-L number</code>: 设置每页行数为 <code>number</code>.</li>
<li><code>-M name</code>: 使用打印媒介的名称 -- 例如,<code>A4</code>.</li>
<li><code>-n number</code>: 每页输出 <code>number</code> 份.</li>
<li><code>-o file</code>: 输出到文件 <code>file</code>.如果指定为 <code>-</code> ,则输出到标准输出.</li>
<li><code>-P printer</code>: 使用打印机 <code>printer</code>.如果未指定,则使用系统默认打印机.</li>
<li><code>-R</code>: 纵向打印.</li>
<li><code>-r</code>: 横向打印.</li>
<li><code>-T number</code>: 设置制表位为每 <code>number</code> 字符.</li>
<li>``:-u text<code>: 用 </code>text` 作为页面底图(水印).</li>
</ul>
<p>以上只是对 <code>a2ps</code> 的总结,更多的选项尚未列出.
注意: <code>a2ps</code> 目前仍在不断的开发中.就我的测试而言,不同版本之间都多少有所变化.
另外,我们也要注意到另一个转换文本为 <code>PostScript</code> 的输出格式化工具,名叫 <code>enscript</code>.它具有许多相同的格式化和打印功能,但和 <code>a2ps</code> 唯一的不同在于,它只能处理纯文本的输入.</p>
<h3 id="监视和控制打印任务"><a class="header" href="#监视和控制打印任务">监视和控制打印任务</a></h3>
<p>由于 <code>Unix</code> 打印系统的设计是能够处理多用户的多重打印任务,<code>CUPS</code> 也是如此设计的.每台打印机都有一个打印队列,其中的任务直到传送到打印机才停下并进行打印.
<code>CUPS</code> 支持一些命令行程序来管理打印机状态和打印队列. 像<code>lpr</code> 和 <code>lp</code> 这样的管理程序都是以 <code>Berkeley</code> 和 <code>System V</code> 打印系统的相应程序为依据进行排列的.</p>
<h4 id="lpstat---显示打印系统状态"><a class="header" href="#lpstat---显示打印系统状态">lpstat - 显示打印系统状态</a></h4>
<p><code>lpstat</code> 程序可用于确定系统中打印机的名字和有效性.例如,我们系统中有一台实体打印机(名叫 <code>printer</code>)和一台 <code>PDF</code> 虚拟打印机(名叫 <code>PDF</code>),我们可以像这样查看打印机状态:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ lpstat -a
PDF accepting requests since Mon 05 Dec 2011 03:05:59 PM EST
printer accepting requests since Tue 21 Feb 2012 08:43:22 AM EST
</code></pre>
<p>接着,我们可以查看打印系统更具体的配置信息:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ lpstat -s
system default destination: printer
device for PDF: cups-pdf:/
device for printer: ipp://print-server:631/printers/printer
</code></pre>
<p>上例中,我们看到 <code>printer</code> 是系统默认的打印机,其本身是一台网络打印机,使用网络打印协议(<code>ipp://</code>)通过网络连接到名为 <code>print-server</code> 的系统.</p>
<p>lpstat 的常用选项列于表23-5.
选项 描述</p>
<ul>
<li><code>-a [printer...] </code>: 显示 <code>printer</code> 打印机的队列.这里显示的状态是打印机队列承受任务的能力,而不是实体打印机的状态.若未指定打印机,则显示所有打印队列.</li>
<li><code>-d</code>: 显示系统默认打印机的名称.</li>
<li><code>-p [printer...] </code>: 显示 <code>printer</code> 指定的打印机的状态.若未指定打印机,则显示所有打印机状态.</li>
<li><code>-r</code>: 显示打印系统的状态.</li>
<li><code>-s</code>: 显示汇总状态.</li>
<li><code>-t</code>: 显示完整状态报告.</li>
</ul>
<h4 id="lpq---显示打印机队列状态"><a class="header" href="#lpq---显示打印机队列状态">lpq - 显示打印机队列状态</a></h4>
<p>使用 <code>lpq</code> 程序可以查看打印机队列的状态,从中我们可以看到队列的状态和所包含的打印任务.下面的例子显示了一台名叫 <code>printer</code> 的系统默认打印机包含一个空队列的情况:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ lpq
printer is ready
no entries
</code></pre>
<p>如果我们不指定打印机(用 <code>-P</code> 参数),就会显示系统默认打印机.如果给打印机添加一项任务再查看队列,我们就会看到下列结果:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ ls *.txt | pr -3 | lp
request id is printer-603 (1 file(s))
[me@linuxbox ~]$ lpq
printer is ready and printing
...
</code></pre>
<h3 id="lprm-和-cancel---取消打印任务"><a class="header" href="#lprm-和-cancel---取消打印任务">lprm 和 cancel - 取消打印任务</a></h3>
<p><code>CUPS</code> 提供两个程序来从打印队列中终止并移除打印任务.一个是 <code>Berkeley</code> 风格的(<code>lprm</code>),另一个是 <code>SystemV</code> 的(<code>cancel</code>).
在支持的选项上两者有较小的区别但是功能却几乎相同.以上面的打印任务为例,我们可以像这样终止并移除任务:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ cancel 603
[me@linuxbox ~]$ lpq
printer is ready
no entries
</code></pre>
<p>每个命令都有选项可用于移除某用户,某打印机或多个任务号的所有任务,相应的参考手册中都有详细的介绍.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manjaro"><a class="header" href="#manjaro">manjaro</a></h1>
<p><a href="https://zhuanlan.zhihu.com/p/114296129">Manjaro-KDE安装配置全攻略</a></p>
<h2 id="系统安装"><a class="header" href="#系统安装">系统安装</a></h2>
<p>这里我假设你的电脑引导方式是 <code>UEFI</code>, 如果你的<code>ssd</code>是<code>NVMe</code>协议<code>M.2</code>的,
需要在进入安装界面之前先进去<code>BIOS</code>里面修改从硬盘的启动形式, 把<code>RAID</code>改成<code>AHCI</code>, 保存退出, 否则进入安装界面你不会看到你的<code>NVMe</code>硬盘, 做好这件事其他就都和普通ssd一样了.
还需要注意的一点是, 修改成<code>AHCI</code>模式之后, 重新进入<code>Windows</code>时会有问题, 这个时候不要慌, 等电脑自动重启第三次的时候, 进入安全模式启动<code>Windows</code>,
进去之后重启系统, 再次进入<code>Windows</code>就不需要安全模式了</p>
<p>插上U盘, 在电脑<code>logo</code>出现之前狂按<code>F12</code>手动选择从<code>U</code>盘启动
如果你的电脑有<code>NVIDIA</code>和Intel双显卡的话, 开机界面将<code>drive</code>改成<code>nonfree</code>, 这样系统会自动帮你安装适配的<code>NVIDIA</code>驱动(简直太方便了)
如果这一步你没有改, 进去之后手动安装<code>NVIDIA</code>驱动千万不要自己随便安装, 这样很可能会导致下次启动进入<code>X-Window</code>界面失败, 具体怎么安装可以参考<code>Manjaro WiKi</code>的解决方案</p>
<p>为保安装一步成功请在启动安装程序之前先联网,
一般来讲, 你只要在Windows下给Manjaro预留出磁盘空间, 如果你有多个硬盘记得在安装窗口的最上面选对硬盘,
安装时候的分区方案直接选择取代一个分区, 点击你之前分好的硬盘空间, 接着下一步即可</p>
<p>如果你需要手动分区:
如果你的硬盘是<code>ssd+hdd</code>, 并且打算把系统装在<code>hdd</code>下的话, 建议直接用<code>windows</code>的<code>efi</code>分区,
<code>hdd</code>中划分一个区出来挂载<code>/</code>区, 或者在<code>ssd</code>中分一个<code>150MB</code>(当然大点也行)的区出来挂载<code>/boot/efi</code>, 安装完毕重启即可.</p>
<h3 id="换源"><a class="header" href="#换源">换源</a></h3>
<p>启动<code>terminal</code>, 输入:</p>
<pre><code class="language-bash">sudo pacman-mirrors -i -c China -m rank
</code></pre>
<p>在弹出的框中选一个最快的源, 一个就好, 选多了会降低速度.
若要安装<code>archlinuxcn</code>的源,参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/archlinuxcn/">ArchlinuxCN 镜像使用帮助</a></p>
<p>打开配置文件: <code>sudo vim /etc/pacman.conf</code>, 在末尾输入:</p>
<pre><code class="language-bash">[archlinuxcn]
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch
</code></pre>
<p>保存退出, 接着更新缓存, 导入 <code>PGP</code>Keys:</p>
<pre><code class="language-bash">sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring
</code></pre>
<h3 id="安装软件"><a class="header" href="#安装软件">安装软件</a></h3>
<p><code>Manjaro</code> 背靠<code>Arch</code>软件仓库,</p>
<pre><code class="language-bash">sudo pacman -S yay
</code></pre>
<p><code>yay</code>是一个用<code>Go</code>语言写的一个<code>AUR</code>助手, 有些时候官方仓库没有你想要的软件, 就需要通过<code>yay</code>来安装,有了<code>yay</code>, 以后就不用<code>sudo pacman</code>了</p>
<hr />
<p>安装拼音输入法, 安装<code>fcitx5</code>(输入法框架)</p>
<pre><code class="language-bash">yay -S fcitx5-im
</code></pre>
<p>配置<code>fcitx5</code>的环境变量:</p>
<pre><code class="language-bash">nano ~/.pam_environment
</code></pre>
<p>内容为:</p>
<pre><code class="language-pam">GTK_IM_MODULE DEFAULT=fcitx
QT_IM_MODULE  DEFAULT=fcitx
XMODIFIERS    DEFAULT=\@im=fcitx
SDL_IM_MODULE DEFAULT=fcitx
</code></pre>
<p>安装中文维基百科词库:</p>
<pre><code class="language-bash">yay -S fcitx5-pinyin-zhwiki
</code></pre>
<p>配置主题:</p>
<pre><code class="language-bash">yay -S fcitx5-material-color
</code></pre>
<p><a href="https://github.com/ayamir/fcitx5-nord">大佬制作的fcitx5主题</a></p>
<p>安装</p>
<pre><code class="language-bash">git clone https://github.com/tonyfettes/fcitx5-nord.git
mkdir -p ~/.local/share/fcitx5/themes/
cd fcitx5-nord
cp -r nord-Dark/ nord-Light/ ~/.local/share/fcitx5/themes/
</code></pre>
<p>然后编辑<code>~/.config/fcitx5/conf/classicui.conf</code>, 更改主题指定的行,</p>
<pre><code class="language-bash">Theme=Nord-Dark
# or
Theme=Nord-Light
</code></pre>
<p>然后重启<code>fcitx5</code>, <code>fcitx5 -r</code></p>
<p>完成之后就可以注销, 重新登录之后打开<code>fcitx5-configtool</code>编辑一下相应配置:</p>
<h3 id="配置ohmyzsh"><a class="header" href="#配置ohmyzsh">配置ohmyzsh</a></h3>
<p>首先说一下这个过程不需要使用<code>pacman/yay</code>安装软件, 首先修改默认<code>shell</code>为<code>zsh</code></p>
<pre><code class="language-bash">chsh -s /usr/bin/zsh
#安装ohmyzsh
wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre>
<p>安装<code>zsh-syntax-highlighting</code>: <a href="https://github.com/zsh-users/zsh-syntax-highlighting">提供命令高亮</a>
作者建议把这个插件放在插件列表的最后</p>
<pre><code class="language-bash">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
</code></pre>
<p>安装<a href="https://github.com/zsh-users/zsh-autosuggestions"><code>autosuggestions</code></a>: 记住你之前使用过的命令</p>
<pre><code class="language-bash">git clone git://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions
</code></pre>
<p>安装incr: (需要注意的是这个插件会拖慢<code>zsh</code>的速度, 新手入门可以试试)</p>
<pre><code class="language-bash">git clone git://github.com/makeitjoe/incr.zsh $ZSH_CUSTOM/plugins/incr
</code></pre>
<p>启用所有插件</p>
<pre><code class="language-bash">nano ~/.zshrc
# 将 plugins=(git) 改为:
plugins=(git tmux  sudo extract  zsh-autosuggestions zsh-syntax-highlighting)
</code></pre>
<p>这个<code>sudo</code>是<code>ohmyzsh</code>自带的插件, 功能是在你输入的命令的开头添加<code>sudo </code>, 方法是<code>双击Esc</code>
<code>extract</code>也是自带插件, 不用再去记不同文件的解压命令, 方法是<code>extract +你要解压的文件名</code>.
保存退出之后, 手动修改<code>konsole</code>的默认<code>bash</code>为<code>zsh</code>: (右键<code>Konsole - 编辑当前方案</code>),打开<code>konsole</code>执行<code>source ~/.zshrc</code>, 配置完毕.</p>
<h3 id="安装vimplus"><a class="header" href="#安装vimplus">安装Vimplus</a></h3>
<p>(现代化的vim插件管理工具, 开箱即用, 不使用vim的可以略过</p>
<pre><code class="language-bash">git clone https://github.com/chxuan/vimplus.git ~/.vimplus
cd ~/.vimplus
./install.sh
</code></pre>
<h3 id="安装腾讯系软件"><a class="header" href="#安装腾讯系软件">安装腾讯系软件</a></h3>
<p>安装Tim</p>
<pre><code class="language-bash">yay -S deepin-wine-tim
</code></pre>
<p>安装过程中出现选择输入<code>n</code>就好</p>
<p>切换<code>deepin-wine</code>环境</p>
<pre><code class="language-bash">sh /opt/deepinwine/apps/Deepin-Tim/run.sh -d
</code></pre>
<p>有问题直接去 <a href="https://github.com/countstarlight/deepin-wine-tim-arch/issues">countstarlight/deepin-wine-tim-arch </a> 开issue反馈就好了,
如果这个版本的卡或者有其他问题, 建议安装:</p>
<pre><code class="language-bash">yay -S deepin.com.qq.office
</code></pre>
<p>如果这个也没办法装, 则使用<code>linuxqq</code></p>
<pre><code class="language-bash">yay -S linuxqq
</code></pre>
<hr />
<p>安装微信</p>
<p><code>deepin-wine</code>版:</p>
<pre><code class="language-bash">yay -S deepin-wine-wechat
</code></pre>
<p>切换到<code>deepin-wine</code>环境:</p>
<pre><code class="language-bash">/opt/apps/com.qq.weixin.deepin/files/run.sh -d
</code></pre>
<p>关于字体发虚问题:</p>
<p>在切换到<code>deepin-wine</code>环境后, 在<code>terminal</code>输入下面的指令:</p>
<pre><code class="language-bash">env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; /usr/bin/deepin-wine winecfg
</code></pre>
<p>在弹出的窗口中选择<code>windows xp</code>, 将<code>DPI</code>调大(默认是<code>96</code>), 我调成了<code>120</code></p>
<p>微信的同样, 只需要将命令改为:</p>
<pre><code class="language-bash">env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-WeChat&quot; /usr/bin/deepin-wine winecfg
</code></pre>
<p><code>electron</code>版:</p>
<pre><code class="language-bash">yay -S electron-wechat
</code></pre>
<h3 id="安装其他软件"><a class="header" href="#安装其他软件">安装其他软件</a></h3>
<p><code>tldr</code>(Too Long; Don't Read): 帮你更加高效地学习<code>linux</code>命令</p>
<pre><code class="language-bash">pip install --user tldr
</code></pre>
<p>如果下载太慢:</p>
<pre><code class="language-bash">mkdir -p ~/.config/pip
nano ~/.config/pip/pip.conf
</code></pre>
<p>写入如下内容</p>
<pre><code class="language-bash">[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<p>这样就永久地修改了用户级别的<code>pip</code>下载源</p>
<p>如果安装失败则用:</p>
<pre><code class="language-bash">yay -S tldr
</code></pre>
<p><code>ranger</code>: 终端文件浏览器</p>
<pre><code class="language-bash">yay -S ranger
</code></pre>
<p><code>wps</code>:中文版, 想要英文版把后面那个包去掉</p>
<pre><code class="language-bash">yay -S wps-office wps-office-mui-zh-cn
</code></pre>
<p>如果你使用<code>fcitx5</code>的话, 还需要修改<code>/usr/bin/wps</code>和<code>/usr/bin/wpp</code>, 将下面这行代码加到文件开头:</p>
<pre><code class="language-bash">export QT_IM_MODULE=&quot;fcitx5&quot;
</code></pre>
<p>网易云音乐:</p>
<pre><code class="language-bash">yay -S netease-cloud-music
</code></pre>
<p>这样得到的版本不能在搜索框输入中文,</p>
<p>高颜值, 开发活跃的第三方客户端:</p>
<pre><code class="language-bash">yay -S yesplaymusic
</code></pre>
<p>qq音乐:</p>
<pre><code class="language-bash">yay -S qqmusic-bin
</code></pre>
<p>一个支持全平台听歌的软件: <code>FeelUown</code></p>
<pre><code class="language-bash">yay -S feeluown
</code></pre>
<p>根据装完之后的提示装对应平台的依赖</p>
<p>chrome</p>
<pre><code class="language-bash">yay -S google-chrome
</code></pre>
<p>百度网盘:</p>
<pre><code class="language-bash">yay -S baidunetdisk
</code></pre>
<p>或者命令行(CLI)的:</p>
<pre><code class="language-bash">yay -S baidupcs-go
</code></pre>
<p>坚果云:</p>
<pre><code class="language-bash">yay -S nutstore
</code></pre>
<p>为知笔记: 全平台通用, 有云端同步, 支持md的笔记</p>
<pre><code class="language-bash">yay -S wiznote
</code></pre>
<p>Typora: 我认为最舒适的md编辑器</p>
<pre><code class="language-bash">yay -S typora
</code></pre>
<hr />
<p><code>flameshot</code>: 强大的截图工具</p>
<pre><code class="language-bash">yay -S flameshot
</code></pre>
<p>设置快捷键启动的方式</p>
<p><code>设置-&gt;快捷键-&gt;自定义快捷键 -&gt; 编辑 -&gt; 新建 -&gt; 全局快捷键 -&gt; 命令/URL</code>, 转到<code>触发器</code>标签, 设置习惯的快捷键.
转到<code>动作</code>标签,在<code>命令/URL</code>中填上<code>/usr/bin/flameshot gui</code></p>
<hr />
<p><code>timeshift</code> : 强大好用的备份, 回滚系统工具</p>
<pre><code class="language-bash">yay -S timeshift
</code></pre>
<p>XDM: Linux下最快的下载神器</p>
<pre><code class="language-bash">yay -S xdman
</code></pre>
<p>建议直接去<a href="https://subhra74.github.io/xdm/">https://subhra74.github.io/xdm/</a>下载压缩包安装, 比命令行快很多</p>
<hr />
<p><code>calibre</code>: 电子书管理神器</p>
<pre><code class="language-bash">yay -S calibre
</code></pre>
<p>系统托盘那开启夜间颜色控制, 不需要安装redshift了</p>
<h3 id="字体"><a class="header" href="#字体">字体</a></h3>
<p>使用Windows/Mac OS字体:
<a href="https://wiki.archlinux.org/index.php/Fonts_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Microsoft_%E5%AD%97%E4%BD%93">Fonts (简体中文) - ArchWiki​</a></p>
<p>这里建议直接拷贝字体文件</p>
<p><a href="https://zhuanlan.zhihu.com/p/343934880">渲染效果优化</a></p>
<h3 id="美化-1"><a class="header" href="#美化-1">美化</a></h3>
<p>安装<code>latte-dock</code></p>
<pre><code class="language-bash">yay -S latte-dock
</code></pre>
<p>添加一个新空面板, 默认会出现在桌面上方, 可以删除下面自带的面板, 在新面板上添加必要的部件: 应用程序面板, 数字时钟, 托盘, 还可以加全局菜单, 显示面板等等</p>
<p>启动<code>latte-dock</code>, 下方就会出现一个dock栏, 具体配置看自己爱好.
除dock栏中时钟的方法: 右键<code>配置lattedock</code>,接着右键时钟,选择<code>移除</code>就好了</p>
<hr />
<p><code>设置-外观</code>中选择你喜欢的主题什么的安装并且应用即可
<code>设置-工作区行为-桌面特效</code> 中可以启用一些华丽的特效
<code>设置-开机和关机</code>中更改登录屏幕等效果
<code>设置-工作区行为-常规行为-点击行为</code>设置双击打开文件/文件夹的设置</p>
<hr />
<p>修改<code>/home/user</code>下的用户文件夹名称为英文:
先去手动修改文件夹名称, 然后在 <code>设置 -&gt; 应用程序 -&gt; 地点</code> 中修改</p>
<hr />
<p>双系统时间同步</p>
<p>按照<a href="https://wiki.archlinux.org/index.php/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)"> Arch WiKi </a>的建议, 这里修改<code>Windows</code>系统的注册表:
<code>win+X</code> 以管理员方式打开PowerShell, 输入</p>
<pre><code class="language-bash">reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f
</code></pre>
<p>如果你的<code>Windows</code>是<code>32</code>位的, 把上述代码中的<code>REG_QWORD</code>改成<code>REG_DWORD</code></p>
<p>同时禁用<code>Windows</code>的自动同步时间功能</p>
<hr />
<p>查看系统信息</p>
<pre><code class="language-bash">yay -S neofetch lolcat # lolcat 只是渐变色的工具
neofetch | lolcat
</code></pre>
<p>装好<code>Manjaro</code>必须要有的习惯:</p>
<ol>
<li>必须要做<code>timeshift</code>, 以防你哪天玩坏只能重装</li>
<li>每天要开机执行一遍<code>sudo pacman -Syyu</code></li>
</ol>
<p>虽说<code>Manjaro</code>相对<code>Arch</code>应该稳定一点, 但终究是滚动发行版, 还是有滚挂的风险, 防止滚挂的最好办法就是 及时滚 长时间不更新必挂.</p>
<h2 id="维护"><a class="header" href="#维护">维护</a></h2>
<h3 id="manjaro-开机红色提示"><a class="header" href="#manjaro-开机红色提示">manjaro 开机红色提示</a></h3>
<p><code>Failed to start Load/Save Screen Backlight Brightness of amdgpu_bl0</code></p>
<p><a href="https://www.linux.org/threads/failed-to-start-load-save-screen-backlight-brightness-of-amdgpu_bl1.31998/">Load/Save Screen Backlight Brightness</a></p>
<p>开关机的时候出现上面的错误提示, 查看运行状态</p>
<pre><code class="language-bash">sudo systemctl status systemd-backlight@backlight:amdgpu_bl0
</code></pre>
<p>手动启动</p>
<pre><code class="language-bash">sudo systemctl start systemd-backlight@backlight:amdgpu_bl0
</code></pre>
<p>关于 <code>systemd</code> 可以参考:
<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程: 命令篇</a>
<a href="https://wiki.archlinux.org/index.php/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">systemd</a>
<a href="https://wiki.archlinux.org/index.php/Kernel_parameters">Kernel parameters </a></p>
<p>添加<code>systemd</code>开机启动配置, <code>sudo vim /etc/systemd/system/startup-brightness.service</code></p>
<pre><code class="language-systemd">[Unit]
Description=Dummy service for attempting to start the problematic amdgpu_bl0 service

[Service]
Type=simple
ExecStart=systemctl start systemd-backlight@backlight:amdgpu_bl0

[Install]
WantedBy=multi-user.target
</code></pre>
<p>然后启用: <code>sudo systemctl enable startup-brightness.service</code>. 下次开机虽然还有提示, 但是<code>systemd-backlight@backlight:amdgpu_bl0</code>会自动运行.</p>
<hr />
<p>也可以手动调节亮度, <a href="https://zhuanlan.zhihu.com/p/138880080">manjaro 手动调节屏幕亮度</a></p>
<p>亮度由<code>ACPI</code>内核模块控制, 这个模块的接口在以下位置: <code>/sys/class/backlight</code>.
使用<code>root</code>用户进入这个文件夹, 其中<code>max_brightness</code>表示亮度的最大值, 笔者的设备显示为<code>255</code>, 想要修改亮度的话直接修改<code>brightness</code>即可: <code>echo 255 &gt; brightness</code></p>
<hr />
<p><a href="https://bbs.archlinux.org/viewtopic.php?id=254654">Failed to start Load/Save Screen Backlight Brightness of</a></p>
<p><code>ls /sys/class/backlight</code>可以查看<code>linux</code>背光子系统.
对于报错的另一个设备: <code>Failed to start Load/Save Screen Backlight Brightness of backlight:acpi_video1</code>, 提示设备不存在, 直接禁用这个服务:
<code>sudo systemctl mask systemd-backlight@backlight:acpi_video0.service</code></p>
<h3 id="manjaro-grub-内核参数"><a class="header" href="#manjaro-grub-内核参数">manjaro grub 内核参数</a></h3>
<hr />
<p><a href="https://wiki.archlinux.org/index.php/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">systemd</a></p>
<hr />
<p><code>apparmor=1 security=apparmor</code>
<a href="https://wiki.archlinux.org/index.php/AppArmor#Installation">AppArmor</a></p>
<p>AppArmor是基于Linux安全模块(Linux Security Modules, LSM)实施的强制性访问控制(Mandatory Access Control,MAC)系统.</p>
<hr />
<p><a href="https://wiki.archlinux.org/index.php/Udev_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">udev</a>
<code>udev</code> 是 <code>Linux</code> 内核的设备管理器. 总的来说, 它取代了 <code>devfs</code> 和 <code>hotplug</code>, 负责管理 <code>/dev</code> 中的设备节点.
同时, <code>udev</code> 也处理所有用户空间发生的硬件添加, 删除事件, 以及某些特定设备所需的固件加载.</p>
<p>与传统的顺序加载相比, <code>udev</code> 通过并行加载内核模块提供了潜在的性能优势.
异步加载模块的方式也有一个天生的缺点: 无法保证每次加载模块的顺序, 如果机器具有多个块设备, 那么它们的设备节点可能随机变化. 例如如果有两个硬盘, <code>/dev/sda</code> 可能会随机变成<code>/dev/sdb</code></p>
<p><code>Debug output</code></p>
<p>要获取硬件调试信息, 请使用内核参数<code>udev.log-priority=debug</code>.  或者, 您可以设置<code>/etc/udev/udev.conf</code></p>
<pre><code class="language-bash">udev_log=&quot;debug&quot;
</code></pre>
<hr />
<p><a href="https://wiki.archlinux.org/index.php/Kernel_parameters">Kernel parameters </a>
<a href="https://wiki.archlinux.org/index.php/Power_management/Suspend_and_hibernate#Hibernation">Power management/Suspend and hibernate</a>
<a href="https://wiki.archlinux.org/index.php/Kernel_module#Blacklisting">Blacklisting</a></p>
<p><code>resume=UUID=0f163abf-8e60-4626-a4de-54332c64db51</code>. <code>resume</code>指定从休眠状态唤醒时要使用的<code>swap</code>设备.</p>
<p>在升级到内核版本<code>4.15.3</code>后, 唤醒系统时可能会黑屏, 只在黑屏上留下一个静止不动的鼠标指针.  <code>Blacklisting</code> 这个模块 <code>nvidiafb</code> 可能会有帮助.</p>
<hr />
<p>方法1: 在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件, 使用 <code>blacklist</code> 关键字屏蔽不需要的模块, 例如如果不想装入 <code>pcspkr</code> 模块:</p>
<pre><code class="language-bash">vim /etc/modprobe.d/nobeep.conf
# Do not load the pcspkr module on boot
blacklist pcspkr
</code></pre>
<p>注意:  <code>blacklist</code> 命令将屏蔽一个模板, 所以不会自动装入, 但是如果其它非屏蔽模块需要这个模块, 系统依然会装入它. 要避免这个行为, 可以让 <code>modprobe</code> 使用自定义的 <code>install</code> 命令, 而不是像往常一样将模块插入内核, 因此您可以通过以下方式强制模块始终无法加载:</p>
<pre><code class="language-bash">/etc/modprobe.d/blacklist.conf
...
install MODULE /bin/true
...
</code></pre>
<hr />
<p>方法2: 从引导加载程序,例如<code>grub</code>, 将模块列入黑名单.
如<code>Kernel parameters</code>中所述, 只需将<code>module_blacklist=modname1,modname2,modname3</code> 添加到引导加载程序的内核行中即可.
注意:  将多个模块列入黑名单时, 请注意, 它们之间仅用逗号分隔.  空格或其他内容可能会破坏语法.</p>
<p><a href="https://wiki.archlinux.org/index.php/Kernel_parameters">Kernel parameters</a>
对于初学者, 建议编辑 <code>/etc/default/grub</code> 并将您的内核选项添加至 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 行:</p>
<pre><code class="language-bash">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;
GRUB_CMDLINE_LINUX_DEFAULT=&quot;module_blacklist=nvidiafb&quot;
</code></pre>
<p>然后重新生成 <code>grub.cfg</code> 文件:</p>
<pre><code class="language-bash">sudo grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>
<h3 id="vscode-登陆报错"><a class="header" href="#vscode-登陆报错">vscode 登陆报错</a></h3>
<p><a href="https://code.visualstudio.com/docs/editor/settings-sync#_troubleshooting-keychain-issues">Troubleshooting keychain issues</a>
<a href="https://github.com/microsoft/vscode/issues/92972">Sync requests to re-login every 2 minutes</a>
<a href="https://rtfm.co.ua/en/linux-the-nextcloud-client-qtkeychain-and-the-the-name-org-freedesktop-secrets-was-not-provided-by-any-service-files-error/">install gnome keyring and qtkeychain</a></p>
<p><code>KDE</code> 环境下, <code>vs-code</code>登陆账户无法保存, 下次启动仍然提示登陆. 问题出在<code>keychain</code>. 解决方法是安装 gnome keyring and qtkeychain</p>
<pre><code class="language-bash">yay -S qtkeychain gnome-keyring
# 验证现在存在
ls -l /usr/share/dbus-1/services/ | grep secret
cat /usr/share/dbus-1/services/org.freedesktop.secrets.service
</code></pre>
<h3 id="vscode-更新报错"><a class="header" href="#vscode-更新报错">vscode 更新报错</a></h3>
<p><a href="https://github.com/archlinuxcn/repo">Arch Linux Chinese Community Repository</a></p>
<p>vscode 的二进制包<code>visual-studio-code-bin</code>位于<code>archlinucn</code>仓库, 可能是由于 <code>PGP keys</code> 更新, 执行</p>
<pre><code class="language-bash">sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring
</code></pre>
<h3 id="lyx-打开文件窗口报错"><a class="header" href="#lyx-打开文件窗口报错">lyx 打开文件窗口报错</a></h3>
<p><a href="https://forum.manjaro.org/t/unable-to-create-io-slave-klauncher-said-error-loading-usr-lib-qt-plugins-kf5-kio-file-so/1217">/usr/lib/qt/plugins/kf5/kio/file.so</a></p>
<p>类似于</p>
<pre><code>Unable to create io-slave. klauncher said: Error loading  '/usr/lib/qt/plugins/kf5/kio/file.so'
</code></pre>
<ul>
<li>如果进行了系统更新, 应该尝试重新启动你的设备.</li>
<li>如果你确实更新了,请确保没有部分更新.</li>
</ul>
<pre><code class="language-bash">sudo pacman-mirrors -f &amp;&amp; sudo pacman -Syyu
</code></pre>
<p>甚至重新安装<code>kio</code>也会有帮助, 然后按照上面的建议重新启动.</p>
<h2 id="archwiki-帮助"><a class="header" href="#archwiki-帮助">archwiki 帮助</a></h2>
<p><a href="https://wiki.archlinux.org/index.php/Help:Reading_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Help:Reading</a></p>
<h3 id="安装软件包"><a class="header" href="#安装软件包">安装软件包</a></h3>
<p>绝大部分文章仅是给出软件包的名字, 不会列出详细的软件包安装命令.</p>
<hr />
<p>官方软件包:如果软件包位于 官方软件仓库, 安装指令是这样: <code>Install the foobar package</code>. 这意味着需要执行:</p>
<pre><code class="language-bash"># pacman -S foobar
</code></pre>
<hr />
<p>Arch 用户仓库(AUR): 如果软件包来自AUR, 你会看到:<code>Install the foobarAUR package.</code></p>
<p>这意味这您需要打开<code>foobarAUR</code>链接, 下载 <code>PKGBUILD</code>, 解压, 验证内容, 然后在文件目录执行:</p>
<pre><code class="language-bash">$ makepkg -sri
</code></pre>
<h3 id="控制-systemd-单元"><a class="header" href="#控制-systemd-单元">控制 systemd 单元</a></h3>
<p>绝大部分文章仅仅要求你<code>启动</code>(start),<code>启用</code>(enable),<code>停止</code>(stop),<code>重启</code>(restart)<code>systemd</code> 单元(例如: 服务), 不会列出详细的命令. 你会看见类似这样的说明:
<code>启动 example.service.</code></p>
<p>这意味着你需要执行</p>
<pre><code class="language-bash"># systemctl start example.service
</code></pre>
<p><code>systemd</code> 页面包含了管理 systemd 单元的详细介绍.  下面列出一些常用的命令:</p>
<p>立即激活单元: <code># systemctl start &lt;单元&gt;</code>
立即停止单元: <code># systemctl stop &lt;单元&gt;</code>
重启单元: <code># systemctl restart &lt;单元&gt;</code>
重新加载配置: <code># systemctl reload &lt;单元&gt;</code>
输出单元运行状态: <code>$ systemctl status &lt;单元&gt;</code>
检查单元是否配置为自动启动: <code>$ systemctl is-enabled &lt;单元&gt;</code>
开机自动激活单元: <code># systemctl enable &lt;单元&gt;</code>
设置单元为自动启动并立即启动这个单元:<code># systemctl enable --now unit</code>
取消开机自动激活单元: <code># systemctl disable &lt;单元&gt;</code>
禁用一个单元(禁用后, 间接启动也是不可能的): <code># systemctl mask &lt;单元&gt;</code>
取消禁用一个单元: <code># systemctl unmask &lt;单元&gt;</code></p>
<h2 id="pacman"><a class="header" href="#pacman">pacman</a></h2>
<p><a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">pacman</a>
<a href="https://man.archlinux.org/man/pacman.8">PACMAN(8)</a></p>
<p>使用过其它发行版的用户, 可以参考 Pacman Rosetta 中的对比.
<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Rosetta_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Pacman Rosetta</a></p>
<h3 id="pacman-mirrors"><a class="header" href="#pacman-mirrors">pacman-mirrors</a></h3>
<p>使用下面的命令选择较快的镜像.</p>
<pre><code class="language-bash">sudo pacman-mirrors -i -c China -m rank
</code></pre>
<hr />
<p><code>pacman-mirrors</code>:产生Manjaro Linux 的镜像列表</p>
<ul>
<li><code>-i,--interactive [-default]</code>: 互动模式. <code>-default</code>强迫载入默认的镜像文件, 忽略任何自定义pool.</li>
<li><code>-c</code>: 指定国家</li>
<li><code>-m,--method METHOD</code>: 默认的方法是<code>rank</code>, 但可以选择<code>random</code>. <code>rank</code>: 按访问延迟排列镜像. <code>random</code>:随机排列镜像.</li>
</ul>
<h3 id="安装指定的包"><a class="header" href="#安装指定的包">安装指定的包</a></h3>
<p>安装或者升级单个软件包, 或者一列软件包(包含依赖包), 使用如下命令:</p>
<pre><code class="language-bash"># pacman -S package_name1 package_name2 ...
</code></pre>
<p>用正则表达式安装多个软件包(参见 这个帖子):</p>
<pre><code class="language-bash"># pacman -S $(pacman -Ssq package_regex)
</code></pre>
<p>有时候在不同的软件仓库中, 一个软件包有多个版本(比如<code>[extra]</code>和<code>[testing]</code>). 可以选择一个来安装:</p>
<pre><code class="language-bash"># pacman -S extra/package_name
</code></pre>
<p>安装多个含有相似名称的软件包, 而并非整个包组或全部匹配的软件包;  例如, <code>plasma</code>:</p>
<pre><code class="language-bash"># pacman -S plasma-{desktop,mediacenter,nm}
</code></pre>
<p>当然, 可以多层扩展, 并不作限制:</p>
<pre><code class="language-bash"># pacman -S plasma-{workspace{,-wallpapers},pa}
</code></pre>
<h3 id="虚包"><a class="header" href="#虚包">虚包</a></h3>
<p>虚拟软件包是一个特殊的软件包, 它本身并不存在, 但由一或多个其它软件包提供.
虚拟软件包允许其它软件包不以某一个特定的包为依赖, 以应对有多个候选的情况. 虚包不能用它们的名称安装, 相反它们会在你安装提供虚包的软件包时被安装到你的系统中.</p>
<h3 id="安装包组"><a class="header" href="#安装包组">安装包组</a></h3>
<p>一些包属于一个可以同时安装的软件包组. 例如, 运行下面的命令</p>
<pre><code class="language-bash"># pacman -S gnome
</code></pre>
<p>会提醒用户选择 <code>gnome</code> 内需要安装的包.
有的包组包含大量的软件包, 有时用户只需其中几个. 除了逐一键入序号外, <code>pacman</code> 还支持选择或排除某个区间内的的软件包:</p>
<pre><code class="language-bash">Enter a selection (default=all): 1-10 15
</code></pre>
<p>这将选中序号 <code>1</code> 至 <code>10</code> 和 <code>15</code> 的软件包. 而</p>
<pre><code class="language-bash">Enter a selection (default=all): ^5-8 ^2
</code></pre>
<p>将会选中除了序号 <code>5</code> 至 <code>8</code> 和 <code>2</code> 之外的所有软件包.</p>
<p>想要查看哪些包属于 <code>gnome</code> 组, 运行:</p>
<pre><code class="language-bash"># pacman -Sg gnome
</code></pre>
<p>也可以访问<a href="https://archlinux.org/groups/">https://archlinux.org/groups/</a> 查看可用的包组.</p>
<p>注意:  如果列表中的包已经安装在系统中, 它会被重新安装, 即使它已经是最新的. 可以用 <code>--needed</code> 选项覆盖这种行为.</p>
<h3 id="删除软件包"><a class="header" href="#删除软件包">删除软件包</a></h3>
<p>删除单个软件包, 保留其全部已经安装的依赖关系</p>
<pre><code class="language-bash"># pacman -R package_name
</code></pre>
<p>删除指定软件包, 及其所有没有被其他已安装软件包使用的依赖关系:</p>
<pre><code class="language-bash"># pacman -Rs package_name
</code></pre>
<p>上面这条命令在移除包含其他所需包的组时有时候会拒绝运行. 这种情况下可以尝试</p>
<pre><code class="language-bash"># pacman -Rsu package_name
</code></pre>
<p>要删除软件包和所有依赖这个软件包的程序:
警告:  此操作是递归的, 请小心检查, 可能会一次删除大量的软件包.</p>
<pre><code class="language-bash"># pacman -Rsc package_name
</code></pre>
<p>要删除一个被其他软件包依赖的软件包, 但是不删除依赖这个软件包的其他软件包:
警告:  此操作有破坏系统的能力, 应该尽量避免使用. 详情请看<code>避免某些 Pacman 命令</code>.</p>
<pre><code class="language-bash"># pacman -Rdd package_name
</code></pre>
<p>pacman 删除某些程序时会备份重要配置文件, 在其后面加上*.pacsave扩展名. -n 选项可以避免备份这些文件:</p>
<pre><code class="language-bash">pacman -Rn package_name
</code></pre>
<p>注意:  pacman 不会删除软件自己创建的文件(例如主目录中的&quot;点文件&quot;不会被删除. )</p>
<h3 id="升级软件包"><a class="header" href="#升级软件包">升级软件包</a></h3>
<p>警告:</p>
<blockquote>
<p>建议用户遵守<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Rosetta_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">System maintenance (简体中文)#更新系统</a>的指导, 定期更新系统, 并不盲目地执行这些命令.
Arch 只支持系统完整升级, 详细参见System maintenance (简体中文)#不支持部分升级和安装软件包.</p>
</blockquote>
<p>一个 <code>pacman</code> 命令就可以升级整个系统. 花费的时间取决于系统有多老. 这个命令会同步非本地(local)软件仓库并升级系统的软件包:</p>
<pre><code class="language-bash"># pacman -Syu
</code></pre>
<h3 id="查询包数据库"><a class="header" href="#查询包数据库">查询包数据库</a></h3>
<p><code>pacman</code> 使用 <code>-Q</code> 参数查询本地软件包数据库,  <code>-S</code> 查询同步数据库, 以及 <code>-F</code> 查询文件数据库.
要了解每个参数的子选项, 分别参见 <code>Pacman -Q --help</code>, <code>Pacman -S --help</code>和<code>Pacman -F --help</code>.</p>
<p><code>pacman</code> 可以在包数据库中查询软件包, 查询位置包含了软件包的名字和描述:</p>
<pre><code class="language-bash">$ pacman -Ss string1 string2 ...
</code></pre>
<p>有时, <code>-s</code>的内置正则会匹配很多不需要的结果, 所以应当指定仅搜索包名, 而非描述或其他子段:</p>
<pre><code class="language-bash">$ pacman -Ss '^vim-'
</code></pre>
<p>要查询已安装的软件包:</p>
<pre><code class="language-bash">$ pacman -Qs string1 string2 ...
</code></pre>
<p>按文件名查找软件库:</p>
<pre><code class="language-bash">$ pacman -F string1 string2 ...
</code></pre>
<p>显示软件包的详尽的信息:</p>
<pre><code class="language-bash">$ pacman -Si package_name
</code></pre>
<p>查询本地安装包的详细信息:</p>
<pre><code class="language-bash">$ pacman -Qi package_name
</code></pre>
<p>使用两个 <code>-i</code> 将同时显示备份文件和修改状态:</p>
<pre><code class="language-bash">$ pacman -Qii package_name
</code></pre>
<p>要获取已安装软件包所包含文件的列表:</p>
<pre><code class="language-bash">$ pacman -Ql package_name
</code></pre>
<p>查询远程库中软件包包含的文件:</p>
<pre><code class="language-bash">$ pacman -Fl package_name
</code></pre>
<p>检查软件包安装的文件是否都存在:</p>
<pre><code class="language-bash">$ pacman -Qk package_name
</code></pre>
<p>两个参数<code>k</code>将会执行一次更彻底的检查.  查询数据库获取某个文件属于哪个软件包:</p>
<pre><code class="language-bash">$ pacman -Qo /path/to/file_name
</code></pre>
<p>查询文件属于远程数据库中的哪个软件包:</p>
<pre><code class="language-bash">$ pacman -F /path/to/file_name
</code></pre>
<p>要罗列所有不再作为依赖的软件包(孤立orphans):</p>
<pre><code class="language-bash">$ pacman -Qdt
</code></pre>
<p>提示:  将上述命令添加到 pacman 的一个处理后 hook用于在如果有处理产生孤立包后获得提示. 这在当有软件包被仓库放弃时是有用的,
因为任何被抛弃的包都会成为本地的一个孤立包(除非它是被显式安装的).
要避免在没有找到孤立包时<code>failed to execute command</code>的错误, 在你的 <code>hook</code> 中为<code>Exec</code>使用如下的指令:</p>
<pre><code class="language-bash">/usr/bin/bash -c &quot;/usr/bin/pacman -Qtd || /usr/bin/echo '=&gt; None found.'&quot;
</code></pre>
<p>要罗列所有明确安装而且不被其它包依赖的软件包:</p>
<pre><code class="language-bash">$ pacman -Qet
</code></pre>
<p>更多例子查看<code>pacman tips</code>.</p>
<h3 id="pactree"><a class="header" href="#pactree">Pactree</a></h3>
<p>注意:  <code>pactree(8)</code>不再是 <code>pacman</code> 的一部分. 它现在在 <code>pacman-contrib</code> 中.</p>
<p>要显示软件包的依赖树:</p>
<pre><code class="language-bash">$ pactree package_name
</code></pre>
<p>检查一个安装的软件包被哪些包依赖, 将递归标识<code>-r</code>传递给 pactree, 或者使用 <code>pkgtoolsAUR</code> 中的 <code>whoneeds</code></p>
<h3 id="数据库结构"><a class="header" href="#数据库结构">数据库结构</a></h3>
<p><code>pacman</code>数据库通常位于 <code>/var/lib/pacman/sync</code>. 对于每一个在<code>/etc/pacman.conf</code>中指定的软件仓库,  这里都有一个一致的数据库.
数据库文件夹里每个<code>tar.gz</code>文件都包含着一个仓库的软件包信息. 例如 <code>which</code> 包:</p>
<pre><code class="language-bash">$ tree which-2.21-5
which-2.21-5
|-- desc
</code></pre>
<p>这个 <code>depends</code> 项列出了该软件的依赖包,  而<code>desc</code>有该包的介绍, 例如文件大小和MD5值 .</p>
<h3 id="清理软件包缓存"><a class="header" href="#清理软件包缓存">清理软件包缓存</a></h3>
<p><code>pacman</code> 将下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 并且不会自动移除旧的和未安装版本的软件包. 这样做有一些好处:</p>
<ul>
<li>这样允许降级软件包而不需要通过其他方式提取旧版本, 例如 Arch Linux Archive.</li>
<li>被卸载的软件包可以轻易地直接从缓存文件夹重新安装, 不需要重新从软件仓库下载.</li>
</ul>
<p>然而, 需要定期手动清理缓存来避免该文件夹无限制增大.</p>
<p><code>pacman-contrib</code> 提供的 <code>paccache(8)</code> 脚本默认会删除所有缓存的版本和已卸载的软件包, 除了最近的<code>3</code>个会被保留:</p>
<pre><code class="language-bash"># paccache -r
</code></pre>
<p>启用 和 启动 <code>paccache.timer</code>来每周删除不使用的包.</p>
<p>也可以自己设置保留最近几个版本:</p>
<pre><code class="language-bash"># paccache -rk1
</code></pre>
<p>添加<code>-u</code>/<code>--uninstalled</code>开关来限制<code>paccache</code>的行为只作用于卸载的包. 例如清理所有卸载的包的缓存版本, 可以用以下命令:</p>
<pre><code class="language-bash"># paccache -ruk0
</code></pre>
<p>或者你可以将安装其结合, 同时作用于安装的和卸载的包, 例如想要保留最近两个安装的包但是移除所有卸载的包的缓存版本, 使用以下命令:</p>
<pre><code class="language-bash"># paccache -rk2 -ruk0
</code></pre>
<p>更多参数参见<code>paccache -h</code>.</p>
<p>pacman也有一些内建参数用于清除缓存和那些不再在<code>/etc/pacman.conf</code>配置文件中列出的软件仓库残留数据库文件.
然而pacman并不提供保留一定数量的过去版本的功能, 因此它比<code>paccache</code>的默认选项更加激进.</p>
<p>要删除目前没有安装的所有缓存的包, 和没有被使用的同步数据库, 执行:</p>
<pre><code class="language-bash"># pacman -Sc
</code></pre>
<p>要删除缓存中的全部文件, 使用两次-c开关. 这是最为激进的方式, 将会清空缓存文件夹:</p>
<pre><code class="language-bash"># pacman -Scc
</code></pre>
<p>警告:  应当避免从缓存中删除所有过去版本和卸载的包, 除非需要更多磁盘空间. 这样会导致无法降级或重新安装包而不再次下载他们</p>
<p><code>pkgcachecleanAUR</code>以及<code>pacleanerAUR</code>是两个进一步清理缓存的替代工具</p>
<hr />
<p>其它命令</p>
<p>升级系统时安装其他软件包:</p>
<pre><code class="language-bash"># pacman -Syu package_name1 package_name2 ...
</code></pre>
<p>安装原因</p>
<p><code>pacman</code>数据库按照软件包被安装的原因, 将其分为两类:</p>
<ul>
<li>显式安装: 那些真正地被传递给通用<code>pacman -S</code>和<code>-U</code>命令的包;</li>
<li>依赖: 那些虽然(一般)从未被传递给<code>pacman</code>安装命令, 但由于被其它显式安装的包需要从而被隐式安装的包</li>
</ul>
<p>当安装软件包时, 可以把安装原因强制设为依赖:</p>
<pre><code class="language-bash"># pacman -D --asdeps package_name
</code></pre>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p><code>pacman</code> 的配置文件位于<code>/etc/pacman.conf</code>.  <code>man pacman.conf</code> 可以查看配置文件的进一步信息.</p>
<hr />
<p>通用选项: 通用选项都在<code>[options]</code>段. 阅读 man 手册或者查看默认的 pacman.conf 可以获得有关信息和用法.</p>
<hr />
<p>升级前对比版本:要查看旧版和新版的有效安装包, 请取消<code>/etc/pacman.conf</code>中<code>&quot;VerbosePkgLists&quot;</code>的注释. 修改后的<code>pacman -Syu</code>会列出详细表格.</p>
<h2 id="git"><a class="header" href="#git">git</a></h2>
<h3 id="gitk"><a class="header" href="#gitk">gitk</a></h3>
<p>首先需要安装依赖包<code>tk</code>, 然后运行的时候可能会报错<code>unknown color name &quot;BACKGROUND&quot;</code>或者类似下面的</p>
<pre><code class="language-bash">application-specific initialization failed: unknown color name &quot;S_base3&quot;
Error in startup script: unknown color name &quot;S_base3&quot;
    (database entry for &quot;-background&quot; in widget &quot;.&quot;)
    invoked from within
&quot;load /usr/lib/x86_64-linux-gnu/libtk8.6.so Tk&quot;
    (&quot;package ifneeded Tk 8.6.1&quot; script)
    invoked from within
&quot;package require Tk&quot;
    (file &quot;/usr/bin/gitk&quot; line 10)
</code></pre>
<p><code>xrdb</code>--X resource datebase, <a href="https://wiki.archlinux.org/index.php/X_resources">X resources</a>.
<code>Xrdb</code>是一种为GUI应用程序的各种属性指定默认值的方法. 这些属性之一是背景色. 其中有一个规范, 即gitk主窗口的背景颜色为<code>S_base3</code>, 但程序不知道如何解析该颜色名称.</p>
<p><code>Xrdb</code>实际上是在<code>X root window</code>(<code>RESOURCE_MANAGER</code>)的子项中维护的, 对于应用程序是全局指定的. 初始化内容通常来自于用户家目录, 通常是<code>~/.Xresources</code>, 但也可以由桌面环境软件设置. 找出导致问题的原因可能很棘手, 因为许多程序都可以写入该属性.</p>
<p><code>xrdb</code>程序可用于编辑资源数据库. 可以使用: <code>xrdb -query&gt; xprops.txt</code>将当前内容列出到<code>xprops.txt</code>. 编辑文件以获取一些合理的值, 然后使用: <code>xrdb -load &lt;xprops.txt</code>载入新值.</p>
<p>例如把<code>Solarized</code>的颜色方案添加到<code>xprops.txt</code>的前面,<a href="https://github.com/altercation/solarized/blob/master/xresources/solarized">solarized-TrevorBramble</a>.
其中使用了<code>#define</code>, 需要安装<code>gcc</code>编译器.</p>
<pre><code class="language-c">#define S_yellow        #b58900
#define S_orange        #cb4b16
#define S_red           #dc322f
#define S_magenta       #d33682
</code></pre>
<h2 id="yay"><a class="header" href="#yay">yay</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/363666022">yay进阶</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash-常用操作"><a class="header" href="#bash-常用操作">bash 常用操作</a></h1>
<p><a href="https://www.runoob.com/linux/linux-tutorial.html">runoob-linux-tutorial</a></p>
<h2 id="查看帮助"><a class="header" href="#查看帮助">查看帮助</a></h2>
<ol>
<li><code>命令 -- help</code></li>
<li><code>man 命令</code></li>
</ol>
<p>后者更加详细</p>
<p>首先帮助中尖括号<code>&lt;&gt;</code>和方括号<code>[]</code>以及省略号<code>...</code>的含义,</p>
<p>在方括号内的表达式<code>[</code> 和 <code>]</code>之间的字符是可选的(要去掉括号).
在尖括号内的表达式<code>&lt;</code>和<code>&gt;</code>之间的字符, 是必须替换的表达式(要去掉括号).</p>
<p>省略号表示该选项可以单个或多个</p>
<p>以<code>7z</code>的参数为例:</p>
<pre><code class="language-bash">7z &lt;command&gt; [&lt;switches&gt;...] &lt;archive_name&gt; [&lt;file_names&gt;...]  [&lt;@listfiles...&gt;]
</code></pre>
<pre><code class="language-bash">7z &lt;命令&gt; [[选项]...] &lt;档案名称(压缩包名称)&gt; [&lt;被压缩的文件名&gt;...] [&lt;@文件列表(如txt文件中的文件列表)...&gt;]
</code></pre>
<p>实例分析</p>
<pre><code class="language-bash">7z a -tzip -p111 archive.zip txt.txt  txt.txt文件压缩为archive.zip, 压缩方式为zip 密码为111
7z x -tzip -p111 archive.zip            解压 密码为111
</code></pre>
<p><code>a</code>为命令, 命令至少要有一个</p>
<p><code>-t /-p</code>为选项(<code>switch</code>), 可选<code>0</code>个或多个, <code>zip</code>和<code>111</code>分别为<code>-t</code>和<code>-p</code>的参数, 中间不需要空格
选项(如<code>-r</code>)放前放后都行</p>
<p><code>7z</code>的命令不区分大小写, 有些命令如<code>cp</code>要区分</p>
<p>示例</p>
<pre><code class="language-bash">7z x archive.zip
#从压缩档案 archive.zip 中释放所有文件到当前文件夹.
7z x archive.zip -oc:\soft *.cpp
#从压缩档案 archive.zip 中释放 *.cpp 文件到 c:\soft 文件夹.
</code></pre>
<p><a href="https://blog.csdn.net/yandaonan/article/details/56489513">linux命令行括号帮助含义</a></p>
<h2 id="alias"><a class="header" href="#alias">alias</a></h2>
<p><a href="https://blog.csdn.net/kobejayandy/article/details/38710859">Linux中使用 alias 来简化命令行输入</a>
<a href="https://www.jianshu.com/p/63e91c67e39a">bash alias的使用</a></p>
<p><code>alias</code>(别名), 顾名思义, 其作用大概为命令的别名, 那么就可以它的好处就显而易见了. 可以用来缩短一些又长又难记的命令.</p>
<p>方法一:</p>
<ul>
<li><code>vim ~/.bashrc</code> ===&gt; 打开bash的配置文件</li>
<li>输入 <code>alias 新命令='旧命令 -选项/参数'</code> ===&gt; 修改命令别名</li>
<li><code>source ~/.bashrc</code> ===&gt; 使得修改完的命令别名生效</li>
<li>命令别名的增删改查都可以在<code>.bashrc</code>操作</li>
</ul>
<p>方法二:</p>
<ul>
<li>增/改: 输入 <code>alias 新命令='旧命令 -选项/参数'</code>即完成了命令别名的添加.</li>
<li>删: <code>unalias</code> 命令</li>
<li>查: <code>alias</code> 命令</li>
</ul>
<h2 id="压缩解压"><a class="header" href="#压缩解压">压缩/解压</a></h2>
<h3 id="7z-1"><a class="header" href="#7z-1">7z</a></h3>
<pre><code class="language-bash">7z a win.configrc.7z -pxxxxx `@tom.configrc
7z x win.configrc.7z -pxxxxx
</code></pre>
<h3 id="tar-1"><a class="header" href="#tar-1">tar</a></h3>
<p>解包: <code>tar xvf FileName.tar</code>
打包: <code>tar cvf FileName.tar DirName</code>
(<code>tar</code> 仅仅是打包, 也有压缩的选项)</p>
<hr />
<h3 id="gz"><a class="header" href="#gz"><code>.gz</code></a></h3>
<p>解压1: <code>gunzip FileName.gz</code>
解压2: <code>gzip -d FileName.gz</code>
压缩: <code>gzip FileName</code></p>
<p><code>.tar.gz</code> 和 <code>.tgz</code>
解压: <code>tar zxvf FileName.tar.gz</code>
压缩: <code>tar zcvf FileName.tar.gz DirName</code></p>
<hr />
<h3 id="bz2"><a class="header" href="#bz2"><code>.bz2</code></a></h3>
<p>解压1: <code>bzip2 -d FileName.bz2</code>
解压2: <code>bunzip2 FileName.bz2</code>
压缩:  <code>bzip2 -z FileName</code></p>
<p><code>.tar.bz2</code>
解压: <code>tar jxvf FileName.tar.bz2</code>
压缩: <code>tar jcvf FileName.tar.bz2 DirName</code></p>
<hr />
<h3 id="bz"><a class="header" href="#bz"><code>.bz</code></a></h3>
<p>解压1: <code>bzip2 -d FileName.bz</code>
解压2: <code>bunzip2 FileName.bz</code>
压缩: 未知</p>
<p><code>.tar.bz</code>
解压: <code>tar jxvf FileName.tar.bz</code>
压缩: 未知</p>
<hr />
<h3 id="z"><a class="header" href="#z"><code>.Z</code></a></h3>
<p>解压: <code>uncompress FileName.Z</code>
压缩: <code>compress FileName</code>
<code>.tar.Z</code></p>
<p>解压: <code>tar Zxvf FileName.tar.Z</code>
压缩: <code>tar Zcvf FileName.tar.Z DirName</code></p>
<hr />
<h3 id="zip-1"><a class="header" href="#zip-1"><code>.zip</code></a></h3>
<p>解压: <code>unzip FileName.zip</code>
压缩: <code>zip FileName.zip DirName</code></p>
<hr />
<h3 id="rar"><a class="header" href="#rar"><code>.rar</code></a></h3>
<p>解压: <code>rar x FileName.rar</code>
压缩: <code>rar a FileName.rar DirName</code></p>
<hr />
<h3 id="lha"><a class="header" href="#lha"><code>.lha</code></a></h3>
<p>解压: <code>lha -e FileName.lha</code>
压缩: <code>lha -a FileName.lha FileName</code></p>
<hr />
<h3 id="rpm"><a class="header" href="#rpm"><code>.rpm</code></a></h3>
<p>解包: <code>rpm2cpio FileName.rpm | cpio -div</code></p>
<hr />
<h3 id="deb"><a class="header" href="#deb"><code>.deb</code></a></h3>
<p>解包: <code>ar p FileName.deb data.tar.gz | tar zxf -</code></p>
<hr />
<h3 id="sex"><a class="header" href="#sex"><code>sEx</code></a></h3>
<p><code>.tar</code> <code>.tgz</code> <code>.tar.gz</code> <code>.tar.Z</code> <code>.tar.bz</code> <code>.tar.bz2</code> <code>.zip</code> <code>.cpio</code> <code>.rpm</code> <code>.deb</code> <code>.slp</code> <code>.arj</code> <code>.rar</code> <code>.ace</code> <code>.lha</code> <code>.lzh</code> <code>.lzx</code> <code>.lzs</code> <code>.arc</code> <code>.sda</code> <code>.sfx</code> <code>.lnx</code> <code>.zoo</code> <code>.cab</code> <code>.kar</code> <code>.cpt</code> <code>.pit</code> <code>.sit</code> <code>.sea</code></p>
<p>解压: <code>sEx x FileName.*</code>
压缩: <code>sEx a FileName.* FileName</code></p>
<p><code>sEx</code>只是调用相关程序, 本身并无压缩, 解压功能, 请注意!</p>
<h3 id="gzip-命令"><a class="header" href="#gzip-命令">gzip 命令</a></h3>
<p>减少文件大小有两个明显的好处, 一是可以减少存储空间, 二是通过网络传输文件时, 可以减少传输的时间.
<code>gzip</code> 是在 <code>Linux</code> 系统中经常使用的一个对文件进行压缩和解压缩的命令, 既方便又好用.</p>
<p>语法: <code>gzip [选项] &lt;压缩(解压缩)的文件名&gt;</code></p>
<p>该命令的各选项含义如下:</p>
<ul>
<li><code>-c</code> 将输出写到标准输出上, 并保留原有文件.</li>
<li><code>-d</code> 将压缩文件解压.</li>
<li><code>-l</code> 对每个压缩文件, 显示下列字段: 压缩文件的大小; 未压缩文件的大小; 压缩比; 未压缩文件的名字</li>
<li><code>-r</code> 递归式地查找指定目录并压缩其中的所有文件或者是解压缩.</li>
<li><code>-t</code> 测试, 检查压缩文件是否完整.</li>
<li><code>-v</code> 对每一个压缩和解压的文件, 显示文件名和压缩比.</li>
<li><code>-num</code> 用指定的数字 <code>num</code> 调整压缩的速度, <code>-1</code> 或 <code>--fast</code> 表示最快压缩方法(低压缩比);<code>-9</code> 或<code>--best</code>表示最慢压缩方法(高压缩比).系统缺省值为<code>6</code>.</li>
</ul>
<p>指令实例:</p>
<ul>
<li><code>gzip *%</code> 把当前目录下的每个文件压缩成<code>.gz</code>文件.</li>
<li><code>gzip -dv *</code> 把当前目录下每个压缩的文件解压, 并列出详细的信息.</li>
<li><code>gzip -l *</code> 详细显示例1中每个压缩的文件的信息, 并不解压.</li>
<li><code>gzip usr.tar</code> 压缩<code>tar</code>备份文件<code>usr.tar</code>, 此时压缩文件的扩展名为<code>.tar.gz</code>.</li>
</ul>
<p><a href="https://blog.csdn.net/u013063153/article/details/53894711">Linux/Ubuntu下解压命令</a></p>
<h2 id="linux-文件与目录管理"><a class="header" href="#linux-文件与目录管理">Linux 文件与目录管理</a></h2>
<p>我们知道 <code>Linux</code> 的目录结构为树状结构, 最顶级的目录为根目录 <code>/</code>.
其他目录可以通过挂载添加到树中, 可以通过解除挂载移除.
在开始本教程前我们需要先知道什么是绝对路径与相对路径.</p>
<p>绝对路径:
路径的写法, 由根目录 <code>/</code> 写起, 例如:  <code>/usr/share/doc</code> 这个目录.</p>
<p>相对路径:
路径的写法, 不是由 <code>/</code> 写起, 例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code> 底下时, 可以写成: <code>cd ../man</code> 这就是相对路径的写法啦!</p>
<h3 id="处理目录的常用命令"><a class="header" href="#处理目录的常用命令">处理目录的常用命令</a></h3>
<p>接下来我们就来看几个常见的处理目录的命令吧:</p>
<ul>
<li><code>ls</code> : 列出目录</li>
<li><code>cd</code> : 切换目录</li>
<li><code>pwd</code> : 显示目前的目录</li>
<li><code>mkdir</code> : 创建一个新的目录</li>
<li><code>rmdir</code> : 删除一个空的目录</li>
<li><code>cp</code> : 复制文件或目录</li>
<li><code>rm</code> : 移除文件或目录</li>
<li><code>mv</code> : 移动文件与目录, 或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <code>man [命令]</code> 来查看各个命令的使用文档, 如 : <code>man cp</code>.</p>
<h3 id="ls-列出目录"><a class="header" href="#ls-列出目录">ls (列出目录)</a></h3>
<p>在<code>Linux</code>系统当中,  <code>ls</code> 命令可能是最常被运行的.</p>
<p>语法:</p>
<pre><code class="language-bash">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
[root@www ~]# ls [--color={never,auto,always}] 目录名称
[root@www ~]# ls [--full-time] 目录名称
</code></pre>
<p>选项与参数:</p>
<p><code>-a</code> : 全部的文件, 连同隐藏档( 开头为 <code>.</code> 的文件) 一起列出来(常用)
<code>-d</code> : 仅列出目录本身, 而不是列出目录内的文件数据(常用)
<code>-l</code> : 长数据串列出, 包含文件的属性与权限等等数据; (常用)</p>
<p>将家目录下的所有文件列出来(含属性与隐藏档)</p>
<pre><code class="language-bash">[root@www ~]# ls -al ~
</code></pre>
<h3 id="cd-切换目录"><a class="header" href="#cd-切换目录">cd (切换目录)</a></h3>
<p><code>cd</code>是<code>Change Directory</code>的缩写, 这是用来变换工作目录的命令.</p>
<p>语法:</p>
<pre><code class="language-bash">cd [相对路径或绝对路径]
</code></pre>
<pre><code class="language-bash">#使用 mkdir 命令创建 runoob 目录
[root@www ~]# mkdir runoob

#使用绝对路径切换到 runoob 目录
[root@www ~]# cd /root/runoob/

#使用相对路径切换到 runoob 目录
[root@www ~]# cd ./runoob/

# 表示回到自己的家目录, 亦即是 /root 这个目录
[root@www runoob]# cd ~

# 到目前的上一级目录, 即 /root 的上一级目录;
[root@www ~]# cd ..
</code></pre>
<h3 id="pwd-显示目前所在的目录"><a class="header" href="#pwd-显示目前所在的目录">pwd (显示目前所在的目录)</a></h3>
<p><code>pwd</code> 是 <code>Print Working Directory</code> 的缩写, 也就是&quot;显示目前所在目录&quot;.</p>
<pre><code class="language-bash">[root@www ~]# pwd [-P]
</code></pre>
<p>选项与参数:</p>
<p><code>-P</code> : 显示出确实的路径, 而非使用链接 (link) 路径.</p>
<p>实例: 单纯显示出目前的工作目录:</p>
<pre><code class="language-bash">[root@www ~]# pwd
/root   &lt;== 显示出目录

实例:显示出实际的工作目录, 而非链接本身的目录名.

[root@www ~]# cd /var/mail   &lt;==注意, /var/mail是一个链接
[root@www mail]# pwd
/var/mail         &lt;==列出目前的工作目录
[root@www mail]# pwd -P
/var/spool/mail   &lt;==怎么回事?
[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail
# 看到这里知道为啥了吧? 因为 /var/mail 是链接档, 链接到 /var/spool/mail
# 所以, 加上 pwd -P 的选项后, 会显示完整路径
</code></pre>
<h3 id="mkdir-创建新目录"><a class="header" href="#mkdir-创建新目录">mkdir (创建新目录)</a></h3>
<p>如果想要创建新的目录的话, 那么就使用mkdir (make directory)吧.</p>
<p>语法:</p>
<pre><code class="language-bash">mkdir [-mp] 目录名称
</code></pre>
<p>选项与参数:</p>
<p><code>-m</code> : 配置文件的权限, 而不是默认权限 (umask)
<code>-p</code> : 帮助你直接将所需要的目录(包含上一级目录)递归创建</p>
<p>实例: 请到<code>/tmp</code>底下尝试创建数个新目录看看:</p>
<pre><code class="language-bash">[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    &lt;==创建名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4`:
No such file or directory       &lt;== 没办法直接创建此目录

[root@www tmp]# mkdir -p test1/test2/test3/test4

# 加了这个 -p 的选项, 可以自行帮你创建多层目录

</code></pre>
<p>实例: 创建权限为 <code>rwx--x--x</code> 的目录.</p>
<pre><code class="language-bash">[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</code></pre>
<p>上面的权限部分, 如果没有加上 <code>-m</code> 来强制配置属性, 系统会使用默认属性.</p>
<p>如果我们使用 <code>-m</code> , 如上例我们给予 <code>-m 711</code> 来给予新的目录 <code>drwx--x--x</code> 的权限.</p>
<h3 id="rmdir-删除空的目录"><a class="header" href="#rmdir-删除空的目录">rmdir (删除空的目录)</a></h3>
<p>语法:</p>
<pre><code class="language-bash">rmdir [-p] 目录名称
</code></pre>
<p>选项与参数:</p>
<p><code>-p</code> : 连同上一级&quot;空的&quot;目录也一起删除</p>
<p>删除 <code>runoob</code> 目录</p>
<pre><code class="language-bash">[root@www tmp]# rmdir runoob/

将 mkdir 实例中创建的目录(/tmp 底下)删除掉!

[root@www tmp]# ls -l   &lt;==看看有多少目录存在?
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# rmdir test   &lt;==可直接删除掉, 没问题
[root@www tmp]# rmdir test1  &lt;==因为尚有内容, 所以无法删除!
rmdir: `test1`: Directory not empty
[root@www tmp]# rmdir -p test1/test2/test3/test4
[root@www tmp]# ls -l      &lt;==中test与test1不见了!
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</code></pre>
<p>利用 <code>-p</code> 这个选项, 可以将 <code>test1/test2/test3/test4</code> 一次删除.</p>
<p>不过要注意的是, 这个 <code>rmdir</code> 仅能删除空的目录, 你可以使用 <code>rm</code> 命令来删除非空目录.</p>
<h3 id="cp-复制文件或目录"><a class="header" href="#cp-复制文件或目录">cp (复制文件或目录)</a></h3>
<p><code>cp</code> 即拷贝文件和目录.</p>
<p>语法:</p>
<pre><code class="language-bash">[root@www ~]# cp [-adfilprsu] 来源(source) 目标(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
</code></pre>
<p>选项与参数:</p>
<p><code>-a</code> : 相当于 <code>-pdr</code> 的意思, 至于 <code>pdr</code> 请参考下列说明; (常用)
<code>-d</code> : 若来源档为链接的属性(<code>link file</code>), 则复制链接档属性而非文件本身;
<code>-f</code> : 强制(<code>force</code>)的意思, 若目标文件已经存在且无法开启, 则移除后再尝试一次;
<code>-i</code> : 若目标档(<code>destination</code>)已经存在时, 在覆盖时会先询问动作的进行(常用)
<code>-l</code> : 进行硬式链接(<code>hard link</code>)的链接档创建, 而非复制文件本身;
<code>-p</code> : 连同文件的属性一起复制过去, 而非使用默认属性(备份常用);
<code>-r</code> : 递归持续复制,<code>recursive</code>, 用于目录的复制行为; (常用)
<code>-s</code> : 复制成为符号链接档 (<code>symbolic link</code>), 即&quot;捷径&quot;文件;
<code>-u</code> : 若 <code>destination</code> 比 <code>source</code> 旧才升级 <code>destination</code></p>
<p>用 <code>root</code> 身份, 将 <code>root</code> 目录下的 <code>.bashrc</code> 复制到 <code>/tmp</code> 下, 并命名为<code>bashrc</code></p>
<pre><code class="language-bash">[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc`? n  &lt;==n不覆盖, y为覆盖
</code></pre>
<h3 id="rm-移除文件或目录"><a class="header" href="#rm-移除文件或目录">rm (移除文件或目录)</a></h3>
<p>语法:</p>
<pre><code class="language-bash"> rm [-fir] 文件或目录
</code></pre>
<p>选项与参数:</p>
<p><code>-f</code> : 就是 <code>force</code> 的意思, 忽略不存在的文件, 不会出现警告信息;
<code>-i</code> : 互动模式, 在删除前会询问使用者是否动作
<code>-r</code> : 递归删除, 最常用在目录的删除, 这是非常危险的选项!</p>
<p>将刚刚在 <code>cp</code> 的实例中创建的 <code>bashrc</code> 删除掉:</p>
<pre><code class="language-bash">[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc'? y
</code></pre>
<p>如果加上 <code>-i</code> 的选项就会主动询问, 避免你错误删除.</p>
<h3 id="mv-移动文件与目录-或修改名称"><a class="header" href="#mv-移动文件与目录-或修改名称">mv (移动文件与目录, 或修改名称)</a></h3>
<p>语法:</p>
<pre><code class="language-bash">[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
</code></pre>
<p>选项与参数:</p>
<p><code>-f</code> :  <code>force</code> 强制的意思, 如果目标文件已经存在, 不会询问而直接覆盖;
<code>-i</code> :  若目标文件 (<code>destination</code>) 已经存在时, 就会询问是否覆盖.
<code>-u</code> :  若目标文件已经存在, 且 <code>source</code> 比较新, 才会升级 (<code>update</code>)</p>
<p>复制一文件, 创建一目录, 将文件移动到目录中</p>
<pre><code class="language-bash">[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
</code></pre>
<p>将刚刚的目录名称更名为 <code>mvtest2</code></p>
<pre><code class="language-bash">[root@www tmp]# mv mvtest mvtest2
</code></pre>
<h3 id="linux-文件内容查看"><a class="header" href="#linux-文件内容查看">Linux 文件内容查看</a></h3>
<p><code>Linux</code> 系统中使用以下命令来查看文件的内容:</p>
<ul>
<li><code>cat</code>  由第一行开始显示文件内容,<code>catenate</code></li>
<li><code>tac</code>  从最后一行开始显示, 可以看出 <code>tac</code> 是 <code>cat</code> 的倒着写</li>
<li><code>nl</code>   显示的时候, 顺便输出行号</li>
<li><code>more</code> 一页一页的显示文件内容</li>
<li><code>less</code> 与 <code>more</code> 类似, 但是比 <code>more</code> 更好的是, 他可以往前翻页!</li>
<li><code>head</code> 只看头几行</li>
<li><code>tail</code> 只看尾巴几行</li>
</ul>
<p>你可以使用 <code>man [命令]</code>来查看各个命令的使用文档, 如 : <code>man cp</code>.</p>
<h4 id="cat-1"><a class="header" href="#cat-1">cat</a></h4>
<p>由第一行开始显示文件内容</p>
<p>语法:</p>
<pre><code class="language-bash">cat [-AbEnTv]
</code></pre>
<p>选项与参数:</p>
<p><code>-A</code> : 相当于 <code>-vET</code> 的整合选项, 可列出一些特殊字符而不是空白而已;
<code>-b</code> : 列出行号, 仅针对非空白行做行号显示, 空白行不标行号!
<code>-E</code> : 将结尾的断行字节 <code>$</code> 显示出来;
<code>-n</code> : 列印出行号, 连同空白行也会有行号, 与 <code>-b</code> 的选项不同;
<code>-T</code> : 将 [tab] 按键以 <code>^I</code> 显示出来;
<code>-v</code> : 列出一些看不出来的特殊字符</p>
<p>检看 <code>/etc/issue</code> 这个文件的内容:</p>
<pre><code class="language-bash">[root@www ~]# cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
</code></pre>
<p><code>tac</code></p>
<p><code>tac</code>与<code>cat</code>命令刚好相反, 文件内容从最后一行开始显示, 可以看出 <code>tac</code> 是 <code>cat</code> 的倒写.如:</p>
<pre><code class="language-bash">[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)
</code></pre>
<h4 id="nl-显示行号"><a class="header" href="#nl-显示行号">nl 显示行号</a></h4>
<p>numbered list
语法:</p>
<pre><code class="language-bash">nl [-bnw] 文件
</code></pre>
<p>选项与参数:</p>
<p><code>-b</code> : 指定行号指定的方式, 主要有两种:
<code>-b a</code> : 表示不论是否为空行, 也同样列出行号(类似 <code>cat -n</code>);
<code>-b t</code> : 如果有空行, 空的那一行不要列出行号(默认值);
<code>-n</code> : 列出行号表示的方法, 主要有三种:
<code>-n ln</code> : 行号在荧幕的最左方显示;
<code>-n rn</code> : 行号在自己栏位的最右方显示, 且不加 0 ;
<code>-n rz</code> : 行号在自己栏位的最右方显示, 且加 0 ;
<code>-w</code> : 行号栏位的占用的位数.</p>
<p>实例一: 用 <code>nl</code> 列出 <code>/etc/issue</code> 的内容</p>
<pre><code class="language-bash">[root@www ~]# nl /etc/issue
     1  CentOS release 6.4 (Final)
     2  Kernel \r on an \m
</code></pre>
<h4 id="more"><a class="header" href="#more">more</a></h4>
<p>一页一页翻动</p>
<pre><code class="language-bash">[root@www ~]# more /etc/man_db.config
#
# Generated automatically from man.conf.in by the
# configure script.
....(中间省略)....
--More--(28%)  &lt;== 重点在这一行喔! 你的光标会在这里等待命令
</code></pre>
<p>在 <code>more</code> 这个程序的运行过程中, 你有几个按键可以按:</p>
<p><code>空白键 (space)</code> : 代表向下翻一页;
<code>Enter</code>        : 代表向下翻一行;
<code>/字串</code>        : 代表在这个显示的内容当中, 向下搜寻&quot;字串&quot;这个关键字;
<code>:f</code>          : 立刻显示出档名以及目前显示的行数;
<code>q</code>          : 代表立刻离开<code>more</code> , 不再显示该文件内容.
<code>b 或 [ctrl]-b</code> : 代表往回翻页, 不过这动作只对文件有用, 对管线无用.</p>
<h4 id="less"><a class="header" href="#less">less</a></h4>
<p>一页一页翻动, 以下实例输出<code>/etc/man.config</code>文件的内容:</p>
<pre><code class="language-bash">[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
....(中间省略)....
:   &lt;== 这里可以等待你输入命令
</code></pre>
<p><code>less</code>运行时可以输入的命令有:</p>
<ul>
<li><code>空白键</code>    : 向下翻动一页;</li>
<li><code>[pagedown]</code> : 向下翻动一页;</li>
<li><code>[pageup]</code>  : 向上翻动一页;</li>
<li><code>/字串</code>     : 向下搜寻&quot;字串&quot;的功能;</li>
<li><code>?字串</code>     : 向上搜寻&quot;字串&quot;的功能;</li>
<li><code>n</code>        : 重复前一个搜寻 (与 <code>/</code> 或 <code>?</code> 有关! )</li>
<li><code>N</code>        : 反向的重复前一个搜寻 (与 <code>/</code> 或 <code>?</code> 有关! )</li>
<li><code>q</code>        : 离开 <code>less</code> 这个程序;</li>
</ul>
<h4 id="head"><a class="header" href="#head">head</a></h4>
<p>取出文件前面几行</p>
<p>语法:</p>
<pre><code class="language-bash">head [-n number] 文件
</code></pre>
<p>选项与参数:</p>
<p><code>-n</code> : 后面接数字, 代表显示几行的意思</p>
<pre><code class="language-bash">[root@www ~]# head /etc/man.config
# 默认的情况中, 显示前面 10 行! 若要显示前 20 行, 需要这样
[root@www ~]# head -n 20 /etc/man.config
</code></pre>
<h4 id="tail"><a class="header" href="#tail">tail</a></h4>
<p>取出文件后面几行</p>
<p>语法:</p>
<pre><code class="language-bash">tail [-n number] 文件
</code></pre>
<p>选项与参数:</p>
<p><code>-n</code> : 后面接数字, 代表显示几行的意思
<code>-f</code> : 表示持续侦测后面所接的档名, 要等到按下<code>[ctrl]-c</code>才会结束<code>tail</code>的侦测</p>
<pre><code class="language-bash">[root@www ~]# tail /etc/man.config
# 默认的情况中, 显示最后的十行,若要显示最后的 20 行, 需要这样:
[root@www ~]# tail -n 20 /etc/man.config
</code></pre>
<h2 id="安装-windows-字体"><a class="header" href="#安装-windows-字体">安装 Windows 字体</a></h2>
<p>或者, 将所有的 <code>Windows</code> 字体复制到 /usr/share/fonts 目录下并使用一下命令安装字体:</p>
<pre><code class="language-bash">mkdir /usr/share/fonts/WindowsFonts
cp /Windowsdrive/Windows/Fonts/* /usr/share/fonts/WindowsFonts
chmod 755 /usr/share/fonts/WindowsFonts/*
</code></pre>
<p>最后, 使用命令行重新生成<code>fontconfig</code> 缓存:</p>
<pre><code class="language-bash">fc-cache
</code></pre>
<h3 id="vscode-调整字体"><a class="header" href="#vscode-调整字体">vscode 调整字体</a></h3>
<p>&quot;editor.fontFamily&quot;: &quot;Fira Code, Source Code Pro, Noto Sans CJK SC, monospace&quot;</p>
<p>这个是用的谷歌的开源字体思源黑体.</p>
<p><code>makrdown</code> 的话, 还有个&quot;<code>markdown.preview.fontFamily</code>&quot;设置.</p>
<blockquote>
<p>但是也许是我的版本较高, 版本<code>1.23.1</code>, 我的里面设置是这样子的:
<code>&quot;editor.fontFamily&quot;: &quot;Consolas, Dengxian&quot;</code>,
英文字体用了<code>Consolas</code>, 如果不适用的字体就用<code>Dengxian</code></p>
</blockquote>
<p>我的设置</p>
<pre><code class="language-json">&quot;editor.fontFamily&quot;: &quot;Fira Code Retina, Microsoft YaHei&quot;,
&quot;editor.fontLigatures&quot;: true,
</code></pre>
<p><code>makrdown</code> 的话, 还有个<code>&quot;markdown.preview.fontFamily&quot;</code>设置.</p>
<p><a href="https://zhuanlan.zhihu.com/p/40434062">refer1</a>
<a href="https://segmentfault.com/a/1190000004168301">refer2</a>
[refer3][(https://www.v2ex.com/t/453862)</p>
<h3 id="oh-my-zsh-中定义的别名"><a class="header" href="#oh-my-zsh-中定义的别名">oh-my-zsh 中定义的别名</a></h3>
<p>为了方便使用, oh-my-zsh 定义了许多别名, 下面是其中一部分.</p>
<pre><code class="language-bashrc">-='cd -'
...=../..
....=../../..
.....=../../../..
......=../../../../..
1='cd -'
2='cd -2'
3='cd -3'
4='cd -4'
5='cd -5'
6='cd -6'
7='cd -7'
8='cd -8'
9='cd -9'
_='sudo '
afind='ack -il'
diff='diff --color'
egrep='egrep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}'
fgrep='fgrep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}'
g=git
ga='git add'
gaa='git add --all'
gam='git am'
gama='git am --abort'
gamc='git am --continue'
gams='git am --skip'
gamscp='git am --show-current-patch'
gap='git apply'
gapa='git add --patch'
gapt='git apply --3way'
gau='git add --update'
gav='git add --verbose'
gb='git branch'
gbD='git branch -D'
gba='git branch -a'
gbd='git branch -d'
gbda='git branch --no-color --merged | command grep -vE &quot;^(\+|\*|\s*($(git_main_branch)|development|develop|devel|dev)\s*$)&quot; | command xargs -n 1 git branch -d'
gbl='git blame -b -w'
gbnm='git branch --no-merged'
gbr='git branch --remote'
gbs='git bisect'
gbsb='git bisect bad'
gbsg='git bisect good'
gbsr='git bisect reset'
gbss='git bisect start'
gc='git commit -v'
'gc!'='git commit -v --amend'
gca='git commit -v -a'
'gca!'='git commit -v -a --amend'
gcam='git commit -a -m'
'gcan!'='git commit -v -a --no-edit --amend'
'gcans!'='git commit -v -a -s --no-edit --amend'
gcb='git checkout -b'
gcd='git checkout develop'
gcf='git config --list'
gcl='git clone --recurse-submodules'
gclean='git clean -id'
gcm='git checkout $(git_main_branch)'
gcmsg='git commit -m'
'gcn!'='git commit -v --no-edit --amend'
gco='git checkout'
gcount='git shortlog -sn'
gcp='git cherry-pick'
gcpa='git cherry-pick --abort'
gcpc='git cherry-pick --continue'
gcs='git commit -S'
gcsm='git commit -s -m'
gd='git diff'
gdca='git diff --cached'
gdct='git describe --tags $(git rev-list --tags --max-count=1)'
gdcw='git diff --cached --word-diff'
gds='git diff --staged'
gdt='git diff-tree --no-commit-id --name-only -r'
gdw='git diff --word-diff'
gf='git fetch'
gfa='git fetch --all --prune --jobs=10'
gfg='git ls-files | grep'
gfo='git fetch origin'
gg='git gui citool'
gga='git gui citool --amend'
ggpull='git pull origin &quot;$(git_current_branch)&quot;'
ggpur=ggu
ggpush='git push origin &quot;$(git_current_branch)&quot;'
ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'
ghh='git help'
gignore='git update-index --assume-unchanged'
gignored='git ls-files -v | grep &quot;^[[:lower:]]&quot;'
git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github $(git_main_branch):svntrunk'
gk='\gitk --all --branches'
gke='\gitk --all $(git log -g --pretty=%h)'
gl='git pull'
glg='git log --stat'
glgg='git log --graph'
glgga='git log --graph --decorate --all'
glgm='git log --graph --max-count=10'
glgp='git log --stat -p'
glo='git log --oneline --decorate'
globurl='noglob urlglobber '
glod='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\'
glods='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\'' --date=short'
glog='git log --oneline --decorate --graph'
gloga='git log --oneline --decorate --graph --all'
glol='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\'
glola='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\'' --all'
glols='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\'' --stat'
glp=_git_log_prettily
glum='git pull upstream $(git_main_branch)'
gm='git merge'
gma='git merge --abort'
gmom='git merge origin/$(git_main_branch)'
gmt='git mergetool --no-prompt'
gmtvim='git mergetool --no-prompt --tool=vimdiff'
gmum='git merge upstream/$(git_main_branch)'
gp='git push'
gpd='git push --dry-run'
gpf='git push --force-with-lease'
'gpf!'='git push --force'
gpoat='git push origin --all &amp;&amp; git push origin --tags'
gpristine='git reset --hard &amp;&amp; git clean -dffx'
gpsup='git push --set-upstream origin $(git_current_branch)'
gpu='git push upstream'
gpv='git push -v'
gr='git remote'
gra='git remote add'
grb='git rebase'
grba='git rebase --abort'
grbc='git rebase --continue'
grbd='git rebase develop'
grbi='git rebase -i'
grbm='git rebase $(git_main_branch)'
grbs='git rebase --skip'
grep='grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox}'
grev='git revert'
grh='git reset'
grhh='git reset --hard'
grm='git rm'
grmc='git rm --cached'
grmv='git remote rename'
groh='git reset origin/$(git_current_branch) --hard'
grrm='git remote remove'
grs='git restore'
grset='git remote set-url'
grss='git restore --source'
grt='cd &quot;$(git rev-parse --show-toplevel || echo .)&quot;'
gru='git reset --'
grup='git remote update'
grv='git remote -v'
gsb='git status -sb'
gsd='git svn dcommit'
gsh='git show'
gsi='git submodule init'
gsps='git show --pretty=short --show-signature'
gsr='git svn rebase'
gss='git status -s'
gst='git status'
gsta='git stash push'
gstaa='git stash apply'
gstall='git stash --all'
gstc='git stash clear'
gstd='git stash drop'
gstl='git stash list'
gstp='git stash pop'
gsts='git stash show --text'
gstu='git stash --include-untracked'
gsu='git submodule update'
gsw='git switch'
gswc='git switch -c'
gtl='gtl(){ git tag --sort=-v:refname -n -l &quot;${1}*&quot; }; noglob gtl'
gts='git tag -s'
gtv='git tag | sort -V'
gunignore='git update-index --no-assume-unchanged'
gunwip='git log -n 1 | grep -q -c &quot;\-\-wip\-\-&quot; &amp;&amp; git reset HEAD~1'
gup='git pull --rebase'
gupa='git pull --rebase --autostash'
gupav='git pull --rebase --autostash -v'
gupv='git pull --rebase -v'
gwch='git whatchanged -p --abbrev-commit --pretty=medium'
gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify --no-gpg-sign -m &quot;--wip-- [skip ci]&quot;'
history=omz_history
l='ls -lah'
la='ls -lAh'
ll='ls -lh'
ls='ls --color=tty'
lsa='ls -lah'
md='mkdir -p'
mma='mathematica -singleLaunch'
rd=rmdir
which-command=whence
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash-语法"><a class="header" href="#bash-语法">bash 语法</a></h1>
<h2 id="shell-变量"><a class="header" href="#shell-变量">shell 变量</a></h2>
<p><a href="http://c.biancheng.net/view/743.html">Shell变量:Shell变量的定义,赋值和删除</a></p>
<p>脚本语言在定义变量时通常不需要指明类型,直接赋值就可以,<code>Shell</code> 变量也遵循这个规则.</p>
<p>在 <code>Bash shell</code> 中,每一个变量的值都是<strong>字符串</strong>,无论你给变量赋值时有没有使用引号,值都会以字符串的形式存储.</p>
<p>这意味着,<code>Bash shell</code> 在默认情况下不会区分变量类型,即使你将整数和小数赋值给变量,它们也会被视为字符串,这一点和大部分的编程语言不同.</p>
<p>例如在C语言或者 C++ 中,变量分为整数,小数,字符串,布尔等多种类型.</p>
<p>当然,如果有必要,你也可以使用 <code>Shell declare</code> 关键字显式定义变量的类型,但在一般情况下没有这个需求,Shell 开发者在编写代码时自行注意值的类型即可.</p>
<h3 id="定义变量"><a class="header" href="#定义变量">定义变量</a></h3>
<p><code>Shell</code> 支持以下三种定义变量的方式:</p>
<pre><code class="language-bash">variable=value
variable='value'
variable=&quot;value&quot;
</code></pre>
<p><code>variable</code> 是变量名,<code>value</code> 是赋给变量的值.如果 <code>value</code> 不包含任何空白符(例如空格,<code>Tab</code> 缩进等),那么可以不使用引号;
如果 <code>value</code> 包含了空白符,那么就必须使用引号包围起来.使用单引号和使用双引号也是有区别的,稍后我们会详细说明.</p>
<p>注意,赋值号<code>=</code>的周围不能有空格,这可能和你熟悉的大部分编程语言都不一样.</p>
<p><code>Shell</code> 变量的命名规范和大部分编程语言都一样:</p>
<ul>
<li>变量名由数字,字母,下划线组成;</li>
<li>必须以字母或者下划线开头;</li>
<li>不能使用 <code>Shell</code> 里的关键字(通过 <code>help</code> 命令可以查看保留关键字).</li>
</ul>
<p>变量定义举例:</p>
<pre><code class="language-bash">url=http://c.biancheng.net/shell/
echo $url
name='C语言中文网'
echo $name
author=&quot;严长生&quot;
echo $author
</code></pre>
<h3 id="使用变量"><a class="header" href="#使用变量">使用变量</a></h3>
<p>使用一个定义过的变量,只要在变量名前面加美元符号<code>$</code>即可,如:</p>
<pre><code class="language-bash">author=&quot;严长生&quot;
echo $author
echo ${author}
</code></pre>
<p>变量名外面的花括号<code>{ }</code>是可选的,加不加都行,
加花括号是为了帮助解释器识别变量的边界,比如下面这种情况:</p>
<pre><code class="language-bash">skill=&quot;Java&quot;
echo &quot;I am good at ${skill}Script&quot;
</code></pre>
<p>如果不给 <code>skill</code> 变量加花括号,写成<code>echo &quot;I am good at $skillScript&quot;</code>,解释器就会把 <code>$skillScript</code> 当成一个变量(其值为空),代码执行结果就不是我们期望的样子了.</p>
<p>推荐给所有变量加上花括号<code>{ }</code>,这是个良好的编程习惯.</p>
<h3 id="修改变量的值"><a class="header" href="#修改变量的值">修改变量的值</a></h3>
<p>已定义的变量,可以被重新赋值,如:</p>
<pre><code class="language-bash">url=&quot;http://c.biancheng.net&quot;
echo ${url}
url=&quot;http://c.biancheng.net/shell/&quot;
echo ${url}
</code></pre>
<p>第二次对变量赋值时不能在变量名前加<code>$</code>,只有在使用变量时才能加<code>$</code>.</p>
<h3 id="单引号和双引号的区别"><a class="header" href="#单引号和双引号的区别">单引号和双引号的区别</a></h3>
<p>定义变量时,变量的值可以由单引号<code>' '</code>包围,也可以由双引号<code>&quot; &quot;</code>包围,
它们的区别以下面的代码为例来说明:</p>
<pre><code class="language-bash">#!/bin/bash
url=&quot;http://c.biancheng.net&quot;
website1='C语言中文网:${url}'
website2=&quot;C语言中文网:${url}&quot;
echo $website1
echo $website2
运行结果:
C语言中文网:${url}
C语言中文网:http://c.biancheng.net
</code></pre>
<p>以单引号<code>' '</code>包围变量的值时,单引号里面是什么就输出什么,即使内容中有变量和命令(命令需要<code>反引</code>起来)也会把它们原样输出.
这种方式比较适合定义显示纯字符串的情况,即不希望解析变量,命令等的场景.</p>
<p>以双引号<code>&quot; &quot;</code>包围变量的值时,输出时会先解析里面的变量和命令,而不是把双引号中的变量名和命令原样输出.
这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义.</p>
<p>我的建议:
如果变量的内容是数字,那么可以不加引号;
如果真的需要原样输出就加单引号;
其他没有特别要求的字符串等最好都加上双引号,定义变量时加双引号是最常见的使用场景.</p>
<h3 id="将命令的结果赋值给变量"><a class="header" href="#将命令的结果赋值给变量">将命令的结果赋值给变量</a></h3>
<p><code>Shell</code> 也支持将命令的执行结果赋值给变量,常见的有以下两种方式:</p>
<pre><code class="language-bash">variable=`command`
variable=$(command)
</code></pre>
<p>第一种方式把命令用反引号<code> </code>(位于 <code>Esc</code> 键的下方)包围起来,反引号和单引号非常相似,容易产生混淆,所以不推荐使用这种方式;
第二种方式把命令用<code>$()</code>包围起来,区分更加明显,所以推荐使用这种方式.</p>
<p>例如,我在 <code>demo</code> 目录中创建了一个名为 <code>log.txt</code> 的文本文件,用来记录我的日常工作.
下面的代码中,使用 <code>cat</code> 命令将 <code>log.txt</code> 的内容读取出来,并赋值给一个变量,然后使用 <code>echo</code> 命令输出.</p>
<pre><code class="language-bash">[mozhiyan@localhost ~]$ cd demo
[mozhiyan@localhost demo]$ log=$(cat log.txt)
[mozhiyan@localhost demo]$ echo $log
严长生正在编写Shell教程,教程地址:http://c.biancheng.net/shell/
[mozhiyan@localhost demo]$ log=`cat log.txt`
[mozhiyan@localhost demo]$ echo $log
严长生正在编写Shell教程,教程地址:http://c.biancheng.net/shell/
</code></pre>
<h3 id="只读变量"><a class="header" href="#只读变量">只读变量</a></h3>
<p>使用 <code>readonly</code> 命令可以将变量定义为只读变量,只读变量的值不能被改变.</p>
<p>下面的例子尝试更改只读变量,结果报错:</p>
<pre><code class="language-bash">#!/bin/bash
myUrl=&quot;http://c.biancheng.net/shell/&quot;
readonly myUrl
myUrl=&quot;http://c.biancheng.net/shell/&quot;

运行脚本,结果如下:
bash: myUrl: This variable is read only.
</code></pre>
<h3 id="删除变量"><a class="header" href="#删除变量">删除变量</a></h3>
<p>使用 <code>unset</code> 命令可以删除变量.语法:</p>
<pre><code class="language-bash">unset variable_name
</code></pre>
<p>变量被删除后不能再次使用; <code>unset</code> 命令不能删除只读变量.</p>
<p>举个例子:</p>
<pre><code class="language-bash">#!/bin/sh
myUrl=&quot;http://c.biancheng.net/shell/&quot;
unset myUrl
echo $myUrl
</code></pre>
<p>上面的脚本没有任何输出.</p>
<h3 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h3>
<p>运行<code>shell</code>时,会同时存在三种变量:</p>
<ol>
<li><strong>局部变量</strong> 局部变量在脚本或命令中定义,仅在当前shell实例中有效,其他shell启动的程序不能访问局部变量.</li>
<li><strong>环境变量</strong> 所有的程序,包括shell启动的程序,都能访问环境变量,有些程序需要环境变量来保证其正常运行.必要的时候shell脚本也可以定义环境变量.</li>
<li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量.shell变量中有一部分是环境变量,有一部分是局部变量,这些变量保证了shell的正常运行</li>
</ol>
<h2 id="shell-字符串"><a class="header" href="#shell-字符串">Shell 字符串</a></h2>
<p>字符串是<code>shell</code>编程中最常用最有用的数据类型(除了数字和字符串,也没啥其它类型好用了),字符串可以用单引号,也可以用双引号,也可以不用引号.单双引号的区别跟PHP类似.</p>
<h3 id="单引号"><a class="header" href="#单引号">单引号</a></h3>
<pre><code class="language-bash">str='this is a string'
</code></pre>
<p>单引号字符串的限制:</p>
<ul>
<li>单引号里的任何字符都会原样输出,单引号字符串中的变量是无效的;</li>
<li>单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行),但可成对出现,作为字符串拼接使用.</li>
</ul>
<h3 id="双引号"><a class="header" href="#双引号">双引号</a></h3>
<pre><code class="language-bash">your_name='runoob'
str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;
echo -e $str
out: Hello, I know you are &quot;runoob&quot;!
</code></pre>
<p>双引号的优点:</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3 id="拼接字符串"><a class="header" href="#拼接字符串">拼接字符串</a></h3>
<pre><code class="language-bash">your_name=&quot;runoob&quot;
# 使用双引号拼接
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting  $greeting_1
out: hello, runoob ! hello, runoob !
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
out: hello, runoob ! hello, ${your_name} !
</code></pre>
<h3 id="获取字符串长度"><a class="header" href="#获取字符串长度">获取字符串长度</a></h3>
<pre><code class="language-bash">string=&quot;abcd&quot;
echo ${#string} #输出 4
</code></pre>
<h3 id="提取子字符串"><a class="header" href="#提取子字符串">提取子字符串</a></h3>
<p>以下实例从字符串第 <code>2</code> 个字符开始截取 <code>4</code> 个字符:</p>
<pre><code class="language-bash">string=&quot;runoob is a great site&quot;
echo ${string:1:4} # 输出 unoo
</code></pre>
<p>注意:第一个字符的索引值为 <code>0</code>.</p>
<h3 id="查找子字符串"><a class="header" href="#查找子字符串">查找子字符串</a></h3>
<p>查找字符 <code>i</code> 或 <code>o</code> 的位置(哪个字母先出现就计算哪个):</p>
<pre><code class="language-bash">string=&quot;runoob is a great site&quot;
echo $(expr index &quot;$string&quot; io)  # 输出 4
</code></pre>
<h3 id="shell-数组"><a class="header" href="#shell-数组">Shell 数组</a></h3>
<p><a href="https://www.w3cschool.cn/bashshell/bashshell-2ynf37ls.html">Bash 数组</a></p>
<p><code>bash</code>支持一维数组(不支持多维数组),并且没有限定数组的大小.</p>
<p>类似于 <code>C</code> 语言,数组元素的下标由 <code>0</code> 开始编号.
获取数组中的元素要利用下标,下标可以是整数或算术表达式,其值应大于或等于 <code>0</code>.
定义数组</p>
<p>在 <code>Shell</code> 中,用括号来表示数组,数组元素用&quot;空格&quot;符号分割开.定义数组的一般形式为:</p>
<pre><code class="language-bash">数组名=(值1 值2 ... 值n)
</code></pre>
<p>例如:</p>
<pre><code class="language-bash">array_name=(value0 value1 value2 value3)
</code></pre>
<p>或者</p>
<pre><code class="language-bash">array_name=(
value0
value1
value2
value3
)
</code></pre>
<p>还可以单独定义数组的各个分量:</p>
<pre><code class="language-bash">array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
</code></pre>
<p>可以不使用连续的下标,而且下标的范围没有限制.</p>
<h3 id="读取数组"><a class="header" href="#读取数组">读取数组</a></h3>
<p>读取数组元素值的一般格式是:</p>
<pre><code class="language-bash">${数组名[下标]}
</code></pre>
<p>例如:</p>
<pre><code class="language-bash">valuen=${array_name[n]}
</code></pre>
<p>使用 <code>@</code> 符号可以获取数组中的所有元素,例如:</p>
<pre><code class="language-bash">echo ${array_name[@]}
</code></pre>
<h3 id="获取数组的长度"><a class="header" href="#获取数组的长度">获取数组的长度</a></h3>
<p>获取数组长度的方法与获取字符串长度的方法相同,例如:</p>
<pre><code class="language-bash"># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
</code></pre>
<h3 id="shell-注释"><a class="header" href="#shell-注释">Shell 注释</a></h3>
<p>以 <code>#</code> 开头的行就是注释,会被解释器忽略.</p>
<p>通过每一行加一个 <code>#</code> 号设置多行注释,像这样:</p>
<pre><code class="language-bash">#--------------------------------------------
# 这是一个注释
# author:菜鸟教程
# site:www.runoob.com
# slogan:学的不仅是技术,更是梦想!
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
#
#
##### 用户配置区 结束  #####
</code></pre>
<p>如果在开发过程中,遇到大段的代码需要临时注释起来,过一会儿又取消注释,怎么办呢?</p>
<p>每一行加个<code>#</code>符号太费力了,可以把这一段要注释的代码用一对花括号括起来,定义成一个函数,
没有地方调用这个函数,这块代码就不会执行,达到了和注释一样的效果.</p>
<h3 id="多行注释"><a class="header" href="#多行注释">多行注释</a></h3>
<p>多行注释还可以使用以下格式:</p>
<pre><code class="language-bash">:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF

EOF 也可以使用其他符号:

:&lt;&lt;'
注释内容...
注释内容...
注释内容...
'

:&lt;&lt;!
注释内容...
注释内容...
注释内容...
!
</code></pre>
<h2 id="shell-传递参数"><a class="header" href="#shell-传递参数">Shell 传递参数</a></h2>
<p>传入脚本的参数,要用双引号保护起来<code>&quot;args&quot;</code>,防止变量的自动分字(word splitting)
也就是双层引号可以避免分字</p>
<p>与<code>mathematica</code>配合的时候,尽量把长参数放到 <code>mathematica</code>  脚本中,把短参数放到调用的<code>shell</code>中,结构化成一个关联的形式.</p>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<h2 id="shell-数组-1"><a class="header" href="#shell-数组-1">Shell 数组</a></h2>
<h3 id="实例-1"><a class="header" href="#实例-1">实例</a></h3>
<h3 id="shell中的数组作为参数传递"><a class="header" href="#shell中的数组作为参数传递">shell中的数组作为参数传递</a></h3>
<p><a href="https://blog.csdn.net/brouse8079/article/details/6417836">shell中的数组作为参数传递</a></p>
<p><code>./test.sh  &quot;${atest[@]}&quot;</code> 简而言之,需要把数组参数用引号括起来.</p>
<p>其中 <code>$0</code> 为执行的文件名(包含文件路径)</p>
<pre><code class="language-bash">#!/bin/bash

echo $1
echo $2
...
echo ${10}
</code></pre>
<hr />
<p>构造数组</p>
<pre><code class="language-bash">atest=(&quot;a&quot; &quot;bb cc&quot; &quot;dd ee ff&quot; &quot;gg hh ii jj&quot;)
</code></pre>
<hr />
<p>测试</p>
<p><code>atest</code>为数组.此时若把这个数组的内容作为参数调用另一个shell脚本时,写法很关键.</p>
<p>第一种写法:<code>./test.sh ${atest[@]}</code></p>
<p>执行结果:</p>
<pre><code class="language-bash">a
...
a0
</code></pre>
<p>此时传递的参数为<code>a bb cc dd ee ff gg hh ii jj</code>.把数组的内容组成了一个字符串,已经破坏了原来数组的结构.</p>
<p>第二种写法:<code>./test.sh  &quot;${atest[@]}&quot;</code></p>
<p>执行结果:</p>
<pre><code class="language-bash">a
bb cc
dd ee ff
gg hh ii jj
a0
</code></pre>
<p>把数组用双引号括起来,此时传递到<code>test.sh</code>中的参数仍然为数组的原来结构.</p>
<h2 id="环境变量-path"><a class="header" href="#环境变量-path">环境变量 path</a></h2>
<p><a href="https://www.cnblogs.com/crave/p/11818594.html">ubuntu 修改环境变量(PATH)</a></p>
<p>在Linux中,在执行命令时,系统会按照<code>PATH</code>的设置,去每个<code>PATH</code>定义的路径下搜索执行文件,先搜索到的文件先执行.</p>
<p>当我们在执行一个指令癿时候,举例来说&quot;ls&quot;好了,系统会依照PATH的设定去每个PATH定义的目录下搜寻文件名为ls 的可执行文件, 如果在PATH定义的目录中含有多个文件名为ls 的可执行文件,那么先搜寻到癿同名指令先被执行!</p>
<hr />
<p>如何改变PATH</p>
<ol>
<li>直接修改<code>$PATH</code>值:</li>
</ol>
<p>生效方法:立即生效
有效期限:临时改变,只能在当前的终端窗口中有效,当前窗口关闭后就会恢复原有的<code>path</code>配置
用户局限:仅对当前用户</p>
<p><code>echo $PATH //查看当前PATH的配置路径</code></p>
<p><code>export PATH=$PATH:/xxx/xxx //将需配置路径加入$PATH  等号两边一定不能有空格</code></p>
<p>配置完后可以通过第一句命令查看配置结果.</p>
<h3 id="通过修改bashrc文件"><a class="header" href="#通过修改bashrc文件">通过修改.bashrc文件</a></h3>
<p>有效期限:永久有效
用户局限:仅对当前用户</p>
<p><code>.bashrc</code>文件在根目录下</p>
<pre><code class="language-bash">vi .bashrc  //编辑.bashrc文件
//在最后一行添上:
export PATH=$PATH:/xxx/xxx  ///xxx/xxx位需要加入的环境变量地址 等号两边没空格
</code></pre>
<p>生效方法:(有以下两种)</p>
<ul>
<li>关闭当前终端窗口,重新打开一个新终端窗口就能生效</li>
<li>输入<code>source .bashrc</code>命令,立即生效</li>
</ul>
<h3 id="通过修改profile文件profile文件在etc目录下"><a class="header" href="#通过修改profile文件profile文件在etc目录下">通过修改profile文件:(profile文件在/etc目录下)</a></h3>
<p>生效方法:系统重启
有效期限:永久有效
用户局限:对所有用户</p>
<pre><code class="language-bash">vi /etc/profile //编辑profile文件
//在最后一行添上:
export PATH=$PATH:/xxx/xxx
</code></pre>
<h3 id="通过修改environment文件"><a class="header" href="#通过修改environment文件">通过修改environment文件</a></h3>
<p>生效方法:系统重启
有效期限:永久有效
用户局限:对所有用户</p>
<p>environment文件在<code>/etc</code>目录下</p>
<pre><code class="language-bash">vi /etc/profile //编辑profile文件
在PATH=/......中加入`:/xxx/xxx`
</code></pre>
<h2 id="运算符与括号用法"><a class="header" href="#运算符与括号用法">运算符与括号用法</a></h2>
<p><a href="https://www.jianshu.com/p/617c1ee1e46e">shell 中 &amp;&amp; || () {} 用法</a>
<a href="https://www.cnblogs.com/xunbu7/p/6187017.html">shell中$(( )) 与 $( ) 还有${ }的区别</a>
<a href="http://c.biancheng.net/view/954.html">小括号和大括号用法</a>
<a href="https://www.shell-tips.com/bash/math-arithmetic-calculation/">How To Do Calculation in Bash</a>
<a href="https://www.runoob.com/w3cnote/shell-summary-brackets.html">Shell 中的中括号用法总结</a>
<a href="https://blog.csdn.net/yifeng4321/article/details/70232436">linux shell 中判断文件,目录是否存在</a></p>
<h3 id="shell-算术逻辑运算符"><a class="header" href="#shell-算术逻辑运算符">shell 算术逻辑运算符</a></h3>
<ul>
<li><code>id++, id–</code>: 运算后, 变量自增自减运算符</li>
<li><code>++id, –id</code>:运算前, 变量自增自减运算符</li>
<li><code>-, +</code>:  加减一元运算符</li>
<li><code>!, ~</code>:  逻辑和按位取反</li>
<li><code>**</code>: 指数</li>
<li><code>*, /, %</code>: 乘除余数</li>
<li><code>+, -</code>:  加减</li>
<li><code>«, » </code>: 左右移位</li>
<li><code>&lt;=, &gt;=, &lt;, &gt;</code>:  比较运算</li>
<li><code>==, !=</code>:  等于, 不等于</li>
<li><code>&amp;</code>:  按位 AND</li>
<li><code>^</code>:  按位 XOR</li>
<li><code>|</code>:  按位 OR</li>
<li><code>&amp;&amp;</code>:  逻辑 AND</li>
<li><code>||</code>:  逻辑 OR</li>
<li><code>expr1 ? expr2 : expr3</code>:  条件运算</li>
<li><code>=, *=, /=, %=, +=, -=, «=, »=, &amp;=, ^=, |=</code>: 赋值</li>
</ul>
<p>使用<code>pstree</code>可以查看进程树. 知道了<code>父Shell</code> 和<code>子Shell</code>, 我们接着解释小括号和大括号的区别. 如果用于一串命令的执行, 那么小括号和大括号主要区别在于:</p>
<p><code>{}</code>是<code>shell</code>的保留字.</p>
<ul>
<li><code>()</code> 在子Shell执行代码块, <code>{}</code>在<code>当前Shell</code>执行代码块.</li>
<li><code>()</code> 和 <code>{}</code> 都用<code>;</code>隔开命令. <code>{}</code>与命令之间需要用空格分隔, 而<code>()</code>开头结尾不需要空格.</li>
<li><code>{}</code> 最末条命令要用分号结束, <code>()</code> 的最末命令不需要分号.</li>
<li><code>()</code> 和 <code>{}</code> 内部某个命令的重定向只影响该命令, 但括号外部的重定向则会影响到括号内的所有命令.</li>
</ul>
<h3 id="括号总结"><a class="header" href="#括号总结">括号总结</a></h3>
<hr />
<p>命令成组, 用 <code>()</code> 或者 <code>{  }</code></p>
<pre><code class="language-bash">&gt; A=1; echo $A; { A=2 }; echo $A
1
2
&gt; A=1; echo $A; (A=2); echo $A
1
1
</code></pre>
<p>在使用<code>{  }</code>时,<code>{  }</code>与命令之间必须使用一个<code>空格</code></p>
<hr />
<p><code>$( )</code>命令替换</p>
<p><code>$( )</code> 与 `` (反引号) 都是用来做命令替换</p>
<hr />
<p><code>${ }</code> 变量替换,各种字符串功能</p>
<p><code>${ }</code> 用来作变量替换,把括号里的变量代入值.</p>
<hr />
<p><code>$(( ))</code>整数算术</p>
<p>在 bash 中,<code>$(( ))</code> 的整数运算符号大致有这些:</p>
<ul>
<li><code>+ - * /</code> :分别为 &quot;加,减,乘,除&quot;.</li>
<li><code>%</code> :余数运算</li>
<li><code>&amp; | ^ !</code>:分别为 &quot;<code>AND</code>,<code>OR</code>,<code>XOR</code>,<code>NOT</code>&quot; 运算.</li>
</ul>
<h3 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h3>
<hr />
<p>&amp;&amp;运算符语法格式如下:</p>
<pre><code class="language-bash">command1 &amp;&amp; command2 &amp;&amp; command3 ...
</code></pre>
<p><code>command1  &amp;&amp; command2</code>: <code>command1</code>返回真, 才执行<code>command2</code>, 如果<code>command1</code>为假, 不执行<code>command2</code>.</p>
<p>示例1中,<code>cp</code>命令首先从<code>root</code>的家目录复制文件文件<code>anaconda-ks.cfg</code>到 <code>/data</code>目录下;
执行成功后,使用 <code>rm</code> 命令删除源文件; 如果删除成功则输出提示信息&quot;<code>SUCCESS</code>&quot;.</p>
<p><code>cp anaconda-ks.cfg /data/ &amp;&amp; rm -f anaconda-ks.cfg &amp;&amp; echo &quot;SUCCESS&quot;</code></p>
<hr />
<p><code>||</code>运算符:</p>
<pre><code class="language-bash">command1 || command2
</code></pre>
<p><code>||</code>则与<code>&amp;&amp;</code>相反.如果<code>command1</code>未执行成功,那么就执行<code>command2</code>; 如果<code>command1</code>执行成功, 就不执行<code>command2</code>
这和C语言中的逻辑或语法功能相同,即实现短路逻辑或操作.只要有一个命令返回真(命令返回值 <code>$? == 0</code>),后面的命令就不会被执行.</p>
<p>例如: 若<code>dir</code>目录不存在,将输出提示信息<code>fail</code> .</p>
<pre><code class="language-bash">ls dir &amp;&gt;/dev/null || echo &quot;fail&quot;
</code></pre>
<p>如果 <code>dir</code> 目录存在,将输出 <code>success</code> 提示信息; 否则输出 <code>fail</code> 提示信息.</p>
<pre><code class="language-bash">ls dir &amp;&gt;/dev/null &amp;&amp; echo &quot;fail&quot; || echo &quot;fail&quot;
</code></pre>
<hr />
<p><code>&amp;&gt;</code> 的意思是重定向标准输出和错误到 同一个地方,如</p>
<pre><code class="language-bash">ls -l /bin/usr &amp;&gt; ls-output.txt
</code></pre>
<p>利用<code>/dev/null</code>处理不需要的输出,这个文件是系统设备,叫做位存储桶,它可以 接受输入,并且对输入不做任何处理.</p>
<hr />
<p>下面是一个<code>shell</code>脚本中常用的<code>||</code>组合示例</p>
<pre><code class="language-bash">echo $BASH | grep -q 'bash' || { exec bash &quot;$0&quot; &quot;$@&quot; || exit 1; }
</code></pre>
<p>系统调用<code>exec</code>是以新的进程去代替原来的进程,但进程的<code>PID</code>保持不变.
因此,可以这样认为,<code>exec</code>系统调用并没有创建新的进程,只是替换了原来进程上下文的内容. 原进程的代码段,数据段,堆栈段被新的进程所代替.</p>
<h3 id="代码段"><a class="header" href="#代码段">(){}代码段</a></h3>
<p>如果希望把几个命令合在一起执行, <code>shell</code> 提供了两种方法. 既可以在<code>当前shell</code>, 也可以在<code>子shell</code>中执行.</p>
<p>格式:</p>
<pre><code class="language-bash">(命令1;命令2;命令3....)        # 命令用;分隔, 或者每个命令放到单独的一行. 在子shell中执行, 不影响当前shell的变量
{ command1;command2;command3...  } #在当前shell执行, 会影响当前shell的变量
</code></pre>
<p><code>()</code> 表示在<code>子shell </code>中将多个命令作为一个整体执行. 例如 <code>(cd ~/Downloads)</code> 执行完毕后, 当前shell的目录不会切换到<code>~/Downloads</code>.
而<code>{ cd ~/Downloads }</code>会切换到<code>~/Downloads</code>, 注意<code>{}</code>中, 命令开头和结尾必须用空格隔开.</p>
<p>命令组合常和命令执行控制结合起来使用.比如如果目录<code>dir</code>不存在,则执行命令组合.</p>
<pre><code class="language-bash">ls dir &amp;&gt;/dev/null || (cd /home/; ls -lh; echo &quot;success&quot;)
ls dir &amp;&gt;/dev/null || { cd /home/; ls -lh; echo &quot;success&quot; }
</code></pre>
<p>另外,<code>{}</code>可以用来做花括号展开,例如:</p>
<pre><code class="language-bash">echo Front-{A,B,C}-Back
echo Number_{1..5}
echo {Z..A}
echo aa{A{1,2},B{3,4}}bb
</code></pre>
<p>开头称为报头,结尾称为附言,中间包含由逗号分开的字符串或整数列表,不能包含空白. 还可以使用范围, 可以嵌套.</p>
<h3 id="--命令替换"><a class="header" href="#--命令替换">$( ) 命令替换</a></h3>
<p><code>$( )</code> 与 两个反引号(backtick), 均可以用来做命令替换, 但一般不建议用反引号, 也就是ESC下面那个按键.</p>
<p><code>$( )</code> 的优点: 反引号容易与单引号搞混,尤其对于初学者来说; 在多层次的复合替换中,<code>backtick</code> 须要额外的跳脱处理,而 <code>$( )</code> 则比较直观.
<code>$( )</code> 的不足: 反引号基本上可用在全部的 <code>unix shell</code> 中使用,若写成 <code>shell script</code> ,其移植性比较高.</p>
<h3 id="-花括号展开"><a class="header" href="#-花括号展开">${} 花括号展开</a></h3>
<p><code>${ }</code> 用来作变量替换,把括号里的变量代入值.</p>
<p>以上的理解在于, 你一定要分清楚 <code>unset</code> 与 <code>null</code> 及 <code>non-null</code> 这三种赋值状态.
一般而言, <code>:</code> 与 <code>null</code> 有关, 若不带 <code>:</code> 的话, null 不受影响, 若带 <code>:</code> 则连 null 也受影响.</p>
<p>还有哦,<code>${#var}</code> 可计算出变量值的长度:
<code>${#file}</code> 可得到 <code>27</code> ,因为 <code>/dir1/dir2/dir3/my.file.txt</code> 刚好是 <code>27</code> 个字节...</p>
<hr />
<p>接下来,再为大家介稍一下 <code>bash</code> 的组数(<code>array</code>)处理方法.</p>
<p>一般而言,<code>A=&quot;a b c def&quot;</code> 这样的变量只是将 <code>$A</code> 替换为一个单一的字符串,
但是改为 <code>A=(a b c def) </code>,则是将 <code>$A</code> 定义为组数...</p>
<p>bash 的组数替换方法可参考如下方法:</p>
<ul>
<li><code>${A[@]}</code> 或 <code>${A[*]}</code> 可得到 <code>a b c def</code> (全部组数)</li>
<li><code>${A[0]}</code> 可得到 <code>a</code> (第一个组数),${A[1]} 则为第二个组数...</li>
<li><code>${#A[@]}</code> 或 <code>${#A[*]}</code> 可得到 <code>4</code> (全部组数数量)</li>
<li><code>${#A[0]}</code> 可得到 <code>1</code> (即第一个组数(<code>a</code>)的长度),<code>${#A[3]}</code> 可得到 <code>3</code> (第四个组数(def)的长度)</li>
<li><code>A[3]=xyz</code> 则是将第四个组数重新定义为 <code>xyz</code> ...</li>
</ul>
<h3 id="-算术展开"><a class="header" href="#-算术展开">(()) 算术展开</a></h3>
<p><code>$(( 算术表达式 ))</code>称为算术展开, <code>((...))</code>称为复合命令, 它返回最后一个表达式的值, 它只能计算整数算术. 括号<code>(())</code>和<code>==</code>等操作符周围都不需要空格.</p>
<ul>
<li><code>+ - * /</code> :分别为加,减,乘,除.</li>
<li><code>%</code> :余数运算</li>
<li><code>&lt;&lt;</code>: 左移</li>
<li><code>&gt;&gt;</code>: 右移</li>
<li><code>&amp;</code>: 按位与</li>
<li><code>|</code>: 按位或</li>
<li><code>~</code>: 按位非</li>
<li><code>^</code>: 按位异或</li>
<li><code>&amp; | ^ !</code>:分别为 <code>AND</code>,<code>OR</code>,<code>XOR</code>,<code>NOT</code> 的位运算.</li>
</ul>
<p>其中<code>XOR</code>表示<code>exclusive OR</code>:一样为<code>0</code>,不一样为<code>1</code>,相当于不考虑进位的加法. 例:</p>
<pre><code class="language-bash">$ a=5; b=7; c=2
$ echo $(( a+b*c ))
19
$ echo $(( (a+b)/c ))
6
$ echo $(( (a*b)%c))
1
</code></pre>
<p><code>$(( ))</code> 中可以做变量替换,  <code>$变量名称</code>将替换成变量的值, 可以省略<code>$</code>, 如:<code>$(( $a + $b * $c))</code> 也可得到 <code>19</code> 的结果.
此外,<code>$(( ))</code> 还可作不同进位(如二进制,八进位,十六进制)作运算,只是,输出结果皆为十进制:</p>
<pre><code class="language-bash">echo $((16#2a)) 结果为 42 (16进位转十进制)
</code></pre>
<p>以一个实用的例子来看看吧:</p>
<p>假如当前的   <code>umask</code> 是 <code>022</code> ,那么新建文件的权限即为:</p>
<pre><code class="language-bash">$ umask 022
$ echo &quot;obase=8;$(( 8#666 &amp; (8#777 ^ 8#$(umask)) ))&quot; | bc
644
</code></pre>
<p>事实上,单纯用 <code>(( ))</code> 也可重定义变量值,或作 <code>testing</code>:</p>
<ul>
<li><code>a=5; ((a++))</code> 可将 <code>$a</code> 重定义为 <code>6</code></li>
<li><code>a=5; ((a–))</code> 则为 <code>a=4</code></li>
<li><code>a=5; b=7; ((a &lt; b))</code> 会得到   <code>0</code> (<code>true</code>) 的返回值.</li>
</ul>
<p>用于 <code>(( ))</code> 的比较运算符:</p>
<ul>
<li><code>&lt;</code>:小于</li>
<li><code>&gt;</code>:大于</li>
<li><code>&lt;=</code>:小于或等于</li>
<li><code>&gt;=</code>:大于或等于</li>
<li><code>==</code>:等于</li>
<li><code>!=</code>:不等于</li>
</ul>
<h3 id="文件系统测试bash-test"><a class="header" href="#文件系统测试bash-test">[],文件系统测试,bash test</a></h3>
<p><code>test</code>和<code>[</code>基本是同一个 <code>shell</code> 内置命令. <code>test</code>  检查文件系统, 或者比较两个值的关系(数字或者字符串)</p>
<ul>
<li>算术比较.比如一个变量是否为<code>0</code>, <code>[ $var -eq 0 ]</code>.</li>
<li>文件属性测试. 比如一个文件是否存在,<code>[ -e $var ]</code>, 是否是目录,<code>[ -d $var ]</code>.</li>
<li>字符串比较. 比如两个字符串是否相同, <code>[[ $var1 = $var2 ]]</code>.</li>
</ul>
<p>语法:</p>
<pre><code class="language-bash">test 表达式
test
[ 表达式 ]
[ ]
[ OPTION
</code></pre>
<p>需要注意的是 <code>[</code> 与 <code>]</code> 与操作数之间一定要有一个空格,否则会报错.比如下面这样就会报错: <code>[$var -eq 0 ]</code>  或 <code>[ $var -ne 0]</code>.</p>
<p><code>Shell</code> 还提供了与<code>-a</code> , 或<code>-o</code>, 非<code>!</code>三个逻辑操作符用于将测试条件连接起来, 其优先级为:  <code>!</code> 最高,  <code>-a</code> 次之,  <code>-o</code> 最低.  例如:</p>
<p><code>[ $var1 -ne 0 -a $var2 -gt 2 ]</code>  # 使用逻辑与 <code>-a</code>
<code>[ $var1 -ne 0 -o $var2 -gt 2 ]</code>  # 使用逻辑或 <code>-o</code></p>
<h4 id="各种测试"><a class="header" href="#各种测试">各种测试</a></h4>
<p>如果省略了<code>EXPRESSION</code>, 则默认为<code>false</code>.  否则, <code>EXPRESSION为</code>真或假, 并设置返回状态.</p>
<ul>
<li>
<p><code>( EXPRESSION )</code>:EXPRESSION为真</p>
</li>
<li>
<p><code>! EXPRESSION</code>: EXPRESSION 为假</p>
</li>
<li>
<p><code>EXPRESSION1 -a EXPRESSION2</code>: EXPRESSION1和EXPRESSION2都是真.</p>
</li>
<li>
<p><code>EXPRESSION1 -o EXPRESSION2</code>: EXPRESSION1或EXPRESSION2为真.</p>
</li>
<li>
<p><code>[[-n STRING]]</code>: <code>STRING</code> 的长度为非零. <code>STRING</code> 相当于<code>-n STRING</code>, 可以用来判断环境变量是否存在</p>
</li>
<li>
<p><code>[[-z STRING]]</code>: 表示 <code>STRING</code> 的长度为零</p>
</li>
<li>
<p><code>[[string1 = string2]]</code>: 字符串是相等的</p>
</li>
<li>
<p><code>[[string1 != string2]]</code>: 字符串不相等</p>
</li>
<li>
<p><code>[INTEGER1 -eq INTEGER2]</code>: <code>INTEGER1</code>等于<code>INTEGER2</code></p>
</li>
<li>
<p><code>[INTEGER1 -ge INTEGER2]</code>: 大于或等于</p>
</li>
<li>
<p><code>[INTEGER1 -gt INTEGER2]</code>: 大于</p>
</li>
<li>
<p><code>[INTEGER1 -le INTEGER2]</code>: 小于或等于</p>
</li>
<li>
<p><code>[INTEGER1 -lt INTEGER2]</code>:小于</p>
</li>
<li>
<p><code>[INTEGER1 -ne INTEGER2]</code>:不等于</p>
</li>
<li>
<p><code>[FILE1 -ef FILE2]</code>: <code>FILE1</code>和<code>FILE2</code>有相同的设备号和节点号</p>
</li>
<li>
<p><code>[FILE1 -nt FILE2]</code>: <code>FILE1</code>比<code>FILE2</code>要新(修改日期).</p>
</li>
<li>
<p><code>[FILE1 -ot FILE2]</code>: <code>FILE1</code> 比<code>FILE2</code>老</p>
</li>
<li>
<p><code>[-b FILE]</code>: <code>FILE</code>存在并且是块类型</p>
</li>
<li>
<p><code>[-c FILE]</code>: <code>FILE</code>存在, 并且是字符类型</p>
</li>
<li>
<p><code>[-d FILE]</code>: <code>FILE</code>存在并且是一个目录</p>
</li>
<li>
<p><code>[-e FILE]</code>: <code>FILE</code>存在.</p>
</li>
<li>
<p><code>[-f FILE]</code>: <code>FILE</code>存在并且是一个普通文件.</p>
</li>
<li>
<p><code>[-g FILE]</code>:<code>FILE</code>存在并且是<code>set-group-ID</code>.</p>
</li>
<li>
<p><code>[-G FILE]</code>: <code>FILE</code>存在并且被有效的组ID所拥有</p>
</li>
<li>
<p><code>[-h FILE]</code>: <code>FILE</code>存在并且是一个符号链接(与-L相同).</p>
</li>
<li>
<p><code>[-k FILE]</code>:<code>FILE</code>存在, 并且其<code>sticky bit </code>被设置.</p>
</li>
<li>
<p><code>[-L FILE]</code>:<code>FILE</code>存在并且是一个符号链接(与-h相同).</p>
</li>
<li>
<p><code>[-O FILE]</code>: <code>FILE</code>存在并且被有效的用户<code>ID</code>所拥有</p>
</li>
<li>
<p><code>[-p FILE]</code>:<code>FILE</code>存在, 并且是一个命名的管道</p>
</li>
<li>
<p><code>[-r FILE]</code>:<code>FILE</code>存在并且被授予读取权限</p>
</li>
<li>
<p><code>[-s FILE]</code>:<code>FILE</code>存在并且大小大于<code>0</code></p>
</li>
<li>
<p><code>[-S FILE]</code>:<code>FILE</code>存在并且是一个套接字</p>
</li>
<li>
<p><code>[-t FD]</code>: 文件描述符<code>FD</code>在一个终端上被打开.</p>
</li>
<li>
<p><code>[-u FILE]</code>:<code>FILE</code>存在并且其<code>set-user-ID</code>位被设置</p>
</li>
<li>
<p><code>[-w FILE]</code>:<code>FILE</code>存在并且被授予写权限</p>
</li>
<li>
<p><code>[-x FILE]</code>:<code>FILE</code>存在, 并且被授予执行(或搜索)权限</p>
</li>
</ul>
<p>除了<code>-h</code>和<code>-L</code>之外, 所有与<code>FILE</code>相关的测试都会对符号链接<code>dereference</code>.
注意, 对于<code>shells</code>来说, 小括号需要被转义(<code>\(  \)</code>).  <code>INTEGER</code>也可以是<code>-l STRING</code>, 它被运算为<code>STRING</code>的长度.</p>
<p>注意: 二元的<code>-a</code>和<code>-o</code>本身有歧义.  使用<code>test EXPR1 &amp;&amp; test EXPR2</code>或<code>test EXPR1 || test EXPR2</code>代替.
注意: <code>[</code> 具有 <code>--help</code> 和 <code>--version</code> 选项, 但 <code>test</code> 不具有. <code>test</code> 对这些选项的处理与对其他非空字符串的处理相同.
注意: 你的shell可能有自己的<code>test</code>或<code>[</code>的版本, 它通常取代这里描述的版本.  关于它所支持的选项的细节, 请参考你的shell的文档.</p>
<p>例子:</p>
<pre><code class="language-bash"># 如果 filename 存在,则为真
if [ -e filename ]; then echo &quot;true&quot;;fi
# 如果存在某文件,则删除
if [ -f trials ]; then rm ${result_path}trials; fi
# 如果没有文件夹,则创建
if [ ! -d $result_name ];then mkdir -p $result_name;fi
</code></pre>
<blockquote>
<p>注意: <code>bash</code>在变量代入时比较粗犷, 最好用双引号把<code>变量</code>裹住, 例如:</p>
</blockquote>
<pre><code class="language-bash">abc=&quot;hello xx&quot;; if test &quot;hello&quot; != &quot;$abc&quot;; then  echo &quot;Your word is not 'hello'.&quot;; fi
</code></pre>
<p>变量 <code>abc</code> 的值为<code>hello xx</code>, 在字符串中间有个空格. 如果不用引号保护起来, <code>bash</code>解释上面的命令时, 会将<code>test</code> 命令解释成:</p>
<pre><code class="language-bash">test &quot;hello&quot; != hello xx
</code></pre>
<p>这不是一个合法的 <code>test</code> 命令, 所以脚本执行时就会报错.
其实不光是空格, 包含在 <code>$IFS </code>(internal field separator)中的其它字符, 以及空变量, 都会造成语法错误.
所以使用双引号包裹变量是一种保护机制, 可以提高脚本的健壮性. 但是在<code>zsh</code>中可以不用引号包裹, <code>zsh</code>和<code>bash</code>的分词机制不同.</p>
<h3 id="-字符串比较"><a class="header" href="#-字符串比较">[[ ]]字符串比较</a></h3>
<p>在进行字符串比较时,最好使用双中括号 <code>[[ ]]</code>. 因为单中括号可能会导致一些错误, 因此最好避开它们.</p>
<p>检查两个字符串是否相同:</p>
<pre><code class="language-bash">[[ $str1 == $str2 ]]
</code></pre>
<p>当 <code>str1</code> 等于 <code>str2</code> 时,返回真.也就是说, <code>str1</code> 和 <code>str2</code> 包含的文本是一样的.
其中的双等于号也可以写成单等于号,也就是说,上面的字符串比较等效于 <code>[[ $str1 = $str2 ]]</code>.
注意 <code>=</code> 前后有一个<code>空格</code>,如果忘记加空格, 就变成了赋值语句,而非比较关系了.
字符串比较,<code>[[</code>,<code>]]</code>,<code>==</code>周围必须都有空格,中括号比较时,变量必须写成如<code>$a</code>的形式.</p>
<p>字符串的其他比较情况:</p>
<ul>
<li><code>[[ $str1 != $str2 ]]</code>   如果 <code>str1</code> 与 <code>str2</code> 不相同,则返回真</li>
<li><code>[[ -z $str1 ]]</code>   如果 <code>str1</code> 是<code>null</code>字符串,则返回真</li>
<li><code>[[ -n $str1 ]]</code>   如果 <code>str1</code> 是非<code>null</code>字符串,则返回真</li>
</ul>
<p>使用逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 可以轻松地将多个条件组合起来, 比如:</p>
<pre><code class="language-bash">str1=&quot;Not empty&quot;
str2=&quot;&quot;
if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]];
then
  echo str1 is nonempty and str2 is empty string.
fi
</code></pre>
<p><code>test</code> 命令也可以从来执行条件检测,用 <code>test</code> 可以避免使用过多的括号,<code>[]</code> 中的测试条件同样可以通过 <code>test</code> 来完成.</p>
<pre><code class="language-bash">if [ $var -eq 0 ]; then echo &quot;True&quot;; fi
# 等价于:
if test $var -eq 0; then echo &quot;True&quot;; fi
</code></pre>
<h3 id="declare"><a class="header" href="#declare">declare</a></h3>
<p><a href="https://www.w3cschool.cn/bashshell/bashshell-2ynf37ls.html">Bash 数组</a></p>
<pre><code class="language-bash">declare: declare [-aAfFgilnrtux] [-p] [name[=value] ...]
</code></pre>
<p><code>declare</code>用来设置变量的值和属性. 声明变量并赋予其属性.  如果没有给出<code>NAME</code>,  显示所有变量的属性和值.</p>
<p>选项:</p>
<ul>
<li><code>-f</code>:  只将动作或显示作用在函数类的名称和定义上</li>
<li><code>-F</code>: 限制只显示函数名(调试时加上行号和源文件)</li>
<li><code>-g</code>: 用于<code>shell</code>函数时, 创建局变量; 否则忽略此选项</li>
<li><code>-p</code>:  显示每个<code>NAME</code>的属性和值</li>
</ul>
<p>设置属性的选项:</p>
<ul>
<li><code>-a</code>: 使<code>NAME</code>成为索引数组(如果支持)</li>
<li><code>-A</code>: 使<code>NAME</code>成为关联数组(如果支持)</li>
<li><code>-i</code>: 使<code>NAME</code>具有 &quot;整数 &quot;属性</li>
<li><code>-l</code>: 在赋值时将每个<code>NAME</code>的值转换为小写.</li>
<li><code>-n</code>: 以值命名的变量,把<code>NAME</code>当成它的引用</li>
<li><code>-r</code>: 使<code>NAME</code>成为只读变量</li>
<li><code>-t</code>: 使<code>NAME</code>具有 <code>trace</code>属性</li>
<li><code>-u</code>: 在赋值时将每个<code>NAME</code>的值转换为大写字母</li>
<li><code>-x</code>: 使<code>NAME</code>输出.</li>
</ul>
<p>因为命令行选项用<code>-</code>开头, 跟通常相反, 使用<code>+</code>关闭指定的属性.
带有整数属性的变量, 在赋值的时候会先进行算术计算(见<code>let</code>命令).
当在一个函数中使用时, <code>declare</code>使<code>NAME</code>成为局部的, 就像<code>local</code>命令那样. <code>-g</code>选项抑制这种行为.</p>
<hr />
<ul>
<li><code>-a</code>选项指定索引数组, 索引从0开始. <code>=</code>两侧无空格.</li>
<li><code>-A</code>选项指定关联数组.</li>
<li><code>${Array_Name[index]}</code>: 获取数组元素. 使用<code>@</code>或<code>*</code>作为索引,可以得到数组中的所有元素.</li>
<li><code>${!Array_Name[index]}</code>: 打印数组中的键使用</li>
<li><code>${#ARRAY_NAME[@]}</code>: 获取数组长度.</li>
<li><code>for i in ${arr[@]}; do echo $i;done</code>: 遍历数组的值</li>
<li><code>for i in &quot;${!arr[@]}&quot;;  do   echo $i;    done</code>: 遍历数组的键.</li>
<li><code>arr[4]=&quot;JavaScript&quot;</code>: 增加元素.</li>
<li><code>unset arr[1]</code>: 删除数组元素</li>
<li><code>unset arr</code> :删除数组</li>
<li><code> arr2=(&quot;${arr[@]:m:n}&quot;)</code>: 获取数组切片</li>
</ul>
<p>举例:</p>
<pre><code class="language-bash">declare -a x=(a b c d e);declare -a y=([0]=a [2]=c [3]=f [4]=k);
declare -p x y;echo ${x[2]};
echo '删除数组'; declare -a arr=( &quot;Java&quot; &quot;Python&quot; &quot;HTML&quot; &quot;CSS&quot; &quot;JavaScript&quot; );unset arr;echo ${!arr[@]};
echo '数组的键'; declare -a arr=( &quot;Welcome&quot; &quot;To&quot; &quot;W3Cschool&quot; );echo &quot;${!arr[@]}&quot;;
echo '数组的长度';echo ${#arr[@]};echo ${#arr[*]};
echo '遍历数组'; for i in &quot;${!arr[@]}&quot;; do echo The key value of element &quot;${arr[$i]}&quot; is &quot;$i&quot;; done;
echo '数组切片';arr=( &quot;Java&quot; &quot;Python&quot; &quot;HTML&quot; &quot;CSS&quot; &quot;JavaScript&quot; );arr2=(&quot;${example_array[@]:1:3}&quot;); declare -p arr2;
</code></pre>
<hr />
<p><code>@</code>和<code> *</code>两者的区别:</p>
<pre><code class="language-bash">declare -a arr=(&quot;welcome&quot; &quot;to&quot; &quot;W3Cschool&quot;)
echo &quot;@&quot;;for i in &quot;${arr[@]}&quot;;do echo &quot;$i&quot;;done;
echo &quot;*&quot;;for i in &quot;${arr[*]}&quot;;do echo &quot;$i&quot;;done;
</code></pre>
<h3 id="local"><a class="header" href="#local">local</a></h3>
<pre><code class="language-bash">local: local [option] name[=value] ...
</code></pre>
<p><code>local</code>定义局部变量. 它的选项和<code>declare</code>相同. <code>local</code>变量只在定义的函数内可用, 它只对此函数和子函数可见.</p>
<h2 id="字符串和数字"><a class="header" href="#字符串和数字">字符串和数字</a></h2>
<p>commandline chapter 35</p>
<p>在这一章中,我们将查看几个用来操作字符串和数字的 shell 功能.
shell 提供了各种执行字符串操作的参数展开功能.
除了算术展开(在第七章中接触过),还有一个常见的命令行程序叫做 <code>bc</code>,能执行更高级别的数学运算.</p>
<h3 id="字符串总结"><a class="header" href="#字符串总结">字符串总结</a></h3>
<p>parameter 前面可能出现的保留字,<code>!</code>, <code>#</code>
parameter 后面可能接的保留字,<code>:</code> <code>#</code> <code>%</code> <code>/</code></p>
<ul>
<li>返回变量名的参数展开</li>
<li><code>${!prefix*}</code> :这种展开会返回以 <code>prefix</code> 开头的已有变量名</li>
<li><code>${#parameter}</code> :展开成由 parameter 所包含的字符串的长度.</li>
<li>空变量的展开</li>
<li><code>${parameter:-word}</code> :若 parameter 没有设置(例如,不存在)或者为空,展开结果是 word 的值</li>
<li><code>${parameter:=word}</code> :若 parameter 没有设置或为空,展开结果是 word 的值.另外,word 的值会赋值给 parameter.</li>
<li><code>${parameter:?word}</code>:若 parameter 没有设置或为空,这种展开导致脚本带有错误退出,并且 word 的内容会发送到标准错误.</li>
<li><code>${parameter:+word}</code>:若 parameter 为空,结果为空.若 parameter 不为空, word 的值; parameter 的值不改变.</li>
<li>字符串展开</li>
<li><code>${parameter:offset}</code> :从 <code>parameter</code> 所包含的字符串中提取一部分字符,到结尾</li>
<li><code>${parameter:offset:length}</code> :从 <code>parameter</code> 所包含的字符串中提取一部分字符,<code>length</code>制定长度</li>
<li>字符串修剪</li>
<li><code>${parameter#pattern}</code> :从 <code>paramter</code> 所包含的字符串中清除开头的<code>pattern</code></li>
<li><code>${parameter##pattern}</code> :## 模式清除最长的匹配结果.</li>
<li><code>${parameter%pattern}</code> :清除 <code>parameter</code> 末尾所包含的<code>pattern</code></li>
<li><code>${parameter%%pattern}</code> :%% 模式清除最长的匹配结果.</li>
<li>字符串查找和替换操作 <code>parameter</code>必须是一个变量 <code>pattern</code> 和 <code>string</code> 可以不加引号</li>
<li><code>${parameter/pattern/string}</code> :如果找到了匹配通配符 <code>pattern</code> 的文本, 则用 <code>string</code> 的内容替换它.</li>
<li><code>${parameter//pattern/string}</code> : <code>//</code> 形式下,所有的匹配项都会被替换掉</li>
<li><code>${parameter/#pattern/string}</code> :<code>/#</code>要求匹配项出现在字符串的开头,</li>
<li><code>${parameter/%pattern/string}</code> :<code>/%</code> 要求匹配项出现在字符串的末尾</li>
</ul>
<h3 id="参数展开"><a class="header" href="#参数展开">参数展开</a></h3>
<p>尽管参数展开在第七章中出现过,但我们并没有详尽地介绍它,因为大多数的参数展开会用在脚本中,而不是命
令行中. 我们已经使用了一些形式的参数展开;例如,shell 变量.shell 提供了更多方式.</p>
<h3 id="基本参数展开"><a class="header" href="#基本参数展开">基本参数展开</a></h3>
<p>最简单的参数展开形式反映在平常使用的变量上.</p>
<p>在这个例子中,我们试图创建一个文件名,通过把字符串 <code>_file</code> 附加到变量 <code>a</code> 的值的后面.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ a=&quot;foo&quot;
[me@linuxbox ~]$ echo &quot;$a_file&quot;
</code></pre>
<p>如果我们执行这个序列,没有任何输出结果,因为 <code>shell</code> 会试着展开一个称为 <code>a_file</code> 的变量,而不是 <code>a</code>.通过添加花括号可以解决这个问题:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo &quot;${a}_file&quot;
foo_file
</code></pre>
<p>我们已经知道通过把数字包裹在花括号中,可以访问大于<code>9</code>的位置参数.例如,访问第十一个位置参数,我们可以这样做: <code>${11}</code></p>
<h3 id="管理空变量的展开"><a class="header" href="#管理空变量的展开">管理空变量的展开</a></h3>
<p><code>null</code>
<code>undefined</code>
<code>defined</code></p>
<p>几种用来处理不存在和空变量的参数展开形式.
这些展开形式对于解决丢失的位置参数和给参数指定默认值的情况很方便.</p>
<pre><code class="language-bash">${parameter:-word}
</code></pre>
<p>若 parameter 没有设置(例如,不存在)或者为空,展开结果是 <code>word</code> 的值.
若 parameter 不为空,则展开结果是 parameter 的值.</p>
<pre><code class="language-bash">foo=
echo ${foo:-&quot;substitute value if unset&quot;}
echo $foo
foo=bar
echo ${foo:-&quot;substitute value if unset&quot;}
echo $foo
</code></pre>
<pre><code class="language-bash">${parameter:=word}
</code></pre>
<p>若 <code>parameter</code> 没有设置或为空,展开结果是 <code>word</code> 的值.另外,<code>word</code> 的值会赋值给 <code>parameter</code>.
若 <code>parameter</code> 不为空,展开结果是 <code>parameter</code> 的值.</p>
<pre><code class="language-bash">foo=
echo ${foo:=&quot;default value if unset&quot;}
unset
echo $foo
unset
foo=bar
echo ${foo:=&quot;default value if unset&quot;}
echo $foo
</code></pre>
<p>注意: 位置参数或其它的特殊参数不能以这种方式赋值.</p>
<pre><code class="language-bash">${parameter:?word}
</code></pre>
<p>若 parameter 没有设置或为空,这种展开导致脚本带有错误退出,并且 word 的内容会发送到标准错误.
若parameter 不为空, 展开结果是 parameter 的值.</p>
<pre><code class="language-bash">foo=
echo ${foo:?&quot;parameter is empty&quot;
echo $?
foo=bar
echo ${foo:?&quot;parameter is empty&quot;}
echo $?
</code></pre>
<pre><code class="language-bash">${parameter:+word}
</code></pre>
<p>若 parameter 没有设置或为空,展开结果为空.
若 parameter 不为空, 展开结果是 word 的值会替换掉parameter 的值;然而,parameter 的值不会改变.</p>
<pre><code class="language-bash">foo=
echo ${foo:+&quot;substitute value if set&quot;}
foo=bar
echo ${foo:+&quot;substitute value if set&quot;}
</code></pre>
<h3 id="返回变量名的参数展开"><a class="header" href="#返回变量名的参数展开">返回变量名的参数展开</a></h3>
<p><code>shell</code> 具有返回变量名的能力.这会用在一些相当独特的情况下.</p>
<pre><code class="language-bash">${!prefix*}
${!prefix@}
</code></pre>
<p>这种展开会返回以 <code>prefix</code> 开头的已有变量名.根据 bash 文档,这两种展开形式的执行结果相同.
这里,我们列出了所有以 <code>BASH</code> 开头的环境变量名:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ echo ${!BASH*}
BASH BASH_ARGC BASH_ARGV BASH_COMMAND BASH_COMPLETION
...
</code></pre>
<h3 id="字符串展开"><a class="header" href="#字符串展开">字符串展开</a></h3>
<p>有大量的展开形式可用于操作字符串.其中许多展开形式尤其适用于路径名的展开.</p>
<pre><code class="language-bash">${#parameter}
</code></pre>
<p>展开成由 <code>parameter</code> 所包含的字符串的长度.</p>
<p>通常,<code>parameter</code> 是一个字符串;然而,如果 <code>parameter</code> 是 <code>@</code>或者是 <code>*</code> 的话, 则展开结果是位置参数的个数.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ foo=&quot;This string is long.&quot;
[me@linuxbox ~]$ echo &quot;'$foo' is ${#foo} characters long.&quot;
'This string is long.' is 20 characters long.
</code></pre>
<hr />
<pre><code class="language-bash">${parameter:offset}
${parameter:offset:length}
</code></pre>
<p>这些展开用来从 <code>parameter</code> 所包含的字符串中提取一部分字符.
提取的字符始于第 <code>offset</code> 个字符(从字符串开头算起)直到字符串的末尾,除非指定提取的长度.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ foo=&quot;This string is long.&quot;
[me@linuxbox ~]$ echo ${foo:5}
string is long.
[me@linuxbox ~]$ echo ${foo:5:6}
string
</code></pre>
<p>若 <code>offset</code> 的值为负数,则认为 <code>offset</code> 值是从字符串的末尾开始算起,而不是从开头.
注意负数前面必须有一个空格, 为防止与 <code>${parameter:-word}</code> 展开形式混淆.<code>length</code>,若出现,则必须不能小于零.
如果 <code>parameter</code> 是 <code>@</code>,展开结果是 <code>length</code> 个位置参数,从第 offset 个位置参数开始.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ foo=&quot;This string is long.&quot;
[me@linuxbox ~]$ echo ${foo: -5}
long.
[me@linuxbox ~]$ echo ${foo: -5:2}
lo
</code></pre>
<hr />
<pre><code class="language-bash">${parameter#pattern}
${parameter##pattern}
</code></pre>
<p>这些展开会从 <code>paramter</code> 所包含的字符串中清除开头一部分文本,这些字符要匹配定义的 <code>patten</code> .
pattern 是通配符模式,就如那些用在路径名展开中的模式.
这两种形式的差异之处是该 <code>#</code> 形式清除最短的匹配结果, 而该<code>##</code> 模式清除最长的匹配结果.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo ${foo#*.}
txt.zip
[me@linuxbox ~]$ echo ${foo##*.}
zip
</code></pre>
<hr />
<pre><code class="language-bash">${parameter%pattern}
${parameter%%pattern}
</code></pre>
<p>这些展开和上面的 <code>#</code> 和 <code>##</code> 展开一样,除了它们清除的文本从 <code>parameter</code> 所包含字符串的末尾开始,而不是开头.</p>
<pre><code class="language-bash">[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo ${foo%.*}
file.txt
[me@linuxbox ~]$ echo ${foo%%.*}
file
</code></pre>
<hr />
<pre><code class="language-bash">${parameter/pattern/string}
${parameter//pattern/string}
${parameter/#pattern/string}
${parameter/%pattern/string}
</code></pre>
<p>这种形式的展开对 <code>parameter</code> 的内容执行查找和替换操作.</p>
<p>如果找到了匹配通配符 <code>pattern</code> 的文本, 则用 <code>string</code> 的内容替换它.
在正常形式下,只有第一个匹配项会被替换掉.在 <code>//</code> 形式下,所有的匹配项都会被替换掉.
<code>/#</code>要求匹配项出现在字符串的开头,而 <code>/%</code> 要求匹配项出现在字符串的末尾.
<code>/string</code> 可能会省略掉,这样会导致删除匹配的文本.</p>
<pre><code class="language-bash">[me@linuxbox~]$ foo=JPG.JPG
[me@linuxbox ~]$ echo ${foo/JPG/jpg}
jpg.JPG
[me@linuxbox~]$ echo ${foo//JPG/jpg}
jpg.jpg
[me@linuxbox~]$ echo ${foo/#JPG/jpg}
jpg.JPG
[me@linuxbox~]$ echo ${foo/%JPG/jpg}
JPG.jpg
</code></pre>
<p>知道参数展开是件很好的事情.字符串操作展开可以用来替换其它常见命令比方说 <code>sed</code> 和 <code>cut</code>.通过减少使用外部程序,展开提高了脚本的效率.</p>
<p>举例说明,我们将修改在之前章节中讨论的 <code>longest-word</code> 程序,
用参数展开<code>${#j}</code> 取代命令 <code>$(echo $j | wc -c)</code> 及其<code>subshell</code> ,像这样:</p>
<p><code>wc</code>- print newline, word, and byte counts for each file</p>
<pre><code class="language-bash">#!/bin/bash
# longest-word3 : find longest string in a file
for i; do
   if [[ -r $i ]]; then
      max_word=
      max_len=
      for j in $(strings $i); do
  len=${#j}
  if (( len &gt; max_len )); then
     max_len=$len
     max_word=$j
  fi
      done
      echo &quot;$i: '$max_word' ($max_len characters)&quot;
   fi
   shift
done
</code></pre>
<p>下一步,我们将使用 <code>time</code> 命令来比较这两个脚本版本的效率:</p>
<pre><code class="language-bash">[me@linuxbox ~]$ time longest-word2 dirlist-usr-bin.txt
dirlist-usr-bin.txt: 'scrollkeeper-get-extended-content-list' (38 characters)
real 0m3.618s
user 0m1.544s
sys 0m1.768s
[me@linuxbox ~]$ time longest-word3 dirlist-usr-bin.txt
dirlist-usr-bin.txt: 'scrollkeeper-get-extended-content-list' (38 characters)
real 0m0.060s
user 0m0.056s
sys 0m0.008s
</code></pre>
<p>原来的脚本扫描整个文本文件需耗时<code>3.168</code>秒,
而使用参数展开的新版本, 仅仅花费了<code>0.06</code>秒  --  一个非常巨大的提高.</p>
<h3 id="通配符wildcardglob"><a class="header" href="#通配符wildcardglob">通配符/Wildcard/glob</a></h3>
<p><a href="https://www.jianshu.com/p/25f3d0cd5fdc">Shell中的通配符</a></p>
<p><code>glob()</code>, glob: 一滴 一团</p>
<p><code>glob()</code>函数根据<code>shell</code>使用的规则搜索所有与模式匹配的路径名 (请参阅<code>glob(7)</code>)
没有<code>tilde expansion</code>或<code>parameter substitution</code>;  如果需要这些,请使用<code>wordexp(3)</code>.</p>
<p><code>globfree()</code>函数释放先前调用<code>glob()</code>时,动态分配的存储空间 .
<code>man 7 glob()</code> see glob(7)</p>
<p>在 <code>Shell</code> 中命令中,通常会使用通配符表达式来匹配一些文件,如以下命令可以查找当前目录下所有后缀为 <code>.xml</code> 的文件</p>
<pre><code class="language-bash">find . -name &quot;*.xml&quot;
</code></pre>
<p>Shell 中可以使用的通配符如下:</p>
<table><thead><tr><th>通配符</th><th>含义</th><th>实例</th></tr></thead><tbody>
<tr><td><code>*</code></td><td>匹配 <code>0</code> 或多个字符</td><td><code>a*b</code>,<code>a</code>与<code>b</code>之间可以有任意长度的任意字符, 也可以一个也没有, 如 <code>aabcb</code>, <code>axyzb</code>, <code>a012b</code>, <code>ab</code></td></tr>
<tr><td><code>?</code></td><td>匹配任意单个字符</td><td><code>a?b</code>,<code>a</code>与<code>b</code>之间有且只有一个字符, 可以是任意字符,如 <code>aab</code>, <code>abb</code>, <code>acb</code>, <code>a0b</code></td></tr>
<tr><td><code>[list]</code></td><td>匹配 <code>list</code> 中的任意单个字符</td><td><code>a[xyz]b</code>,<code>a</code>与<code>b</code>之间必须也只能有一个字符, 但只能是 <code>x</code> 或 <code>y</code> 或 <code>z</code>, 如 <code>axb</code>, <code>ayb</code>, <code>azb</code>.</td></tr>
<tr><td><code>[!list]</code></td><td>匹配除 <code>list</code> 中的任意单一字符</td><td><code>a[!0-9]b</code>,<code>a</code>与<code>b</code>之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 <code>axb,</code> <code>aab</code>, <code>a-b</code>.</td></tr>
<tr><td><code>[c1-c2]</code></td><td>匹配 <code>c1-c2</code> 中的任意单一字符</td><td><code>a[0-9]b</code>,匹配<code>0</code>与<code>9</code>之间其中一个字符,如 <code>a0b</code>, <code>a1b</code>... <code>a9b</code></td></tr>
<tr><td><code>{s1,s2,...}</code></td><td>匹配 <code>s1</code> 或 <code>s2</code> (或更多)中的一个字符串</td><td><code>a{abc,xyz,123}b</code>,<code>a</code>与<code>b</code>之间只能是<code>abc</code>或<code>xyz</code>或<code>123</code>这三个字符串之一</td></tr>
<tr><td><code>[[:class:]]</code></td><td>匹配任意一个属于指定字符类中的字符</td><td><code>*[[:lower:]123]</code>,以小写字母开头,或者以<code>1</code>,<code>2</code>,<code>3</code>结尾的文件</td></tr>
</tbody></table>
<p>常用字符类</p>
<ul>
<li><code>[:alnum:]</code> : 匹配任意一个字母或数字</li>
<li><code>[:alpha:]</code> :  匹配任意一个字母</li>
<li><code>[:digit:]</code> : 匹配任意一个数字</li>
<li><code>[:lower:]</code> : 匹配任意一个小写字母</li>
<li><code>[:upper:]</code> : 匹配任意一个大写字母</li>
</ul>
<h3 id="转义字符"><a class="header" href="#转义字符">转义字符</a></h3>
<p>有的时候,我们匹配的内容里面会存在 <code>*</code>,<code>?</code>,<code>[</code>等通配符中的符号.
为了表示他们原来的意思,我们需要使用转义字符 <code>\</code>,如 <code>a\[ac\]c</code> 表示匹配 <code>a[a]c</code> 或 <code>a[c]c</code>.</p>
<p><code>\ </code>本身用<code> \\</code> 表示.</p>
<h3 id="字符切割"><a class="header" href="#字符切割">字符切割</a></h3>
<p>分字 word splitting</p>
<p><a href="ttps://blog.csdn.net/u010003835/article/details/80750003">Shell_Linux Shell 中实现字符串切割的几种方法</a>
<a href="https://blog.csdn.net/u010003835/article/details/80749220">refs1</a>
<a href="https://blog.csdn.net/whuslei/article/details/7187639">refs2</a></p>
<hr />
<p><code>shell</code> 的 <code>for</code> 参数可以是一个连续的字符串,用<code>IFS</code>分割</p>
<pre><code class="language-bash">#!/bin/bash
string=&quot;hello shell split test&quot;  ; for var in ${string[@]}; do echo -e &quot;$var EOF&quot; ; done
####
echo test2
string=&quot;hello shell split test&quot;
for var in ${string}
do
   echo -e &quot;$var EOF&quot;
done
</code></pre>
<hr />
<p>我们在 <code>shell</code> 脚本编程中,经常需要用到字符串切割,即将字符串切割为一个数组,
类似 <code>java</code> 中的<code>split</code>函数,下面对几种常见的方式做一个总结.</p>
<ul>
<li>利用 <code>shell</code> 中 变量 的字符串替换</li>
<li>设置分隔符,通过 <code>IFS</code> 变量</li>
<li>利用<code>tr</code> 指令实现字符替换  (!只能针对单个分隔符)</li>
</ul>
<hr />
<p>方法一:利用 <code>shell</code> 中变量的字符串替换</p>
<p>示例:</p>
<pre><code class="language-bash">#!/bin/bash
string=&quot;hello,shell,split,test&quot;
array=(${string//,/ })

for var in ${array[@]}
do
   echo -e &quot;$var \n&quot;
done
</code></pre>
<hr />
<p>方法二: 设置分隔符,通过 <code>IFS </code>变量</p>
<p>原理:自定义IFS变量, 改变分隔符, 对字符串进行切分</p>
<p><code>IFS</code> 介绍</p>
<p><code>Shell</code> 脚本中有个变量叫 <code>IFS</code>(Internal Field Seprator) ,<strong>内部域分隔符</strong>.</p>
<p><code>Shell</code> 的环境变量分为 <code>set</code>, <code>env</code> 两种,其中 <code>set</code> 变量可以通过 <code>export</code> 工具导入到 <code>env</code> 变量中.
其中,<code>set</code> 是显示设置 <code>shell</code> 变量,仅在本 <code>shell</code> 中有效; <code>env</code> 是显示设置用户环境变量 ,仅在当前会话中有效.
换句话说,<code>set</code> 变量里包含了 <code>env</code> 变量,但 <code>set</code> 变量不一定都是 <code>env</code> 变量.
这两种变量不同之处在于变量的作用域不同.显然,<code>env</code> 变量的作用域要大些,它可以在 <code>subshell</code> 中使用.</p>
<p>而 <code>IFS</code> 是一种 <code>set</code> 变量,当 <code>shell</code> 处理&quot;命令替换&quot;和&quot;参数替换&quot;时, <code>shell</code> 根据 <code>IFS</code> 的值,默认是 <code>space</code>, <code>tab</code>, <code>newline</code> 来拆解读入的变量,然后对特殊字符进行处理,最后重新组合赋值给该变量.</p>
<hr />
<p><code>IFS</code> 简单实例</p>
<p>查看变量 <code>IFS</code> 的值.</p>
<pre><code class="language-bash">$ echo $IFS

$ echo &quot;$IFS&quot; | od -b
0000000 040 011 012 012
0000004
</code></pre>
<p>直接输出IFS是看不到的,把它转化为二进制就可以看到了, <code>040</code>是空格,<code>011</code>是<code>Tab</code>,<code>012</code>是换行符<code>\n</code> .
最后一个 <code>012</code> 是 <code>echo</code>输出的(<code>echo</code> 默认会换行的).</p>
<pre><code class="language-bash">SAVEIFS=$(echo -en &quot;\0040\0011\0012&quot;); # 默认的IFS
</code></pre>
<p>示例</p>
<pre><code class="language-bash">#!/bin/bash

string=&quot;hello,shell,split,test&quot;

#对IFS变量 进行替换处理
OLD_IFS=&quot;$IFS&quot;
IFS=&quot;,&quot;
array=($string)
IFS=&quot;$OLD_IFS&quot;

for var in ${array[@]}
do
   echo -e $var\n
done
</code></pre>
<hr />
<p>方法三: 利用<code>tr</code>指令实现字符替换</p>
<p>原理: 由于只是对单个字符进行的替换,则可以用  <code>echo args |   tr &quot;oldSpilt&quot; &quot;newSpilt&quot;</code>  的方式实现.</p>
<p><code>tr</code> 指令讲解: <code>tr</code>命令可以对来自标准输入的字符进行替换,压缩和删除.</p>
<p>语法:<code>tr(选项)(参数)</code></p>
<p>选项</p>
<ul>
<li><code>-c</code>或<code>--complerment</code>:取代所有不属于第一字符集的字符;</li>
<li><code>-d</code>或<code>--delete</code>:删除所有属于第一字符集的字符;</li>
<li><code>-s</code>或<code>--squeeze-repeats</code>:把连续重复的字符以单独一个字符表示;</li>
<li><code>-t</code>或<code>--truncate-set1</code>:先删除第一字符集较第二字符集多出的字符.</li>
</ul>
<p>参数</p>
<ul>
<li><code>字符集1</code>:指定要转换或删除的原字符集.当执行转换操作时,必须使用参数<code>字符集2</code>指定转换的目标字符集.
但执行删除操作时,不需要参数<code>字符集2</code>;</li>
<li><code>字符集2</code>:指定要转换成的目标字符集.</li>
</ul>
<p>示例:</p>
<pre><code class="language-bash">#!/bin/bash

string=&quot;hello,shell,split,test&quot;
array=(`echo $string | tr ',' ' '` )

for var in ${array[@]}
do
   echo -e $var
done
</code></pre>
<p>cmdline 第七章 重定向</p>
<h2 id="重定向"><a class="header" href="#重定向">重定向</a></h2>
<ul>
<li><code>cat</code> --连接文件</li>
<li><code>sort</code>--排序文本行</li>
<li><code>uniq</code>--报道或忽略重复行</li>
<li><code>grep</code>--打印匹配行</li>
<li><code>wc</code>--打印文件中换行府, 字, 和字节个数</li>
<li><code>head</code>--输出文件第一部分</li>
<li><code>tail</code>--输出文件最后一部分</li>
</ul>
<h3 id="标准输入-输出和错误"><a class="header" href="#标准输入-输出和错误">标准输入, 输出和错误</a></h3>
<p>Unix<code>一切皆文件</code>, 程序, 比如说<code>ls</code>, 把它们的运行结果输送到一个叫做标准输出(<code>stdout</code>)的特殊文件,
把它们的状态信息送到另一个叫做标准错误(<code>stderr</code>)的文件. 默认情况下, 标准输出和标准错误都连接到屏幕, 而不是保存到磁盘文件.</p>
<p>此外, 许多程序从一个叫做标准输入(<code>stdin</code>)的设备得到输入. 默认情况下, 标准输入连接到键盘.</p>
<p><code>I/O</code> 重定向允许我们可以更改输出走向和输入来向.
一般地,输出送到屏幕,输入来自键盘, 但是通过 <code>I/O</code> 重定向,我们可以改变输入输出方向.</p>
<h3 id="重定向标准输出"><a class="header" href="#重定向标准输出">重定向标准输出</a></h3>
<p><code>I/O</code> 重定向允许我们来重定义标准输出送到哪里.</p>
<p>重定向标准输出到另一个文件,我们使用 <code>&gt;</code> 重定向符,其后跟着文件名.
把重定向结果追加到文件内容后面,而不是从开头重写文件, 我们使用<code>&gt;&gt;</code>重定向符,像这样:</p>
<pre><code class="language-bash">ls -l /usr/bin &gt;&gt; ls-output.txt
</code></pre>
<h3 id="重定向标准错误"><a class="header" href="#重定向标准错误">重定向标准错误</a></h3>
<p>重定向标准错误缺乏专用的重定向操作符. 重定向标准错误,我们必须参考它的文件描述符.
一个程序可以在几个编号的文件流中的任一个上产生输出.
然而我们必须把这些文件流的前三个看作标准输入,输出和错误, shell内部给它们的文件描述符分别为<code>0</code>,<code>1</code>和<code>2</code>.</p>
<p>可能有这种情况,我们希望捕捉一个命令的所有输出到一个文件.
为了完成这个,我们 必须同时重定向标准输出和标准错误. 有两种方法.</p>
<p>第一个,传统的方法, 在旧版本 shell 中也有效:</p>
<pre><code class="language-bash">ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1
</code></pre>
<p>使用这种方法,我们完成两个重定向.
首先重定向标准输出到文件 <code>ls-output.txt</code>,然后 重定向文件描述符<code>2</code>(标准错误)到文件描述符<code>1</code>(标准输出)使用表示法<code>2&gt;&amp;1</code>. 注意重定向的顺序安排非常重要. 标准错误的重定向必须总是出现在标准输出重定向之后,要不然它不起作用.</p>
<p>现在的 bash 版本提供了第二种方法,更精简合理的方法来执行这种联合的重定向.</p>
<pre><code class="language-bash">ls -l /bin/usr &amp;&gt; ls-output.txt
</code></pre>
<p>在这个例子里面,我们使用单单一个表示法 <code>&amp;&gt;</code> 来重定向标准输出和错误到文件 <code>ls-output.txt</code>.</p>
<h3 id="处理不需要的输出"><a class="header" href="#处理不需要的输出">处理不需要的输出</a></h3>
<p>有时候<code>沉默是金</code>,我们不想要一个命令的输出结果,只想把它们扔掉.</p>
<p>系统为我们提供了解决问题的方法,通过重定向输出结果 到一个特殊的叫做<code>/dev/null</code>的文件.
这个文件是系统设备,叫做位存储桶,它可以接受输入,并且对输入不做任何处理.
为了隐瞒命令错误信息,我们这样做:</p>
<pre><code class="language-bash">ls -l /bin/usr 2&gt; /dev/null
</code></pre>
<blockquote>
<p>Unix 文化中的/dev/null
位存储桶是个古老的 Unix 概念,由于它的普遍性,它的身影出现在 Unix 文化的 许多部分.
当有人说他/她正在发送你的评论到<code>/dev/null</code>,现在你应该知道那是 什么意思了.
更多的例子,可以阅读 Wikipedia 关于<code>/dev/null</code>的文章.</p>
</blockquote>
<h3 id="重定向标准输入"><a class="header" href="#重定向标准输入">重定向标准输入</a></h3>
<p><code>cat - 连接文件</code></p>
<p><code>cat </code>命令读取一个或多个文件,然后复制它们到标准输出,就像这样:<code>cat [file]</code></p>
<p><code>cat</code> 经常被用来显示简短的文本文件. 因为 <code>cat</code> 可以 接受不只一个文件作为参数,所以它也可以用来把文件连接在一起.</p>
<p>比方说我们下载了一个大型文件,这个文件被分离成多个部分(<code>USENET</code> 中的多媒体文件经常以这种方式分离), 我们想把它们连起来.</p>
<pre><code class="language-bash">cat movie.mpeg.0* &gt; movie.mpeg
</code></pre>
<p>如果 <code>cat</code> 没有给出任何参数,它会从标准输入读入数据,因为标准输入,默认情况下,连接到键盘.
它正在等待我们输入数据!试试这个:</p>
<pre><code class="language-bash">cat
The quick brown fox jumped over the lazy dog.
</code></pre>
<p>下一步,输入 <code>Ctrl-d</code>(按住 <code>Ctrl</code> 键同时按下<code>d</code>),来告诉 <code>cat</code>,在标准输入中, 它已经到达文件末尾(EOF):
由于文件名参数的缺席,<code>cat</code> 复制标准输入到标准输出,所以我们看到文本行重复出现.
我们可以使用这种行为来创建简短的文本文件. 比方说,我们想创建一个叫做<code>lazy_dog.txt</code> 的文件,这个文件包含例子中的文本.
我们这样做:</p>
<pre><code class="language-bash">cat &gt; lazy_dog.txt
The quick brown fox jumped over the lazy dog.
</code></pre>
<p>输入命令,其后输入要放入文件中的文本. 记住,最后输入<code>Ctrl-d</code>. 通过使用这个命令,我们实现了世界上最低能的文字处理器!</p>
<p>现在我们知道怎讲接受标准输入:</p>
<pre><code class="language-bash">cat &lt; lazy_dog.txt
The quick brown fox jumped over the lazy dog.
</code></pre>
<p>使用<code>&lt;</code>重定向操作符,我们把标准输入源从键盘改到文件 <code>lazy_dog.txt</code>.</p>
<p><code>2.05b</code>版本以后, <code>bash</code>可以用下列语法重定向标准输入至字符串(称为here string/here-string):</p>
<pre><code class="language-bash">command &lt;&lt;&lt; &quot;string to be read as standard input&quot;
</code></pre>
<p>如果字符串包括空格就需要用引号包裹字符串</p>
<h3 id="管道线"><a class="header" href="#管道线">管道线</a></h3>
<p>命令可以从<strong>标准输入</strong>读取数据,然后再把数据输送到<strong>标准输出</strong>,
命令的这种能力被 一个 <code>shell</code> 特性所利用,这个特性叫做管道线.</p>
<p>使用管道操作符<code>|</code>(竖杠),一个命令的标准输出可以管道到另一个命令的标准输入:</p>
<pre><code class="language-bash">command1 | command2
</code></pre>
<p>我们用 less 来一页一页地显示任何命令的输出,命令把它的运行结果输送到标准输出:</p>
<pre><code class="language-bash">ls -l /usr/bin | less
</code></pre>
<p>这极其方便!使用这项技术,我们可以方便地检测会产生标准输出的任一命令的运行结果.</p>
<h3 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h3>
<p>管道线经常用来对数据完成复杂的操作. 有可能会把几个命令放在一起组成一个管道线.
通常,以这种方式使用的命令被称为过滤器. 过滤器接受输入,以某种方式改变它,然后 输出它.</p>
<h4 id="sort-1"><a class="header" href="#sort-1">sort</a></h4>
<p>第一个我们想试验的过滤器是 <code>sort</code>.</p>
<pre><code class="language-bash">ls /bin /usr/bin | sort | less
</code></pre>
<p>因为我们指定了两个目录<code>(/bin</code> 和<code>/usr/bin</code>),<code>ls</code> 命令的输出结果由有序列表组成, 各自针对一个目录.
通过在管道线中包含 <code>sort</code>,我们改变输出数据,从而产生一个 有序列表.</p>
<h3 id="uniq---报道或忽略重复行"><a class="header" href="#uniq---报道或忽略重复行">uniq - 报道或忽略重复行</a></h3>
<p><code>uniq</code> 命令经常和 <code>sort</code> 命令结合在一起使用.
<code>uniq</code> 从标准输入或单个文件名参数接受数据有序列表(详情查看<code>uniq</code>手册页),默认情况下,从数据列表中删除任何重复行.</p>
<pre><code class="language-bash">ls /bin /usr/bin | sort | uniq | less
</code></pre>
<p>在这个例子中,我们使用 <code>uniq</code> 从 <code>sort</code> 命令的输出结果中,来删除任何重复行.</p>
<p>如果我们想看到 重复的数据列表,让 uniq 命令带上<code>-d</code>选项,就像这样:</p>
<pre><code class="language-bash">ls /bin /usr/bin | sort | uniq -d | less
</code></pre>
<h3 id="wc---打印行字和字节数"><a class="header" href="#wc---打印行字和字节数">wc - 打印行,字和字节数</a></h3>
<p><code>wc</code>(字计数)命令是用来显示文件所包含的行,字和字节数. 例如:</p>
<pre><code class="language-bash">wc ls-output.txt
7902 64566 503634 ls-output.txt
</code></pre>
<p><code>wc</code> 打印出来三个数字:包含在文件 <code>ls-output.txt</code> 中的行数,单词数和字节数,.
正如我们先前的命令,如果 <code>wc</code> 不带命令行参数,它接受标准输入.
<code>-l</code>选项限制命令输出只能报道行数.</p>
<p>添加 <code>wc</code> 到管道线来统计数据,是个很便利的方法.</p>
<pre><code class="language-bash">ls /bin /usr/bin | sort | uniq | wc -l
2728
</code></pre>
<h3 id="grep---打印匹配行"><a class="header" href="#grep---打印匹配行">grep - 打印匹配行</a></h3>
<p>grep 是个很强大的程序,用来找到文件中的匹配文本. 这样使用 <code>grep</code> 命令:</p>
<pre><code class="language-bash">grep pattern [file...]
</code></pre>
<p>当 grep 遇到一个文件中的匹配<code>模式</code>,它会打印出包含这个类型的行.
grep 能够匹配的模式可以很复杂(正则表达式),但是现在我们把注意力集中在简单文本匹配上面.</p>
<p>比如说,我们想在我们的程序列表中,找到文件名中包含单词<code>zip</code>的所有文件.
这样一个搜索, 可能让我们了解系统中的一些程序与文件压缩有关系. 这样做:</p>
<pre><code class="language-bash">ls /bin /usr/bin | sort | uniq | grep zip
</code></pre>
<p>grep 有一对方便的选项:
<code>-i</code>导致 <code>grep</code> 忽略大小写当执行搜索时(通常,搜索是大小写 敏感的),
<code>-v</code>选项会告诉 <code>grep</code> 只打印不匹配的行.</p>
<h3 id="headtail---打印文件开头部分结尾部分"><a class="header" href="#headtail---打印文件开头部分结尾部分">head/tail - 打印文件开头部分/结尾部分</a></h3>
<p>有时候你不需要一个命令的所有输出. 可能你只想要前几行或者后几行的输出内容.
<code>head</code> 命令打印文件的前十行,而 <code>tail</code> 命令打印文件的后十行.
默认情况下,两个命令 都打印十行文本,但是可以通过<code>-n</code>选项来调整命令打印的行数.</p>
<pre><code class="language-bash">head -n 5 ls-output.txt
tail -n 5 ls-output.txt
</code></pre>
<p>它们也能用在管道线中:</p>
<pre><code class="language-bash">ls /usr/bin | tail -n 5
</code></pre>
<p><code>tail</code> 有一个选项允许你实时的浏览文件. 当观察日志文件的进展时,这很有用,因为它们同时在被写入.</p>
<p>在以下的例子里,我们要查看目录<code>/var/log</code>里面的信息文件.
在 一些 Linux 发行版中,要求有超级用户权限才能阅读这些文件,因为文件<code>/var/log/messages</code>可能包含安全信息.</p>
<pre><code class="language-bash">tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
</code></pre>
<p>使用<code>-f</code>选项,<code>tail</code>命令继续监测这个文件,当新的内容添加到文件后,它们会立即出现在屏幕上.
这会一直继续下去直到你输入<code>Ctrl-c</code>.</p>
<h3 id="tee---从-stdin-读取数据并同时输出到-stdout-和文件"><a class="header" href="#tee---从-stdin-读取数据并同时输出到-stdout-和文件">tee - 从 Stdin 读取数据,并同时输出到 Stdout 和文件</a></h3>
<p>为了和我们的管道隐喻保持一致,Linux 提供了一个叫做 <code>tee</code> 的命令,这个命令制造了 一个<code>tee</code>,安装到我们的管道上.</p>
<p><code>tee</code> 程序从标准输入读入数据,并且同时复制数据到<strong>标准输出</strong>(相当于允许数据继续随着管道线流动)和一个或多个文件.
当在某个中间处理阶段来捕捉一个管道线的内容时,这很有帮助.</p>
<p>这里,我们重复执行一个先前的例子, 这次包含 <code>tee</code> 命令,在 <code>grep</code> 过滤管道线的内容之前,来捕捉整个目录列表到文件 ls.txt:</p>
<pre><code class="language-bash">ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
</code></pre>
<h2 id="从shell眼中看世界"><a class="header" href="#从shell眼中看世界">从shell眼中看世界</a></h2>
<h3 id="字符展开"><a class="header" href="#字符展开">字符展开</a></h3>
<p>传递到 echo 命令的任一个参数都会在(屏幕上)显示出来.  让我们试一个例子:</p>
<pre><code class="language-bash">echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
</code></pre>
<p>为什么 <code>echo</code> 不打印<code>*</code>呢?答案就是在 <code>echo</code> 命令被执行前, shell 把<code>*</code>展开成了另外的东西(在这种情况下,就是在当前工作目录下的文件名字).</p>
<p>当回车键被按下时,<code>shell</code> 在命令被执行前在命令行上自动展开任何符合条件的字符, 所以 <code>echo</code> 命令从不会发现<code>*</code>,只把它展开成结果.
知道了这个以后,我们能看到 <code>echo</code> 执行的结果和我们想象的一样.</p>
<h3 id="路径名展开"><a class="header" href="#路径名展开">路径名展开</a></h3>
<p>这种通配符工作机制叫做路径名展开. 我们能够执行以下参数展开模式:</p>
<pre><code class="language-bash">echo D*
Desktop Documents
</code></pre>
<p>和:</p>
<pre><code class="language-bash">echo *s
Documents Pictures Templates Videos
</code></pre>
<pre><code class="language-bash">甚至是:
echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos
</code></pre>
<p>查看家目录之外的目录:</p>
<pre><code class="language-bash">echo /usr/*/share
/usr/kerberos/share /usr/local/share
</code></pre>
<h3 id="隐藏文件路径名展开"><a class="header" href="#隐藏文件路径名展开">隐藏文件路径名展开</a></h3>
<p>正如我们知道的,以圆点字符开头的文件名是隐藏文件. 路径名展开也尊重这种 行为. 像这样的展开:</p>
<pre><code class="language-bash">echo *
</code></pre>
<p>不会显示隐藏文件. 要是展开模式以一个圆点开头,我们就能够在展开模式中包含隐藏文件,
而且隐藏文件可能会出现在第一位置,就像这样:</p>
<pre><code class="language-bash">echo .*
</code></pre>
<p>然而,如果我们仔细检查一下输出结果,我们会看到名字<code>.</code> 和<code>..</code>也出现在结果中.
因为这些名字是指当前工作目录和它的父目录,使用这种 模式可能会产生不正确的结果.
我们能看到这样的结果,如果我们试一下这个命令:
<code>ls -d .* | less</code>
为了在这种情况下正确地完成路径名展开,我们应该使用一个更精确些的模式.  这个模式会正确地工作:
<code>ls -d .[!.]?*</code>
这种模式展开成为文件名,每个文件名以圆点开头,第二个字符不包含圆点,再包含至少一个字符, 并且这
个字符之后紧接着任意多个字符.</p>
<p>这将列出大多数的隐藏文件 (但仍将不能包含以多个圆点开头的文件名)</p>
<p>这个带有 <code>-A</code> 选项(<code>几乎所有</code>)的<code>ls</code>命令能够提供一份正确的隐藏文件清单:</p>
<pre><code class="language-bash">ls -A
</code></pre>
<h3 id="波浪线展开"><a class="header" href="#波浪线展开">波浪线展开</a></h3>
<p>可能你从我们对 cd 命令的介绍中回想起来,波浪线字符(<code>~</code>)有特殊的意思.
当它用在 一个单词的开头时,它会展开成指定用户的家目录名,如果没有指定用户名,则是当前用户的家目录:</p>
<pre><code class="language-bash">echo ~
/home/me
</code></pre>
<p>如果有用户<code>foo</code>这个帐号,然后:</p>
<pre><code class="language-bash">echo ~foo
/home/foo
</code></pre>
<h3 id="算术表达式展开"><a class="header" href="#算术表达式展开">算术表达式展开</a></h3>
<p><code>shell</code> 允许算术表达式通过展开来执行. 这允许我们把 <code>shell</code> 提示当作计算器来使用:</p>
<pre><code class="language-bash">echo $((2 + 2))
4
</code></pre>
<p>算术表达式展开使用这种格式:<code>$((expression))</code></p>
<p>算术表达式只支持整数(全部是数字,不带小数点),但是能执行很多不同的操作.
这里是 一些它支持的操作符:</p>
<hr />
<p>操作符 说明</p>
<ul>
<li><code>+</code> 加</li>
<li><code>-</code> 减</li>
<li><code>*</code> 乘</li>
<li><code>/</code> 除(但是记住,因为展开只是支持整数除法,所以结果是整数. )</li>
<li><code>%</code> 取余,只是简单的意味着,<code>余数</code></li>
<li><code>**</code> 取幂</li>
</ul>
<p>在算术表达式中空格并不重要,并且表达式可以嵌套. 例如,5的平方乘以3:</p>
<pre><code>echo $(($((5**2)) * 3))
</code></pre>
<p>一对括号可以用来把多个子表达式括起来. 通过这个技术,我们可以重写上面的例子:</p>
<pre><code class="language-bash">echo $(((5**2) * 3))
</code></pre>
<p>这是一个使用除法和取余操作符的例子. 注意整数除法的结果:</p>
<pre><code class="language-bash">echo Five divided by two equals $((5/2))
Five divided by two equals 2
echo with $((5%2)) left over.
with 1 left over.
</code></pre>
<p>在35章会更深入的讨论算术表达式的内容.</p>
<h3 id="花括号展开"><a class="header" href="#花括号展开">花括号展开</a></h3>
<p>可能最奇怪的展开是花括号展开. 通过它,你可以从一个包含花括号的模式中创建多个文本字符串. 例:</p>
<pre><code class="language-bash">echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre>
<p>花括号展开模式可能包含一个开头部分叫做报头,一个结尾部分叫做附言.
花括号表达式本身可能包含一个由逗号分开的字符串列表,或者一系列整数,或者单个的字符串.
这种模式不能嵌入空白字符. 这个例题使用了一系列整数:</p>
<pre><code class="language-bash">echo Number_{1..5}
</code></pre>
<p>一系列以倒序排列的字母:</p>
<pre><code class="language-bash">echo {Z..A}
</code></pre>
<p>花括号展开可以嵌套(会自动展平):</p>
<pre><code class="language-bash">echo a{A{1,2},B{3,4}}b
</code></pre>
<p>那么这对什么有好处呢?最普遍的应用是,创建一系列的文件或目录列表.</p>
<pre><code class="language-bash">mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
</code></pre>
<h3 id="参数展开-1"><a class="header" href="#参数展开-1">参数展开</a></h3>
<p>在这一章我们将会简单地介绍参数展开,只是皮毛而已.
这个特性在 <code>shell</code> 脚本中比直接在命令行中更有用. 它的许多性能和系统存储小块数据,并给每块数据命名的能力有关系.</p>
<p>许多像这样的小块数据, 更适当些应叫做变量,可以方便地检查它们.
例如,叫做<code>USER</code>的变量包含你的用户名. 唤醒参数展开,揭示 <code>USER</code> 中的内容,可以这样做:</p>
<pre><code class="language-bash">echo $USER
me
</code></pre>
<p>查看有效的变量列表,试试这个:</p>
<pre><code class="language-bash">printenv | less
</code></pre>
<p>你可能注意到其它展开类型,如果你误输入一个模式,展开就不会发生.
这时 <code>echo</code> 命令只简单地显示误键入的模式. 通过参数展开,如果你拼写错了一个变量名, 展开仍然会进行,只是展成一个空字符串:</p>
<pre><code class="language-bash">echo $SUER
</code></pre>
<h3 id="命令替换"><a class="header" href="#命令替换">命令替换</a></h3>
<p>命令替换允许我们把一个命令的输出作为一个展开模式来使用:</p>
<pre><code class="language-bash">echo $(ls)
</code></pre>
<p>我最喜欢用的一行命令是像这样的:</p>
<pre><code class="language-bash">ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
</code></pre>
<p>这里我们把 <code>which cp</code> 的执行结果作为一个参数传递给 <code>ls</code> 命令,因此要想得到 <code>cp</code> 程序的输出列表,
不必知道它完整的路径名.</p>
<p>我们不只限制于简单命令. 也可以使用整个管道线 (只展示部分输出):</p>
<pre><code class="language-bash">file $(ls /usr/bin/* | grep zip)
....
</code></pre>
<p>在这个例子中,管道线的输出结果成为 <code>file</code> 命令的参数列表.</p>
<p>在旧版 shell 程序中,有另一种语法也支持命令替换,可与刚提到的语法换使用.
<code>bash</code> 也支持这种语法. 它使用倒引号来代替美元符号和括号:</p>
<pre><code class="language-bash">ls -l `which cp`
</code></pre>
<p>我们已经知道 shell 有许多方式可以完成展开,现在是时候学习怎样来控制展开了.</p>
<h3 id="双引号-1"><a class="header" href="#双引号-1">双引号</a></h3>
<p>我们将要看一下引用的第一种类型,双引号. 如果你把文本放在双引号中, <code>shell</code> 使用的特殊字符,
除了<code>\</code>(反斜杠),<code>$</code> ,和 <code>`</code>(倒引号)之外, 则失去它们的特殊含义,被当作普通字符来看待.</p>
<p>这意味着</p>
<ul>
<li>单词分割, (<code>空格</code>)</li>
<li>路径名展开, (<code>*``?</code>)</li>
<li>波浪线展开,(<code>~</code>)</li>
<li>和花括号展开(<code>{}</code>)</li>
</ul>
<p>都被禁止,然而</p>
<ul>
<li>参数展开(<code>$USER</code>)</li>
<li>算术展开(<code>$(())</code>)</li>
<li>命令替换<code>$()</code></li>
</ul>
<p>仍然执行.
使用双引号,我们可以处理包含空格的文件名. 比方说我们是不幸的名为 <code>two words.txt</code> 文件的受害者.
如果我们试图在命令行中使用这个 文件,<strong>单词分割机制</strong>会导致这个文件名被看作两个独自的参数,而不是所期望的单个参数:</p>
<pre><code class="language-bash">ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
</code></pre>
<p>使用双引号,我们可以阻止单词分割,得到期望的结果;进一步,我们甚至可以修复 破损的文件名.</p>
<pre><code class="language-bash">ls -l `two words.txt`
mv `two words.txt` two_words.txt
</code></pre>
<p>记住,在双引号中,<strong>参数展开</strong>,<strong>算术表达式展开</strong>,和<strong>命令替换</strong>仍然有效:</p>
<pre><code class="language-bash">echo `${USER} $((2+2)) $(cal)`
me 4
</code></pre>
<p>在默认情况下,单词分割机制会在单词中寻找<strong>空格</strong>,<strong>制表符</strong>,和<strong>换行符</strong>,并把它们看作单词之间的界定符. 它们只作为分隔符使用.</p>
<p>如果我们加上双引号,单词分割被禁止,内嵌的空格也不会被当作界定符,它们成为参数的一部分.
一旦加上双引号,我们的命令行就包含一个带有一个参数的命令.</p>
<p>考虑下面的例子:</p>
<pre><code class="language-bash">echo $(cal)
echo `$(cal)`
</code></pre>
<p>在第一个实例中,没有引用的命令替换导致命令行包含<code>38</code>个参数.
在第二个例子中, 命令行只有一个参数,参数中包括嵌入的<strong>空格</strong>和<strong>换行符</strong>.</p>
<h3 id="单引号-1"><a class="header" href="#单引号-1">单引号</a></h3>
<p>如果需要禁止所有的展开,我们使用单引号. 以下例子是无引用,双引号,和单引号的比较结果:</p>
<pre><code class="language-bash">echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
echo `text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER`
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
</code></pre>
<p>正如我们所看到的,随着引用程度加强,越来越多的展开被禁止.</p>
<h3 id="转义字符-1"><a class="header" href="#转义字符-1">转义字符</a></h3>
<p>有时候我们只想引用单个字符. 我们可以在字符之前加上一个反斜杠,在这个上下文中叫做转义字符.
经常在双引号中使用转义字符,来有选择地阻止展开.</p>
<pre><code class="language-bash">echo `The balance for user $USER is: \$5.00`
The balance for user me is: $5.00
</code></pre>
<p>使用转义字符来消除文件名中一个字符的特殊含义,是很普遍的. 例如,在文件名中可能使用一些对于 <code>shell</code> 来说,有特殊含义的字符.
这些字符包括<code>$</code>, <code>!</code>, <code>空格</code>等字符.
注意在单引号中,反斜杠失去它的特殊含义,它 被看作普通字符.</p>
<h3 id="反斜杠转义字符序列"><a class="header" href="#反斜杠转义字符序列">反斜杠转义字符序列</a></h3>
<p>反斜杠除了作为转义字符外,反斜杠也是一种表示法的一部分,这种表示法代表某种特殊字符,叫做控制码.
<code>ASCII</code>编码表中前<code>32</code>个字符被用来把命令转输到像电报机一样的设备.</p>
<p>一些编码是众所周知的(制表符,退格符,换行符,和回车符),其它一些编码就不熟悉了(空值,传输结束码,和确认).</p>
<hr />
<p>转义序列 含义</p>
<ul>
<li><code>\a</code> : 响铃(<code>警告</code>-导致计算机嘟嘟响)</li>
<li><code>\b</code> : 退格符</li>
<li><code>\n</code> : 新的一行. 在类 Unix 系统中,产生换行.</li>
<li><code>\r</code> : 回车符</li>
<li><code>\t</code> : 制表符</li>
</ul>
<p>上表列出了一些常见的反斜杠转义字符.
反斜杠表示法背后的思想来源于 C 编程语言, 许多其它语言也采用了这种表示方法,包括 shell.</p>
<p><code>echo</code> 命令带上 <code>-e</code> 选项,能够解释转义序列. 你可以把转义序列放在<code>$' '</code>里面.</p>
<p>以下例子,使用 <code>sleep</code> 命令,一个简单的程序,它会等待指定的秒数,然后退出.
我们可以创建一个简单的倒数计数器:</p>
<pre><code class="language-bash">sleep 2; echo -e `Time's up\a`
</code></pre>
<p>我们也可以这样做:</p>
<pre><code class="language-bash">sleep 2; echo `Time's up` /span&gt;\a'
</code></pre>
<h2 id="键盘高级操作技巧"><a class="header" href="#键盘高级操作技巧">键盘高级操作技巧</a></h2>
<p>以下命令将会露面:</p>
<ul>
<li><code>clear</code></li>
<li><code>history</code></li>
</ul>
<h3 id="命令行编辑"><a class="header" href="#命令行编辑">命令行编辑</a></h3>
<p>Bash使用了一个名为<code>Readline</code>的库(共享的线程集合, 可以被不同的程序使用), 来实现命令行编辑.</p>
<p>利用历史命令</p>
<pre><code class="language-bash">history | grep /usr/bin
</code></pre>
<p>可以通过类似<code>!88</code>的形式, 引用历史命令.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash-4"><a class="header" href="#bash-4">bash-4</a></h1>
<h2 id="linux-内核编码风格"><a class="header" href="#linux-内核编码风格">linux 内核编码风格</a></h2>
<p><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/process/coding-style.html">Linux 内核代码风格</a>
<a href="https://zhuanlan.zhihu.com/p/330280764">Linux 内核编码风格</a></p>
<h3 id="括号"><a class="header" href="#括号">括号</a></h3>
<p>左括号紧跟在语句的最后, 与语句在相同的一行. 而右括号要另起一行, 作为该行的第一个字符.
如果接下来的部分是相同语句的一部分, 那么右括号就不单独占一行.</p>
<pre><code class="language-c">if ... {
              if ... {
              ...
              } else {
              ...
                     }
       }
return ... ;

do {
...
} while ( ...);
</code></pre>
<p>函数采用以下的书写方式:</p>
<pre><code class="language-c">static inline int rt_policy(int policy)
{
              ...
}
</code></pre>
<p>最后不需要一定使用括号的语句可以忽略它:</p>
<pre><code class="language-c">if (a==b)
              return 0;
return 1;
</code></pre>
<h3 id="每行代码的长度"><a class="header" href="#每行代码的长度">每行代码的长度</a></h3>
<p>要尽可能地保证代码长度不超过80个字符, 如果代码行超过<code>80</code>应该折到下一行.
将参数分行输入, 在开头简单地加入两个标准tab:</p>
<pre><code class="language-c">static int wait_noreap_copyout ( a, b, c, ...
              d,e,f )
{

}
</code></pre>
<h3 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h3>
<p>名称中不允许使用混合的大小写字符.
局部变量如果能够清楚地表明它的用途, 那么选取<code>idx</code>甚至是i这样的名称都是可行的.
而像<code>theLoopIndex</code>这样冗长反复的名字不在接受之列.  -- 匈牙利命名法(在变量名称中加入变量的类别)危害极大.</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>根据经验函数的代码长度不应该超过两屏, 局部变量不应该超过十个.</p>
<ul>
<li>一个函数应该功能单一并且实现精准.</li>
<li>将一个函数分解成一些更短小的函数的组合不会带来危害.  -- 如果你担心函数调用导致的开销, 可以使用inline关键字.</li>
</ul>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p>一般情况下, 注释的目的是描述你的代码要做什么和为什么要做, 而不是具体通过什么方式实现的. 怎么实现应该由代码本身展现.
注释不应该包含谁写了那个函数, 修改日期和其他那些琐碎而无实际意义的内容. 这些信息应该集中在文件最开头地方.
重要信息常常以<code>XXX:</code>开头, 而<code>bug</code>通常以<code>FIXME</code>开头.</p>
<h2 id="脚本参数处理"><a class="header" href="#脚本参数处理">脚本参数处理</a></h2>
<p><a href="https://cloud.tencent.com/developer/article/1043821">解析命令行参数工具</a>
<a href="https://www.golinuxcloud.com/bash-getopts/">use getopts in bash</a></p>
<p><code>bash</code> 脚本中, 简单点的参数选项, 我们可以直接用位置参数 <code>$1</code>, <code>$2</code> 这样来获取处理了.</p>
<p>但是如果你的参数选项很多, 比如 <code>rsync</code>, <code>wget</code> 等动辄几十上百的参数选项, 那就必须用专业的工具来处理了,
在 <code>bash/shell</code> 中我们一般用: <code>getopts/getopt </code></p>
<h3 id="bash-内置的-getopts"><a class="header" href="#bash-内置的-getopts">bash 内置的 getopts</a></h3>
<p>先看简单的例子:</p>
<pre><code class="language-bash">#!/bin/bash
while getopts 'd:Dm:f:t:' OPT; do
    case $OPT in
        d)
            DEL_DAYS=&quot;$OPTARG&quot;;;
        D)
            DEL_ORIGINAL='yes';;
        f)
            DIR_FROM=&quot;$OPTARG&quot;;;
        m)
            MAILDIR_NAME=&quot;$OPTARG&quot;;;
        t)
            DIR_TO=&quot;$OPTARG&quot;;;
        ?)
            echo &quot;Usage: `basename $0` [options] filename&quot;
    esac
done
shift $(($OPTIND - 1))
</code></pre>
<p><code>getopts</code> 后面的字符串就是可以使用的<code>选项列表</code>, 每个字母代表一个选项.
后面带<code>:</code>的意味着除了选项本身之外, 还会带上一个<code>参数</code>作为选项的值, 比如<code>d:</code>在实际的使用中就会对应<code>-d 30</code>, 选项的值就是<code>30</code>;</p>
<p><code>getopts</code>字符串中没有跟随<code>:</code>的是<code>开关型</code>选项, 不需要再指定值, 相当于<code>true/false</code>, 只要带了这个参数就是<code>true</code>.
如果命令行中包含了没有在<code>getopts</code>列表中的选项, 会有警告信息, 如果在整个<code>getopts</code>字符串前面也加上个<code>:</code>, 就能消除警告信息了.</p>
<p>使用<code>getopts</code>识别出各个选项之后, 就可以配合<code>case</code>来进行相应的操作了.
操作中有两个相对固定的&quot;常量&quot;, 一个是<code>OPTARG</code>, 用来取当前<code>选项的值</code>, 另外一个是<code>OPTIND</code>, 代表当前选项在参数列表中的位移.
注意<code>case</code>中的最后一个选择 --<code>?</code>, 代表这如果出现了不认识的选项,  所进行的操作.</p>
<p><code>选项参数</code>识别完成之后, 如果要取剩余的其它命令行参数, 也就是位置参数 <code>#1,#2,...</code>, 可以使用<code>shift</code>把选项参数抹去.
就像例子里面的那样, 对整个参数列表进行<code>左移</code>操作, 最左边的参数就丢失了(已经用<code>case</code>判断并进行了处理, 不再需要了),
位移的长度正好是刚才<code>case</code>循环完毕之后的<code>OPTIND - 1</code>, 因为参数从<code>1</code>开始编号,
选项处理完毕之后, 正好指向剩余其它参数的第一个.
在这里还要知道, <code>getopts</code>在处理参数的时候, 处理一个<code>开关型</code>选项, <code>OPTIND</code>加<code>1</code>,
处理一个<code>带值</code>的选项参数, <code>OPTIND则会加</code>2`.</p>
<p>最后, 真正需要处理的参数就是<code>$1~$#</code>了, 可以用<code>for</code>循环依次处理.</p>
<p>使用<code>getopts</code>处理参数虽然是方便, 但仍然有局限:</p>
<ol>
<li>选项参数的格式必须是<code>-d val</code>, 而不能是中间没有空格的<code>-dval</code>.</li>
<li>所有<code>选项参数</code>必须写在其它参数的前面, 因为<code>getopts</code>是从命令行前面开始处理,
遇到非<code>-</code>开头的参数, 或者选项参数结束标记<code>--</code>就中止了, 如果中间遇到非选项的命令行参数, 后面的<code>选项参数</code>就都取不到了.</li>
<li>不支持长选项,  也就是<code>--debug</code>之类的选项</li>
</ol>
<h3 id="外部强大的参数解析工具-getopt"><a class="header" href="#外部强大的参数解析工具-getopt">外部强大的参数解析工具: getopt</a></h3>
<p>先来看下<code>getopt</code>/<code>getopts</code>的区别</p>
<ol>
<li><code>getopts</code>是<code>bash</code>内建命令的,  而<code>getopt</code>是外部命令</li>
<li><code>getopts</code>不支持长选项,  比如: <code>--date</code></li>
<li>在使用<code>getopt</code>的时候,  每处理完一个位置参数后都需要自己<code>shift</code>来跳到下一个位置,
<code>getopts</code>只需要在最后使用<code>shift $(($OPTIND - 1))</code>来跳到<code>位置参数</code>的位置.</li>
<li>使用<code>getopt</code>时,  在命令行输入的位置参数是什么,  在<code>getopt</code>中需要保持原样,
比如 <code>-t </code>,  在<code>getopt</code>的<code>case</code>语句中也要使用<code>-t</code>,   而<code>getopts</code>中不要前面的<code>-</code>.</li>
<li><code>getopt</code>往往需要跟<code>set</code>配合使用</li>
<li><code>getopt -o</code>的选项</li>
<li><code>getopts</code> 使用语法简单, <code>getopt</code> 使用语法较复杂</li>
<li><code>getopts</code> 不会重排所有参数的顺序, <code>getopt</code> 会重排参数顺序</li>
<li><code>getopts</code> 出现的目的是为了代替 <code>getopt</code> 较快捷的执行参数分析工作</li>
</ol>
<h2 id="shell-的自动变量"><a class="header" href="#shell-的自动变量">shell 的自动变量</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/57784678">Bash Shell $*, $@, $#,</a></p>
<h3 id="-和-"><a class="header" href="#-和-">$* 和 $@</a></h3>
<ul>
<li>在 <code>Bash</code> 中, 不被双引号 <code>&quot;</code> 包裹时, 它们两个展开的结果是相同的, 都是表示外部输入的<code>参数列表</code>.</li>
<li>当被<code>双引号</code> 包裹时, 即 <code>&quot;$*&quot;</code>, <code>&quot;$@&quot;</code>. 这个时候, 前者表示的是用 <code>IFS</code> (Internal Field Separator) 连接起来的统一字符, 后者则表示的是输入的<code>每个参数</code>.
举例如下:</li>
</ul>
<p>文档名字为 <code>test_1.sh</code></p>
<pre><code class="language-bash">#!/bin/bash

export IFS=%

cnt=1
for i in &quot;$*&quot;
do
    echo &quot;Number of $cnt parameter is: $i&quot;
    (( cnt++ ))
done

echo
echo

cnt=1
for i in &quot;$@&quot;
do
    echo &quot;Number of $cnt parametre is: $i&quot;
    (( cnt++ ))
done
</code></pre>
<p>执行这个文件:</p>
<pre><code>./test_1.sh &quot;Hello, how are you?&quot; Second Third Fourth
</code></pre>
<p>输出的结果会是:</p>
<pre><code>Number of 1 parameter is: Hello, how are you?%Second%Third%Fourth

Number of 1 parameter is: Hello, how are you?
Number of 2 parameter is: Second
Number of 3 parameter is: Third
Number of 4 parameter is: Fourth
</code></pre>
<p>解释如下:</p>
<ul>
<li>被双括号后, <code>&quot;$*&quot;</code> 表示的是用<code>IFS</code>(内部分割符 ) 连接起来的<code>单个</code>字符串, 注意上面的打印输出只有<code>一个参数</code>.</li>
<li>而 <code>&quot;$@&quot;</code> 仍然表示的是各个输入的参数. 所以这也就解释了, 除非特殊情况, 为什么推荐使用 <code>$@</code>, 而不是 <code>$*</code> 展开<code>参数列表</code>.</li>
<li><code>$#</code> 获得<code>参数列表</code>的<code>个数</code>.</li>
</ul>
<p>如果接着上面的 <code>test_1.sh</code> 文件, 在最后添加:</p>
<pre><code>echo Number of total parameters are $#
</code></pre>
<p>执行后获得另外新的结果将会是:</p>
<pre><code>Number of total parameteers are 4
</code></pre>
<h3 id="---获得进程-id-信息"><a class="header" href="#---获得进程-id-信息">$$, $!, $? 获得进程 ID 信息</a></h3>
<pre><code>$$      获得当前进程 ID
$!      获得之前(上一个)进程 ID
$?      获得之前(上一个)进程结束的状态码 (0 表示成功, 1 表示失败)
</code></pre>
<p>举例如下:
例如我们有一个文档, <code>test_2.sh</code></p>
<pre><code class="language-bash">#!/bin/bash

echo &quot;Current process ID is: $$&quot;

sleep 100 &amp;
echo &quot;The most recent process ID is: $!&quot;
echo &quot;The most recent process exit status is: $?&quot;
</code></pre>
<p>执行<code>./test_2.sh</code>, 输出的结果:</p>
<pre><code>Current process ID is: 15599
The most recent process ID is: 15600
The most recent process ID exit status is: 0
</code></pre>
<p>然后接着执行<code>ps</code>, 输出的结果会是:</p>
<pre><code>  PID   TTY       TIME      CMD
14941   pts/0   00:00:00    bash
15600   pts/0   00:00:00    sleep
15601   pts/0   00:00:00    ps
</code></pre>
<p>解释如下:</p>
<p>注意: 不同的机器获得进程 <code>ID</code> 可能和上边的举例结果不一样.</p>
<p>当执行 <code>./test_2.sh</code> 之后, 我们得到了执行这个文件的进程 <code>ID: 15599</code> ,
后台执行 <code>sleep</code> 后, 再执行 <code>$!</code>, 我们可以获得这个后台进程的 <code>ID</code>, 结果为 <code>15600</code>;</p>
<p>由于这个进程是一个 <code>100</code> 秒的后台进程, 在后边的 <code>ps</code> 命令中, 我们很容易的就看到了这个 <code>ID</code> 为 <code>15600</code> 的后台进程.</p>
<p>紧接着我们执行 <code>$?,</code> 注意, 这个获得的进程状态码是上一个的进程结束码,
由于我们上一个命令是 <code>echo</code>, 而 <code>echo</code> 是顺利结束命令的, 所以我们获得了状态码 <code>0</code> , 表示 <code>echo</code> 命令执行成功.</p>
<h3 id="--和-_"><a class="header" href="#--和-_">$- 和 $_</a></h3>
<p><code>$-</code> 是 <code>set</code> 命令的 <code>–h</code> 和 <code>–B</code> 的参数, 表示使用内置的 <code>set</code> 命令扩展解释之后的<code>参数行</code>,
具体分别表示为, 记住<code>工作路径</code>, 和允许使用 <code>!</code> 历史扩展, 详细请参阅 <code>set</code> 命令.</p>
<p><code>$_ </code>(下划线) 表示的是打印上一个输入<code>参数行</code>, 在脚本开头使用这个命令, 打印出脚本的<code>路径名</code>.</p>
<p>举例如下: 例如我们有一个文档, <code>test_3.sh</code></p>
<pre><code class="language-bash">#!/bin/bash
echo &quot;Current absolute file path name is: $_&quot;
echo &quot;$-&quot;
echo &quot;Second $_&quot;

let cnt=1
echo &quot;Third $_&quot;
echo &quot;$cnt&quot;
echo &quot;Fourth $_&quot;
</code></pre>
<p>执行命令: <code>./test_3.sh</code>. 输出的结果是:</p>
<pre><code>Current absolute file path name is: ./test_3.sh
hB
Second hB
Third cnt=1
1
Fourth 1
</code></pre>
<p>解释如下:</p>
<ul>
<li>由于我们是在<code>当前路径</code>下执行的<code>脚本</code>, 那么在<code>脚本</code>开始执行其他命令之前,
<code>$_</code> 获得就是<code>脚本</code>的<code>绝对路径</code>名称 -- <code>./test_3.sh</code>, 这里 <code>.</code> (点号) 表示当前路径.</li>
<li>执行 <code>$-</code> 后, 表示使用 <code>set</code> 的 <code>–h</code> 和 <code>–B</code> 选项, 这时传入的参数是 <code>hB</code>;</li>
<li>第二次执行 <code>$_</code> 后, 获得上次传入的参数, 表示为 <code>hB</code>;</li>
<li>在第三次执行时, 由于上次对于 <code>let</code> 命令传入的参数是 <code>cnt=1</code>, 那么这时获得的参数是 <code>cnt=1</code>;</li>
<li>第四次执行时, 对于 <code>echo</code> 传入的参数是扩展后的 <code>$cnt</code>, 也就是 <code>1</code>, 那么这时获得参数就是 <code>1</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="awk"><a class="header" href="#awk">awk</a></h1>
<p><a href="https://www.w3cschool.cn/awk/hs671k8f.html">w3c AWk</a></p>
<p>部分 AWK 的典型应用场景</p>
<p>AWK 可以做非常多的工作.  下面只是其中的一小部分:</p>
<ul>
<li>
<p>文本处理,</p>
</li>
<li>
<p>生成格式化的文本报告,</p>
</li>
<li>
<p>进行算术运算,</p>
</li>
<li>
<p>字符串操作, 以及其它更多.</p>
</li>
<li>
<p>awk 用<code>#</code>进行注释.</p>
</li>
</ul>
<h2 id="awk-工作流程"><a class="header" href="#awk-工作流程">AWK 工作流程</a></h2>
<h3 id="工作流程"><a class="header" href="#工作流程">工作流程</a></h3>
<p>AWK 执行的流程非常简单: 读( Read ), 执行( Execute )与重复( Repeat ).</p>
<ul>
<li>读(Read): AWK 从输入流(文件, 管道或者标准输入)中读入一行然后将其存入内存中.</li>
<li>执行(Execute): 对于每一行输入, 所有的 <code>AWK</code> 命令按顺执行.  默认情况下, AWK 命令是针对于每一行输入, 但是我们可以将其限制在指定的模式中.</li>
<li>重复(Repeate):一直重复上述两个过程直到文件结束.</li>
</ul>
<h3 id="程序的结构"><a class="header" href="#程序的结构">程序的结构</a></h3>
<p>我们已经见过 AWK 程序的工作流程.  现在让我们一起来学习 AWK 程序的结构.</p>
<ul>
<li>开始块(BEGIN block)<code>BEGIN {awk-commands}</code></li>
<li>主体块(Body Block)<code>/pattern/ {awk-commands}</code></li>
<li>结束块(END Block)<code>END {awk-commands}</code></li>
</ul>
<p>开始块和结束块需要大写, 它们是可选的. 默认情况下, 对于输入的每一行, <code>AWK</code> 都会很执行命令. 但是, 我们可以将其限定在指定的模式中.  注意, 在主体块部分没有关键字存在.</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>先创建一个名为 <code>marks.txt</code> 的文件. 其中包括序列号, 学生名字, 课程名称与所得分数.</p>
<pre><code class="language-bash">1)    Amit     Physics    80
2)    Rahul    Maths      90
3)    Shyam    Biology    87
4)    Kedar    English    85
5)    Hari     History    89
</code></pre>
<p>接下来, 我们将使用 AWK 脚本来显示输出文件中的内容, 同时输出表头信息.</p>
<pre><code class="language-bash">awk 'BEGIN{printf &quot;Sr No\tName\tSub\tMarks\n&quot;} {print}' marks.txt
</code></pre>
<p>程序启动时, AWK 在开始块中输出表头信息. 在主体块中, AWK 每读入一行就将读入的内容输出至标准输出流中, 一直到整个文件被全部读入为止.</p>
<h2 id="awk-基本示例"><a class="header" href="#awk-基本示例">awk 基本示例</a></h2>
<hr />
<p>默认情况下, 如果某行与模式串匹配, <code>AWK</code> 会将整行输出:</p>
<pre><code class="language-bash">awk '/a/ {print $0}' marks.txt
</code></pre>
<p>上面的示例中, 我们搜索模式串 <code>a</code>, 每次成功匹配后都会执行主体块中的命令.
如果没有主体块--默认的动作是输出记录(行). 因此上面的效果也可以使用下面简略方式实现,它们会得到相同的结果:</p>
<pre><code class="language-bash">awk '/a/' marks.txt
</code></pre>
<hr />
<p>不过, 我们可以让 AWK 只输出特定的域(列)的内容.  例如, 下面的这个例子中当模式串匹配成功后只会输出第三列与第四列的内容:
注意, 列的顺序可以任意, 比如下面的<code>$4 &quot;\t&quot; $3</code></p>
<p><code>awk '/a/ {print $4 &quot;\t&quot; $3}' marks.txt</code></p>
<hr />
<p>计数匹配次数并输出</p>
<p><code>awk '/a/{++cnt} END {print &quot;Count = &quot;, cnt}' marks.txt</code></p>
<hr />
<p>输出字符数多于 <code>18</code> 的行</p>
<p>这个例子中我们只输出那些字符数超过 <code>18</code> 的记录:</p>
<p><code>awk 'length($0) &gt; 18' marks.txt</code>
<code>awk 'length($0) &gt; 18 {print}' marks.txt</code>
<code>awk 'length($0) &gt; 18 {print $2}' marks.txt</code></p>
<p>AWK 提供了内置的 <code>length</code> 函数. 该函数返回字符串的长度.
变量 <code>$0</code> 表示整行, 缺失的主体块会执行默认动作, 例如, 打印输出.
因此, 如果一行中字符数超过 <code>18</code>,  则比较的结果为真, 该行则被输出.</p>
<h2 id="awk-内置变量"><a class="header" href="#awk-内置变量">AWK 内置变量</a></h2>
<p><code>AWK</code> 提供了一些内置变量.  它们在你写 <code>AWK</code> 脚本的时候起着很重要的作用.</p>
<h3 id="标准-awk-变量"><a class="header" href="#标准-awk-变量">标准 AWK 变量</a></h3>
<p><code>ARGC</code></p>
<p><code>ARGC</code> 表示在命令行提供的参数的个数.</p>
<p><code>awk 'BEGIN {print &quot;Arguments =&quot;, ARGC}' One Two Three Four</code></p>
<p>执行上面的命令可以得到如下的结果:</p>
<p><code>Arguments = 5</code></p>
<p>程序哪儿出毛病了吗? 为什么只输入四个参数而 AWK 却显示输入的参数个数的五呢?  看完下面这个例子, 你就会明白的.</p>
<hr />
<p><code>ARGV</code></p>
<p>这个变量表示存储命令行输入参数的数组. 数组的有效索引是从 <code>0</code> 到 <code>ARGC-1</code>.</p>
<pre><code class="language-bash">awk 'BEGIN { for (i = 0; i &lt; ARGC - 1; ++i)
      { printf &quot;ARGV[%d] = %s\n&quot;, i, ARGV[i] }
                    }' one two three four
</code></pre>
<hr />
<p><code>CONVFMT</code></p>
<p>此变量表示数据转换为字符串的格式, 其默认值为 <code>%.6g</code>.</p>
<p><code>awk 'BEGIN { print &quot;Conversion Format =&quot;, CONVFMT }'</code></p>
<hr />
<p><code>ENVIRON</code></p>
<p>此变量是与环境变量相关的关联数组变量.</p>
<p><code>awk 'BEGIN { print ENVIRON[&quot;USER&quot;] }'</code></p>
<p>可以使用 GNU/Linux 系统中的 <code>env</code> 命令查询其它环境变量的名字.</p>
<hr />
<p><code>FILENAME</code></p>
<p>此变量表示当前文件名称.</p>
<p><code>awk 'END {print FILENAME}' marks.txt</code></p>
<p>值得注意的是在开始块中<code>FILENAME</code>是未定义的.</p>
<hr />
<p><code>FS</code></p>
<p>此变量表示输入的数据域之间的分隔符, 其默认值是空格.  你可以使用 <code>-F</code> 命令行选项改变它的默认值.</p>
<p><code>awk 'BEGIN {print &quot;FS = &quot; FS}' | cat -vte</code></p>
<hr />
<p><code>NF</code></p>
<p>此变量表示当前输入记录中域的数量(相当于<strong>列</strong>的数量). 例如, 下面这个例子只输出超过两个域的行:</p>
<p><code>echo -e &quot;One Two\nOne Two Three\nOne Two Three Four&quot; | awk 'NF &gt; 2'</code></p>
<hr />
<p><code>NR</code></p>
<p>此变量表示当前记录的数量(即<strong>行</strong>的数量). (译注: 该变量类似一个计数器, 统计记录的数量).
下面例子会输出读入的前三行(<code>NR&lt;3</code>).</p>
<p><code>echo -e &quot;One Two\nOne Two Three\nOne Two Three Four&quot; | awk 'NR &lt; 3'</code></p>
<hr />
<p><code>FNR</code></p>
<p>该变量与 <code>NR</code> 类似, 不过它是相对于当前文件而言的. 此变量在处理多个文件输入时有重要的作用.
每当从新的文件中读入时 <code>FNR</code> 都会被重新设置为 <code>0</code>.</p>
<hr />
<p><code>OFMT</code></p>
<p>此变量表示数值输出的格式, 它的默认值为 <code>%.6g</code>.</p>
<p><code>awk 'BEGIN {print &quot;OFMT = &quot; OFMT}'</code></p>
<hr />
<p><code>OFS</code></p>
<p>此变量表示输出域之间的分割符, 其默认为空格.</p>
<p><code>awk 'BEGIN {print &quot;OFS = &quot; OFS}' | cat -vte</code></p>
<hr />
<p><code>ORS</code></p>
<p><code>cat -vte</code> 等于 <code>cat -A</code>, 打印所有字符, 包括通常不显示的.</p>
<p>此变量表示输出记录(行)之间的分割符, 其默认值是换行符.</p>
<p><code>awk 'BEGIN {print &quot;ORS = &quot; ORS}' | cat -vte</code></p>
<hr />
<p><code>RLENGTH</code></p>
<p>此变量表示 <code>match</code> 函数匹配的字符串长度. AWK 的 <code>match</code> 函数用于在输入的字符串中搜索指定字符串.</p>
<p><code>awk 'BEGIN { if (match(&quot;One Two Three&quot;, &quot;re&quot;)) { print RLENGTH } }'</code></p>
<p><code>RS</code></p>
<p>此变量表示输入记录的分割符, 其默认值为换行符.</p>
<p><code>awk 'BEGIN {print &quot;RS = &quot; RS}' | cat -vte</code></p>
<hr />
<p><code>RSTART</code></p>
<p>此变量表示由 <code>match</code> 函数匹配的字符串的第一个字符的位置.</p>
<p><code>awk 'BEGIN { if (match(&quot;One Two Three&quot;, &quot;Thre&quot;)) { print RSTART } }'</code></p>
<hr />
<p><code>SUBSEP</code></p>
<p>此变量表示数组下标的分割行符, 其默认值为<code>\034</code>.</p>
<p><code>awk 'BEGIN { print &quot;SUBSEP = &quot; SUBSEP }' | cat -vte</code></p>
<hr />
<p><code>$0</code></p>
<p>此变量表示整个输入记录.</p>
<p><code>awk '{print $0}' marks.txt</code></p>
<hr />
<p><code>$n</code></p>
<p>此变量表示当前输入记录的第 <code>n</code> 个域, 这些域之间由 <code>FS</code> 分割.</p>
<p><code>awk '{print $3 &quot;\t&quot; $4}' marks.txt</code></p>
<h3 id="gnu-awk-特定的变量"><a class="header" href="#gnu-awk-特定的变量">GNU AWK 特定的变量</a></h3>
<p>下面将介绍 <code>GNU</code> <code>AWK </code>专有的变量:</p>
<p><code>ARGIND</code></p>
<p>此变量表示当前文件中正在处理的 <code>ARGV</code> 数组的索引值.</p>
<p><code>awk '{ print &quot;ARGIND   = &quot;, ARGIND; print &quot;Filename = &quot;, ARGV[ARGIND] }' junk1 junk2 junk3</code></p>
<hr />
<p><code>BINMODE</code></p>
<p>此变量用于在非 POSIX 系统上指定 AWK 对所有文件的 <code>I/O</code> 都使用二进制模式.
数值<code>1</code>, <code>2</code> 或者 <code>3</code> 分别指定输入文件, 输出文件或所有文件.
字符串值 <code>r</code> 或 <code>w</code> 分别指定输入文件或者输出文件使用二进制 <code>I/O</code>模式.  字符串值 <code>rw</code> 或 <code>wr</code> 指定所有文件使用二进制 I/O模式.</p>
<p><code>ERRNO</code></p>
<p>此变量用于存储当 <code>getline</code> 重定向失败或者 <code>close</code> 函数调用失败时的失败信息.</p>
<p><code>awk 'BEGIN { ret = getline &lt; &quot;junk.txt&quot;; if (ret == -1) print &quot;Error:&quot;, ERRNO }'</code></p>
<hr />
<p><code>FIELDWIDTHS</code></p>
<p>该变量表示一个分割域之间的空格的宽度. 当此变量被设置后,  <code>GAWK</code> 将输入的域之间的宽度处理为固定宽度, 而不是使用 <code>FS</code> 的值作为域间的分割符.</p>
<hr />
<p><code>IGNORECASE</code></p>
<p>当此变量被设置后, <code>GAWK</code>将变得大小写不敏感. 下面是一个简单的例子:</p>
<p><code>awk 'BEGIN{IGNORECASE=1} /amit/' marks.txt</code></p>
<hr />
<p><code>LINT</code></p>
<p>此变量提供了在 <code>GAWK</code> 程序中动态控制 <code>--lint</code> 选项的一种途径.
当这个变量被设置后,  <code>GAWK</code> 会输出 <code>lint</code> 警告信息. 如果给此变量赋予字符值 <code>fatal</code>, <code>lint</code> 的所有警告信息将会变了致命错误信息(fatal errors)输出, 这和 <code>--lint=fatal</code> 效果一样.</p>
<p><code>awk 'BEGIN {LINT=1; a}'</code></p>
<hr />
<p><code>PROCINFO</code></p>
<p>这是一个关联数组变量, 它保存了进程相关的信息. 比如,  真正的和有效的 <code>UID</code> 值, 进程 <code>ID</code> 值等等.</p>
<p><code>awk 'BEGIN { print PROCINFO[&quot;pid&quot;] }'</code></p>
<hr />
<p><code>TEXTDOMAIN</code></p>
<p>此变量表示　<code>AWK</code> 程序当前文本域.  它主要用寻找程序中的字符串的本地翻译, 用于程序的国际化.</p>
<p><code>awk 'BEGIN { print TEXTDOMAIN }'</code></p>
<p>执行上面的命令可以得到如下的结果:</p>
<p><code>messages</code></p>
<p>(译注: 输出 <code>message</code> 是由于 <code>TEXTDOMAIN</code> 的默认值为 <code>messages</code>) 上面所有的输出都是英文字符是因为本地语言环境配置为 <code>en_IN</code></p>
<h2 id="awk-操作符"><a class="header" href="#awk-操作符">AWK 操作符</a></h2>
<p>与其它编程语言一样, AWK 也提供了大量的操作符. 这一章节中, 我们将结合例子介绍　AWK 操作符的使用方法: 　</p>
<h3 id="算术运算符"><a class="header" href="#算术运算符">算术运算符　　</a></h3>
<hr />
<p>加法运算符　</p>
<p>加法运算由符号 <code>+</code> 表示, 它求得两个或者多个数字的和. 下面是一个使用示例:</p>
<p><code>awk 'BEGIN { a = 50; b = 20; print &quot;(a + b) = &quot;, (a + b) }'</code></p>
<hr />
<p>减法运算符　　</p>
<p>减法运算由符号<code>-</code> 表示, 它求得两个或者多个数值的差. 示例如下:</p>
<p><code>awk 'BEGIN { a = 50; b = 20; print &quot;(a - b) = &quot;, (a - b) }'</code></p>
<hr />
<p>乘法运算符　　</p>
<p>乘法运算由星号( <code>*</code> )表示, 它求得两个或者多个数值的乘积. 示例如下:</p>
<p><code>awk 'BEGIN { a = 50; b = 20; print &quot;(a * b) = &quot;, (a * b) }'</code></p>
<hr />
<p>除法运算符　　</p>
<p>除法运算由斜线(<code> /</code> ) 表示, 它求得两个或者两个以上数值的商. 示例如下:</p>
<p><code>awk 'BEGIN { a = 50; b = 20; print &quot;(a / b) = &quot;, (a / b) }'</code></p>
<hr />
<p>模运算符　　</p>
<p>模运算由百分(<code>％</code>)表示, 它表示两个或者多个数进行模除运算得到其余数. 下面是示例:</p>
<p><code>awk 'BEGIN { a = 50; b = 20; print &quot;(a % b) = &quot;, (a % b) }'</code></p>
<hr />
<p>递增运算符与递减运算符　　
　
前置递增运算由 <code>++</code> 表示. 它将操作数加 <code>1</code>. 这个运算符将操作值增加 <code>1</code>, 然后再返回增加后的值.</p>
<p><code>awk 'BEGIN { a = 10; b = ++a; printf &quot;a = %d, b = %d\n&quot;, a, b }'</code></p>
<hr />
<p>前置递减运算符　　</p>
<p>前置递减运算由 <code>--</code> 表示. 它的语义是将操作数减 <code>1</code>. 这个运算符先将操作数的值减 <code>1</code>,  再将被减小后的值返回.</p>
<p><code>awk 'BEGIN { a = 10; b = --a; printf &quot;a = %d, b = %d\n&quot;, a, b }'</code></p>
<hr />
<p>后置递增运算符 　　</p>
<p>后置递增运算由 <code>++</code> 表示. 它同样将操作数的值加<code>1</code>. 与前置递增运算符不同, 它先将操作数的值返回, 再将操作数的值加 <code>1</code>.</p>
<p><code>awk 'BEGIN { a = 10; b = a++; printf &quot;a = %d, b = %d\n&quot;, a, b }'</code></p>
<hr />
<p>后置递减运算符　　</p>
<p>后置递增运算符由 <code>--</code> 表示. 它同样将操作数的值减<code>1</code>. 该操作符先将操作数的值返回, 然后将操作数减<code>1</code>.</p>
<p><code>awk 'BEGIN { a = 10; b = a--; printf &quot;a = %d, b = %d\n&quot;, a, b }'</code></p>
<h3 id="赋值操作符"><a class="header" href="#赋值操作符">赋值操作符　　</a></h3>
<p>AWK 支持下面这些赋值操作: 　</p>
<hr />
<p>简单赋值　　</p>
<p>简单赋值操作由 <code>=</code> 表示. 示例如下: 　　</p>
<p><code>awk 'BEGIN { name = &quot;Jerry&quot;; print &quot;My name is&quot;, name }'</code></p>
<hr />
<p>加法赋值　　</p>
<p>加法赋值运算符为 <code>+=</code>. 下面为示例:  　　</p>
<p><code>awk 'BEGIN { cnt=10; cnt += 10; print &quot;Counter =&quot;, cnt }'</code></p>
<hr />
<p>减法赋值　　</p>
<p>减法赋值运算符为 <code>-=</code>. 下面为示例:  　　</p>
<p><code>awk 'BEGIN { cnt=100; cnt -= 10; print &quot;Counter =&quot;, cnt }'</code></p>
<hr />
<p>乘法赋值　　</p>
<p>乘法赋值运算符为 <code>*=</code>. 下面为示例:  　　</p>
<p><code>awk 'BEGIN { cnt=10; cnt *= 10; print &quot;Counter =&quot;, cnt }'</code></p>
<p>***　　
除法赋值　　</p>
<p>除法赋值运算符为 <code>/=</code>. 下面为示例: 　　</p>
<p><code>awk 'BEGIN { cnt=100; cnt /= 5; print &quot;Counter =&quot;, cnt }'</code></p>
<p>***　
模运算赋值　　</p>
<p>模运算赋值运算符为 <code>%=</code>. 下面为示例:  　　</p>
<p><code>awk 'BEGIN { cnt=100; cnt %= 8; print &quot;Counter =&quot;, cnt }'</code></p>
<hr />
<p>指数赋值　　</p>
<p>指数赋值运算符为 <code>^=</code>. 下面为示例:  　　</p>
<p><code>awk 'BEGIN { cnt=2; cnt ^= 4; print &quot;Counter =&quot;, cnt }'</code>
　</p>
<h3 id="关系运算符"><a class="header" href="#关系运算符">关系运算符 　　</a></h3>
<p>AWK 支持如下关系运算符:</p>
<p>***　　
等于　　</p>
<p>等于运算符为 <code>==</code>. 如果两个操作数相等则返回真, 否则返回假. 示例如下: 　　</p>
<p><code>awk 'BEGIN { a = 10; b = 10; if (a == b) print &quot;a == b&quot; }'</code></p>
<hr />
<p>不等于</p>
<p>不等于运算符为 <code>!=</code>. 如果两个操作数相等则返回假, 否则返回真. 示例如下: 　　</p>
<p><code>awk 'BEGIN { a = 10; b = 20; if (a != b) print &quot;a != b&quot; }'</code></p>
<hr />
<p>小于 　　</p>
<p>小于运算符为 <code>&lt;</code>. 如果左操作数小于右操作数据则返回真, 否则返回假. 示例如下:  　　</p>
<p><code>awk 'BEGIN { a = 10; b = 20; if (a &lt; b) print &quot;a &lt; b&quot; }'</code></p>
<hr />
<p>小于或等于 　　</p>
<p>小于等于运算符为 <code>&lt;=</code>. 如果左操作数小于或等于右操作数据则返回真, 否则返回假. 示例如下:  　　</p>
<p><code>awk 'BEGIN { a = 10; b = 10; if (a &lt;= b) print &quot;a &lt;= b&quot; }'</code></p>
<hr />
<p>大于　　</p>
<p>大于运算符为 <code>&gt;</code>. 如果左操作数大于右操作数则返回真, 否则返回假. 示例如下:  　</p>
<p><code>awk 'BEGIN { a = 10; b = 20; if (b &gt; a ) print &quot;b &gt; a&quot; }'</code></p>
<hr />
<p>大于或等于　　</p>
<p>大于等于运算符为<code> &gt;=</code>. 如果左操作数大于或等于右操作数则返回真, 否则返回假. 示例如下: 　　</p>
<p><code>awk 'BEGIN { a = 10; b = 10; if (a &gt;= b) print &quot;a &gt;= b&quot; }'</code></p>
<h3 id="逻辑运算符-1"><a class="header" href="#逻辑运算符-1">逻辑运算符　</a></h3>
<p><code>AWK</code> 包括如下逻辑运算符: 　</p>
<p>***　
逻辑与　　</p>
<p>逻辑与运算符为 <code>&amp;&amp;</code>. 下面是逻辑与运算符的语法:</p>
<p><code>expr1 &amp;&amp; expr2</code></p>
<p>如果 <code>expr1</code> 与 <code>epxr2</code> 均为真, 则最终结果为真; 否则为假. 请注意, 只有当 <code>expr1</code> 为真时才会计算 <code>expr2</code> 的值, 若 <code>expr1</code> 为假则直接返回真, 而不再计算 <code>expr2</code> 的值. 下面的例子判断给定的字符串是否是八进制形式:</p>
<p><code>awk 'BEGIN {num = 5; if (num &gt;= 0 &amp;&amp; num &lt;= 7) printf &quot;%d is in octal format\n&quot;, num }'</code></p>
<hr />
<p>逻辑或　　</p>
<p>逻辑或运算符为 <code>||</code>. 该运算符语法如下:  　</p>
<p><code>expr1 || expr2</code></p>
<p>如果 <code>expr1</code> 与 <code>epxr2</code> 至少其中一个为真, 则最终结果为真; 二者均为假时则为假. 请注意, 只有当 <code>expr1</code> 为假时才会计算 expr2 的值, 若 <code>expr1</code> 为真则不会再计算 <code>expr2</code> 的值. 示例如下:</p>
<p><code>awk 'BEGIN {ch = &quot;\n&quot;; if (ch == &quot; &quot; || ch == &quot;\t&quot; || ch == &quot;\n&quot;) print &quot;Current character is whitespace.&quot; }'</code></p>
<hr />
<p>逻辑非</p>
<p>逻辑非运算为感叹号(<code>!</code>). 此运算符语法如下:</p>
<p><code>! expr1</code></p>
<p>逻辑非将 <code>expr1</code> 的真值取反. 如果 <code>expr1</code> 为真, 则返回 <code>0</code>. 否则返回 <code>1</code>. 下面的示例判断字符串是否为空:</p>
<p><code>awk 'BEGIN { name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; }'</code></p>
<hr />
<p>三元运算符</p>
<p>我们可以使用三元运算符来实现条件表达式. 下面为其语法:</p>
<p><code>condition_expression ? statement1 : statement2</code></p>
<p>当条件表达式( condition expression)为真时, <code>statement1</code> 执行, 否则 <code>statement2</code> 执行. 下面的示例将返回最大数值:</p>
<pre><code class="language-bash">awk 'BEGIN { a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max}'
</code></pre>
<h3 id="一元运算符"><a class="header" href="#一元运算符">一元运算符</a></h3>
<p>AWK 支持如下几种一元运算符:</p>
<hr />
<p>一元加运算</p>
<p>一元加运算符表示为 <code>+</code>. 它将操作数乘以 <code>+1</code>.</p>
<p><code>awk 'BEGIN { a = -10; a = +a; print &quot;a =&quot;, a }'</code></p>
<hr />
<p>一元减运算符</p>
<p>一元减运算符为 <code>- </code>. 它表示将操作数乘以 <code>-1</code>.</p>
<p><code>awk 'BEGIN { a = -10; a = -a; print &quot;a =&quot;, a }'</code></p>
<hr />
<p>指数运算符</p>
<p>幂运算符<code>^</code></p>
<p><code>^</code> 运算符对操作数执行幂运算. 下面的示例求 10 的二次幂.</p>
<p><code>awk 'BEGIN { a = 10; a = a ^ 2; print &quot;a =&quot;, a }'</code></p>
<p>幂运算符 <code>**</code></p>
<p>** 运算符对操作数执行幂运算. 下面的示例求 10 的二次幂.</p>
<p><code>awk 'BEGIN { a = 10; a = a ** 2; print &quot;a =&quot;, a }'</code></p>
<hr />
<p>字符串连接操作符</p>
<p>空格 (<code>space</code>) 操作符可以完成两个字符串的连接操作. 示例如下:</p>
<p><code>awk 'BEGIN { str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 }'</code></p>
<hr />
<p>数组成员操作符</p>
<p>数组成员操作符为 <code>in</code>. 该操作符用于访问数组元素 . 下面的示例用于此操作符输出数组中所有元素.</p>
<p><code>awk 'BEGIN { arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\n&quot;, i, arr[i] }'</code></p>
<h3 id="正则表达式操作符"><a class="header" href="#正则表达式操作符">正则表达式操作符</a></h3>
<p>下面将介绍两种正则表达式操作符:</p>
<hr />
<p>匹配运算符为 <code>~</code>. 它用于搜索包含匹配模式字符串的域. 下面的示例中将输出包括 <code>9</code> 的行:</p>
<p><code>awk '$0 ~ 9' marks.txt</code></p>
<hr />
<p>不匹配操作符为 <code>!~</code>.  此操作符用于搜索不匹配指定字符串的域. 如下示例输出不包含 <code>9</code> 的行:</p>
<p><code>awk '$0 !~ 9' marks.txt</code></p>
<h2 id="awk-正则表达式"><a class="header" href="#awk-正则表达式">AWK 正则表达式</a></h2>
<p>AWK 可以方便高效地处理正则表达式. 大量复杂的任务都可以由极其简单的正则表达式来解决.
每一个精通命令行的人都知道正则表达式真正的威力所在.</p>
<p>字符集</p>
<p>Class Meaning</p>
<ul>
<li><code>[:alnum:]</code> Alphanumeric characters</li>
<li><code>[:alpha:]</code> Alphabetic characters</li>
<li><code>[:blank:]</code> Space and TAB characters</li>
<li><code>[:cntrl:]</code> Control characters</li>
<li><code>[:digit:]</code> Numeric characters</li>
<li><code>[:graph:]</code> Characters that are both printable and visible (a space is printable but not visible, whereas an 'a' is both)</li>
<li><code>[:lower:]</code>    Lowercase alphabetic characters</li>
<li><code>[:print:]</code>    Printable characters (characters that are not control characters)</li>
<li><code>[:punct:]</code>    Punctuation characters (characters that are not letters, digits, control characters, or space characters)</li>
<li><code>[:space:]</code> Space characters (these are: space, TAB, newline, carriage return, formfeed and vertical tab)</li>
<li><code>[:upper:]</code> Uppercase alphabetic characters</li>
<li><code>[:xdigit:]</code> Characters that are hexadecimal digits</li>
</ul>
<p>若要匹配ASCII 字符集, 使用<code>[\x00-\x7F]</code>, 匹配<code>0</code>到<code>127</code>. 匹配非ASCII字符集, 使用<code>[^\x00-\x7F]</code></p>
<p><code>gawk</code> 还允许以下拓展用法</p>
<p><code>\s</code> : 空白符号, 相当于<code>[[:space:]]</code>
<code>\S</code> : 非空白字符, 相当于<code>[^[:space:]]</code>
<code>\w</code>: 匹配任何word字符, 字母数字下划线, 相当于<code>[[:alnum:]_]</code>
<code>\W</code>: 匹配任何非word字符, 相当于<code>[^[:alnum:]_]</code>
<code>\&lt;</code> : 匹配单词开头(空字符), 如<code>/\&lt;away/</code>匹配<code>'away'</code>, 但不匹配<code>'stowaway'</code>
<code>\&gt;</code> : 匹配单词结尾(空字符), 如<code>/stow\&gt;/</code>匹配<code>'stow'</code>但不匹配<code>'stowaway'</code>
<code>\y</code>: 匹配开头或者结尾
<code>\B</code>: 匹配word中间的空字符位置. 比如, <code>/\Brat\B/</code>匹配<code>'crate'</code>, 但不匹配<code>'dirty rat'</code>, 它是<code>\y</code>的反义.</p>
<p>There are two other operators that work on buffers. In Emacs, a buffer is, naturally, an Emacs buffer. Other GNU programs, including gawk, consider the entire string to match as the buffer. The perators are:</p>
<p><code>\`</code>: Matches the empty string at the beginning of a buffer (string)
<code>\'</code>: Matches the empty string at the end of a buffer (string)</p>
<h3 id="点dot"><a class="header" href="#点dot">点(Dot)</a></h3>
<p>点字符(<code>.</code>)可以匹配除了行结束字符的所有字符. 比如下面的便子就可以匹配 <code>fin</code>, <code>fun</code>, <code>fan</code> 等等.</p>
<p><code>echo -e &quot;cat\nbat\nfun\nfin\nfan&quot; | awk '/f.n/'</code></p>
<h3 id="行开始"><a class="header" href="#行开始">行开始</a></h3>
<p>行开始符(<code>^</code>)匹配一行的开始. 下面的示例将输出所有以字符串 <code>The</code> 开始的行.</p>
<p><code>echo -e &quot;This\nThat\nThere\nTheir\nthese&quot; | awk '/^The/'</code></p>
<h3 id="行结束"><a class="header" href="#行结束">行结束</a></h3>
<p>行结束符(<code>$</code>)匹配一行的结束. 下面的例子中将输出所有以字符 <code>n</code> 结束的行:</p>
<p><code>echo -e &quot;knife\nknow\nfun\nfin\nfan\nnine&quot; | awk '/n$/'</code></p>
<h3 id="匹配字符集"><a class="header" href="#匹配字符集">匹配字符集</a></h3>
<p>匹配字符集用于匹配集合(由方括号表示)中的一个字符. 如下例子中, 匹配 <code>Call</code> 与 <code>Tall</code> 而不会匹配 <code>Ball</code>.</p>
<p><code>echo -e &quot;Call\nTall\nBall&quot; | awk '/[CT]all/'</code></p>
<h3 id="排除集"><a class="header" href="#排除集">排除集</a></h3>
<p>正则匹配时会排除集合中的字符. 如下例子中只会输出 <code>Ball</code> .</p>
<p><code>echo -e &quot;Call\nTall\nBall&quot; | awk '/[^CT]all/'</code></p>
<h3 id="或"><a class="header" href="#或">或</a></h3>
<p>竖线(<code>|</code>)允许正则表达式实现逻辑或运算. 下面例子将会输出 <code>Ball</code> 与 <code>Call</code> .</p>
<p><code>echo -e &quot;Call\nTall\nBall\nSmall\nShall&quot; | awk '/Call|Ball/'</code></p>
<h3 id="最多出现一次"><a class="header" href="#最多出现一次">最多出现一次</a></h3>
<p>该符号( <code>?</code>)前面的字符不出现或者出现一次. 如下示例匹配 <code>Colour</code> 与 <code>Color. </code> 使用 <code>?</code> 使得 <code>u</code> 变成了可选字符 .</p>
<p><code>echo -e &quot;Colour\nColor&quot; | awk '/Colou?r/'</code></p>
<h3 id="出现零次或多次"><a class="header" href="#出现零次或多次">出现零次或多次</a></h3>
<p>该符号(<code>*</code>) 允许其前的字符出现多次或者不出现. 如下示例将匹配 <code>ca</code>, <code>cat</code>, <code>catt</code> 等等.</p>
<p><code>echo -e &quot;ca\ncat\ncatt&quot; | awk '/cat*/'</code></p>
<h3 id="出现一次或多次"><a class="header" href="#出现一次或多次">出现一次或多次</a></h3>
<p>该符号(<code>+</code>)使得其前的字符出现一次或者多次. 下面的例子会匹配一个 <code>2</code> 或者多个连续的 <code>2</code>.</p>
<p><code>echo -e &quot;111\n22\n123\n234\n456\n222&quot;  | awk '/2+/'</code></p>
<h3 id="分组"><a class="header" href="#分组">分组</a></h3>
<p>括号用于分组而字符 <code>|</code> 用于提供多种选择. 如下的正则表达式会匹配所有包含 <code>Apple Juice</code> 或 <code>Aplle Cake</code> 的行.</p>
<p><code>echo -e &quot;Apple Juice\nApple Pie\nApple Tart\nApple Cake&quot; | awk '/Apple (Juice|Cake)/'</code></p>
<h2 id="awk-数组"><a class="header" href="#awk-数组">AWK 数组</a></h2>
<p>AWK 有<strong>关联数组</strong>这种数据结构, 而这种数据结构最好的一个特点就是它的索引值不需要是连续的整数值.
我们既可以使用数字也可以使用字符串作为数组的索引.
除此之外, 关联数组也不需要提前声明其大小, 因为它在运行时可以自动的增大或减小.</p>
<p>如下为数组使用的语法格式:</p>
<pre><code class="language-bash">array_name[index]=value
</code></pre>
<p>其中 <code>array_name</code> 是数组的名称, <code>index</code> 是数组索引, <code>value</code> 为数组中元素所赋予的值.
创建数组</p>
<p>为了进一步了解数组, 我们先来看一下如何创建数组以及如何访问数组元素:</p>
<pre><code class="language-bash">awk 'BEGIN {
fruits[&quot;mango&quot;]=&quot;yellow&quot;;
fruits[&quot;orange&quot;]=&quot;orange&quot;
print fruits[&quot;orange&quot;] &quot;\n&quot; fruits[&quot;mango&quot;]
}'
</code></pre>
<p>在上面的例子中, 我们定义了一个水果(fruits)数组, 该数组的索引为水果名称, 值为水果的颜色.
可以使用如下格式访问数组元素:</p>
<p><code>array_name[index] </code></p>
<h3 id="删除数组元素"><a class="header" href="#删除数组元素">删除数组元素</a></h3>
<p>插入元素时我们使用赋值操作符. 删除数组元素时, 我们则使用 <code>delete</code> 语句. 如下所示:</p>
<p><code>delete array_name[index]</code></p>
<p>下面的例子中, 数组中的 orange 元素被删除(删除命令没有输出):</p>
<pre><code class="language-bash">awk 'BEGIN {
fruits[&quot;mango&quot;]=&quot;yellow&quot;;
fruits[&quot;orange&quot;]=&quot;orange&quot;;
delete fruits[&quot;orange&quot;];
print fruits[&quot;orange&quot;]
}'
</code></pre>
<h3 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h3>
<p>AWK 本身不支持多维数组, 不过我们可以很容易地使用一维数组模拟实现多维数组.</p>
<p>如下示例为一个 <code>3x3</code> 的三维数组:</p>
<pre><code class="language-bash">100 200 300
400 500 600
700 800 900
</code></pre>
<p>上面的示例中, <code>array[0][0]</code> 存储 <code>100</code>, <code>array[0][1]</code> 存储 <code>200</code> , 依次类推. 为了在 <code>array[0][0]</code> 处存储<code>100</code>, 我们可以使用如下语法:</p>
<p><code>array[&quot;0,0&quot;] = 100</code></p>
<p>尽管在示例中, 我们使用了 <code>0,0</code> 作为索引, 但是这并不是两个索引值. 事实上, 它是一个字符串索引 <code>0,0</code>.</p>
<p>下面是模拟二维数组的例子:</p>
<pre><code class="language-bash">awk 'BEGIN {
array[&quot;0,0&quot;] = 100;
array[&quot;0,1&quot;] = 200;
array[&quot;0,2&quot;] = 300;
array[&quot;1,0&quot;] = 400;
array[&quot;1,1&quot;] = 500;
array[&quot;1,2&quot;] = 600;
# print array elements
print &quot;array[0,0] = &quot; array[&quot;0,0&quot;];
print &quot;array[0,1] = &quot; array[&quot;0,1&quot;];
print &quot;array[0,2] = &quot; array[&quot;0,2&quot;];
print &quot;array[1,0] = &quot; array[&quot;1,0&quot;];
print &quot;array[1,1] = &quot; array[&quot;1,1&quot;];
print &quot;array[1,2] = &quot; array[&quot;1,2&quot;];
}'
</code></pre>
<p>在数组上可以执行很多操作, 比如, 使用 <code>asort</code> 完成数组元素的排序, 或者使用 <code>asorti</code> 实现数组索引的排序等等.
我们会在后面的章节中介绍可以对数组进行操作的函数.</p>
<h2 id="awk-控制流"><a class="header" href="#awk-控制流">AWK 控制流</a></h2>
<p>与其它编程语言一样, <code>AWK</code> 同样提供了条件语句控制程序的执行流程.</p>
<h3 id="if-语句"><a class="header" href="#if-语句">IF 语句</a></h3>
<p>条件语句测试条件然后根据条件选择执行相应的动作. 下面是条件语句的语法:</p>
<pre><code class="language-bash">if (condition)
    action
</code></pre>
<p>也可以使用花括号来执行一组操作:</p>
<pre><code class="language-bash">if (condition)
{
    action-1
    action-1
    .
    .
    action-n
}
</code></pre>
<p>下面的例子判断数字是奇数还是偶数:</p>
<pre><code class="language-bash">awk 'BEGIN {num = 10; if (num % 2 == 0) printf &quot;%d is even number.\n&quot;, num }'
awk ' if ($8  == 0) printf &quot;%d is even number.\n&quot;'
</code></pre>
<h3 id="if---else-语句"><a class="header" href="#if---else-语句">IF - ELSE 语句</a></h3>
<p><code>if-else</code>语句中允许在条件为假时执行另外一组的动作. 下面为 <code>if-else</code> 的语法格式:</p>
<pre><code class="language-bash">if (condition)
    action-1
else
    action-2
</code></pre>
<p>其中, 条件为真时执行 <code>action-1</code>, 条件为假时执行 <code>action-2</code>. 下面是使用该语句判断数字是否为偶数的例子:</p>
<pre><code class="language-bash">awk 'BEGIN {num = 11;
   if (num % 2 == 0) printf &quot;%d is even number.\n&quot;, num;
   else printf &quot;%d is odd number.\n&quot;, num
                    }'
</code></pre>
<h3 id="if-else-if"><a class="header" href="#if-else-if">if-else-if</a></h3>
<p>我们可以很轻松地使用多个 <code>if-else</code> 语句构造 <code>if-else-if</code> 梯从而实现多个条件的判断. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
a=30;
if (a==10)
  print &quot;a = 10&quot;;
else if (a == 20)
  print &quot;a = 20&quot;;
else if (a == 30)
  print &quot;a = 30&quot;;
}'
</code></pre>
<h2 id="awk-循环"><a class="header" href="#awk-循环">AWK 循环</a></h2>
<p>除了前面介绍的条件语句, AWK 还提供了循环语句. 该语句的作用就是当条件为真时重复执行一系列的命令.</p>
<h3 id="for"><a class="header" href="#for">For</a></h3>
<p><code>For</code> 循环的语法如下:</p>
<pre><code class="language-bash">for (initialisation; condition; increment/decrement)
    {action}
</code></pre>
<p><code>for</code> 语句首先执行初始化动作( initialisation ), 然后再检查条件( condition ). 如果条件为真, 则执行动作( action ), 然后执行递增( increment )或者递减( decrement )操作.
只要条件为真循环就会一直执行. 每次循环结束都会进条件检查, 若条件为假则结束循环. 下
面的例子使用 <code>For</code> 循环输出数字 <code>1</code> 至 <code>5</code>:</p>
<p><code>awk 'BEGIN { for (i = 1; i &lt;= 5; ++i) print i }'</code></p>
<h3 id="while"><a class="header" href="#while">While</a></h3>
<p><code>While</code> 循环会一直执行动作直到逻辑条件为假为止. 其使用方法如下:</p>
<pre><code class="language-bash">while (condition)
    action
</code></pre>
<p>AWK 首先检查条件是否为真, 若条件为真则执行动作. 此过程一直重复直到条件为假时, 则停止.
下面是使用 <code>While</code> 循环输出数字 <code>1</code> 到 <code>5</code> 的例子:</p>
<p><code>awk 'BEGIN {i = 1; while (i &lt; 6) { print i; ++i } }'</code></p>
<h3 id="do-while"><a class="header" href="#do-while">Do-While</a></h3>
<p><code>Do-While</code> 循环与 <code>While</code> 循环相似, 但是 <code>Do-While</code> 的条件测试放到了循环的尾部. 下面是 <code>do-while</code> 的语法:</p>
<pre><code class="language-bash">do
    action
while (condition)
</code></pre>
<p>在 do-while 循环中, 无论条件是真是假, 循环语句至少执行一次, 执行后检查条件真假. 下面是使用 <code>do-While</code> 循环输出数字 <code>1</code> 到 <code>5</code> 的例子:</p>
<p><code>awk 'BEGIN {i = 1; do { print i; ++i } while (i &lt; 6) }'</code></p>
<h3 id="break"><a class="header" href="#break">Break</a></h3>
<p>顾名思义, <code>break</code> 用以结束循环过程. 在下面的示例子中, 当计算的和大于 <code>50</code> 的时候使用 <code>break</code> 结束循环过程:</p>
<pre><code class="language-bash">awk 'BEGIN {
    sum = 0; for (i = 0; i &lt; 20; ++i) {
         sum += i; if (sum &gt; 50) break; else print &quot;Sum =&quot;, sum
                                      }
                    }'
</code></pre>
<h3 id="continue"><a class="header" href="#continue">Continue</a></h3>
<p><code>Continue</code> 语句用于在循环体内部结束本次循环, 从而直接进入下一次循环迭代.
当我们希望跳过循环中某处数据处理时就会用到 <code>Continue</code>. 下面的例子输出 <code>1</code> 到 <code>20</code> 之间的偶数:</p>
<p><code>awk 'BEGIN {for (i = 1; i &lt;= 20; ++i) {if (i % 2 == 0) print i ; else continue} }'</code></p>
<h3 id="exit"><a class="header" href="#exit">Exit</a></h3>
<p><code>Exit</code> 用于结束脚本程序的执行. 该函数接受一个整数作为参数表示 <code>AWK</code> 进程结束状态.
如果没有提供该参数, 其默认状态为 <code>0</code> . 下面例子中当和大于 <code>50</code> 时结束 AWK 程序.</p>
<pre><code class="language-bash">awk 'BEGIN {
    sum = 0; for (i = 0; i &lt; 20; ++i) {
        sum += i; if (sum &gt; 50) exit(10); else print &quot;Sum =&quot;, sum
                                     }
                    }'
</code></pre>
<p>让我们检查一下脚本执行后的返回状态:</p>
<p><code>echo $?</code></p>
<p>执行上面的命令可以得到如下的结果:</p>
<p><code>10</code></p>
<h2 id="awk-内置函数"><a class="header" href="#awk-内置函数">AWK 内置函数</a></h2>
<p>AWK 为程序开发者提供了丰富的内置函数.
这一章节会讲解 AWK 提供的算术函数, 字符串操作函数, 时间操作相关的函数, 位操作函数以及其它各种各样的函数.</p>
<h3 id="算术函数"><a class="header" href="#算术函数">算术函数</a></h3>
<p>AWK 提供了如下的内置算术运算函数:</p>
<hr />
<p><code>atan2(y,x)</code></p>
<p>该函数返回正切值 <code>y/x</code> 的角度值, 角度以弧度为单位. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
  PI = 3.14159265
  x = -10
  y = 10
  result = atan2 (y,x) * 180 / PI;
  printf &quot;The arc tangent for (x=%f, y=%f) is %f degrees\n&quot;, x, y, result
}'
</code></pre>
<hr />
<p>cos(expr)</p>
<p>该函数返回 <code>expr</code> 的余弦值,  输入参数以弧度为单位. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
  PI = 3.14159265
  param = 60
  result = cos(param * PI / 180.0);
  printf &quot;The cosine of %f degrees is %f.\n&quot;, param, result
}'
</code></pre>
<p>***exp(expr)</p>
<p>此函数返回自然数 <code>e</code> 的 <code>expr</code> 次幂.</p>
<pre><code class="language-bash">awk 'BEGIN {
  param = 5
  result = exp(param);
  printf &quot;The exponential value of %f is %f.\n&quot;, param, result
}'
</code></pre>
<hr />
<p>int(expr)</p>
<p>此函数返回数值 <code>expr</code> 的整数部分. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
  param = 5.12345
  result = int(param)

  print &quot;Truncated value =&quot;, result
}'
</code></pre>
<hr />
<p>log(expr)</p>
<p>此函数计算 <code>expr</code> 自然对数.</p>
<pre><code class="language-bash">awk 'BEGIN {
  param = 5.5
  result = log (param)

  printf &quot;log(%f) = %f\n&quot;, param, result
}'
</code></pre>
<hr />
<p>rand</p>
<p><code>rand</code> 函数返回一个大于等于 <code>0</code> 小于 <code>1</code> 的随机数 <code>N</code>(<code>0&lt;= N &lt; 1</code>). 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
  print &quot;Random num1 =&quot; , rand()
  print &quot;Random num2 =&quot; , rand()
  print &quot;Random num3 =&quot; , rand()
}'
</code></pre>
<p><code>sin(expr)</code></p>
<p>正弦函数返回角度 <code>expr</code> 的正弦值, 角度以弧度为单位. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
  PI = 3.14159265
  param = 30.0
  result = sin(param * PI /180)
  printf &quot;The sine of %f degrees is %f.\n&quot;, param, result
}'
</code></pre>
<hr />
<p>sqrt(expr)</p>
<p>此函数计算 <code>expr</code> 的平方根.</p>
<pre><code class="language-bash">awk 'BEGIN {
  param = 1024.0
  result = sqrt(param)
  printf &quot;sqrt(%f) = %f\n&quot;, param, result
}'
</code></pre>
<hr />
<p>srand([expr])</p>
<p>此函数使用种子值生成随机数, 数值 <code>expr </code>作为随机数生成器的种子值. 如果没有指定 <code>expr</code> 的值则函数默认使用当前系统时间作为种子值.</p>
<pre><code class="language-bash">awk 'BEGIN {
  param = 10
  printf &quot;srand() = %d\n&quot;, srand()
  printf &quot;srand(%d) = %d\n&quot;, param, srand(param)
}'
</code></pre>
<h3 id="字符串函数"><a class="header" href="#字符串函数">字符串函数</a></h3>
<p>AWK 提供了下面所示的字符串操作函数:
<code>asort(arr,[, d [,how] ])</code></p>
<p><code>asort</code> 函数使用 <code>GAWK</code> 值比较的一般规则排序 <code>arr</code> 中的内容, 然后用以 <code>1</code> 开始的有序整数替换排序内容的索引.</p>
<pre><code class="language-bash">awk 'BEGIN {
    arr[0] = &quot;Three&quot;
    arr[1] = &quot;One&quot;
    arr[2] = &quot;Two&quot;
    print &quot;Array elements before sorting:&quot;
    for (i in arr) {
        print arr[i]
    }
    asort(arr)
    print &quot;Array elements after sorting:&quot;
    for (i in arr) {
        print arr[i]
    }
}'
</code></pre>
<hr />
<p><code>asorti(arr,[, d [,how] ])</code></p>
<p><code>asorti</code> 函数的行为与 <code>asort</code> 函数的行为很相似, 二者的差别在于 <code>aosrt</code> 对数组的值排序, 而 <code>asorti</code> 对数组的索引排序.</p>
<pre><code class="language-bash">awk 'BEGIN {
    arr[&quot;Two&quot;] = 1
    arr[&quot;One&quot;] = 2
    arr[&quot;Three&quot;] = 3
    asorti(arr)
    print &quot;Array indices after sorting:&quot;
    for (i in arr) {
        print arr[i]
    }
}'
</code></pre>
<hr />
<p><code>gsub(regx,sub, string)</code></p>
<p><code>gsub</code> 是全局替换( global substitution )的缩写. 它将出现的子串(<code>sub</code>)替换为 <code>regx</code>. 第三个参数 <code>string</code> 是可选的, 默认值为 <code>$0</code>, 表示在整个输入记录中搜索子串.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;Hello, World&quot;
    print &quot;String before replacement = &quot; str
    gsub(&quot;World&quot;, &quot;Jerry&quot;, str)
    print &quot;String after replacement = &quot; str
}'
</code></pre>
<hr />
<p><code>index(str,sub)</code></p>
<p><code>index</code> 函数用于检测字符串 <code>sub</code> 是否是 <code>str</code> 的子串.
如果 <code>sub</code> 是 <code>str</code> 的子串, 则返回子串 <code>sub</code> 在字符串 <code>str</code> 的开始位置; 若不是其子串, 则返回 <code>0</code>.
<code>str</code> 的字符位置索引从 <code>1</code> 开始计数.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;One Two Three&quot;
    subs = &quot;Two&quot;
    ret = index(str, subs)
    printf &quot;Substring \&quot;%s\&quot; found at %d location.\n&quot;, subs, ret
}'
</code></pre>
<hr />
<p><code>length(str)</code></p>
<p><code>length</code> 函数返回字符串的长度.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;Hello, World !!!&quot;
    print &quot;Length = &quot;, length(str)
}'
</code></pre>
<hr />
<p><code>match(str, regex)</code></p>
<p><code>match</code> 返回正则表达式在字符串 <code>str</code> 中第一个最长匹配的位置. 如果匹配失败则返回<code>0</code>.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;One Two Three&quot;
    subs = &quot;Two&quot;
    ret = match(str, subs)
    printf &quot;Substring \&quot;%s\&quot; found at %d location.\n&quot;, subs, ret
}'
</code></pre>
<hr />
<p><code>split(str, arr,regex)</code></p>
<p><code>split</code> 函数使用正则表达式 <code>regex</code> 分割字符串 <code>str</code>. 分割后的所有结果存储在数组 <code>arr</code> 中. 如果没有指定 <code>regex</code> 则使用 <code>FS</code> 切分.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;One,Two,Three,Four&quot;
    split(str, arr, &quot;,&quot;)
    print &quot;Array contains following values&quot;
    for (i in arr) {
        print arr[i]
    }
}'
</code></pre>
<hr />
<p><code>sprintf(format,expr-list)</code></p>
<p><code>sprintf</code> 函数按指定的格式( format )将参数列表 <code>expr-list</code> 构造成字符串然后返回.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = sprintf(&quot;%s&quot;, &quot;Hello, World !!!&quot;)
    print str
}'
</code></pre>
<hr />
<p><code>strtonum(str)</code></p>
<p><code>strtonum</code> 将字符串 <code>str</code> 转换为数值.  如果字符串以 <code>0</code> 开始, 则将其当作十进制数;
如果字符串以 <code>0x</code> 或 <code>0X</code> 开始, 则将其当作十六进制数; 否则, 将其当作浮点数.</p>
<pre><code class="language-bash">awk 'BEGIN {
    print &quot;Decimal num = &quot; strtonum(&quot;123&quot;)
    print &quot;Octal num = &quot; strtonum(&quot;0123&quot;)
    print &quot;Hexadecimal num = &quot; strtonum(&quot;0x123&quot;)
}'
</code></pre>
<hr />
<p><code>sub(regex,sub,string)</code></p>
<p><code>sub</code> 函数执行一次子串替换. 它将第一次出现的子串用 <code>regex</code> 替换. 第三个参数是可选的, 默认为 <code>$0</code>.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;Hello, World&quot;
    print &quot;String before replacement = &quot; str
    sub(&quot;World&quot;, &quot;Jerry&quot;, str)
    print &quot;String after replacement = &quot; str
}'
</code></pre>
<hr />
<p><code>substr(str, start, l)</code></p>
<p><code>substr</code> 函数返回 <code>str</code> 字符串中从第 <code>start</code> 个字符开始长度为 <code>l</code> 的子串. 如果没有指定 <code>l</code> 的值, 返回 <code>str</code> 从第 start 个字符开始的后缀子串.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;Hello, World !!!&quot;
    subs = substr(str, 1, 5)
    print &quot;Substring = &quot; subs
}'
</code></pre>
<hr />
<p><code>tolower(str)</code></p>
<p>此函数将字符串 str 中所有大写字母转换为小写字母然后返回. 注意, 字符串 <code>str</code> 本身并不被改变.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;HELLO, WORLD !!!&quot;
    print &quot;Lowercase string = &quot; tolower(str)
}'
</code></pre>
<hr />
<p><code>toupper(str)</code></p>
<p>此函数将字符串 <code>str</code> 中所有小写字母转换为大写字母然后返回. 注意, 字符串 <code>str</code> 本身不被改变.</p>
<pre><code class="language-bash">awk 'BEGIN {
    str = &quot;hello, world !!!&quot;
    print &quot;Uppercase string = &quot; toupper(str)
}'
</code></pre>
<h3 id="时间函数"><a class="header" href="#时间函数">时间函数</a></h3>
<p>AWK 提供了如下的内置时间函数:</p>
<hr />
<p><code>systime</code></p>
<p>此函数返回从 <code>Epoch</code> 以来到当前时间的秒数(在 <code>POSIX</code> <code>系统上, Epoch</code> 为<code>1970-01-01 00:00:00 UTC</code>).</p>
<pre><code class="language-bash">awk 'BEGIN {
    print &quot;Number of seconds since the Epoch = &quot; systime()
}'
</code></pre>
<hr />
<p><code>mktime(dataspec)</code></p>
<p>此函数将字符串 <code>dataspec</code> 转换为与 <code>systime</code> 返回值相似的时间戳.  <code>dataspec</code> 字符串的格式为 <code>YYYY MM DD HH MM SS</code>.</p>
<pre><code class="language-bash">awk 'BEGIN {
    print &quot;Number of seconds since the Epoch = &quot; mktime(&quot;2014 12 14 30 20 10&quot;)
}'
</code></pre>
<hr />
<p><code>strftime([format [, timestamp[, utc-flag]]])</code></p>
<p>此函数根据 <code>format</code> 指定的格式将时间戳 <code>timestamp</code> 格式化.</p>
<pre><code class="language-bash">awk 'BEGIN {
    print strftime(&quot;Time = %m/%d/%Y %H:%M:%S&quot;, systime())
}'
</code></pre>
<p>下面是 <code>AWK</code> 支持的不同的日期格式说明:</p>
<p>SN  描述</p>
<ul>
<li><code>%a</code>  星期缩写(Mon-Sun).</li>
<li><code>%A</code>  星期全称(Monday-Sunday).</li>
<li><code>%b</code>  月份缩写(Jan).</li>
<li><code>%B</code>  月份全称(January).</li>
<li><code>%c</code>  本地日期与时间.</li>
<li><code>%C</code>  年份中的世纪部分, 其值为年份整除100.</li>
<li><code>%d</code>  十进制日期(01-31)</li>
<li><code>%D</code>  等价于 %m/%d/%y.</li>
<li><code>%e</code>  日期, 如果只有一位数字则用空格补齐</li>
<li><code>%F</code>  等价于 %Y-%m-%d, 这也是 ISO 8601 标准日期格式.</li>
<li><code>%g</code>  ISO8610 标准周所在的年份模除 100(00-99). 比如, 1993 年 1 月 1 日属于 1992 年的第 53 周. 所以, 虽然它是 1993 年第 1 天, 但是其　ISO8601 标准周所在年份却是 1992. 同样, 尽管 1973 年 12 月 31 日属于 1973 年但是它却属于 1994 年的第一周. 所以 1973 年 12 月 31 日的 ISO8610 标准周所在的年是 1974 而不是 1973.</li>
<li><code>%G</code>  ISO 标准周所在年份的全称.</li>
<li><code>%h</code>  等价于 %b.</li>
<li><code>%H</code>  用十进制表示的 24 小时格式的小时(00-23)</li>
<li><code>%I</code>  用十进制表示的 12 小时格式的小时(00-12)</li>
<li><code>%j</code>  一年中的第几天(001-366)</li>
<li><code>%m</code>  月份(01-12)</li>
<li><code>%M</code>  分钟数(00-59)</li>
<li><code>%n</code>  换行符 (ASCII LF)</li>
<li><code>%p</code>  十二进制表示法(AM/PM)</li>
<li><code>%r</code>  十二进制表示法的时间(等价于 %I:%M:%S %p).</li>
<li><code>%R</code>  等价于 %H:%M.</li>
<li><code>%S</code>  时间的秒数值(00-60)</li>
<li><code>%t</code>  制表符 (tab)</li>
<li><code>%T</code>  等价于 %H:%M:%S.</li>
<li><code>%u</code>  以数字表示的星期(1-7),1 表示星期一.</li>
<li><code>%U</code>  一年中的第几个星期(第一个星期天作为第一周的开始), 00-53</li>
<li><code>%V</code>  一年中的第几个星期(第一个星期一作为第一周的开始), 01-53.</li>
<li><code>%w</code>  以数字表示的星期(0-6), 0表示星期日 .</li>
<li><code>%W</code>  十进制表示的一年中的第几个星期(第一个星期一作为第一周的开始), 00-53.</li>
<li><code>%x</code>  本地日期表示</li>
<li><code>%X</code>  本地时间表示</li>
<li><code>%y</code>  年份模除 100.</li>
<li><code>%Y</code>  十进制表示的完整年份.</li>
<li><code>%z</code>  时区, 表示格式为+HHMM(例如, 格式要求生成的 RFC 822或者 RFC 1036 时间头)</li>
<li><code>%Z</code>  时区名称或缩写, 如果时区待定则无输出.</li>
</ul>
<h3 id="位操作函数"><a class="header" href="#位操作函数">位操作函数</a></h3>
<p>AWK 提供了如下的内置的位操作函数:</p>
<hr />
<p><code>and</code></p>
<p>执行位<strong>与</strong>操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10
    num2 = 6
    printf &quot;(%d AND %d) = %d\n&quot;, num1, num2, and(num1, num2)
}'
</code></pre>
<hr />
<p><code>compl</code></p>
<p>按位求补.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10
    printf &quot;compl(%d) = %d\n&quot;, num1, compl(num1)
}'
</code></pre>
<hr />
<p><code>lshift</code></p>
<p>左移位操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10
    printf &quot;lshift(%d) by 1 = %d\n&quot;, num1, lshift(num1, 1)
}'
</code></pre>
<hr />
<p><code>rshift</code></p>
<p>向右移位操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10

    printf &quot;rshift(%d) by 1 = %d\n&quot;, num1, rshift(num1, 1)
}'
</code></pre>
<hr />
<p><code>or</code></p>
<p>按位或操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10
    num2 = 6

    printf &quot;(%d OR %d) = %d\n&quot;, num1, num2, or(num1, num2)
}'
</code></pre>
<hr />
<p><code>xor</code></p>
<p>按位异或操作.</p>
<pre><code class="language-bash">awk 'BEGIN {
    num1 = 10
    num2 = 6

    printf &quot;(%d XOR %d) = %d\n&quot;, num1, num2, xor(num1, num2)
}'
</code></pre>
<h3 id="其它函数"><a class="header" href="#其它函数">其它函数</a></h3>
<p>其它函数中主要包括:</p>
<hr />
<p><code>close(expr)</code></p>
<p>关闭管道的文件.</p>
<pre><code class="language-bash">awk 'BEGIN {
    cmd = &quot;tr [a-z] [A-Z]&quot;
    print &quot;hello, world !!!&quot; |&amp; cmd
    close(cmd, &quot;to&quot;)
    cmd |&amp; getline out
    print out;
    close(cmd);
}'
</code></pre>
<p>脚本的内容看上去很神秘吗? 让我们来揭开它神秘的面纱.</p>
<p>第一条语句 <code>cmd = &quot;tr [a-z] [A-Z]&quot;</code> 在 <code>AWK</code> 中建立了一个双向的通信通道.
第二条语句 <code>print</code> 为 <code>tr</code> 命令提供输入. &amp;| 表示双向通信.
第三条语句 <code>close(cmd, &quot;to&quot;)</code> 完成执行后关闭 <code>to</code> 进程.
第四条语句 <code>cmd |&amp; getline out</code> 使用 <code>getline</code> 函数将输出存储到 <code>out</code> 变量中.
接下来的输出语句打印输出的内容, 最后 <code>close</code> 函数关闭 <code>cmd</code>.</p>
<hr />
<p><code>delete</code></p>
<p><code>delete</code> 被用于从数组中删除元素. 下面的例子演示了如何使用 <code>delete</code>:</p>
<pre><code class="language-bash">awk 'BEGIN {
    arr[0] = &quot;One&quot;
    arr[1] = &quot;Two&quot;
    arr[2] = &quot;Three&quot;
    arr[3] = &quot;Four&quot;
    print &quot;Array elements before delete operation:&quot;
    for (i in arr) {
        print arr[i]
    }
    delete arr[0]
    delete arr[1]
    print &quot;Array elements after delete operation:&quot;
    for (i in arr) {
        print arr[i]
    }
}'
</code></pre>
<hr />
<p><code>exit</code></p>
<p>该函数终止脚本执行. 它可以接受可选的参数 <code>expr</code> 传递 <code>AWK</code> 返回状态. 示例如下:</p>
<pre><code class="language-bash">awk 'BEGIN {
    print &quot;Hello, World !!!&quot;
    exit 10
    print &quot;AWK never executes this statement.&quot;
}'
</code></pre>
<hr />
<p><code>flush</code></p>
<p>flush 函数用于刷新打开文件或管道的缓冲区.  使用方法如下:</p>
<p><code>fflush([output-expr])</code></p>
<p>如果没有提供 <code>output-expr</code>, <code>fflush</code> 将刷新标准输出. 若 <code>output-epxr </code>是空字符串 (<code>&quot;&quot;</code>), <code>fflush</code> 将刷新所有打开的文件和管道.</p>
<hr />
<p><code>getline</code></p>
<p><code>getline</code> 函数读入下一行. 示例中使用 <code>getline</code> 从文件 <code>marks.txt</code> 中读入一行并输出:</p>
<p><code>awk '{getline; print $0}' marks.txt </code></p>
<p>执行上面的命令可以得到如下的结果:</p>
<pre><code class="language-bash">1)  Rahul   Maths   90
2)  Kedar   English 85
3)  Hari    History 89
</code></pre>
<p>脚本看似工作正常, 但是第一行去哪儿了呢? 让我们理一下整个过程.
刚启动时, AWK 从文件 <code>marks.txt</code> 中读入一行存储到变量 <code>$0</code> 中.
在下一条语句中, 我们使用 <code>getline</code> 读入下一行. 因此 <code>AWK</code> 读入第二行并存储到 <code>$0</code> 中.
最后, AWK 使用 <code>print</code> 输出第二行的内容. 这个过程一直到文件结束.</p>
<hr />
<p><code>next</code></p>
<p><code>next</code> 停止处理当前记录, 并且进入到下一条记录的处理过程. 下面的例子中, 当模式串匹配成功后程序并不执行任何操作:</p>
<p><code>awk '{if ($0 ~/Shyam/) next; print $0}' marks.txt</code></p>
<hr />
<p><code>nextfile</code></p>
<p><code>nextfile</code> 停止处理当前文件, 从下一个文件第一个记录开始处理.
下面的的例子中, 匹配成功时停止处理第一个文件转而处理第二个文件:</p>
<p>首先创建两个文件.  <code>file1.txt</code> 内容如下:</p>
<pre><code class="language-txt">file1:str1
file1:str2
file1:str3
file1:str4
</code></pre>
<p>文件 <code>file2.txt</code> 内容如下:</p>
<pre><code class="language-txt">file2:str1
file2:str2
file2:str3
file2:str4
</code></pre>
<p>现在我们来测试 <code>nextfile</code> 函数.</p>
<p><code>awk '{ if ($0 ~ /file1:str2/) nextfile; print $0 }' file1.txt file2.txt</code></p>
<hr />
<p><code>return</code></p>
<p><code>return</code> 用于从用户自定义的函数中返回值. 请注意, 如果没有指定返回值, 那么的返回值是未定义的.
下面的例子演示了 <code>return</code> 的使用方法:</p>
<p>首先, 创建文件 <code>functions.awk</code>, 内容如下:</p>
<pre><code class="language-bash">function addition(num1, num2)
{
    result = num1 + num2
    return result
}

BEGIN {
    res = addition(10, 20)
    print &quot;10 + 20 = &quot; res
}
</code></pre>
<hr />
<p><code>system</code></p>
<p><code>system</code> 函数可以执行特定的命令然后返回其退出状态. 返回值为 <code>0</code> 表示命令执行成功; 非 <code>0</code> 表示命令执行失败. 下面的示例中执行 <code>Date</code> 显示当前的系统时间, 然后输出命令的返回状态:</p>
<p><code>awk 'BEGIN { ret = system(&quot;date&quot;); print &quot;Return value = &quot; ret }'</code></p>
<h2 id="awk-用户自定义函数"><a class="header" href="#awk-用户自定义函数">AWK 用户自定义函数</a></h2>
<p>函数是程序的基本构造部分. AWK 允许我们自定义函数.
事实上, 大部分的程序功能都可以被切分成多个函数, 这样每个函数可以独立的编写与测试.
函数不仅提高了代码的复用度也提高代码的robust.</p>
<p>下面是用户自定义函数的一般形式:</p>
<pre><code class="language-bash">function function_name(argument1, argument2, ...)
{
    function body
}
</code></pre>
<p>上述定义函数的语法中:</p>
<p><code>function_name</code> 是用户自定义函数的名称. 函数名称应该以字母开头, 其后可以是数字, 字母或下划线的自由组合.
AWK 保留的关键字不能作为用户自定义函数的名称.</p>
<p>自定义函数可以接受多个输入参数, 这些参数之间通过逗号分隔.
参数并不是必须的. 我们也可以定义没有任何输入参数的函数.</p>
<p><code>function body</code> 是函数体部分, 它包含 AWK 程序代码.</p>
<p>下面我们实现了两个简单函数, 它们分别返回两个数值中的最小值和最大值. 我们在主函数 <code>main</code> 中调用了这两个函数.  文件 <code>functions.awk</code> 内容如下:</p>
<pre><code class="language-bash"># Returns minimum number
function find_min(num1, num2)
{
  if (num1 &lt; num2)
    return num1
  return num2
}

# Returns maximum number
function find_max(num1, num2)
{
  if (num1 &gt; num2)
    return num1
  return num2
}

# Main function
function main(num1, num2)
{
  # Find minimum number
  result = find_min(10, 20)
  print &quot;Minimum =&quot;, result

  # Find maximum number
  result = find_max(10, 20)
  print &quot;Maximum =&quot;, result
}

# Script execution starts here
BEGIN {
  main(10, 20)
}
</code></pre>
<h2 id="awk-输出重定向"><a class="header" href="#awk-输出重定向">AWK 输出重定向</a></h2>
<p>到目前为止我们输出的数据都是输出到标准输出流中. 不过我们也可以将数据输出重定向到文件中.
重定向操作往往出现在 <code>print</code> 或者 <code>printf</code> 语句中.  <code>AWK</code> 中的重定向方法与 <code>shell</code> 重定向十分相似, 除了 <code>AWK</code> 重定向只用于 <code>AWK</code> 程序中外.</p>
<h3 id="重定向操作符"><a class="header" href="#重定向操作符">重定向操作符</a></h3>
<p>重定向操作符的使用方法如下:</p>
<p><code>print DATA &gt; output-file</code></p>
<p>上面重定向操作将输出数据重定向到 <code>output-file</code> 中. 如果 <code>output-file</code> 文件不存在, 则先创建该文件. 使用这种重定向方式时, 数据输出前会将 <code>output-file</code> 文件中原有的数据删除. 下面的示例将 <code>Hello,World!!!</code> 消息重定向输出到文件中.</p>
<p>先创建文件并在文件中输入一些数据.</p>
<pre><code class="language-bash">echo &quot;Old data&quot; &gt; /tmp/message.txt
cat /tmp/message.txt
</code></pre>
<p>再用 AWK 重定向操作符重定向数据到文件 <code>message.txt </code>中.</p>
<pre><code class="language-bash">awk 'BEGIN { print &quot;Hello, World !!!&quot; &gt; &quot;/tmp/message.txt&quot; }'
cat /tmp/message.txt
</code></pre>
<h3 id="追加重定向"><a class="header" href="#追加重定向">追加重定向</a></h3>
<p>追加重定向操作符的语法如下:</p>
<p><code>print DATA &gt;&gt; output-file</code></p>
<p>用这种重定向方式将数据追加到 <code>output-file</code> 文件的末尾. 如果文件不存在则先创建该文件. 示例如下:</p>
<p>创建文件并输入一些数据:</p>
<pre><code class="language-bash">echo &quot;Old data&quot; &gt; /tmp/message.txt
cat /tmp/message.txt
</code></pre>
<p>再使用 AWK 追加操作符追加内容到文件中:</p>
<pre><code class="language-bash">awk 'BEGIN { print &quot;Hello, World !!!&quot; &gt; &quot;/tmp/message.txt&quot; }'
cat /tmp/message.txt
</code></pre>
<h3 id="管道"><a class="header" href="#管道">管道</a></h3>
<p>除了使用文件在程序之间传递数据之外, AWK 还提供使用管道将一个程序的输出传递给另一个程序. 这种重定向方式会打开一个管道, 将对象的值通过管道传递给管道另一端的进程, 然后管道另一端的进程执行命令. 下面是管道的使用方法:</p>
<p><code>print items | command</code></p>
<p>下面的例子中我们使用 <code>tr</code> 命令将小写字母转换成大写.</p>
<p><code>awk 'BEGIN { print &quot;hello, world !!!&quot; | &quot;tr [a-z] [A-Z]&quot; }'</code></p>
<h3 id="双向通信通道"><a class="header" href="#双向通信通道">双向通信通道</a></h3>
<p><code>AWK</code> 允许使用 <code>|&amp;</code> 与一个外部进程通信, 并且可以双向通信. 下面的例子中, 我们仍然使用 <code>tr</code> 命令将字母转换为大写字母.</p>
<pre><code class="language-bash">awk 'BEGIN {
    cmd = &quot;tr [a-z] [A-Z]&quot;
    print &quot;hello, world !!!&quot; |&amp; cmd
    close(cmd, &quot;to&quot;)
    cmd |&amp; getline out
    print out;
    close(cmd);
}'
</code></pre>
<p>脚本的内容看上去很神秘吗? 让我们一步一步揭开它神秘的面纱.</p>
<ul>
<li>第一条语句 <code>cmd = &quot;tr [a-z] [A-Z]&quot;</code> 在<code>AWK </code>中建立了一个双向的通信通道.</li>
<li>第二条语句 <code>print</code> 为 <code>tr</code> 命令提供输入. <code>&amp;|</code> 表示双向通信.</li>
<li>第三条语句 <code>close(cmd, &quot;to&quot;) </code>执行后关闭 <code>to </code>进程.</li>
<li>第四条语句 <code>cmd |&amp; getline out</code> 使用 <code>getline</code> 函数将输出存储到 <code>out</code> 变量中.</li>
<li>接下来的输出语句打印输出的内容, 最后 <code>close</code> 函数关闭 <code>cmd</code>.</li>
</ul>
<h2 id="awk-优雅的输出"><a class="header" href="#awk-优雅的输出">AWK 优雅的输出</a></h2>
<p>前面我们已经用过了 AWK 中的 <code>print</code> 函数与 <code>printf</code> 函数, 它们将数据输出到标准输出流中.
其实 <code>printf</code> 函数的功能远比我们前面演示的强大. 这个函数是从 <code>C</code> 语言中借鉴来而的, 主要用于生成格式化的输出.
下面是 <code>printf</code> 的使用方法:</p>
<p><code>printf fmt, expr-list</code></p>
<p>其中, <code>fmt</code> 是字符串常量或者格式规格说明字符串, <code>expr-list</code> 是与格式说明相对应的参数列表.</p>
<h3 id="转义序列"><a class="header" href="#转义序列">转义序列</a></h3>
<p>与一般字符串一样, 格式化字符串也能内嵌转义序列.  <code>AWK</code> 支持的转义序列如下:</p>
<ul>
<li><code>\n</code> 换行</li>
<li><code>\t</code> 水平制表</li>
<li><code>\v</code>垂直制表</li>
<li><code>\b</code> 退格</li>
<li><code>\r</code>  回车</li>
<li><code>\f</code>  换页</li>
</ul>
<hr />
<p>换行符</p>
<p>下面的例子中使用换行符将 <code>Hello</code> 与 <code>World</code> 分开输出到独立两行:</p>
<p><code>awk 'BEGIN { printf &quot;Hello\nWorld\n&quot; }'</code></p>
<hr />
<p>水平制表符</p>
<p>如下示例, 使用制表符显示不同的域:</p>
<p><code>awk 'BEGIN { printf &quot;Sr No\tName\tSub\tMarks\n&quot; }'</code></p>
<hr />
<p>垂直制表符</p>
<p>如下示例, 使用垂直制表符输出不同域:</p>
<p><code>awk 'BEGIN { printf &quot;Sr No\vName\vSub\vMarks\n&quot; }'</code></p>
<hr />
<p>退格符</p>
<p>下面的例子中, 我们在每个域输出后都再输出退格符(最后一个域除外). 这样前三个域的每一域的最后一个字符都会被删除.
比如说, <code>Field 1</code> 输出为 <code>Field</code> . 因为最后一个字符被退格符删除. 不过<code>Field 4</code>可以正常显示, 因为在<code>Field 4</code>输出后没有输出退格符.</p>
<p><code>awk 'BEGIN { printf &quot;Field 1\bField 2\bField 3\bField 4\n&quot; }'</code></p>
<hr />
<p>回车</p>
<p>下面的例子中, 我们在每个域输出后输出一个回车符, 随后输出的域会覆盖之前输出的内容.
也就是说, 我们只能看到最后输出的 <code>Field 4</code>.</p>
<p><code>awk 'BEGIN { printf &quot;Field 1\rField 2\rField 3\rField 4\n&quot; }'</code></p>
<hr />
<p>换页符</p>
<p>下面的例子中每个域后输出后输出一个换页符:</p>
<p><code>awk 'BEGIN { printf &quot;Sr No\fName\fSub\fMarks\n&quot; }'</code></p>
<h3 id="格式说明符"><a class="header" href="#格式说明符">格式说明符</a></h3>
<p>与 <code>C</code> 语言一样, AWK 也定义了格式说明符.  AWK 的 <code>printf</code> 允许如下的格式的转换:</p>
<ul>
<li><code>%c</code> : 单个字符</li>
<li><code>%d, %i</code> : 十进制整数<code>decimal</code> <code>integer</code></li>
<li><code>%e, %E</code> : 浮点数e or E</li>
<li><code>%f, %F</code> : 浮点数 dot</li>
<li><code>%g, %G</code> : 浮点数dot,删去冗余<code>0</code></li>
<li><code>%o</code> : 无符号八进制整数</li>
<li><code>%u</code> : 无符号十进制整数</li>
<li><code>%x, %X</code> : 无符号16进制数</li>
</ul>
<hr />
<p><code>%c</code></p>
<p>输出单个字符. 如果参数是个数值, 那么数值也会被当作字符然后输出. 如果参数是字符串, 那么只会输出字符串的第一个字符.</p>
<p><code>awk 'BEGIN { printf &quot;ASCII value 65 = character %c\n&quot;, 65 }'</code></p>
<hr />
<p><code>%d</code> 与 <code>%i</code>(效果一样)</p>
<p>输出十进制数的整数部分.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %d\n&quot;, 80.66 }'</code></p>
<hr />
<p><code>%e</code> 与 <code>%E</code></p>
<p>以 <code>[-]d.dddddde[+-]dd</code> 的格式输出浮点数.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %e\n&quot;, 80.66 }'</code></p>
<p><code>%E</code> 格式使用 <code>E</code> 而不是 <code>e</code>.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %E\n&quot;, 80.66 }'</code></p>
<hr />
<p><code>%f</code></p>
<p>以 <code>[-]ddd.dddddd</code> 的格式输出浮点数.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %f\n&quot;, 80.66 }'</code></p>
<hr />
<p><code>%g</code> 与 <code>%G</code></p>
<p>输出浮点数, 使用 <code>%f</code> 或 <code>%F</code> 转换. 但它们会删除那些对数值无影响的 <code>0</code>.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %g\n&quot;, 80.66 }'</code></p>
<p><code>%G</code> 使用 <code>%E</code> 格式化, 而不是<code> %e</code>.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %G\n&quot;, 80.66 }'</code></p>
<hr />
<p><code>%o</code></p>
<p>无符号八进制输出.</p>
<p><code>awk 'BEGIN { printf &quot;Octal representation of decimal number 10 = %o\n&quot;, 10}'</code></p>
<hr />
<p><code>%u</code></p>
<p>无符号十进制数输出.</p>
<p><code>awk 'BEGIN { printf &quot;Unsigned 10 = %u\n&quot;, 10 }'</code></p>
<hr />
<p><code>%x</code> 与 <code>%X</code></p>
<p>输出无符号十六进制数. <code>%X </code>中使用大写字母, <code>%x</code> 使用小写字母.</p>
<p><code>awk 'BEGIN { printf &quot;Hexadecimal representation of decimal number 15 = %x\n&quot;, 15}'</code></p>
<hr />
<p>使用 <code>%X</code> 的输出结果如下:</p>
<p><code>awk 'BEGIN { printf &quot;Hexadecimal representation of decimal number 15 = %X\n&quot;, 15}'</code></p>
<hr />
<p><code>%%</code></p>
<p>输出百分号(<code>%</code>), 不需要输入参数.</p>
<p><code>awk 'BEGIN { printf &quot;Percentags = %d%%\n&quot;, 80.66 }'</code></p>
<h3 id="-的可选参数"><a class="header" href="#-的可选参数">% 的可选参数</a></h3>
<p><code>%</code> 可以使用如下可选参数:</p>
<ul>
<li><code>%5</code> 输出宽度</li>
<li><code>%0</code> 用<code>0</code>填充, <code>0</code> 要紧跟在<code>%</code>后面</li>
<li><code>%-</code> 左对齐</li>
<li><code>%+</code> 输出正负号</li>
<li><code>%#</code> hash形式</li>
</ul>
<p>例如:</p>
<pre><code class="language-bash"># 左对齐, 用0填充, 显示符号, 小数6位, hash形式
awk 'BEGIN { printf &quot;Percentags = %0-+#20.6f\n&quot;, 34543.661 }' | cat -A
# 用0填充, 显示符号, hash形式
awk 'BEGIN { printf &quot;Percentags = %0+#20.6f\n&quot;, 34543.661 }' | cat -A
用空格填充, 显示符号, hash形式
awk 'BEGIN { printf &quot;Percentags = %+#20.6f\n&quot;, 34543.661 }' | cat -A
#输出
Percentags = +34543.661000       $
Percentags = +000000034543.661000$
Percentags =        +34543.661000$
</code></pre>
<hr />
<p>宽度</p>
<p>输出域会被填充满足宽度要求. 默认情况下使用空格字符填充. 但是, 当标志 <code>0</code> 被设置后会使用 <code>0</code> 填充.</p>
<p><code>awk 'BEGIN { num1 = 10; num2 = 20; printf &quot;Num1 = %10d\nNum2 = %10d\n&quot;, num1, num2 }'</code></p>
<hr />
<p>前导零</p>
<p>紧接在 <code>%</code> 后的零被当作标示, 表示输出应该使用零填充而不是空格字符.
请注意, 只有当域的宽度比要求宽度小时该标示才会有效. 示例如下:</p>
<p><code>awk 'BEGIN { num1 = -10; num2 = 20; printf &quot;Num1 = %05d\nNum2 = %05d\n&quot;, num1, num2 }'</code></p>
<hr />
<p>左对齐</p>
<p>输出域被设置为左对齐. 当输出字符串字符数比指定宽度少时, 你可能希望在输出它时能左对齐.
比如, 在右边添加空格符. 在 <code>%</code> 之后数字之前使用减号(<code>-</code>)即可指定输出左对齐.
下面的例子中, AWK 的输出作为 <code>cat</code> 的输入, <code>cat</code>会输出行结束符号(<code>$</code>).</p>
<p><code>awk 'BEGIN { num = 10; printf &quot;Num = %-5d\n&quot;, num }' | cat -vte</code></p>
<hr />
<p>符号前缀</p>
<p>输出数值的符号, 正号也输出.</p>
<p><code>awk 'BEGIN { num1 = -10; num2 = 20; printf &quot;Num1 = %+d\nNum2 = %+d\n&quot;, num1, num2 }'</code></p>
<hr />
<p>哈希(Hash)<code>%#</code></p>
<p>使用 <code>Hash</code> 可以为 <code>%o</code> 的结果前添加<code>0</code>,
为 <code>%x</code> 或 <code>%X</code> 输出的结果前添加 <code>0x</code> 或 <code>0X</code> (结果不为零时),
为 <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>添加小数点;
对于 <code>%g</code> 或 <code>%G</code>, 使用哈希可以保留尾部的零. 使用示例如下:</p>
<p><code>awk 'BEGIN { printf &quot;Octal representation = %#o\nHexadecimal representaion = %#X\n&quot;, 10, 10}'</code></p>
<h2 id="awk-计算精度"><a class="header" href="#awk-计算精度">awk 计算精度</a></h2>
<p><a href="https://www.gnu.org/software/gawk/manual/gawk.html#Setting-precision">gawk/manual/gawk.html#Setting-precision</a></p>
<p><code>gawk</code>使用<code>MPFR</code>库来控制精度和近似. 在命令行选项中使用<code>-M</code>来启用<code>MPFR </code>:来支持任意精度的计算.</p>
<p>有两个预定义的变量, <code>PREC</code> and <code>ROUNDMODE</code>, 提供了工作精度控制和近似模式, 可以进行全局设置.</p>
<p><code>gawk</code>使用一个全局精度, 而不跟踪每个数字的精度. 函数的结果被精确到给定的工作精度. 默认是<code>53 bits</code>.</p>
<p>你可以通过更改预定义变量<code>PREC</code>来更改. 也可以设置为下面的字符串(大小写敏感的), 来模拟<code>IEEE 754 binary format</code>.
Table 16.4: Predefined precision strings for PREC
PREC IEEE 754 binary format</p>
<ul>
<li><code>&quot;half&quot;</code> 16-bit half-precision</li>
<li><code>&quot;single&quot;</code>  32-bit single precision</li>
<li><code>&quot;double&quot;</code>  64-bit double precision</li>
<li><code>&quot;quad&quot;</code>  128-bit quadruple precision</li>
<li><code>&quot;oct&quot;</code> 256-bit octuple precision</li>
</ul>
<pre><code class="language-bash">gawk -M -v PREC=&quot;double&quot; 'BEGIN {
    printf(&quot;%0.25f\n&quot;, 0.1)

    }'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="awk-2"><a class="header" href="#awk-2">awk-2</a></h1>
<p><a href="https://man.linuxde.net/awk">awk命令</a></p>
<p><code>awk</code>是一种编程语言, 用于在<code>linux/unix</code>下对文本和数据进行处理. 数据可以来自标准输入(stdin), 一个或多个文件, 或其它命令的输出.
它支持用户自定义函数和动态正则表达式等先进功能, 是<code>linux/unix</code>下的一个强大编程工具.
它在命令行中使用, 但更多是作为脚本来使用.</p>
<p><code>awk</code>有很多内建的功能, 比如数组, 函数等, 这是它和<code>C</code>语言的相同之处, 灵活性是<code>awk</code>最大的优势.</p>
<h2 id="awk命令格式和选项"><a class="header" href="#awk命令格式和选项">awk命令格式和选项</a></h2>
<p>我们可以直接通过命令行的方式为 <code>AWK</code> 程序提供 <code>AWK</code> 命令, 也可以使用包括 <code>AWK</code> 命令的脚本文件.</p>
<hr />
<p>语法形式</p>
<pre><code class="language-bash">awk [options] 'script' var=value file(s)
awk [options] -f scriptfile var=value file(s)
</code></pre>
<hr />
<p>常用命令选项</p>
<ul>
<li><code>-F fs</code>   fs指定输入分隔符, <code>fs</code>可以是字符串或正则表达式, 如<code>-F:</code></li>
<li><code>-v var=value</code>   赋值一个用户定义变量, 将外部变量传递给<code>awk</code></li>
<li><code>-f scripfile</code>  从脚本文件中读取<code>awk</code>命令</li>
<li><code>-m[fr] val</code>   对<code>val</code>值设置内在限制, <code>-mf</code>选项限制分配给<code>val</code>的最大块数目; <code>-mr</code>选项限制记录的最大数目. 这两个功能是Bell实验室版awk的扩展功能, 在标准awk中不适用.</li>
<li><code>--dump-variables[=file] 选项</code>: 将全局变量及相应值按序输出到指定文件中, 默认的输出文件名是 <code>awkvars.out</code>.</li>
</ul>
<hr />
<p><code>--lint[=fatal]</code> 选项</p>
<p>这个选项用于检查程序的可移植情况以及代码中的可疑部分. 如果提供了参数 <code>fatal</code>, AWK 会将所有的警告信息当作错误信息处理. 下面这个简单的示例说明了 <code>lint</code> 选项的用法:</p>
<p><code>awk --lint '' /bin/ls</code></p>
<hr />
<p><code>--posix</code> 选项</p>
<p>这个选项会打开严格 <code>POSIX</code> 兼容性审查.  如此, 所有共同的以及 GAWK 特定的扩展将被设置为无效.</p>
<hr />
<p><code>--profile[=file]</code> 选项</p>
<p>这个选项会将程序文件以一种很优美的方式输出(译注: 用于格式化 awk 脚本文件). 默认输出文件是 <code>awkprof.out</code>. 示例如下:</p>
<pre><code class="language-bash">awk --profile 'BEGIN{printf&quot;---|Header|--\n&quot;} {print} END{printf&quot;---|Footer|---\n&quot;}' marks.txt &gt; /dev/null
cat awkprof.out
</code></pre>
<hr />
<p><code>--traditional</code> 选项</p>
<p>此选项用于禁止 GAWK 相关的扩展</p>
<h3 id="awk模式和操作"><a class="header" href="#awk模式和操作">awk模式和操作</a></h3>
<p>awk脚本是由模式和操作组成的.</p>
<hr />
<p>模式</p>
<p>模式可以是以下任意一个:</p>
<ul>
<li>/正则表达式/: 使用通配符的扩展集.</li>
<li>关系表达式: 使用运算符进行操作, 可以是字符串或数字的比较测试.</li>
<li>模式匹配表达式: 用运算符<code>~</code>(匹配)和<code>~!</code>(不匹配).</li>
<li><code>BEGIN</code>语句块, <code>pattern</code>语句块, <code>END</code>语句块: 参见awk的工作原理</li>
</ul>
<hr />
<p>操作</p>
<p>操作由一个或多个命令, 函数, 表达式组成, 之间由换行符或分号隔开, 并位于大括号内, 主要部分是:</p>
<ul>
<li>变量或数组赋值</li>
<li>输出命令</li>
<li>内置函数</li>
<li>控制流语句</li>
</ul>
<h3 id="awk脚本基本结构"><a class="header" href="#awk脚本基本结构">awk脚本基本结构</a></h3>
<pre><code class="language-bash">awk 'BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }' file
</code></pre>
<p>一个<code>awk</code>脚本通常由: <code>BEGIN</code>语句块, 能够使用模式匹配的通用语句块, <code>END</code>语句块3部分组成, 这三个部分是可选的.
任意一个部分都可以不出现在脚本中, 脚本通常在单引号或双引号中, 例如:</p>
<pre><code class="language-bash">awk 'BEGIN{ i=0 } { i++ } END{ print i }' filename
awk &quot;BEGIN{ i=0 } { i++ } END{ print i }&quot; filename
</code></pre>
<h3 id="awk的工作原理"><a class="header" href="#awk的工作原理">awk的工作原理</a></h3>
<pre><code class="language-bash">awk 'BEGIN{ commands } pattern{ commands } END{ commands }'
</code></pre>
<ul>
<li>第一步: 执行<code>BEGIN{ commands }</code>语句块中的语句;</li>
<li>第二步: 从文件或标准输入(stdin)读取一行, 然后执行<code>pattern{ commands }</code>语句块, 它逐行扫描文件, 从第一行到最后一行重复这个过程, 直到文件全部被读取完毕.</li>
<li>第三步: 当读至输入流末尾时, 执行<code>END{ commands }</code>语句块.</li>
</ul>
<p><code>BEGIN</code>语句块在<code>awk</code>开始从输入流中读取行之前被执行,
这是一个可选的语句块, 比如变量初始化, 打印输出表格的表头等语句通常可以写在<code>BEGIN</code>语句块中.</p>
<p><code>END</code>语句块在<code>awk</code>从输入流中读取完所有的行之后即被执行,
比如打印所有行的分析结果这类信息汇总都是在<code>END</code>语句块中完成, 它也是一个可选语句块.</p>
<p><code>pattern</code>语句块中的通用命令是最重要的部分, 它也是可选的. 如果没有提供<code>pattern</code>语句块, 则默认执行<code>{ print }</code>, 即打印每一个读取到的行, <code>awk</code>读取的每一行都会执行该语句块.</p>
<p>示例</p>
<pre><code class="language-bash">echo -e &quot;A line 1\nA line 2&quot; | awk 'BEGIN{ print &quot;Start&quot; } { print } END{ print &quot;End&quot; }'
</code></pre>
<p>当使用不带参数的<code>print</code>时, 它就打印当前行, 当<code>print</code>的参数是以逗号进行分隔时, 打印时则以空格作为定界符.
在<code>awk</code>的<code>print</code>语句块中双引号是被当作拼接符使用, 例如:</p>
<pre><code class="language-bash">echo | awk '{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }'
v1 v2 v3
</code></pre>
<p>双引号拼接使用:</p>
<pre><code class="language-bash">echo | awk '{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }'
v1=v2=v3
</code></pre>
<p><code>{ }</code>类似一个循环体, 会对文件中的每一行进行迭代,
通常变量初始化语句(如: <code>i=0</code>)以及打印文件头部的语句放入<code>BEGIN</code>语句块中, 将打印的结果等语句放在<code>END</code>语句块中.</p>
<h3 id="awk内置变量"><a class="header" href="#awk内置变量">awk内置变量</a></h3>
<p>内置变量, 也就是预定义变量</p>
<p>说明: <code>[A][N][P][G]</code>表示第一个支持变量的工具, <code>[A]=awk</code>, <code>[N]=nawk</code>, <code>[P]=POSIXawk</code>, <code>[G]=gawk</code></p>
<p><code>$n</code>: 当前记录的第<code>n</code>个字段, 比如<code>n</code>为<code>1</code>表示第一个字段, <code>n</code>为<code>2</code>表示第二个字段.
<code>$0</code>: 这个变量包含执行过程中当前行的文本内容.
<code>ARGC</code>: (<code>[N]</code> ) 命令行参数的数目.
<code>ARGIND</code>: (<code>[G]</code> ) 命令行中当前文件的位置(从0开始算).
<code>ARGV</code>: (<code>[N]</code> ) 包含命令行参数的数组.
<code>CONVFMT</code>: (<code>[G]</code> ) 数字转换格式(默认值为%.6g).
<code>ENVIRON</code>: (<code>[P]</code> ) 环境变量关联数组.
<code>ERRNO</code>: (<code>[N]</code> ) 最后一个系统错误的描述.
<code>FIELDWIDTHS</code>: (<code>[G]</code> ) 字段宽度列表(用空格键分隔).
<code>FILENAME</code>: (<code>[A]</code> ) 当前输入文件的名.
<code>FNR</code>: (<code>[P]</code> ) 同NR, 但相对于当前文件.
<code>FS</code>: (<code>[A]</code> ) 字段分隔符(默认是任何空格).
<code>IGNORECASE</code>: (<code>[G]</code> ) 如果为真, 则进行忽略大小写的匹配.
<code>NF</code>: (<code>[A]</code> ) 表示字段数, 在执行过程中对应于当前的字段数.
<code>NR</code>: (<code>[A]</code> ) 表示记录数, 在执行过程中对应于当前的行号.
<code>OFMT</code>: (<code>[A]</code> ) 数字的输出格式(默认值是%.6g).
<code>OFS</code>: (<code>[A]</code> ) 输出字段分隔符(默认值是一个空格).
<code>ORS</code>: (<code>[A]</code> ) 输出记录分隔符(默认值是一个换行符).
<code>RS</code>: (<code>[A]</code> ) 记录分隔符(默认是一个换行符).
<code>RSTART</code>: (<code>[N]</code> ) 由match函数所匹配的字符串的第一个位置.
<code>RLENGTH</code>: (<code>[N]</code> ) 由match函数所匹配的字符串的长度.
<code>SUBSEP</code>: (<code>[N]</code> ) 数组下标分隔符(默认值是34).</p>
<h3 id="内建变量示例"><a class="header" href="#内建变量示例">内建变量示例</a></h3>
<hr />
<p>简单查询</p>
<pre><code class="language-bash">echo -e &quot;line1 f2 f3\nline2 f4 f5\nline3 f6 f7&quot; | awk '{print &quot;行数:&quot;NR, &quot;字段总数:&quot;NF, &quot;字段0=&quot;$0, &quot;字段1=&quot;$1, &quot;字段2=&quot;$2, &quot;字段3=&quot;$3}'
</code></pre>
<p>使用<code>print $NF</code>可以打印出一行中的最后一个字段, 使用<code>$(NF-1)</code>则是打印倒数第二个字段, 其他以此类推:</p>
<pre><code class="language-bash">echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk '{print $NF}'
echo -e &quot;line1 f2 f3\n line2 f4 f5&quot; | awk '{print $(NF-1)}'
</code></pre>
<p>打印每一行的第二和第三个字段:</p>
<pre><code class="language-bash">awk '{ print $2,$3 }' filename
</code></pre>
<p>统计文件中的行数:</p>
<pre><code class="language-bash">awk 'END{ print NR }' filename
</code></pre>
<p>以上命令只使用了<code>END</code>语句块, 在读入每一行的时, <code>awk</code>会将<code>NR</code>更新为对应的行号,
当到达最后一行<code>NR</code>的值就是最后一行的行号, 所以<code>END</code>语句块中的<code>NR</code>就是文件的行数.</p>
<p>一个每一行中第一个字段值累加的例子:</p>
<pre><code class="language-bash">seq 5 | awk 'BEGIN{ sum=0; print &quot;总和: &quot; } { print $1&quot;+&quot;; sum+=$1 } END{ print &quot;等于&quot;; print sum }'
</code></pre>
<p><code>seq</code> - print a sequence of numbers</p>
<h3 id="将外部变量值传递给awk"><a class="header" href="#将外部变量值传递给awk">将外部变量值传递给awk</a></h3>
<p>借助<code>-v</code>选项, 可以将外部值(并非来自<code>stdin</code>)传递给<code>awk</code>:</p>
<pre><code class="language-bash">VAR=10000
echo | awk -v VARIABLE=$VAR '{ print VARIABLE }'
</code></pre>
<p>另一种传递外部变量方法:</p>
<pre><code class="language-bash">var1=&quot;aaa&quot;
var2=&quot;bbb&quot;
echo | awk '{ print v1,v2 }' v1=$var1 v2=$var2
</code></pre>
<p>当输入来自于文件时使用:</p>
<p><code>awk '{ print v1,v2 }' v1=$var1 v2=$var2 filename</code></p>
<p>以上方法中, 变量之间用空格分隔作为<code>awk</code>的命令行参数跟随在<code>BEGIN</code>, <code>{}</code>和<code>END</code>语句块之后.</p>
<h2 id="awk运算与判断"><a class="header" href="#awk运算与判断">awk运算与判断</a></h2>
<p>作为一种程序设计语言所应具有的特点之一, <code>awk</code>支持多种运算, 这些运算与C语言提供的基本相同.
<code>awk</code>还提供了一系列内置的运算函数(如<code>log</code>, <code>sqr</code>, <code>cos</code>, <code>sin</code>等)和一些用于对字符串进行操作(运算)的函数(如<code>length</code>, <code>substr</code>等等).</p>
<p>这些函数的引用大大的提高了<code>awk</code>的运算功能. 作为对条件转移指令的一部分, 关系判断是每种程序设计语言都具备的功能, <code>awk</code>也不例外, <code>awk</code>中允许进行多种测试, 作为样式匹配, 还提供了模式匹配表达式<code>~</code>(匹配)和<code>~!</code>(不匹配).
作为对测试的一种扩充, <code>awk</code>也支持用逻辑运算符.</p>
<hr />
<p>算术运算符</p>
<ul>
<li><code>+ -</code>  加, 减</li>
<li><code>* / &amp;</code>  乘, 除与求余</li>
<li><code>+ - !</code>  一元加, 减和逻辑非</li>
<li><code>^ ***</code>  求幂</li>
<li><code>++ --</code>  增加或减少, 作为前缀或后缀</li>
</ul>
<p>例:</p>
<pre><code class="language-bash">awk 'BEGIN{a=&quot;b&quot;;print a++,++a;}'
</code></pre>
<p>注意: 所有用作算术运算符进行操作, 操作数自动转为数值, 所有非数值都变为0</p>
<h3 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h3>
<p><code>= += -= *= /= %= ^= **=  赋值语句</code></p>
<p>例:</p>
<p><code>a+=5; 等价于: a=a+5; 其它同类</code></p>
<h3 id="逻辑运算符-2"><a class="header" href="#逻辑运算符-2">逻辑运算符</a></h3>
<ul>
<li><code>||</code>  逻辑或</li>
<li><code>&amp;&amp; </code> 逻辑与</li>
</ul>
<p>例:</p>
<pre><code class="language-bash">awk 'BEGIN{a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);}'
</code></pre>
<h3 id="正则运算符"><a class="header" href="#正则运算符">正则运算符</a></h3>
<p><code>~ ~!</code>  匹配正则表达式和不匹配正则表达式</p>
<p>例:</p>
<pre><code class="language-bash">awk 'BEGIN{a=&quot;100testa&quot;;if(a ~ /^100*/){print &quot;ok&quot;;}}'
ok
</code></pre>
<h3 id="关系运算符-1"><a class="header" href="#关系运算符-1">关系运算符</a></h3>
<p><code>&lt; &lt;= &gt; &gt;= != ==</code>  关系运算符</p>
<p>例:</p>
<pre><code class="language-bash">awk 'BEGIN{a=11;if(a &gt;= 9){print &quot;ok&quot;;}}'
ok
</code></pre>
<p>注意: <code>&gt;</code>,<code>&lt;</code>可以作为字符串比较, 也可以用作数值比较, 关键看操作数(operand).
如果是字符串就会转换为字符串比较, 两个都为数字才转为数值比较. 字符串比较: 按照<code>ASCII</code>码顺序比较.</p>
<h3 id="其它运算符"><a class="header" href="#其它运算符">其它运算符</a></h3>
<ul>
<li><code>$</code>  字段引用</li>
<li><code>空格</code>  字符串连接符</li>
<li><code>?:</code>  C条件表达式</li>
<li><code>in</code>  <strong>数组中</strong>是否存在某<strong>键值</strong></li>
</ul>
<p>例:</p>
<pre><code class="language-bash">awk 'BEGIN{a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;}'
awk 'BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);}'
awk 'BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);}'
</code></pre>
<h3 id="运算级优先级表"><a class="header" href="#运算级优先级表">运算级优先级表</a></h3>
<p>级别越高越优先
级别越高越优先</p>
<h2 id="awk高级输入输出"><a class="header" href="#awk高级输入输出">awk高级输入输出</a></h2>
<h3 id="读取下一条记录"><a class="header" href="#读取下一条记录">读取下一条记录</a></h3>
<p><code>awk</code>中<code>next</code>语句使用: 在循环逐行匹配, 如果遇到<code>next</code>, 就会跳过当前行, 直接忽略下面语句. 而进行下一行匹配.
<code>next</code>语句一般用于多行合并:</p>
<pre><code class="language-bash">cat text.txt
a
b
c
d
e
awk 'NR%2==1{next}{print NR,$0;}' text.txt
</code></pre>
<p>当记录行号除以<code>2</code>余<code>1</code>, 就跳过当前行. 下面的<code>print NR,$0</code>也不会执行.
下一行开始, 程序有开始判断<code>NR%2</code>值. 这个时候记录行号是: <code>2</code> , 就会执行下面语句块: <code>printNR,$0</code></p>
<hr />
<p>例子</p>
<p>将包含有<code>web</code>的行与下面的行合并:</p>
<pre><code class="language-bash">cat text.txt
web01[192.168.2.100]
httpd            ok
tomcat               ok
sendmail               ok
web02[192.168.2.101]
httpd            ok
postfix               ok
web03[192.168.2.102]
mysqld            ok
httpd               ok
</code></pre>
<pre><code class="language-bash">awk '/^web/{T=$0;next;}{print T&quot;:\t&quot;$0;}' marks.txt
</code></pre>
<h3 id="简单地读取一条记录"><a class="header" href="#简单地读取一条记录">简单地读取一条记录</a></h3>
<p><code>awk</code> <code>getline</code>用法: 输出重定向需用到<code>getline</code>函数.</p>
<p><code>getline</code>从标准输入, 管道或者当前正在处理的文件之外的其他输入文件获得输入.
它负责从输入获得下一行的内容, 并给<code>NF</code>,<code>NR</code>和<code>FNR</code>等内建变量赋值.
如果得到一条记录, <code>getline</code>函数返回<code>1</code>, 如果到达文件的末尾就返回<code>0</code>, 如果出现错误, 例如打开文件失败, 就返回<code>-1</code>.</p>
<p><code>getline</code>语法: <code>getline var</code>, 变量<code>var</code>包含了特定行的内容.</p>
<p>awk <code>getline</code>从整体上来说, 用法说明:</p>
<p>当其左右无重定向符<code>|</code>或<code>&lt;</code>时: <code>getline</code>作用于当前文件, 读入当前文件的第一行给其后跟的变量<code>var</code>或<code>$0</code>(无变量时候),
应该注意到, 由于<code>awk</code>在处理<code>getline</code>之前已经读入了一行, 所以<code>getline</code>得到的返回结果是隔行的.</p>
<p>当其左右有重定向符<code>|</code>或<code>&lt;</code>时: <code>getline</code>则作用于定向输入文件,
由于该文件是刚打开, 并没有被<code>awk</code>读入一行, 只是<code>getline</code>读入, 那么<code>getline</code>返回的是该文件的第一行, 而不是隔行.</p>
<p>示例:</p>
<p>执行<code>linux</code>的<code>date</code>命令, 并通过管道输出给<code>getline</code>, 然后再把输出赋值给自定义变量<code>out</code>, 并打印它:</p>
<pre><code class="language-bash">awk 'BEGIN{ &quot;date&quot; | getline out; print out }' test
</code></pre>
<p>执行<code>shell</code>的<code>date</code>命令, 并通过管道输出给<code>getline</code>, 然后<code>getline</code>从管道中读取并将输入赋值给<code>out</code>, <code>split</code>函数把变量<code>out</code>转化成数组<code>mon</code>, 然后打印数组<code>mon</code>的第二个元素:</p>
<pre><code class="language-bash">awk 'BEGIN{ &quot;date&quot; | getline out; split(out,mon); print mon[2] }' test
</code></pre>
<p>命令<code>ls</code>的输出传递给<code>geline</code>作为输入, 循环使<code>getline</code>从<code>ls</code>的输出中读取一行, 并把它打印到屏幕.
这里没有输入文件, 因为<code>BEGIN</code>块在打开输入文件前执行, 所以可以忽略输入文件.</p>
<pre><code class="language-bash">awk 'BEGIN{ while( &quot;ls&quot; | getline) print }'
</code></pre>
<h3 id="关闭文件"><a class="header" href="#关闭文件">关闭文件</a></h3>
<p><code>awk</code>中允许在程序中关闭一个<strong>输入或输出</strong>文件, 方法是使用<code>awk</code>的<code>close</code>语句.</p>
<p><code>close(&quot;filename&quot;)</code></p>
<p><code>filename</code>可以是<code>getline</code>打开的文件, 也可以是<code>stdin</code>, 包含文件名的变量, 或者<code>getline</code>使用的确切命令.
或一个输出文件, 可以是<code>stdout</code>, 包含文件名的变量或使用管道的确切命令.</p>
<h3 id="输出到一个文件"><a class="header" href="#输出到一个文件">输出到一个文件</a></h3>
<p><code>awk</code>中允许用如下方式将结果输出到一个文件:</p>
<p><code>echo | awk '{printf(&quot;hello word!n&quot;) &gt; &quot;datafile&quot;}'</code>
或
<code>echo | awk '{printf(&quot;hello word!n&quot;) &gt;&gt; &quot;datafile&quot;}'</code></p>
<h2 id="设置字段定界符"><a class="header" href="#设置字段定界符">设置字段定界符</a></h2>
<p>默认的字段定界符是空格, 可以使用<code>-F &quot;定界符&quot;</code> 明确指定一个定界符:</p>
<p><code>awk -F: '{ print $NF }' /etc/passwd</code>
或
<code>awk 'BEGIN{ FS=&quot;:&quot; } { print $NF }' /etc/passwd</code></p>
<p>在<code>BEGIN</code>语句块中则可以用<code>OFS=&quot;定界符&quot;</code>设置输出字段的定界符.</p>
<h2 id="流程控制语句"><a class="header" href="#流程控制语句">流程控制语句</a></h2>
<p><code>linux awk</code>的<code>while</code>, <code>do-while</code>和<code>for</code>语句允许使用<code>break</code>,<code>continue</code>语句来控制流程走向, 也允许使用<code>exit</code>这样的语句来退出.</p>
<p><code>break</code>中断当前正在执行的循环并跳到循环外执行下一条语句. <code>if </code>是流程选择用法.
<code>awk</code>中, 流程控制语句, 语法结构, 与c语言类似. 有了这些语句, 其实很多<code>shell</code>程序都可以交给<code>awk</code>, 而且性能是非常快的.
下面是各个语句用法.</p>
<h3 id="条件判断语句"><a class="header" href="#条件判断语句">条件判断语句</a></h3>
<pre><code class="language-bash">if(表达式)
  {语句1}
else
  {语句2}
</code></pre>
<p>格式中<code>语句1</code>可以是多个语句, 为了方便判断和阅读, 最好将多个语句用<code>{}</code>括起来. <code>awk</code>分枝结构允许嵌套, 其格式为:</p>
<pre><code class="language-bash">if(表达式)
  {语句1}
else if(表达式)
  {语句2}
else
  {语句3}
</code></pre>
<p>示例:</p>
<pre><code class="language-bash">awk 'BEGIN{
test=100;
if(test&gt;90){
  print &quot;very good&quot;;
  }
  else if(test&gt;60){
    print &quot;good&quot;;
  }
  else{
    print &quot;no pass&quot;;
  }
}'
</code></pre>
<p>每条命令语句后面可以用<code>;</code>分号结尾.</p>
<h3 id="循环语句"><a class="header" href="#循环语句">循环语句</a></h3>
<p><code>while</code>语句</p>
<pre><code class="language-bash">while(表达式)
  {语句}
</code></pre>
<p>示例:</p>
<pre><code class="language-bash">awk 'BEGIN{
test=100;
total=0;
while(i&lt;=test){
  total+=i;
  i++;
}
print total;
}'
</code></pre>
<hr />
<p><code>for</code>循环</p>
<p><code>for</code>循环有两种格式:</p>
<p>格式1:</p>
<pre><code class="language-bash">for(变量 in 数组)
  {语句}
</code></pre>
<p>示例:</p>
<pre><code class="language-bash">awk 'BEGIN{
for(k in ENVIRON){
  print k&quot;=&quot;ENVIRON[k];
}
}'
</code></pre>
<p>注: <code>ENVIRON</code>是<code>awk</code>常量, 是字典型数组.</p>
<p>格式2:</p>
<pre><code class="language-bash">for(变量;条件;表达式)
  {语句}
</code></pre>
<p>示例:</p>
<pre><code class="language-bash">awk 'BEGIN{
total=0;
for(i=0;i&lt;=100;i++){
  total+=i;
}
print total;
}'
</code></pre>
<hr />
<p><code>do</code>循环</p>
<pre><code class="language-bash">do
{语句} while(条件)
</code></pre>
<p>例子:</p>
<pre><code class="language-bash">awk 'BEGIN{
total=0;
i=0;
do {total+=i;i++;} while(i&lt;=100)
  print total;
}'
</code></pre>
<h3 id="其他语句"><a class="header" href="#其他语句">其他语句</a></h3>
<ul>
<li><code>break</code> 当 <code>break</code> 语句用于 <code>while</code> 或 <code>for</code> 语句时, 导致退出程序循环.</li>
<li><code>continue</code> 当 <code>continue</code> 语句用于 <code>while</code> 或 <code>for</code> 语句时, 使程序循环移动到下一个迭代.</li>
<li><code>next</code> 能能够导致读入下一个输入行, 并返回到脚本的顶部. 这可以避免对当前输入行执行其他的操作过程.</li>
<li><code>exit</code> 语句使主输入循环退出并将控制转移到<code>END</code>,如果<code>END</code>存在的话. 如果没有定义<code>END</code>规则, 或在<code>END</code>中应用<code>exit</code>语句, 则终止脚本的执行.</li>
</ul>
<h2 id="数组应用"><a class="header" href="#数组应用">数组应用</a></h2>
<p>数组是<code>awk</code>的灵魂, 处理文本中最不能少的就是它的数组处理.
<code>awk</code>的数组索引(下标)可以是<strong>数字</strong>或者<strong>字符串</strong>, 所以<code>awk</code>的数组叫做关联数组(associative arrays).
<code>awk</code> 中的数组不必提前声明, 也不必声明大小. 数组元素用<code>0</code>或<strong>空字符串</strong>来初始化, 这根据上下文而定.</p>
<h3 id="数组的定义"><a class="header" href="#数组的定义">数组的定义</a></h3>
<p>数字做数组索引(下标):</p>
<pre><code class="language-bash">Array[1]=&quot;sun&quot;
Array[2]=&quot;kai&quot;
</code></pre>
<p>字符串做数组索引(下标):</p>
<pre><code class="language-bash">Array[&quot;first&quot;]=&quot;www&quot;
Array[&quot;last&quot;]=&quot;name&quot;
Array[&quot;birth&quot;]=&quot;1987&quot;
</code></pre>
<p>使用中<code>print Array[1]</code>会打印出<code>sun</code>; 使用<code>print Array[2]</code>会打印出<code>kai</code>; 使用<code>print[&quot;birth&quot;]</code>会得到<code>1987</code>.</p>
<p>读取数组的值</p>
<pre><code class="language-bash">{ for(item in array) {print array[item]}; }       #输出的顺序是随机的
{ for(i=1;i&lt;=len;i++) {print array[i]}; }         #Len是数组的长度
</code></pre>
<h3 id="数组相关函数"><a class="header" href="#数组相关函数">数组相关函数</a></h3>
<p>得到数组长度:</p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),&quot;length is:&quot;lens;}'
</code></pre>
<p><code>length</code>返回字符串以及数组长度, <code>split</code>进行分割字符串为数组, 也会返回分割得到数组长度.</p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);for (k in tA){print k,tA[k];}}'
</code></pre>
<p><code>asort</code>对数组进行排序, 返回数组长度.</p>
<p>输出数组内容(无序, 有序输出):</p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);for(k in tA){print k,tA[k];}}'
</code></pre>
<p><code>for... in</code>输出, 因为数组是关联数组, 默认是无序的. 所以通过<code>for... in</code>得到是无序的数组. 如果需要得到有序数组, 需要通过下标获得.</p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&lt;=tlen;k++){print k,tA[k];}}'
</code></pre>
<p>注意: 数组下标是从<code>1</code>开始, 与<code>C</code>数组不一样.</p>
<p>判断键值存在以及删除键值:</p>
<pre><code class="language-bash">#错误的判断方法:
awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if(tB[&quot;c&quot;]!=&quot;1&quot;){print &quot;no found&quot;;};for(k in tB){print k,tB[k];}}'
no found
a a1
b b1
c
</code></pre>
<p>以上出现奇怪问题, <code>tB[&quot;c&quot;]</code>没有定义, 但是循环时候, 发现已经存在该键值, 它的值为空.
这里需要注意, <code>awk</code>数组是关联数组, 只要通过数组引用它的<code>key</code>, 就会自动创建改序列.</p>
<pre><code class="language-bash">#正确判断方法:
awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB){print &quot;ok&quot;;};for(k in tB){print k,tB[k];}}'
a a1
b b1
</code></pre>
<p><code>if(key in array)</code>通过这种方法判断数组中是否包含<code>key</code>键值.</p>
<pre><code class="language-bash">#删除键值:
[chengmo@localhost ~]$ awk 'BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB){print k,tB[k];}}'
b b1
</code></pre>
<p><code>delete array[key]</code>可以删除, 对应数组<code>key</code>的, 序列值.</p>
<h3 id="二维-多维数组使用"><a class="header" href="#二维-多维数组使用">二维, 多维数组使用</a></h3>
<p><code>awk</code>的多维数组在本质上是一维数组, 更确切一点, <code>awk</code>在存储上并不支持多维数组. <code>awk</code>提供了逻辑上模拟二维数组的访问方式.
例如, <code>array[2,4]=1</code>这样的访问是允许的. <code>awk</code>使用一个特殊的字符串<code>SUBSEP</code>作为分割字段, 在上面的例子中, 关联数组array存储的键值实际上是<code>2SUBSEP4</code>.</p>
<p>类似一维数组的成员测试, 多维数组可以使用<code>if ( (i,j) in array)</code>这样的语法, 但是下标必须放置在圆括号中.</p>
<pre><code class="language-bash">awk 'BEGIN{
for(i=1;i&lt;=4;i++){
  for(j=1;j&lt;=4;j++){
    tarr[i,j]=i*j;
  }
}
if ((4,5) in tarr)
{print tarr[4,5]}
else
{print &quot;does not exist&quot;}

if ((4,4) in tarr)
{print tarr[4,4]}
else
{print &quot;does not exist&quot;}
}'

类似一维数组的循环访问, 多维数组使用`for ( item in array )`这样的语法遍历数组.

```bash
awk 'BEGIN{
for(i=1;i&lt;=4;i++){
  for(j=1;j&lt;=4;j++){
    tarr[i,j]=i*j;
  }
}
for(m in tarr){
  print m,tarr[m];
}
}'
</code></pre>
<p>与一维数组不同的是, 多维数组必须使用<code>split()</code>函数来访问单独的下标分量.</p>
<pre><code class="language-bash">awk 'BEGIN{
for(i=1;i&lt;=9;i++){
  for(j=1;j&lt;=9;j++){
    tarr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j];
  }
}
}'
</code></pre>
<p>可以通过<code>array[k,k2]</code>引用获得数组内容.</p>
<p>另一种方法:</p>
<pre><code class="language-bash">awk 'BEGIN{
for(i=1;i&lt;=9;i++){
  for(j=1;j&lt;=9;j++){
    tarr[i,j]=i*j;
  }
}
for(m in tarr){
  split(m,tarr2,SUBSEP); print tarr2[1],&quot;*&quot;,tarr2[2],&quot;=&quot;,tarr[m];
}
}'
</code></pre>
<h2 id="内置函数"><a class="header" href="#内置函数">内置函数</a></h2>
<p><code>awk</code>内置函数, 主要分以下<code>3</code>种类似: 算数函数, 字符串函数, 其它一般函数, 时间函数.</p>
<h3 id="算术函数-1"><a class="header" href="#算术函数-1">算术函数</a></h3>
<ul>
<li><code>atan2(y, x)</code>  返回 y/x 的反正切.</li>
<li><code>cos(x)</code>  返回 <code>x</code> 的余弦; <code>x</code> 是弧度.</li>
<li><code>sin(x)</code>  返回 <code>x</code> 的正弦; <code>x</code> 是弧度.</li>
<li><code>exp(x)</code>  返回 <code>x</code> 幂函数.</li>
<li><code>log(x)</code>  返回 <code>x</code> 的自然对数.</li>
<li><code>sqrt(x)</code>  返回 <code>x</code> 平方根.</li>
<li><code>int(x)</code>  返回 <code>x</code> 的截断至整数的值.</li>
<li><code>rand( )</code>  返回任意数字 <code>n</code>, 其中 <code>0 &lt;= n &lt; 1</code>.</li>
<li><code>srand( [expr])</code>  将 <code>rand</code> 函数的种子值设置为 <code>Expr</code> 参数的值, 或如果省略 <code>Expr</code> 参数则使用某天的时间. 返回先前的种子值.</li>
</ul>
<p>举例说明:</p>
<pre><code class="language-bash">awk 'BEGIN{OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;}'
0.841 22026.466 2.303 3
</code></pre>
<p><code>OFMT</code> 设置输出数据格式是保留<code>3</code>位小数.</p>
<p>获得随机数:</p>
<pre><code class="language-bash">awk 'BEGIN{srand();fr=int(100*rand());print fr;}'
awk 'BEGIN{srand();fr=int(100*rand());print fr;}'
awk 'BEGIN{srand();fr=int(100*rand());print fr;}'
</code></pre>
<h3 id="字符串函数-1"><a class="header" href="#字符串函数-1">字符串函数</a></h3>
<ul>
<li><code>gsub(Ere, Repl, [In] )</code>  和<code>sub</code>函数类似, 只不过进行所有可能的替换.</li>
<li><code>sub(Ere, Repl, [In] )</code>  匹配<code>In</code>中由 <code>Ere</code> 指定的字符串(扩展正则表达式), 并用 <code>Repl</code>参数替换, 只替换第一个具体值. <code>sub</code>函数返回替换的数量. 用<code>&amp;</code>来进行匹配结果的引用. 如果未指定 <code>In</code> 参数, 缺省值是整个记录(<code>$0</code> 记录变量).</li>
<li><code>index(str1,str2)</code>  返回<code>str2</code>在<code>str1</code>中的位置, 从 1 开始编号. 如果 <code>str2</code>参数不在<code>str1</code>中出现, 则返回<code>0</code>(零).</li>
<li><code>length [(str)]</code>  返回 <code>str</code> 参数指定的字符串的长度(字符形式). 如果未给出 <code>str</code>, 则返回整个记录的长度(<code>$0</code>的长度).</li>
<li><code>blength [(str)]</code>  返回 <code>str</code> 参数指定的字符串的长度(以<strong>字节</strong>为单位). 如果未给出 <code>str</code> 参数, 则返回整个记录的长度(<code>$0</code>的长度).</li>
<li><code>substr(str,M,[N])</code>  返回<code>str</code>中长度为<code>N</code>的字符子串. 子串从 <code>M</code>指定的位置开始.  <code>str</code> 中的第一个字符编号为 <code>1</code>. 如果未指定 <code>N</code> 参数, 则默认取到 <code>str</code> 的末尾.</li>
<li><code>match(str,Ere)</code>  返回 <code>str</code>中<code>Ere</code>的位置(字符形式), 从<code>1</code> 开始编号. 如果 Ere 参数不出现, 则返回 <code>0</code>. <code>RSTART</code> 特殊变量记录返回值. <code>RLENGTH</code> 特殊变量记录匹配字符串的长度, 或如果未找到任何匹配, 则值为 <code>-1</code>.</li>
<li><code>split(str,A,[Ere])</code>  将 <code>str</code> 分割为数组 <code>A[1]</code>, <code>A[2]</code>, <code>. . .</code>, <code>A[n]</code>, 并返回<code>n</code>(数组的长度). 分隔符为<code>Ere</code>指定的扩展正则表达式. 如果没有给出 <code>Ere</code> 参数, 则为当前字段分隔符(<code>FS</code> 特殊变量).
除非上下文指明特定的元素为数字值, 否则 <code>A</code> 中的元素为字符串.</li>
<li><code>tolower(str)</code>  返回 <code>str</code> 的小写形式, 大写和小写的映射由当前语言环境的 <code>LC_CTYPE</code> 范畴定义.</li>
<li><code>toupper(str)</code>  返回 <code>str</code> 的大写形式, 大写和小写的映射由当前语言环境的<code>LC_CTYPE</code> 范畴定义.</li>
<li><code>sprintf(Format, Expr, Expr, . . . )</code>  根据 <code>Format</code> 参数指定的 <code>printf</code> 格式字输出 <code>Expr</code> 参数指定的表达式, 并返回最后生成的字符串.</li>
</ul>
<p>注: <code>Ere</code>都可以是正则表达式.</p>
<hr />
<p><code>gsub</code>,<code>sub</code></p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;AAA&quot;,info);print info}'
</code></pre>
<p>在<code>info</code>中查找<code>/[0-9]+/ </code>,并用<code>&quot;AAA&quot;</code>替换, 并将替换后的值, 赋给<code>info</code>.
如果未给出<code>info</code>参数, 则默认为<code>$0</code>.</p>
<hr />
<p>查找字符串<code>index</code></p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;}'
## or
awk 'BEGIN{info=&quot;this is a test2010test!&quot;;
if(index(info,&quot;test&quot;))
{print &quot;Ok&quot;;}
else{print &quot;not found&quot;;}
}'
## or
awk 'BEGIN{info=&quot;this is a test2010test!&quot;;
if(&quot;test&quot; in info)
{print &quot;Ok&quot;;}
else{print &quot;not found&quot;;}
}'
</code></pre>
<hr />
<p>正则表达式匹配查找<code>match</code></p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;}'
</code></pre>
<hr />
<p>截取字符串<code>substr</code></p>
<pre><code class="language-bash">awk 'BEGIN{info=&quot;this is a test2010test!&quot;;print substr(info,4,10);}'

</code></pre>
<p>从第 4个 字符开始, 截取10个长度字符串</p>
<hr />
<p>字符串分割<code>split</code></p>
<p>awk 'BEGIN{info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA){print k,tA[k];}}'</p>
<p>分割<code>info</code>, 动态创建数组<code>tA</code>. <code>awk</code>中的<code>for ... in</code>循环, 是一个无序的循环.
并不是按照数组下标<code>1... n</code>循环 , 因此使用时候需要注意.</p>
<hr />
<p>格式化字符串输出<code>sprintf</code></p>
<p>格式化的字符串包括两部分内容(内容和格式):
一部分是正常字符, 这些字符将按原样输出;
另一部分是格式控制字符, 以<code>&quot;%&quot;</code>开始, 后跟一个或几个规定字符,用来确定输出内容格式.</p>
<p>格式  描述</p>
<ul>
<li><code>%d</code>  十进制有符号整数</li>
<li><code>%u</code>  十进制无符号整数</li>
<li><code>%f</code>  浮点数</li>
<li><code>%s</code>  字符串</li>
<li><code>%c</code>  单个字符</li>
<li><code>%p</code>  指针的值</li>
<li><code>%e</code>  指数形式的浮点数</li>
<li><code>%x</code>  <code>%X</code> 无符号以十六进制表示的整数</li>
<li><code>%o</code>  无符号以八进制表示的整数</li>
<li><code>%g</code>  自动选择合适的表示法</li>
</ul>
<pre><code class="language-bash">awk 'BEGIN{n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%o\n&quot;,n1,n2,n3,n1,n1);}'
</code></pre>
<h3 id="一般函数"><a class="header" href="#一般函数">一般函数</a></h3>
<p>格式  描述</p>
<ul>
<li><code>close(Expression)</code>  用同一个 <code>Expression</code>参数(值为字符串)来关闭文件或管道. 它们由 <code>print</code>或<code>printf</code> 语句或<code>getline</code> 函数打开.
如果文件或管道成功关闭, 则返回<code>0</code>; 其它情况下返回非零值.
如果打算写一个文件, 并稍后在同一个程序中读取文件, 则<code>close</code>语句是必需的.</li>
<li><code>system(command)</code>  执行 <code>Command</code> 参数指定的命令, 并返回退出状态. 等同于 <code>system</code> 子例程.</li>
<li><code>Expression | getline [Variable]</code>  将 <code>Expression</code>的值当作命令执行, 然后从管道传送的流中读取一个输入记录, 并将该记录的值赋给<code>Variable</code>. 如果当前不存在执行<code>Expression</code>得到的流, 则创建一个.
创建的流等同于调用 <code>popen</code> 子例程, 此时 <code>Command</code> 参数取 <code>Expression</code> 的值且 <code>Mode</code> 为<code>r</code>.
只要流保留打开且<code>Expression</code>不变, 则<code>getline</code>函数继续读取下一个记录. 如果未指定 <code>Variable</code> 参数, 则使用 <code>$0</code> 和<code>NF</code>存储记录.</li>
<li><code>getline [Variable] &lt; Expression</code> 从<code>Expression</code>指定的文件读取下一个记录, 并将 <code>Variable</code>设置为该记录的值. 只要流保留打开且<code>Expression</code>的值不变, 则<code>getline</code>函数继续往下读取记录.
如果未指定 <code>Variable</code> 参数, 则使用 <code>$0</code> 和<code>NF</code>存储记录.</li>
<li><code>getline [Variable]</code>  将 <code>Variable</code> 设置为下一个输入记录. 如果未指定 <code>Variable</code> 参数, 则使用<code>$0</code>,<code>NF</code>, <code>NR</code> 和 <code>FNR</code> 特殊变量.</li>
</ul>
<h3 id="打开外部文件close用法"><a class="header" href="#打开外部文件close用法">打开外部文件(close用法)</a></h3>
<pre><code class="language-bash">awk 'BEGIN{while(&quot;cat /etc/passwd&quot;|getline){print $0;};close(&quot;/etc/passwd&quot;);}'
</code></pre>
<p>逐行读取外部文件</p>
<pre><code class="language-bash">awk 'BEGIN{while(getline &lt; &quot;/etc/passwd&quot;){print $0;};close(&quot;/etc/passwd&quot;);}'
</code></pre>
<pre><code class="language-bash">awk 'BEGIN{print &quot;Enter your name:&quot;;getline name;print name;}'
</code></pre>
<p>调用外部应用程序</p>
<pre><code class="language-bash">awk 'BEGIN{b=system(&quot;ls -al&quot;);print b;}'
</code></pre>
<h3 id="时间函数-1"><a class="header" href="#时间函数-1">时间函数</a></h3>
<p>函数名  说明</p>
<ul>
<li><code>mktime( YYYY MM dd HH MM ss[ DST])</code> 生成时间格式</li>
<li><code>strftime([format [, timestamp]])</code> 格式化时间输出, 将时间戳转为时间字符串, 具体格式见下表.</li>
<li><code>systime()</code>  得到时间戳,返回从<code>1970年1月1日</code>开始到当前时间(不计闰年)的整秒数</li>
</ul>
<p>建指定时间(mktime使用)</p>
<pre><code class="language-bash">awk 'BEGIN{tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);}'
</code></pre>
<pre><code class="language-bash">awk 'BEGIN{tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;}'
</code></pre>
<hr />
<p>strftime日期和时间格式说明符</p>
<p>格式  描述</p>
<ul>
<li><code>%a</code>  星期几的缩写(Sun)</li>
<li><code>%A</code>  星期几的完整写法(Sunday)</li>
<li><code>%b</code>  月名的缩写(Oct)</li>
<li><code>%B</code>  月名的完整写法(October)</li>
<li><code>%c</code>  本地日期和时间</li>
<li><code>%d</code>  十进制日期</li>
<li><code>%D</code>  日期 <code>08/20/99</code></li>
<li><code>%e</code>  日期, 如果只有一位会补上一个空格</li>
<li><code>%H</code>  用十进制表示24小时格式的小时</li>
<li><code>%I</code>  用十进制表示12小时格式的小时</li>
<li><code>%j</code>  从<code>1</code>月<code>1</code>日起一年中的第几天</li>
<li><code>%m</code>  十进制表示的月份</li>
<li><code>%M</code>  十进制表示的分钟</li>
<li><code>%p</code>  12小时表示法(AM/PM)</li>
<li><code>%S</code>  十进制表示的秒</li>
<li><code>%U</code>  十进制表示的一年中的第几个星期(星期天作为一个星期的开始)</li>
<li><code>%w</code>  十进制表示的星期几(星期天是0)</li>
<li><code>%W</code>  十进制表示的一年中的第几个星期(星期一作为一个星期的开始)</li>
<li><code>%x</code>  重新设置本地日期(08/20/99)</li>
<li><code>%X</code>  重新设置本地时间(12: 00: 00)</li>
<li><code>%y</code>  两位数字表示的年(99)</li>
<li><code>%Y</code>  当前月份</li>
<li><code>%Z</code>  时区(PDT)</li>
<li><code>%%</code>  百分号(%)</li>
</ul>
<h2 id="一些示例"><a class="header" href="#一些示例">一些示例</a></h2>
<h3 id="分隔文件"><a class="header" href="#分隔文件">分隔文件</a></h3>
<p>下面这个例子, 是按第<code>6</code>例分隔文件, 相当的简单(其中的<code>NR!=1</code>表示不处理表头).</p>
<p><code>awk 'NR!=1{print &gt; $6}' netstat.txt</code></p>
<p>你也可以把指定的列输出到文件:</p>
<p><code>awk 'NR!=1{print $4,$5 &gt; $6}' netstat.txt</code></p>
<p>再复杂一点: (注意其中的<code>if-else-if</code>语句, 可见<code>awk</code>其实是个脚本解释器)</p>
<pre><code class="language-bash">$ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print &gt; &quot;1.txt&quot;;
else if($6 ~ /LISTEN/) print &gt; &quot;2.txt&quot;;
else print &gt; &quot;3.txt&quot; }' netstat.txt
</code></pre>
<h3 id="统计"><a class="header" href="#统计">统计</a></h3>
<p>下面的命令计算所有的<code>C</code>文件, <code>CPP</code>文件和<code>H</code>文件的文件大小总和.</p>
<pre><code class="language-bash">$ ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'
</code></pre>
<hr />
<p>注: 如果你要指定多个分隔符, 你可以这样来:</p>
<p>awk -F '[;:]'</p>
<hr />
<p>如果我们需要表头的话, 我们可以引入内建变量NR:</p>
<pre><code class="language-bash">awk '$3==0 &amp;&amp; $6==&quot;LISTEN&quot; || NR==1 ' netstat.txt
</code></pre>
<h3 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h3>
<p>即然说到了脚本, 我们来看看怎么和环境变量交互: (使用<code>-v</code>参数和<code>ENVIRON</code>, 使用<code>ENVIRON</code>的环境变量需要<code>export</code>)</p>
<pre><code class="language-bash">$ x=5
$ y=10
$ export y
$ echo $x $y
5 10
$ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]}' OFS=&quot;\t&quot; score.txt
</code></pre>
<h3 id="几个花活"><a class="header" href="#几个花活">几个花活</a></h3>
<p><a href="https://coolshell.cn/articles/9070.html">AWK 简明教程</a></p>
<pre><code class="language-bash">#从file文件中找出长度大于80的行
awk 'length&gt;80' file
#按连接数查看客户端IP
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr
#打印99乘法表
seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i&lt;=NF;i++)printf(&quot;%dx%d=%d%s&quot;, i, NR, i*NR, i==NR?&quot;\n&quot;:&quot;\t&quot;)}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-gpg"><a class="header" href="#linux-gpg">linux-gpg</a></h1>
<p><a href="https://www.gnupg.org/howtos/zh/">Gnu 隐私卫士HOWTO</a></p>
<p>本文阐述如何使用<code>GNU</code> 隐私卫士(<code>GnuPG</code>).
<code>GnuPG</code> 是一个开放源程序的与 <code>OpenPGP</code> 标准兼容的加密系统. 为使该系统完全免费和自由, 避免了使用 <code>RSA</code> 和其他获得专利的算法.</p>
<h2 id="gnu-隐私卫士"><a class="header" href="#gnu-隐私卫士">Gnu 隐私卫士</a></h2>
<p><a href="https://www.gnupg.org/howtos/zh/index.html">Gnu 隐私卫士 (GnuPG) 袖珍 HOWTO (中文版)</a></p>
<h4 id="引进钥匙"><a class="header" href="#引进钥匙">引进钥匙</a></h4>
<p>当你收到一把别人的公钥(或好几把公钥)时,为了能使用它们,你得把它们加进你的钥匙数据库.加进数据库的命令如下:</p>
<pre><code class="language-bash">gpg --import [Filename]
</code></pre>
<p>如果文件名(<code>filename</code>)省略了,数据将从标准输入( <code>stdin</code>)读入.</p>
<h4 id="取消钥匙"><a class="header" href="#取消钥匙">取消钥匙</a></h4>
<p>因为好些原因,你可以想要取消一把已经存在的钥匙,
例如:密钥被盗了或被不该得到它的人得到,用户身份识别改变了,钥匙不够长了,等等.对上述各种情况,取消钥匙的命令是:</p>
<pre><code class="language-bash">gpg --gen-revoke
</code></pre>
<p>该命令将产生一份取消钥匙证书.
要这么做,一定要先有密钥!  否则任何人都能取消你的钥匙.
这种方法有一个缺点: 如果我不知道通行句就用不了密钥.但用不了密钥,我就不能取消我的钥匙.
为解决这个问题,在你产生钥匙对的时候就产生一份取消钥匙证书是一种明智的做法.
如果你这样做的话,一定要把证书保存好!  你可以把它放在磁盘上,纸张上,等等.
一定要保证证书不落入坏人之手! ! !  否则别人就可以发出该证书取消你的钥匙,使你的钥匙作废.</p>
<h4 id="钥匙管理"><a class="header" href="#钥匙管理">钥匙管理</a></h4>
<p>随系统而来,有一个文件,起到某种数据库的作用.
所有有关钥匙和钥匙附带信息的数据都存在这个文件里(只有一样例外:主人的信任值.更多的信息见 钥匙签名).用</p>
<pre><code class="language-bash">gpg --list-keys
</code></pre>
<p>可以显示所有现有的钥匙. 要想同时显示签名,用</p>
<pre><code class="language-bash">gpg --list-sigs
</code></pre>
<p>(更多的信息见 钥匙签名). 要想见到钥匙的指纹,敲入:</p>
<pre><code class="language-bash">gpg --fingerprint
</code></pre>
<p>用户需要见到<code>指纹</code>来确认某人说的身份是真的. 这个命令将会产生一列相对较小的数字.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
