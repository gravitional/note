# cpp 引用与指针

[指针的引用](https://zhuanlan.zhihu.com/p/139543762)
[指针和引用的区别](https://www.cnblogs.com/x_wukong/p/5712345.html)
[指针与引用](https://zhuanlan.zhihu.com/p/140966943)

`指针传递参数` 本质上是 `值传递` 的方式, 它所传递的是一个 `地址值`.
`值传递` 过程中, 被调函数的 `形式参数` 作为被调函数的 `局部变量` 处理,
即在`栈` 中开辟了内存空间以存放由 `主调函数` 放进来的`实参`的值, 从而成为了实参的一个 `副本`.
`值传递` 的特点是被调函数对 `形式参数` 的任何操作都是作为 `局部变量` 进行, **不会影响主调函数的实参变量的值**.
这里是在说 `实参指针` 本身的 `地址值` 不会变.

而在 `引用传递` 过程中, 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间,
但是这时存放的是由主调函数放进来的实参变量的地址(int &a的形式).
被调函数对形参的任何操作都被处理成间接寻址, 即通过栈中存放的地址访问主调函数中的实参变量.
正因为如此, 被调函数对形参做的任何操作都影响了主调函数中的实参变量.

引用传递和指针传递是不同的, 虽然它们都是在被调函数栈空间上的一个局部变量,
但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量.
而对于指针传递的参数, 如果改变被调函数中的指针地址, 它将影响不到主调函数的相关变量.
如果想通过指针参数传递来改变主调函数中的相关变量, 那就得使用指向指针的指针, 或者指针引用.

+ 为了进一步加深大家对指针和引用的区别, 下面我从编译的角度来阐述它们之间的区别:

程序在编译时分别将 `指针` 和 `引用` 添加到 `符号表` 上, 符号表上记录的是 `变量名` 及变量所 `对应地址`.
`指针变量` 在符号表上对应的 `地址值` 为指针变量的地址值, 而引用在符号表上对应的地址值为引用对象的地址值.
符号表生成后就不会再改, 因此 `指针` 可以改变其 `指向的对象`(指针变量中的值可以改), 而 `引用对象` 则不能修改.

最后, 总结一下 `指针` 和 `引用` 的相同点和不同点:

+ 相同点:
    + 都是地址的概念;
    指针指向一块内存, 它的内容是所指内存的地址; 而引用则是某块内存的别名.

+ 不同点:
    + 指针是一个实体, 而引用仅是个别名;
    + 引用只能在定义时被初始化一次, 之后不可变; 指针可变; 引用"从一而终", 指针可以"见异思迁";

    + 引用没有const, 指针有const, const的指针不可变;
    (具体指没有int& const a这种形式, 而const int& a是有    的,
    前者指引用本身即别名不可以改变, 这是当然的, 所以不需要这种形式, 后者指引用所指的值不可以改变)

    + 引用不能为空, 指针可以为空;
    + `sizeof 引用` 得到的是所指向的变量(对象)的大小, 而 `sizeof 指针` 得到的是指针本身的大小;
    + 指针和引用的自增(`++`)运算意义不一样;
    + 引用是类型安全的, 而指针不是 (引用比指针多了类型检查

## b

[引用与解引用](https://www.cnblogs.com/haruyuki/p/15683592.html)

程序的解析过程, 都是从 `地址` 解析到内存中真正的位置,
从 `符号表` 到 `内存位置` 的解析是由编译器自动完成的.
程序中的标识符 `sym`, 被自动依照符号表解析.

`指针`是 `变量`, 存储的是 `地址`, 指向 `内存` 的 `存储单元`;
`引用` 是 `原变量` 的 `别名`, 跟原来的变量实质上是同一个东西.

```cpp
int a = 996;
int *p = &a; // p是指针, &在此是求地址运算
int &r = a; // r是引用, &在此起标识作用
```

上面定义了整型变量 `a`,
`p` 是指针变量, `p` 的值是变量 `a` 的地址;
而引用 `r` 是 `a` 的别名, 在内存中 `r` 和 `a` 占有同一个存储单元.

可以这么理解:
`a` 将被解析成符号表映射的内存单元, `&r` 等于这个内存单元, 所以 `r` 本身也是符号.
所以 `r` 也在符号表上, 和 `a` 指向同一个地方.
`&r` 相当于避免了一次解析, 或者延迟解析.

在函数中, `swap(int* &p1,int* &p2)` 参数前缀 `&` 表示 `传递引用`, 而不是 `传递值`.
函数体中的 `p1, p2` 会被再次解析为 `地址` 指向的对象, 所以可以修改函数范围外的对象.

```cpp
#include <stdio.h>

void swap(int* &p1,int* &p2){

    int* temp=p1;
    p1=p2;
    p2=temp;
    printf("交换中: a=%d,b=%d \n",*p1,*p2);
    printf("交换中(地址): p1=%d \n",p1);
    printf("交换中(地址): p2=%d \n",p2);
}

int main(){

    int a=1,b=3;
    int *p1=&a,*p2=&b;

    // 交换前
    printf("交换前: a=%d,b=%d \n",*p1,*p2);
    printf("交换前(地址): p1=%d \n",p1);
    printf("交换前(地址): p2=%d \n",p2);
    // 交换中
    swap(p1,p2);
    // 交换后
    printf("交换后: a=%d,b=%d \n",*p1,*p2);
    printf("交换后(地址): p1=%d \n",p1);
    printf("交换后(地址): p2=%d \n",p2);
    return 0;

}
```

## 引用

从C过来的同学可能会对C++中的"&"表示不解. "&"在C中就是表示取地址符, 在C++的实践中, 它也确实有取地址的功能. 但是, 在C++中, 它的功能不止于此, 它有了一个更准确的名称: 引用.

　　引用是C++的引入的语言特性, 它表示某一对象的别名. 对象和对象的引用都指向同一地址, 对引用的操作实际上就是对原对象的操作. 引用的声明语法为:

    类型标识符 &引用名=目标变量名;

说明:

+ `&` 在此不是求地址运算, 而是起标识作用.
+ 类型标识符是指目标变量的类型.
+ 声明引用时, 必须同时对其进行初始化.
+ 引用声明完毕后, 相当于目标变量名有两个名称, 即该目标原名称和引用名, 且不能再把该引用名作为其他变量名的别名.
+ 声明一个引用, 不是新定义了一个变量, 它只表示该引用名是目标变量名的一个别名,
它本身不是一种数据类型, 因此引用本身不占存储单元, 系统也不给引用分配存储单元. 故: 对引用求地址, 就是对目标变量求地址. &ra与&a相等.

+ 不能建立数组的引用. 因为数组是一个由若干个元素所组成的集合, 所以无法建立一个数组的别名.

```cpp
int main( ){
    int a=1;
    int &b=a;
    b=2;
    cout<<a<<endl;
}

//输出结果为2
```

## 引用的应用

光是给变量取别名似乎并没有多大的意义, 它的常见用法有下面几种:

### 函数引用传递

普通函数的参数传递为 `值传递`, 在调用时, 会为形参分配存储单元, 然后将实参的值赋给形参,
相当于创建一了份实参的 `副本` 供函数使用. `值传递` 有两个特征:

+ 在函数内对 `形参` 的操作不会影响 `实参`
+ 当传入的数据量较大时, 会 `浪费空间`.

为了解决传递大块数据时, 值传递方式造成的空间浪费, C语言的做法是 `传递指针` 从而实现直接对原数据的操作.
而在 C++ 中, 我们可以使用 `引用传递` 来解决这个问题.
只需要将形参定义为 `引用` 的形式, 例如:

```cpp
#include <iostream>

using namespace std;

//引用传递的方式
void func(int &a){
    a=a+10;
}
//传统值传递的方式
void func1(int a){
    a=a+10;
}
int main( ){
    int a = 5,b=5;
    func(a);
    func1(b);
    cout<<a<<" "<<b<<endl;
}
//输出结果为15 5
```

使用 `指针` 与 `引用` 的区别在于: 使用 `指针` 时, 虽然传递的是 `指针`, 但仍然是 `值传递` 的方式.
`指针` 也是 `变量`, 系统仍然会为 `形参` 分配空间.
并且, 大量使用指针, 会导致程序可读性变差, 且容易出错.

### 常引用

如果想使用 `引用`, 但又想确保引用数据的安全性, 此时可以使用 `const` 关键字来定义 `常引用`.
`常引用` 和常量一样, 不允许被修改.

```cpp
int main( ){
    int a = 1;
    const int &b = a;
    //当尝试通过引用修改变量时, 程序会报错
    b=2;
}
```

## 解引用

在C语言中 `*` 用来定义一个指针变量, 它不表示实质的运算而仅仅起到 `标志` 的作用.
但是在C++中 `*` 是一元运算符, 叫做 `解引用运算符`. 它的作用是获取地址中存储的值.
它的操作数必须是一个合法有效的 `地址数据`.

```cpp
int main( ){
    int a = 1;
    //创建指针b,存储a的地址
    int *b = &a;
    //对指针b中存储的地址进行解引用
    int c = *b;
    //输出结果为: 1 0x61feb4 1
    cout<<a<<" "<<b<<" "<<c;
}
```
