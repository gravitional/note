# cpp 泛型程序设计与C++语言标准模板库

## 容器的基本功能

`STL` 有 13 中容器, 先介绍他们的基本功能.

设 `S` 表示容器类型(例如 `vector<int>`),
`s1`, `s2` 是 `S ` 类型的实例, 容器支持的基本类型如下:

+ `S s1`; 默认构造函数, 用于构造没有任何元素的空容器.
+ `s1.size()`; 返回 s1 的元素个数.
+ `s1.begin()`; 返回指向 s1 第一个元素的迭代器.
+ `s1.end()`; 返回指向 s1 最末元素的下个位置的迭代器. (左开右闭约定)
+ `s1.clear()`; 将容器 `s1` 的内容清空.
+ `s1.empty()`; 返回布尔值, 标志 `s1` 的内容是否为空.

+ `s op s2`; 这里的 `op` 可以是 `==, !=, <m <=, >, >=` 之一,
它会对两个容器之间的元素按字典序进行比较.
+ `s1.swap(s2)`;  将 `s1` 容器 和 `s2` 容器的内容交换.

虽然 `s1.swap(s2)` 等价于 `{S tmp(s)}; s1=s2; s2=tmp;}`,
但是前者往往比后者高效地多.

### 迭代器的 type

+ `S::iterator`; 普通迭代器类型, 指向元素的类型为 `T`
+ `S::const_iterator`; 表示常迭代器类型, 指向的元素类型为 `const T`, 因此只能读, 不能写.

C++11中, 为了支持 `auto`, 提供了 `s1.cbegin()`, `s1.cend()` 用以明确返回容器的常迭代器.

容器作为一种 STL 的概念, 拥有许多子概念.
按 元素组织方式, 可以分为 `顺序容器` 和 `关联容器`.
按 容器的迭代器划分, 又分成 `可逆容器` 与 更细分的 `随机访问容器`.

一般容器的 `begin()` 和 `end()` 成员函数所得到的都是 `前向迭代器`,
也就是对容器的元素进行 `单向遍历`.
可逆容器 提供的迭代器是 `双向迭代器`, 可以对容器的元素进行双向的遍历.

STL 提供的标准容器都至少是 `可逆容器`,
但有些非标准的模板库提供诸如 `slist`(单向链表) 这样的, 仅提供 `前向迭代器` 的容器.

`可逆容器` 的迭代器可以使用 `--` 运算来逆向遍历,
但 STL 算法的输入都是用 `正向区间`(左开右闭)来表示的.
为此, STL 的每个 `可逆容器` 都提供了 `逆向迭代器`.

+ `s1.rbegin()`; 指向容器最后一个元素的逆向迭代器
+ `s1.rend()`; 指向容器首端元素前一位置 的逆向迭代器

逆向迭代器的类型为:

`S::reverse_iterator`;
`S::const_reverse_iterator`;

+ 若 `p1` 是普通迭代器,
则 构造函数 `r1= S::reverse_iterator(p1)` 构造对应的逆向迭代器.
`r1.base()` 给出 `p1`, 即用来构造的普通迭代器.
+ `r1` 与 `p1-1` 所指向的元素相同.

他们实际上是普通迭代器的 `适配器`(adapter).
逆向迭代器的 `++` 被映射到 普通迭代器的`--`,

### 随机访问迭代器

`随机访问容器` 提供的迭代器是 `随机访问迭代器`, 支持对容器进行 `随机访问`,
使用随机访问迭代器, 可以直接通过 `整数` 来访问容器中的 指定元素.

`s1[n]`; 获得容器的第 `n` 个元素, 等价于 `s1.begin()[n]`.

## 顺序容器

+ 包括 `向量`(vector), `双端队列`(deque), `列表`(list), `单向链表`(forward_list) 和 `数组`(array).
+ 除了 固定大小 的数组, 它们在逻辑上可以看成长度可扩展的数组.
+ 每种容器都是 `类模板`, 都具有 `模板参数`, 表示容器的 `元素类型`,
该类型必须符合 `Assignable` 概念(具有共有复制构造函数, 并可以用 `=`) 赋值.

`array` 长度固定, forward_list 有特殊的添加删除操作,
下面的功能基本不包含这两种容器.

约定 `S` 表示容器 type 名, s 表示 S type 的实例.
T 表示 S 容器的元素类型, 用 t 表示 T 类型的实例.
用 n 表示整型数据, 用 p1 和 p2 表示指向 s 中元素的迭代器,
用 q1 和 q2 表示指向 T 类型元素的输入迭代器
(未必指向 S 中的元素, 也未必具有 S::iterator 类型),
args 表示 T 类型构造函数的参数.

### 构造函数

顺序容器除了默认的构造函数, 还可以使用给定的元素构造
还可以使用已有迭代器的区间所表示的序列构造.

`S s(n,t)`; 构造由 n 个 t 元素构成的容器实例
`S s(n)`;  构造有 n 个元素的容器实例 s, 每个元素都是 `T()`.
S s(q1,q2); 使用将 `[q1,q2)` 区间内的数据作为 s 的元素构造 s.

### 赋值函数

赋值函数会清除容器中原先的元素, 与构造函数的 3 中形式一一对应.

s.assign(n, t); 赋值后的容器由 n 个 t 元素构成.
s.assign(n); 赋值后的容器实例 s 有 n 个元素, 每个元素都是 `T()`.
s.assign(q1,q2); 赋值后的容器的元素为 `[q1,q2)` 区间内的数据.

### 元素的插入

可以插入一个或多个指定的元素,
也可以将一个迭代器区间所表示的序列插入.

+ `s.insert(p1, t)`; 在 s 容器中 p1 所指向的位置插入新元素 t,
插入位置在原 p1-1 和 p1 所指向的元素之间,
该函数返回迭代器, 指向新插入的元素

+ `s.insert(p1, n, t)`; 在 s 容器中 p1 位置插入 n 个新元素 t,
插入后的元素位于 p1-1 和 p1 之间, 没有返回值.

+ `s.insert(p1, q1, q2)`; 将 `[q1,q2)` 区间内的元素顺序 前插到 s 容器中 `p1` 位置处.

+ `s.emplace(p1,args)`; 将参数 args 传递给 T 的构造函数构造新元素 t,
在 s 容器中 p1 指向的位置前插该元素;此函数返回迭代器指向新插入的元素.

### 元素的删除

下列函数可以从容器中删除指定元素或清空容器.
通过迭代器指示目标位置或区间.

`s1.erase(p1)`; 删除 s1 容器中 p1 所指向的元素, 返回被删除位置下一个元素的迭代器.
`s1.erase(p1, p2)`; 删除 s1 容器中 `[p1,p2)` 区间内的元素, 返回最后被删除元素下一位置的迭代器
(即删除前 `p2` 所指向元素的迭代器)

### 改变容器的大小

`s1.resize(n)`; 将容器的大小变为 n;多余的被删除, 不足的用 `T()` 填充.

### 首尾元素的直接访问

可以通过容器的成员函数快捷访问容器的首尾元素:

`s.front()`; 获得容器首元素的引用.
`s.back()`; 获取容器尾元素的引用(不包括 forward_list).

### 在容器尾部插入, 删除元素

虽然已经有了 insert, erase, 但是尾部操作很常用, 所以 STL 提供了

`s.push_back(t)`; 向容器尾部插入元素 `t`.
`s.emplace_back(args)`; 将参数传递给 T 的构造函数, 构造新元素 t,  向容器尾部插入该元素.
`s.pop_back()`; 将容器尾部的元素删除.

### 在容器头部插入, 删除元素

列表 list 和 双端队列 deque 支持 高效地 往容器头部插入新元素,
或者删除容器头部元素, 但 vector 不支持.
支持此操作的概念构成 前插顺序容器 的子概念(FrontInsertionSequence),
它是 顺序容器 的子概念. 这些操作包括

`s.push_front(t)`; 向容器头部插入元素 t
`s.emplace_front(args)`; 将参数 args 传递给 T 的构造函数, 向容器头部插入该元素
`s.pop_front()`; 删除容器头部的元素 t.

### 容器的列表初始化

C++11 支持顺序容器的列表初始化,
直接使用一个列表的元素, 来创建新的顺序容器对象,
并隐式地将列表元素个数指定为新建容器大小
(定长数组 array 需指定大小). 初始化方式例如

```cpp
list<int> numberSeq={1,4,5,7}  //包含4个 int 元素的列表容器对象
vector<string> srts={"Hello", "World!"} //包含2 个string 元素的向量容器对象
```

向量容器尽管可以使用 insert, erase 进行首元素操作,
但是远远没有 list 或 deque 的 push_front, 和 pop_front 高效,
所以不作为 前插顺序容器(能够高效地插入或删除头部元素).

## 5中顺序容器的特性

### vector

向量: 高效的随机访问, 高效的尾操作
一般实现为动态分配的数组
若 s 为向量容器, 则

`s.size()`; 获取当前 `已存储` 的元素个数
`s.capacity()`; 返回 s 的容量(一共能容纳多少元素)
`s.reserve(n)`; 若当前的容量大于等于 n, 什么也不做;否则扩大容量, 使容量不小于 `n`.

insert, delete 操作会使 之前获得的 迭代器, 指针, 引用 失效.
如果引起容量扩展, 会使得它们全部失效,
如果没有触发容量扩展, 只会使变动点后面的 迭代器 失效.

`shrink_to_fit` 函数可以回收 vector 容器中未使用的元素空间.
即令 capacity 和 size 相等.
或者使用下面的技巧:

```cpp
vector<T>(s.begin(), s.end()).swap(s);
```

创建 临时对象 并交换内容.

### deque

双端队列: 支持向两端插入数据, 支持随机访问, 但随机访问效率比 vector 低.
在很多 STL 实现中, 双端数列的数据被表示为分段数组.

当向双端队列中间 增加或删除元素时, 效率较低,
需要将插入点到某一端之间的所有元素向容器的某一端移动,
会使所有的迭代器, 指针, 引用失效.

### list 列表

列表不能随机访问, 但可以高效地在任何位置插入和删除元素.
列表容器一般实现为一个链表.
列表容器属于可逆容器, 支持双向遍历(双向链表).

在列表任意位置增删新元素效率很高,
而且不会使任何已有元素的迭代器和指针, 引用失效,
除了被删除的元素.

列表容器还支持特殊操作---结合(splice):
将列表容器A 地一部分连续元素从该列表中删除,
然后插入到另一个列表容器B中.

设 s1 和 s2 分别是两个 list<T> 类型地列表容器实例,
p 是指向 s1 元素的迭代器, q1 和 q2 是指向 s2 元素的迭代器, 下面是 slice 成员函数的几种形式.

`s1.splice(p, s2)`; 将 s2 列表的所有元素 前插到  s1 列表 p 位置, 将 s2 列表清空
`s1.splice(p, s2, q1)`; 将 s2 列表中 q1 所指向的元素插入到 s1 列表 p 位置,
将 q1 所指向的元素从 s2 列表中删除
`s1.splice(p, s2, q1, q2)`; 将 s2 列表中 `[q1,q2)` 区间内的所有元素前插到 p 位置,
将 `[q1,q2)` 区间内的元素从 s2 中删除.

列表容器还支持很多特殊操作, 对应一的 STL 算法,
例如 remove, remove_if, sort, unique, merge, reverse
由于列表容器存储结构的特殊性, 这些算法提供了专门针对列表容器的版本, 作为列表的成员函数.

`advance(iter,2)`; 使迭代器 iter 前进 2 个元素.

### 单向链表和数组

forward_list 和 array, 是 C++11 标准新增的两个顺序容器,
forward_list 的设计目标是达到最好的单向链表结构的性能, 不支持 size 操作.
array 是对内置数组的封装, 提供了更安全, 更方便地使用数组的方式,
仍然是固定大小的, 定义时需要指定元素类型和容器大小.

单向链表增删元素时, 需要从前一位元素下手,
因此 forward_list 没有定义 insert, emplace, erase  操作,
而是定义了 insert_after, emplace_after, erase_after,
所有操作都是对迭代器之后的位置进行的.

数组不能该表大小

```cpp
array<int, 10>arr; // arr 为保存 10 个 int 类型的数组
array<string, 20> astr; // astr 为保存 20 个 string 类型的数组
```

和其他容器不同, 默认构造的 array 是非空的: 它包含了 size 大小的元素, 元素被默认初始化.
如果使用列表初始化, 初始值的数目必须小于等于 `array.size()`.

+ 虽然不能对内置数组类型进行复制或对象赋值操作, 但 array 并无此限制.

STL 中顺序容器的特性比较

|操作  |向量(vector) |双端队列(deque) |列表(list)|单向链表(forward_list)|
|---|---|---|---|---|
|随机访问|快|较慢|不能|不能|
|头部插入(`push_front`)|没有,只能用 `insert`| 快, 已有迭代器失效, 已有指针, 引用不失效|快已有迭代器, 指针, 引用都不会失效||
|头部删除(`pop_front`)|没有, 只能用 `erase`|快, 只会使被删除元素迭代器, 指针, 引用失效|同左||
|尾部插入(`push_back`)|快, 当发生容量扩展时, 会3失效, 否则无影响|快, 已有迭代器失效, 指针和引用不失效|快, 3 不失效| 没有 `push_back`|
|尾部删除(`pop_back`)|快, 只有被删除元素3失效|同左|同左|没有 `pop_back`|
|任意位置插入(`insert`)|越靠近头部越慢, 若容量扩展, 3失效;否则变动点之后3失效|越接近中间越慢, 3失效|快, 不失效|快|
|任意位置删除(`erase`)|越接近头部越慢, 只会使变动点之后3失效|越接近中间越慢, 所有3失效|快, 只有被删除元素3失效||

+ `insert` 操作的声明为 `iterator insert(insert pos, const T& value)`,
在 pos 位置插入后, 返回的是新插入元素的迭代器, 即可以实现在当前位置不断插入新元素:

```cpp
string word;
list<string> words;
auto it_begin=words.begin()
while(cin>>word) it_begin=words.insert(it_begin,word);
```

此代码的功能是, 对列表容器 words, 通过 insert 功能不断在头部插入新的元素.

### 顺序容器的插入迭代器

在顺序容器中插入元素, 除了使用 insert, push_front, push_back,
还可以通过 插入迭代器.

插入迭代器是一种适配器, 使用它可以通过 输出迭代器(write 迭代器)的接口来向指定元素的指定位置插入元素.
在调用 STL 算法时使用输出迭代器, 可以将结果顺序插入到容器的指定位置, 而无需覆盖已有的元素.
输出迭代器有3种:

```cpp
template<class Container>class front_insert_iterator;
template<class Container>class back_insert_iterator;
template<class Container>class insert_iterator;
```

它们把容器类型作为模板参数, 分别用于指定容器头部, 尾部和中间某个指定位置插入元素.
其中 `front_insert_iterator` 只适用于前插顺序容器(双端队列和列表),
而 `back_iterator` 和 `insert_iterator` 适用于所有 `顺序容器`.

插入迭代器的 `实例` 可以通过 构造函数 来构造,
但实际使用时, 一般通过辅助函数:

```cpp
template<class Container>
front_insert_iterator<Container> front_inserter(Container& s);

template<class Container>
back_insert_iterator<Container> back_inserter(Container& s);

template<class Container>
insert_iterator<Container> inserter(Container& s, Iterator i);
```

`辅助函数` 可以自动 推导类型, 无需显式给出, 从而使代码更简短.
例如从 `标准输入` 得到整数, 插入 `容器s` 的末尾:

```cpp
copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(s));
```

### 顺序容器的适配器

STL 提供了容器适配器 栈和队列 (stack and queue), 它们是对顺序容器的封装.
栈和队列是两个类模板, :

```cpp
template <class T, class Container=deque<T>> class stack;
template <class T, class Container=deque<T>> class queue;
```

`T` 表示元素类型, 第二个模板参数表示 基础的容器类型,
栈可以用任意顺序容器作为基础容器,
而队列只允许用 前插顺序容器作为基础容器,
默认使用双端队列.

下面给出它们所共同支持的操作, 设 S 是一种容器适配器类型,
设 s1, s2 是S的两个实例,  t 是T类型的一个实例, 下面是栈和队列所支持的操作:

`s1 op s2`; 这里op可以是 `==  !=, <, <=, >, >=` 之一, 它会对两个容器适配器之间的元素按字典序进行比较
`s.size()`; 返回 s 的元素个数
`s.empty()`; 返回 s 的元素是否为空.
`s.push(t)`; 将元素 t 压入 s 中.
`s.pop`; 将元素从 s 中弹出;对于栈而言是最后压入的元素;对于队列, 是最先被压入的元素.

容器适配器不支持迭代器,
对于栈来说, 只有栈顶的元素是可以访问到的:
`s.top()`; 返回栈顶元素的引用.

对于队列来说, 只有 队头 和 队尾 的元素是可以访问到的:

+ `s.front()`; 获得队头元素的引用.
+ `s.back()`; 获得队尾元素的引用

`string` 类其实也是一种随机访问容器,
`vector<char>` 具有的大部分功能它都具有(除了 pop_back 以外),
因此也可以使用 迭代器 对它进行遍历.

### 优先级队列

除了 栈和队列 外,  STL 还提供了 优先级队列(priority_queue):

```cpp
dtemplate<class T, class Container=vector<T>> class priority_queue;
```

优先级队列的基础容器必须是 随机访问的顺序容器(vector or deque), 默认为向量容器,
优先级队列弹出元素的顺序 与 元素的大小有关, 每次弹出容器中"最大的"元素,
因此必须定义 `<` 运算符, 优先级队列在默认情况下使用 `<` 决定元素的大小.

栈和队列的 `size`, `empty`, `push`, `pop` 它都支持, 但不支持比较操作.
优先级队列也有 `top` 函数, 可以获得下一个即将被弹出元素(最大的元素)的 `引用`.

优先级队列常常用于按照时间顺序来模拟一些事件.
