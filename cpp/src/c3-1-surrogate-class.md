# c++ 代理类

[c++中代理类的学习](https://www.cnblogs.com/zhangkele/p/9236612.html)

C++代理类是为了解决这样的问题:

`容器` 通常只能包含 `同种类型` 的对象, 所以很难在容器中存储各种子类型的 `对象本身`,
而要存储指向对象的 `指针`.

怎样设计一个c++容器, 使它有能力包含类型不同而彼此相关的对象?
`代理` 运行起来和它所代表的对象基本相同, 但是允许将整个 `派生层次` 压缩在同种 `对象类型`中.
其实就是资源管理类.

```cpp
#include <iostream>
using namespace std;

class Vehicle{
    ...
    virtual Vehicle* copy() const = 0;
};

//定义陆地上的车辆
class RoadVehicle:public Vehicle
{
    ...
    //定义一个copy 函数
    Vehicle* copy()const
    {
        //返回动态内存对象,
        // 如果返回值要存储在数组中, 这样可以避免野指针
        return new RoadVehicle(*this);
    }
};

//定义飞机
class AirCraft:public Vehicle
{
    ...
    Vehicle* copy()const
    {
        return new AirCraft(*this);
    }
};
```

如此一来, 可以写出类似下面的代码, 从而能够处理:

```cpp
Vehicle * parking_lot[100]; //存储 Vehicle 对象的指针

if(p != q)
{
    delete parking_lot[p];
    parking_lot[p] = parking_lot[q]->copy();  //这一点 很重要!!
    ... //一些其他操作
    //别忘记 这一步骤
    delete parking_lot[p];
}
```

上面的方法, 在一定程度上解决了我们的问题,
但是它在 `parking_lot` 数组中存储的是指针, 这使得用户必须 `显式处理内存分配`,
那么有没有一种方法, 既能够不显式地处理内存分配,
又能够保持 `类Vehicle` 在运行时动态绑定呢?这就是我们的 `代理类` 了.

我们为 `Vehicle` 类创建一个代理类, 假设命名为 `VehicleSurrogate`,
每个 `VehicleSurrogate` 对象代表一个 `Vehicle` 对象,
只要 `VehicleSurrogate` 对象存在, 那么它所关联的 `Vehicle` 对象就存在,
复制 `VehicleSurrogate` 对象就会复制相对应的 `Vehicle` 对象,
给代理赋新值也会先删除旧的关联的对象, 再复制新的对象.

## 智能指针

`c++代理类(一)` 中完成的简单代理类虽然解决了最急迫的问题,
但效率上又存在了另外的问题, 该简单类存在的问题主要是:

每个代理类对象都唯一关联一个实际对象,
代理类对象存在, 则实际对象存在, 代理类对象释放, 则实际类对象也要释放,
且 `复制代理类` 对象就必须要 `复制实际类` 对象.
这在实际类很大的时候复制开销是非常大的.
而且, 代理类的复制会频繁的发生, 比如: 作为函数的参数进行值传递, 或者作为函数的返回值等等.

我们将对该简单代理类进行改进, 改进的思想主要是:
在代理类中, 为其代理的实际对象添加一个 `标记`,
该 `标记` 指出有 `多少个代理类对象` 对应 此`实际对象`,
这样当我们复制代理类对象时, 其实际所代理的对象就不需要复制了, 只需要修改该标记即可.

其具体做法如下:

```cpp
class VehicleSurrogate
{
public:
        ......//跟简单类一样, 唯一不同的是需要加入处理标记num的部分
private:
    Vehicle* vp;
    int * num; //添加的标记字段
};
```

有了如上的结构, 每次复制代理类时, 只需要将 `(*num)++` 就可以了.
其意义为: 绑定到实际对象的代理类又多了一个

上述的策略在 `不需要修改` 实际对象时非常有用, 即所有代理类对象只是 `读`(read) 它所代理的实际对象时,
但当某个代理类 `需要修改` 它所代理的实际对象时, 问题就发生了,
由于所有代理类对象实际所代理的对象在内存中是同一份, 因此, 一个代理类对象所做的修改将会影响其他代理类,
因此, 此时需要对所代理的实际对象进行 `复制`, 且该复制是无法避免的.
我们称之为 —— `写时复制`(copy on write).

[实现指针的类代码](../cpplibs/../../cppLibs/surrogate-class/surrogate.cpp)

使用 `智能指针`, 既保留了简单代理类的优点: 无需显式管理内存分配,
又能实现所代理的实际对象动态绑定, 又省略了过多的复制开销.
