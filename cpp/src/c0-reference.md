# cpp 引用与指针

[指针的引用](https://zhuanlan.zhihu.com/p/139543762)
[指针和引用的区别](https://www.cnblogs.com/x_wukong/p/5712345.html)
[指针与引用](https://zhuanlan.zhihu.com/p/140966943)
[xinklabi-653643](https://www.iteye.com/blog/xinklabi-653643)

从概念上讲, 指针从本质上讲就是存放变量地址的一个变量,
在逻辑上是独立的, 它可以被改变,
包括其所指向的地址的改变和其指向的地址中所存放的数据的改变.

而引用是一个别名, 它在逻辑上不是独立的,
它的存在具有依附性, 所以引用必须在一开始就被初始化,
而且其引用的对象在其整个生命周期中是不能被改变的(自始至终只能依附于同一个变量).

`指针传递参数` 本质上是 `值传递` 的方式, 它所传递的是一个 `地址值`.
`值传递` 过程中, 被调函数的 `形式参数` 作为被调函数的 `局部变量` 处理,
即在`栈` 中开辟了内存空间以存放由 `主调函数` 放进来的`实参`的值, 从而成为了实参的一个 `副本`.
`值传递` 的特点是被调函数对 `形式参数` 的任何操作都是作为 `局部变量` 进行, **不会影响主调函数的实参变量的值**.
这里是在说 `实参指针` 本身的 `地址值` 不会变.

而在 `引用传递` 过程中, 被调函数 的 形式参数 虽然也作为 局部变量 在栈中开辟了内存空间,
但是这时存放的是由 `主调函数` 放进来的 `实参变量` 的 地址(`int &a` 的形式).

`被调函数` 对 `形参` 的任何操作都被处理成 `间接寻址`, 即通过 栈中 存放的地址访问 `主调函数` 中的 `实参变量`.
正因为如此, `被调函数` 对 `形参` 做的任何操作都影响了 `主调函数` 中的 `实参变量`.

`引用传递` 和 `指针传递` 是不同的, 虽然它们都是在被调函数栈空间上的一个局部变量,
但是任何对于引用参数的处理都会通过一个 `间接寻址` 的方式操作到主调函数中的相关变量.
而对于指针传递的参数, 如果改变被调函数中的指针地址, 它将影响不到主调函数的相关变量.
如果想通过指针参数传递来改变主调函数中的相关变量, 那就得使用指向指针的指针, 或者指针引用.

+ 为了进一步加深大家对指针和引用的区别, 下面我从编译的角度来阐述它们之间的区别:

程序在编译时分别将 `指针` 和 `引用` 添加到 `符号表` 上, 符号表上记录的是 `变量名` 及变量所 `对应地址`.
`指针变量` 在符号表上对应的 `地址值` 为指针变量的地址值, 而引用在符号表上对应的地址值为引用对象的地址值.
符号表生成后就不会再改, 因此 `指针` 可以改变其 `指向的对象`(指针变量中的值可以改), 而 `引用对象` 则不能修改.

最后, 总结一下 `指针` 和 `引用` 的相同点和不同点:

+ 相同点:
    + 都是地址的概念;
    指针指向一块内存, 它的内容是所指内存的地址; 而引用则是某块内存的别名.

+ 不同点:
    + 指针是一个实体, 而引用仅是个别名;
    + 引用只能在定义时被初始化一次, 之后不可变; 指针可变; 引用"从一而终", 指针可以"见异思迁";

    + 引用没有const, 指针有const, const的指针不可变;
    (具体指没有int& const a这种形式, 而const int& a是有    的,
    前者指引用本身即别名不可以改变, 这是当然的, 所以不需要这种形式, 后者指引用所指的值不可以改变)

    + 引用不能为空, 指针可以为空;
    + `sizeof 引用` 得到的是所指向的变量(对象)的大小, 而 `sizeof 指针` 得到的是指针本身的大小;
    + 指针和引用的自增(`++`)运算意义不一样;
    + 引用是类型安全的, 而指针不是 (引用比指针多了类型检查

## 引用与解引用

[引用与解引用](https://www.cnblogs.com/haruyuki/p/15683592.html)

程序的解析过程, 都是从 `地址` 解析到内存中真正的位置,
从 `符号表` 到 `内存位置` 的解析是由编译器自动完成的.
程序中的标识符 `sym`, 被自动依照符号表解析.

`指针`是 `变量`, 存储的是 `地址`, 指向 `内存` 的 `存储单元`;
`引用` 是 `原变量` 的 `别名`, 跟原来的变量实质上是同一个东西.

```cpp
int a = 996;
int *p = &a; // p是指针, &在此是求地址运算
int &r = a; // r是引用, &在此起标识作用
```

上面定义了整型变量 `a`,
`p` 是指针变量, `p` 的值是变量 `a` 的地址;
而引用 `r` 是 `a` 的别名, 在内存中 `r` 和 `a` 占有同一个存储单元.

可以这么理解:
`a` 将被解析成符号表映射的内存单元, `&r` 等于这个内存单元, 所以 `r` 本身也是符号.
所以 `r` 也在符号表上, 和 `a` 指向同一个地方.
`&r` 相当于避免了一次解析, 或者延迟解析.

在函数中, `swap(int* &p1,int* &p2)` 参数前缀 `&` 表示 `传递引用`, 而不是 `传递值`.
函数体中的 `p1, p2` 会被再次解析为 `地址` 指向的对象, 所以可以修改函数范围外的对象.

```cpp
#include <stdio.h>

void swap(int* &p1,int* &p2){

    int* temp=p1;
    p1=p2;
    p2=temp;
    printf("交换中: a=%d,b=%d \n",*p1,*p2);
    printf("交换中(地址): p1=%d \n",p1);
    printf("交换中(地址): p2=%d \n",p2);
}

int main(){

    int a=1,b=3;
    int *p1=&a,*p2=&b;

    // 交换前
    printf("交换前: a=%d,b=%d \n",*p1,*p2);
    printf("交换前(地址): p1=%d \n",p1);
    printf("交换前(地址): p2=%d \n",p2);
    // 交换中
    swap(p1,p2);
    // 交换后
    printf("交换后: a=%d,b=%d \n",*p1,*p2);
    printf("交换后(地址): p1=%d \n",p1);
    printf("交换后(地址): p2=%d \n",p2);
    return 0;

}
```

## 引用 reference

从 C 过来的同学可能会对 `C++` 中的 `&` 表示不解.
`&` 在C中就是表示取地址符, 在C++的实践中, 它也确实有取地址的功能.
但是, 在 `C++` 中, 它的功能不止于此, 它有了一个更准确的名称: `引用`.

`引用` 是`C++` 引入的语言特性, 它表示某一对象的 `别名`.
`对象` 和 `对象的引用` 都指向同一地址, 对引用的操作实际上就是对原对象的操作.
`引用` 的声明语法为:

```cpp
类型标识符 &引用名=目标变量名;
```

说明:

+ `&` 在此不是求地址运算, 而是起标识作用.
+ 类型标识符是指目标变量的类型.
+ 声明引用时, 必须同时对其进行初始化.
+ 引用声明完毕后, 相当于目标变量名有两个名称, 即该目标原名称和引用名,
且不能再把该引用名作为其他变量名的别名.
+ 声明一个引用, 不是新定义了一个变量, 它只表示该引用名是目标变量名的一个别名,
它本身不是一种数据类型, 因此引用本身不占存储单元, 系统也不给引用分配存储单元.
故: 对引用求地址, 就是对目标变量求地址. &ra与&a相等.

+ 不能建立数组的引用. 因为数组是一个由若干个元素所组成的集合, 所以无法建立一个数组的别名.

```cpp
int main( ){
    int a=1;
    int &b=a;
    b=2;
    cout<<a<<endl;
}

//输出结果为2
```

### 引用是别名

引用引入了对象的一个 `同义词`.
定义引用的表示方法与定义指针相似, 只是用 `&` 代替了 `*`.
例如:

```cpp
Point pt1(10,10);
Point &pt2=pt1;
```

定义了pt2为pt1的引用. 通过这样的定义, pt1和pt2表示同一对象.
需要特别强调的是引用并不产生对象的副本, 仅仅是对象的同义词.
因此, 当下面的语句执行后:

```cpp
pt1.offset(2, 2);
```

pt1和pt2都具有(12, 12)的值.
引用必须在定义时马上被初始化, 因为它必须是某个东西的同义词.
你不能先定义一个引用后才初始化它.
例如下面语句是非法的:

```cpp
Point &pt3;
pt3=pt1;
```

那么既然引用只是某个东西的同义词, 它有什么用途呢?
下面讨论引用的两个主要用途: 作为函数参数以及从函数中返回左值.

### 常引用

如果想使用 `引用`, 但又想确保引用数据的安全性, 此时可以使用 `const` 关键字来定义 `常引用`.
`常引用` 和常量一样, 不允许被修改.

```cpp
int main( ){
    int a = 1;
    const int &b = a;
    //当尝试通过引用修改变量时, 程序会报错
    b=2;
}
```

## 指针和引用的异同

最后, 总结一下 `指针` 和 `引用` 的相同点和不同点:

+ 相同
    + 都是地址的概念;
    + 指针指向一块内存, 它的内容是所指内存的地址;而引用则是某块内存的别名.

+ 不同点
    + 指针是一个实体, 而引用仅是个别名;
    + 引用只能在定义时被初始化一次, 之后不可变;
        指针可变;引用"从一而终", 指针可以"见异思迁";

    + 引用没有const, 指针有const, const的指针不可变;
        (具体指没有int& const a这种形式, 而const int& a是有 的,
        前者指引用本身即别名不可以改变, 这是当然的,
        所以不需要这种形式, 后者指引用所指的值不可以改变)

    + 引用不能为空, 指针可以为空;

    + "sizeof 引用"得到的是所指向的变量(对象)的大小,
        而"sizeof 指针"得到的是指针本身的大小;

    + 指针和引用的自增(++)运算意义不一样;
    + 引用是类型安全的, 而指针不是 (`引用` 比指针多了 `类型检查`)

## 引用的应用

光是给变量取别名似乎并没有多大的意义, 它的常见用法有下面几种:

### 函数引用传递

普通函数的参数传递为 `值传递`, 在调用时, 会为形参分配存储单元, 然后将实参的值赋给形参,
相当于创建一了份实参的 `副本` 供函数使用. `值传递` 有两个特征:

+ 在函数内对 `形参` 的操作不会影响 `实参`
+ 当传入的数据量较大时, 会 `浪费空间`.

为了解决传递大块数据时, 值传递方式造成的空间浪费, C语言的做法是 `传递指针` 从而实现直接对原数据的操作.
而在 C++ 中, 我们可以使用 `引用传递` 来解决这个问题.
只需要将形参定义为 `引用` 的形式, 例如:

```cpp
#include <iostream>

using namespace std;

//引用传递的方式
void func(int &a){
    a=a+10;
}
//传统值传递的方式
void func1(int a){
    a=a+10;
}
int main( ){
    int a = 5,b=5;
    func(a);
    func1(b);
    cout<<a<<" "<<b<<endl;
}
//输出结果为15 5
```

使用 `指针` 与 `引用` 的区别在于: 使用 `指针` 时, 虽然传递的是 `指针`, 但仍然是 `值传递` 的方式.
`指针` 也是 `变量`, 系统仍然会为 `形参` 分配空间.
并且, 大量使用指针, 会导致程序可读性变差, 且容易出错.

### 传递可变参数

传统的 `c` 中, 函数在调用时参数是通过值来传递的,
这就是说函数的参数不具备返回值的能力.
所以在传统的c中, 如果需要函数的参数具有返回值的能力,
往往是通过 `指针` 来实现的.
比如, 实现两整数变量值交换的c程序如下:

```cpp
void swapint(int *a,int *b)
{
int temp;
temp=*a;
*a=*b;
*b=temp;
}
```

使用引用机制后, 以上程序的 `c++` 版本为:

```cpp
void swapint(int &a,int &b)
{
int temp;
temp=a;
a=b;
b=temp;
}
```

调用该函数的 `c++` 方法为:

```cpp
swapint(x,y);
```

`c++` 自动把 `x`, `y` 的地址作为参数传递给 `swapint` 函数.

### 给函数传递大型对象

当大型对象被传递给函数时,
使用引用参数可使参数传递效率得到提高,
因为引用并不产生对象的副本, 也就是参数传递时, 对象无须复制.
下面的例子定义了一个有限整数集合的类:

```cpp
const maxCard=100;
Class Set
{
int elems[maxCard]; // 集和中的元素, maxCard 表示集合中元素个数的最大值.
int card; // 集合中元素的个数.
public:
Set () {card=0;} //构造函数
friend Set operator * (Set ,Set ) ; //重载运算符号*, 用于计算集合的交集 用对象作为传值参数
// friend Set operator * (Set & ,Set & ) 重载运算符号*, 用于计算集合的交集 用对象的引用作为传值参数
...
}
先考虑集合交集的实现
Set operator *( Set Set1,Set Set2)
{
Set res;
for(int i=0;i<Set1.card;++i)
for(int j=0;j>Set2.card;++j)
if(Set1.elems[i]==Set2.elems[j])
{
res.elems[res.card++]=Set1.elems[i];
break;
}
return res;
}
```

由于重载运算符不能对指针单独操作, 我们必须把运算数声明为 Set 类型而不是 Set * .
每次使用*做交集运算时, 整个集合都被复制, 这样效率很低. 我们可以用引用来避免这种情况.

```cpp
Set operator *( Set &Set1,Set &Set2)
{ Set res;
for(int i=0;i<Set1.card;++i)
for(int j=0;j>Set2.card;++j)
if(Set1.elems[i]==Set2.elems[j])
{
res.elems[res.card++]=Set1.elems[i];
break;
}
return res;
}
```

### 返回引用的函数

如果一个函数返回了 `引用`, 那么该函数的调用也可以被赋值.
这里有一函数, 它拥有两个 `引用参数` 并返回一个 双精度数 的 `引用`:

```cpp
double &max(double &d1,double &d2)
{
return d1>d2?d1:d2;
}
```

由于 `max()` 函数返回一个对双精度数的引用, 那
么我们就可以用 `max()` 来对其中较大的双精度数加 `1`:

```cpp
max(x,y)+=1.0;
```

我们仔细查看上述程序的签名
返回值类型为  `double&`, 函数内 `return` 的值为 `d1`(假设 `d1` 更大).
这类似于 `引用数据` 的定义时的写法:

```cpp
double &max =d1;
```

所以若要定义返回 `引用` 的函数, 函数内部应该返回 `value`, 而不是 `地址`.
(除非你真的想返回 `指针的引用`).

+ 类似的, 自定义类中的,  返回引用的成员函数:

```cpp
MyClass& method()
{
    // 一些操作
    return *this
}
```

如上, 返回值类型为 `MyClass&`, 返回值 为 `*this`,  两者是一一对应的.

## 引用

## 解引用运算符

在C语言中 `*` 用来定义一个指针变量, 它不表示实质的运算而仅仅起到 `标志` 的作用.
但是在 C++ 中 `*` 是一元运算符, 叫做 `解引用运算符`. 它的作用是获取地址中存储的值.
它的操作数必须是一个合法有效的 `地址数据`.

```cpp
int main( ){
    int a = 1;
    //创建指针b,存储a的地址
    int *b = &a;
    //对指针b中存储的地址进行解引用
    int c = *b;
    //输出结果为: 1 0x61feb4 1
    cout<<a<<" "<<b<<" "<<c;
}
```
