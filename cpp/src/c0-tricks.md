# cpp 使用惯例

## 运算符的优先级

ZL, p35

`[]`, `()`, `.`, `->`, `后置++`, `后置--`; 左->右
`前置++`, `前置--`, `sizeof`,  `&`, `*`, `+(正号)`, `-(负号)`, `~`, `!`; 右->左
`(强制转换类型)`; 右->左
`.*`, `->*`
`*`,    `/`,    `%`
`+`,    `-`
`<<`, `>>`
`<`,`>`,`<=`, `>=`
`==`, `!=`
`&`,
`^`
`|`
`&&`
`||`
`?:`; 右->左
`=`,`*=`, `/*`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `&=`, `^=`, `|=`; 右->左
`,`

## 枚举值作为常量

zhengli, p389

```cpp
template<int SIZE>
class Stack<bool,SIZE>{
private:
    enum{
            UNIT_BITS=sizeof(unsigned*8),
            ARRAY_SIZE=(SIZE-1)/UNIT_BITS+1;
};
//...
```

本例利用了一个小技巧, 把 枚举值 当作 整型常量使用.
由于 枚举值 全部会在 编译时计算出来, 而且可以自动转换为整数,
因此可以通过匿名枚举来达到定义 常量 的目的.

匿名枚举的功能, 完全可以用类的静态成员常量来完成,
但由于历史上有些编译器对 静态成员常量 的编译时求值 支持得不好,
所以人们习惯于使用枚举.

## typedef

zhengli, p54, p213

定义类型别名, `typedef` 的不同用法,

```cpp
typedef double Area,Volume;
typedef int Natural;
Natural i1, i2;
Area a;
Volume v;
```

```cpp
typedef int (*DoubleIntFunc)(double);
DoubleIntFunc funcPtr;
```

声明了名称为 `funcPtr`, 类型为 `DoubleIntFunc` 的函数,
具体的类型就是 `DoubleIntFunc` 所处位置对应的类型.
`typedef` 会推导出他的类型.

## sizeof

ZhengLi, p33

`sizeof` 运算符用于计算某种类型的对象 在 内存中所占的字节数.
语法形式为:

```cpp
sizeof (类型名)
//或
sizeof (表达式)
```

运算结果值为 `类型名` 所指定的类型, 或 表达式 的结果类型所占的 字节数.
注意在这个计算过程中, 并不对括号中的表达式本身求值.

### 数组的sizeof

ZL, p439

作用在数组上时, 返回数组占用的 `byte`, 例如

```cpp
int a[]={1,2,3,4,5};
cont int N=sizeof(a)/sizeof(int);
```

## 指针数组与二维数组的区别

ZL, page 209

如果 数组 的每个元素都是 指针变量, 这个数组就是 指针数组.
指针数组 的 每个元素都必须是同一类型的 指针.

声明一维指针数组的语法形式为:

```cpp
type *name[下标表达式];
```

指针数组的每个元素都是指针, 必须先赋值, 后引用.
因此, 声明数组之后, 对指针元素赋初值是必不可少的.

二维数组在内存中以 行优先 的方式, 按照一维顺序关系存放.
数组名是首地址, 元素是一维数组, 数组元素个数就是行数
例如, 声明一个二维 int 类型数组:

```cpp
int array2[3][3]={{11, 12, 13}, {21, 22, 23}, {31, 32, 33}};

int line1[]={1,0,0};
int line2[]={0,1,0};
int line3[]={0,0,1};
//定义整型指针的数组并初始化
int *pLine[3]={line1, line2, line3};
```

`array2[0]` 元素是长度为 3 的一位数组,
`array2[0]` 表示指向该一维数组首地址的整型指针, 所以

`*(array2[0])` 等价于 `array2[0][0]`,
`*(array2[0]+1)` 等价于 `array2[0][1]`,

+ 对于 `pLine` 来说, `pLine[i]` 的值需要通过读取指针数组 pLine 的第 i 个元素才能得到.
+ 而 `array2[i]` 是通过二维数组 `array2` 的首地址得到的,
内存中并没有一个指针数组来存储 `array2[i]` 的值.

## 指针运算

ZL, page 207

`p1+n1`; p1 当前所指位置 后方第 n1 个数的地址.
`p1-n1`; p1 当前所指位置 前方第 n1 个数的地址.

`*(p1+n1)`; `p1[n1]`; 内容
`*(p1-n1)`; `p1[-n1]`

一般来说, 指针的算术运算是和数组的使用相联系的,
因此只有在使用数组时, 才会得到连续分布的可操作内存空间.

相同类型的指针可以进行关系运算.
如果相同类型的指针相等, 就表示它们指向同一个地址.
不同类型的指针之间或指针与非0整数之间的关系运算毫无意义.

但是指针变量可以和 整数0 进行比较,  0 专用于表示空指针, 也就是一个不指向任何有效地址的指针.

```cpp
int *p; // 声明一个 int 型指针 p
p=0; // 将p设为空指针, 不指向任何地址
```

空指针也可以用 NULL 来表示, 例如

```cpp
int *p=NULL;
```

`NULL` 是一个在许多头文件中都有定义的宏, 被定义为 0.

## &&右值引用
