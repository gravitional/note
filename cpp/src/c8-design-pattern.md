# c++ 设计模式 design pattern

[C++各类设计模式及实现详解](https://zhuanlan.zhihu.com/p/431714886)

## 设计模式的分类

总体来说设计模式分为三大类

+ 创建型模式,
对象的创建和使用分离. 共五种:
工厂方法模式, 抽象工厂模式, 单例模式, 建造者模式, 原型模式.

+ 结构型模式.
类或者对象之间如何组合(如何搭积木), 用来提供一致的接口, 分离接口与实现,
以不变应万变, 节省内存空间, 隐藏实现等. 共七种:
适配器模式, 装饰器模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式.

+ 行为型模式,
研究对象之间如何通信. 共十一种:
策略模式, 模板方法模式, 观察者模式, 迭代子模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式.

其实还有两类: 并发型模式和线程池模式.

## 工厂模式

工厂模式属于创建型模式, 大致可以分为三类,
简单工厂模式, 工厂方法模式, 抽象工厂模式

Factory Method使一个类的实例化延迟到其子类(子工厂类)
抽象工厂模式: 定义是 提供一个创建一系列相关或相互依赖对象的接口,
而无需指定它们具体的类.

特点: 具有两个 `接口类`: 工厂类, 产品类.
工厂子类 <-> 产品子类 (映射关系).

## 策略模式

策略模式是指定义一系列的算法, 把它们一个个封装起来, 并且使它们可相互替换.

特点: 一个 `接口类`, 规定算法的接口. 一个上层类 `Cache`.
子类继承接口类, 实现要求的 `虚函数`
`Cache` 通过使用 `enum` 或 `template<typename T>` 传递参数,
映射到具体算法.

## 适配器模式

适配器模式将一个类的接口转换成客户希望的另外一个接口,
使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

特点: 一个 `接口类`, 满足客户需要的接口(目标接口),
然后在已有 class 上, 修改到 `目标接口`.

## 单例模式

`class` 具有全局唯一实例.

由于构造函数是私有的, 因此无法通过构造函数实例化,
唯一的方法就是通过调用静态函数 `GetInstance()`

特点:
`class` 具有 `静态单例`的指针.
具有 静态函数, 返回 `静态单例`.

```cpp
//Singleton.h
class Singleton
{
public:
    static Singleton* GetInstance(); // 对外静态接口
private:
    Singleton() {}
    static Singleton *singleton;
};

//Singleton.cpp
Singleton* Singleton::singleton = NULL;
Singleton* Singleton::GetInstance()
{
    if(singleton == NULL)
        singleton = new Singleton();
    return singleton;
}
```

## 原型模式, 模板方法

+ 原型模式: DP书上的定义为:
用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象.
其中有一个词很重要, 那就是拷贝. 可以说, 拷贝是原型模式的精髓所在.

特点: 一个 `接口类`, 具有 `Clone()` 方法.
对于C++, 即实现拷贝构造函数, 且是 deep copy

+ 模板方法:
模板方法使得子类可以不改变一个算法的结构, 即可重定义该算法的某些特定步骤

特点: 一个 `接口类`, 规定了调用栈.
子类可以更改调用栈内的子函数.

```cpp
//简历
class Resume
{
protected: //保护成员
    virtual void SetPersonalInfo() {}
    virtual void SetEducation() {}
    virtual void SetWorkExp() {}
public:
    void FillResume()
    {
        SetPersonalInfo();
        SetEducation();
        SetWorkExp();
    }
};
```

## 建造者模式

建造者模式的定义将一个复杂对象的构建与它的表示分离,
使得同样的构建过程可以创建不同的表示(DP)

`<大话设计模式>` 举了一个很好的例子——建造小人,
一共需建造6个部分, 头部, 身体, 左右手, 左右脚.
与工厂模式不同, 建造者模式是在导向者的控制下一步一步构造产品的.

特点: 一个 `接口类`(`Builder`), 规定了各种建造接口,
一个 `Director`(控制类), 持有 `Builder` 指针,
规定 建造过程, 调用建造接口.

## 外观模式, 组合模式

+ 外观模式
外观模式应该是用的很多的一种模式,
特别是当一个系统很复杂时, 系统提供给客户的是一个简单的对外接口,
而把里面复杂的结构都封装了起来.
客户只需使用这些简单接口就能使用这个系统, 而不需要关注内部复杂的结构.

DP一书的定义: 为子系统中的一组接口提供一个一致的界面,
外观模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用
例子: 编译器 `gcc` 与其 `编译`, `汇编`, `链接` 子系统的关系

特点:
高层类的 接口函数 调用 底层类的 接口函数

+ 组合模式
将对象组合成树形结构以表示 `部分-整体` 的层次结构.
组合使得用户对单个对象和组合对象的使用具有一致性.
注意两个字 `树形`
这种树形结构在现实生活中随处可见, 比如一个集团公司, 它有一个母公司, 下设很多家子公司.
不管是母公司还是子公司, 都有各自直属的财务部, 人力资源部, 销售部等.
对于母公司来说, 不论是子公司, 还是直属的财务部, 人力资源部, 都是它的部门.
整个公司的部门拓扑图就是一个树形结构.

特点: 一个`接口类`(`Company`), 具有 `Add` 接口,
以及其他函数动作 `Action`
可以挂 subTree 或者 leaf
具体子类(`ConcreteCompany`) 具有存储器 `list<Company*>`, 存储子树
`Action` 可以在 树形结构上遍历.

## 代理模式

DP 上的定义:
为其他对象提供一种代理以控制对这个对象的访问.
有四种常用的情况:
(1)远程代理, (2)虚代理, (3)保护代理, (4)智能引用.
本文主要介绍 虚代理 和 智能引用 两种情况.

+ 虚代理

考虑一个可以在文档中嵌入图形对象的文档编辑器.
有些图形对象的创建开销很大.
但是打开文档必须很迅速, 因此我们在打开文档时应避免一次性创建所有开销很大的对象.
这里就可以运用代理模式, 在打开文档时, 并不打开图形对象,
而是打开图形对象的代理以替代真实的图形.
待到真正需要打开图形时, 仍由代理负责打开.

虚代理 特点:
一个 `接口类`(`Image`),
规定了 `BigImage` 和 `BigImageProxy` 的共同接口,

`BigImageProxy` 持有实际资源 `BigImage` 的指针,
客户只与 `BigImageProxy` 打交道.

+ 智能引用

`std::auto_ptr` 类就是一个代理,
客户只需操作auto_prt的对象, 而不需要与被代理的指针pointee打交道.
auto_ptr 的好处在于为动态分配的对象提供异常安全.
因为它用一个对象存储需要被自动释放的资源, 然后依靠对象的析构函数来释放资源.
这样客户就不需要关注资源的释放, 由auto_ptr 对象自动完成.
实现中的一个关键就是重载了 `解引用` 操作符和 `箭头` 操作符,
从而使得auto_ptr的使用与真实指针类似.

类似地, 智能指针也是 代理类
C++中没有垃圾回收机制, 可以通过智能指针来弥补,
下面给出智能指针的一种实现, 采用了 `引用计数` 的策略.

特点: 它们都使用 template 实现.

## 享元模式

定义为: 运用共享技术有效地支持大量细粒度的对象.

例子:

`class 棋盘` 需要存放 棋子对象, 一盘棋往往需要含上百颗棋子,
如果每个棋子都 包含棋子的所有属性, 则占用的空间太大.

棋子就是大量细粒度的对象.
其属性有内在的, 比如颜色, 形状等, 也就是固有属性, 跟 棋子数量无关.
也有外在的, 比如在棋盘上的位置, 正比于 棋子数量

内在的属性是可以共享的, 区分在于外在属性.
因此, 可以这样设计, 只需定义两个棋子的对象, 一颗黑棋和一颗白棋,
这两个对象含棋子的内在属性;
棋子的外在属性, 即在棋盘上的位置可以提取出来, 存放在单独的容器中.
相比之前的方案, 现在容器中仅仅存放了位置属性, 而原来则是棋子对象.
显然, 现在的方案大大减少了对于空间的需求.

```cpp
std::vector<Piece*> m_vecPiece //原先
std::vector<PiecePos> m_vecPos // 现在
```

特点:
如果具有大量细类度对象, 称为 `Piece`,
抽取 `Piece` 的固有属性作为 类成员,
其外在属性则 存储到 外层类 的容器中.

## 桥接模式

DP书上定义: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化.
考虑装操作系统, 有多种配置的计算机, 同样也有多款操作系统.
如何运用桥接模式呢?可以将操作系统和计算机分别抽象出来,
让它们各自发展, 减少它们的耦合度.
当然了, 两者之间有标准的接口.

特点: 两个 `接口类`, 分别衍生出具体的子类.
接口具有映射关系, 如

```cpp
virtual void installOS();
virtual void installOS_impl();
```

和工厂模式的区别是, 客户端的使用不同.
桥接模式用于 对象间 传递信息.
工厂模式 用于创建对象.

## 装饰模式

装饰模式: 动态地给一个对象添加一些额外的职责.
就增加功能来说, 装饰模式相比生成子类更为灵活.

有时我们希望给某个 `对象` 而不是整个类添加一些功能.
比如有一个手机, 允许你为手机添加特性, 比如 增加挂件, 屏幕贴膜等.
一种灵活的设计方式是, 将手机嵌入到另一对象中, 由这个对象完成特性的添加,
我们称这个 被嵌入的对象为 `装饰`.
这个装饰与它所装饰的组件 `接口一致`, 因此它对使用该组件的客户透明.

特点: 两个`接口类`(`Phone`, `DecoratorPhone`),

最底层的 `Phone`类 声明了 `Decorate()` 接口;
`Phone` 具有派生 `class`; 例如 `NokiaPhone`, `iPhone`

`DecoratorPhone` 继承自 `Phone` 的 `接口类`,
也具有 `Decorate()` 虚函数(为了保证接口一致, 对客户透明),
`DecoratorPhone` 的子类实现修饰功能,
例如通过 `AddDecorate()` 私有函数实现.

## 备忘录模式

备忘录模式:
在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态.
这样以后就可将该对象恢复到原先保存的状态 (DP).

举个简单的例子, 我们玩游戏时都会保存进度, 所保存的进度以文件的形式存在.
这样下次就可以继续玩, 而不用从头开始.
这里的进度其实就是游戏的内部状态, 而这里的文件相当于是在游戏之外保存状态.
这样, 下次就可以从文件中读入保存的进度, 从而恢复到原来的状态.
这就是备忘录模式.

特点:

目标类 `GameRole`, 具有一定状态.
具有 `Save()`, `Load()` 接口,

备忘录类 `Memento` 记录 `GameRole` 的状态.
作为 `Save()`, `Load()` 的返回值或参数

另有 `CareTake` 类作为 `Memento`对象的管理器.
客户可以使用 `CareTake` 管理多个存档.

```cpp
//测试案例
int main()
{
    Caretake caretake;
    GameRole role;
    role.Show();   //初始值
    caretake.Save(role.Save()); //保存状态
    role.Attack();
    role.Show();  //进攻后
    role.Load(caretake.Load(0)); //载入状态
    role.Show();  //恢复到状态0
    return 0;
}
```

## 中介者模式

中介者模式: 用一个 `中介对象` 来封装一系列的对象交互.
中介者使各对象不需要显式地相互引用, 从而使其耦合松散, 
而且可以独立地改变它们之间的交互.
中介者模式的例子很多, 大到联合国安理会, 小到房屋中介, 
都扮演了中间者的角色, 协调各方利益.

本文就以租房为例子, 如果没有房屋中介, 
那么房客要自己找房东, 而房东也要自己找房客, 非常不方便.
有了房屋中介机构就方便了, 房东可以把要出租的房屋信息放到中介机构, 
而房客可以去中介机构咨询.
在软件中, 就是多个对象之间需要通信, 如果没有中介, 
对象就需要知道其他对象, 最坏情况下, 可能需要知道所有其他对象, 
而有了中介对象就方便多了, 对象只需与中介对象通信, 而不用知道其他的对象.
这就是中介者模式, 下面以租房为例, 给出中介者模式的UML图.

特点:
