# c++ 设计模式 design pattern

[C++各类设计模式及实现详解](https://zhuanlan.zhihu.com/p/431714886)

+ 建造类
**工厂 建造 原型 单例**

+ 结构类
**组合 代理 装饰 外观 享元 适配 桥接**

+ 通信类
**中介 观察 状态 备忘 职责 策略 模板方法**

命令模式
解释器模式
迭代器模式
访问者模式

## 设计模式的分类

总体来说设计模式分为三大类

+ 创建型模式
即对象的创建, 根据 不同输入 创建各种变体
对象的创建和使用分离. 共五种:
工厂方法模式, 抽象工厂模式, 单例模式, 建造者模式, 原型模式.

+ 结构型模式.
管理类内信息;
类或者对象之间如何组合(如何搭积木), 用来提供一致的接口, 分离接口与实现,
以不变应万变, 节省内存空间, 隐藏实现等. 共七种:
适配器模式, 装饰器模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式.

+ 行为型模式,
研究对象之间如何通信. 共十一种:
策略模式, 模板方法模式, 观察者模式, 迭代子模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式.

其实还有两类: 并发型模式和线程池模式.

## B工厂模式 build manager

工厂模式属于 创建型模式, 大致可以分为三类,
简单工厂模式, 工厂方法模式, 抽象工厂模式

Factory Method使一个类的实例化延迟到其子类(子工厂类)
抽象工厂模式: 定义是 提供一个创建一系列相关或相互依赖对象的接口,
而无需指定它们具体的类.

+ 工厂方法通过继承,
**就是在创建对象时使用了继承体系中多态的最简单要义.**

+ 抽象工厂, 偏重组合
**具有多个 build方法, 指向多个 产品Family**

+ 特点: 两个 `接口类`: 工厂类, 产品类.
工厂实现类 调用 产品实现类, 返回指针 (两种实现类一一对应).

## B建造者模式 build stack

>建造者模式的定义将一个复杂对象的构建与它的表示分离,
>使得同样的构建过程可以创建不同的表示(DP)

就是将构造对象的过程拆分成好过个步骤,
每一个步骤都是独立的, 是可以响应外部条件的, 是可更换的.
一般复杂的, 配置项多的类可以使用该模式.
比如, 生产出好的手机, 步骤可以分为:

```bash
//生产出好的手机
1, 构建cpu;
2, 构建屏幕;
3, 构建影像;
4, 构建操作系统.
```

你也可以看到, 每一步都可以使用工厂方法的设计模式.
建造者模式 可以添加一个专门的 `Director` 类用来控制建造过程.

特点: 一个 `接口类`(`Builder`), 规定了各种建造接口,
一个 `Director`(控制类), 持有 `Builder` 指针,
规定 建造过程, 调用建造接口.

## B原型模式 build copy

+ 原型模式: DP书上的定义为:
用 原型 实例指定创建对象的种类, 并且通过拷贝这些 原型创建新的对象.
其中有一个词很重要, 那就是拷贝. 可以说, 拷贝是原型模式的精髓所在.

特点: 一个 `接口类`, 具有 `Clone()` 方法.
对于C++, 即实现拷贝构造函数, 且是 deep copy

这个看起来和C++的copy constructor很像呀,
*那么原型模式和拷贝构造有什么本质不同呢?*
拷贝构造是C++对象上的操作, 必须通过 **具体的对象** 来拷贝,
而原型模式通过**接口**就可以.

比如接口`I`有两个类A和B,
对象`i`可能指向对象`a`(of类`A`)或对象`b`(of类`B`),
如何通过`i`来拷贝?(不知道具体的类名)
而通过原型模式就可以:

```cpp
I* i2 = i.clone();
```

## B单例模式 build single

`class` 具有全局唯一实例.

由于构造函数是私有的, 因此无法通过构造函数实例化,
唯一的方法就是通过调用静态函数 `GetInstance()`

特点:
`class` 具有 `静态单例`的指针.
具有 静态函数, 返回 `静态单例`.

```cpp
//Singleton.h
class Singleton
{
public:
    static Singleton* GetInstance(); // 对外静态接口
private:
    Singleton() {}
    static Singleton *singleton;
};

//Singleton.cpp
Singleton* Singleton::singleton = NULL;
Singleton* Singleton::GetInstance()
{
    if(singleton == NULL)
        singleton = new Singleton();
    return singleton;
}
```

## C外观模式, 门面模式 method stack

外观模式应该是用的很多的一种模式,
特别是当一个系统很复杂时, 系统提供给客户的是一个简单的对外接口,
而把里面复杂的结构都封装了起来.
客户只需使用这些简单接口就能使用这个系统, 而不需要关注内部复杂的结构.

DP一书的定义: 为子系统中的一组接口提供一个一致的界面,
外观模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用
例子: 编译器 `gcc` 与其 `编译`, `汇编`, `链接` 子系统的关系

特点:
高层类的 接口函数 调用 底层类的 接口函数

## C组合模式 class fractal; 类的分形

就是 一个类的接口行为 和 由其组合而成的类的接口行为 一样,
类似分形, Client调用它们的行为都是一致的.

比如一个集团公司,
它有一个母公司, 下设很多家子公司.
不管是母公司还是子公司, 都有各自直属的财务部, 人力资源部, 销售部等.
对于母公司来说, 不论是子公司, 还是直属的财务部, 人力资源部, 都是它的部门.
整个公司的部门拓扑图就是一个树形结构.

特点:
一个`接口类`(`Company`),
具有 `Add` 接口,
以及其他函数动作 `Show`
可以挂 subTree 或者 leaf
某个子类(`ConcreteCompany`) 具有存储器 `list<Company*>` 用于存储子树,
可以在 树形结构上遍历, 依次执行 `Show`.

```cpp

virtual void Add(Company *pCom){}
virtual void Show(int depth) {}

private:
list<Company *> m_listCompany;
```

## C代理模式 class wrapper

`代理类` 可以在不修改 `工作类` 的基础上,
加一些额外的逻辑, 丰富和扩展工作类.

proxy类和工作类会用 `同样的接口`,
这样代码中的工作类能随时被替换为 `proxy` 类.
举个例子, Gemfield是工作类, GemfieldProxy是代理类:
GemfieldProxy类也可以使用 lazy loading,
在晚些时候初始化 Gemfield 类成员.

DP 上的定义:
为其他对象提供一种代理以控制对这个对象的访问.
有四种常用的情况:
(1)远程代理, (2)虚代理, (3)保护代理, (4)智能引用.
本文主要介绍 虚代理 和 智能引用 两种情况.

+ 虚代理

考虑一个可以在文档中嵌入图形对象的文档编辑器.
有些图形对象的创建开销很大.
但是打开文档必须很迅速, 因此我们在打开文档时应避免一次性创建所有开销很大的对象.
这里就可以运用代理模式, 在打开文档时, 并不打开图形对象,
而是打开图形对象的代理以替代真实的图形.
待到真正需要打开图形时, 仍由代理负责打开.

虚代理 特点:
一个 `接口类`(`Image`),
规定了 `BigImage` 和 `BigImageProxy` 的共同接口,

`BigImageProxy` 持有实际资源 `BigImage` 的指针,
客户只与 `BigImageProxy` 打交道.

+ 智能引用

`std::auto_ptr` 类就是一个代理,
客户只需操作auto_prt的对象, 而不需要与被代理的指针pointee打交道.
auto_ptr 的好处在于为动态分配的对象提供异常安全.
因为它用一个对象存储需要被自动释放的资源, 然后依靠对象的析构函数来释放资源.
这样客户就不需要关注资源的释放, 由auto_ptr 对象自动完成.
实现中的一个关键就是重载了 `解引用` 操作符和 `箭头` 操作符,
从而使得auto_ptr的使用与真实指针类似.

类似地, 智能指针也是 代理类
C++中没有垃圾回收机制, 可以通过智能指针来弥补,
下面给出智能指针的一种实现, 采用了 `引用计数` 的策略.

特点: 它们都使用 template 实现.

## C适配器模式 inst wrapper

适配器模式将一个类的接口转换成客户希望的另外一个接口,
使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

Adapter类在构造时, 接收 Adapted类的实例 作为参数,
当Adapter类的方法被调用时,
它将参数 翻译为合适的格式, 然后再调用被封装类的一个或多个方法,
再将结果翻译为合适的返回值:

特点: 一个 `接口类`, 满足客户需要的接口(目标接口),
然后在已有 class 上, 修改到 `目标接口`.

## C装饰模式, inst decorate

也叫 `修饰模式`, 是 `动态的` 往一个`对象`上添加行为,
而又不影响该类其它对象的模式.
这就是和通过 `继承`, `组合` 等有所区别的关键点,
继承, 组合等是定义了新的类, 而不是改变已有对象的行为

一般是通过把 `对象实例`传给装饰类的 `构造函数` 来动态添加的.

装饰模式: 动态地给一个对象添加一些额外的职责.
就增加功能来说, 装饰模式相比生成子类更为灵活.

有时我们希望给某个 `对象` 而不是整个类添加一些功能.
比如有一个手机, 允许你为手机添加特性, 比如 增加挂件, 屏幕贴膜等.
一种灵活的设计方式是, 将手机嵌入到另一对象中, 由这个对象完成特性的添加,
我们称这个 被嵌入的对象为 `装饰`.
这个装饰与它所装饰的组件 `接口一致`, 因此它对使用该组件的客户透明.

特点: 两个`接口类`(`Phone`, `DecoratorPhone`),

最底层的 `Phone`类 声明了 `Decorate()` 接口;
`Phone` 具有派生 `class`; 例如 `NokiaPhone`, `iPhone`

`DecoratorPhone` 继承自 `Phone` 的 `接口类`,
也具有 `Decorate()` 虚函数(为了保证接口一致, 对客户透明),
`DecoratorPhone` 的子类实现修饰功能,
例如通过 `AddDecorate()` 私有函数实现.

## C享元模式 Flyweight; class reference

Flyweight pattern
对于占用内存较多的对象, 在内存中只维持一份实例,
而在用到它的多个地方通过`索引`来访问——这样可以节省内存空间.
比如html文本, 里面的`<h1>`, `<body>`, `<html>`, `<p>` 等tag大量出现,
但又重复比较多, 就可以保存为 `索引-字符串` 的 `map`,
引用索引代替字符串, 从而节省空间.
Boost库中甚至有一个Flyweight实现.

定义为: 运用共享技术有效地支持大量细粒度的对象.

例子:
`class 棋盘` 需要存放 棋子对象, 一盘棋往往需要含上百颗棋子,
如果每个棋子都 包含棋子的所有属性, 则占用的空间太大.

棋子就是大量细粒度的对象.
其属性有内在的, 比如颜色, 形状等, 也就是固有属性, 跟 棋子数量无关.
也有外在的, 比如在棋盘上的位置, 正比于 棋子数量

内在的属性是可以共享的, 区分在于外在属性.
因此, 可以这样设计, 只需定义两个棋子的对象, 一颗黑棋和一颗白棋,
这两个对象含棋子的内在属性;
棋子的外在属性, 即在棋盘上的位置可以提取出来, 存放在单独的容器中.
相比之前的方案, 现在容器中仅仅存放了位置属性, 而原来则是棋子对象.
显然, 现在的方案大大减少了对于空间的需求.

```cpp
std::vector<Piece*> m_vecPiece //原先
std::vector<PiecePos> m_vecPos // 现在
```

特点:
如果具有大量细类度对象, 称为 `Piece`,
抽取 `Piece` 的固有属性作为 类成员,
其外在属性则 存储到 外层类 的容器中.

## C桥接模式 class extract

意图是让接口和实现分离, 类似于 Run stack 和 Run多态 的组合.

将 继承树 中公共的方法 抽离成单独的接口

DP书上定义: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化.
考虑装操作系统, 有多种配置的计算机, 同样也有多款操作系统.
如何运用桥接模式呢?可以将操作系统和计算机分别抽象出来,
让它们各自发展, 减少它们的耦合度.
当然了, 两者之间有标准的接口.

特点: 两个 `接口类`, 分别衍生出具体的子类.
接口具有映射关系, 如

```cpp
virtual void installOS();
virtual void installOS_impl();
```

和工厂模式的区别是, 客户端的使用不同.
桥接模式用于 对象间 传递信息.
工厂模式 用于创建对象.

## R中介者模式

中介者模式: 用一个 `中介对象` 来封装一系列的对象交互.
中介者使各对象不需要显式地相互引用, 从而使其耦合松散,
而且可以独立地改变它们之间的交互.
中介者模式的例子很多, 大到联合国安理会, 小到房屋中介,
都扮演了中间者的角色, 协调各方利益.

本文就以租房为例子, 如果没有房屋中介,
那么房客要自己找房东, 而房东也要自己找房客, 非常不方便.
有了房屋中介机构就方便了, 房东可以把要出租的房屋信息放到中介机构,
而房客可以去中介机构咨询.
在软件中, 就是多个对象之间需要通信, 如果没有中介,
对象就需要知道其他对象, 最坏情况下, 可能需要知道所有其他对象,
而有了中介对象就方便多了, 对象只需与中介对象通信, 而不用知道其他的对象.
这就是中介者模式, 下面以租房为例, 给出中介者模式的UML图.

特点:

## R观察者模式

## R状态模式

## R备忘录模式

备忘录模式:
在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态.
这样以后就可将该对象恢复到原先保存的状态 (DP).

举个简单的例子, 我们玩游戏时都会保存进度, 所保存的进度以文件的形式存在.
这样下次就可以继续玩, 而不用从头开始.
这里的进度其实就是游戏的内部状态, 而这里的文件相当于是在游戏之外保存状态.
这样, 下次就可以从文件中读入保存的进度, 从而恢复到原来的状态.
这就是备忘录模式.

特点:

目标类 `GameRole`, 具有一定状态.
具有 `Save()`, `Load()` 接口,

备忘录类 `Memento` 记录 `GameRole` 的状态.
作为 `Save()`, `Load()` 的返回值或参数

另有 `CareTake` 类作为 `Memento`对象的管理器.
客户可以使用 `CareTake` 管理多个存档.

```cpp
//测试案例
int main()
{
    Caretake caretake;
    GameRole role;
    role.Show();   //初始值
    caretake.Save(role.Save()); //保存状态
    role.Attack();
    role.Show();  //进攻后
    role.Load(caretake.Load(0)); //载入状态
    role.Show();  //恢复到状态0
    return 0;
}
```

## R职责链模式

## R策略模式

策略模式是指定义一系列的算法, 把它们一个个封装起来, 并且使它们可相互替换.

特点: 一个 `接口类`, 规定算法的接口. 一个上层类 `Cache`.
子类继承接口类, 实现要求的 `虚函数`
`Cache` 通过使用 `enum` 或 `template<typename T>` 传递参数,
映射到具体算法.

## R模板方法, 骨架方法

模板方法使得子类可以不改变一个算法的结构, 即可重定义该算法的某些特定步骤

特点: 一个 `接口类`, 规定了调用栈.
子类可以更改调用栈内的子函数.

```cpp
//简历
class Resume
{
protected: //保护成员
    virtual void SetPersonalInfo() {}
    virtual void SetEducation() {}
    virtual void SetWorkExp() {}
public:
    void FillResume()
    {
        SetPersonalInfo();
        SetEducation();
        SetWorkExp();
    }
};
```
