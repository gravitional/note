# c++ 函数别名

[C++11: How to alias a function](https://stackoverflow.com/questions/9864125/c11-how-to-alias-a-function)

## 模板

```cpp
template <typename... Args>
auto g(Args&&... args) -> decltype(f(std::forward<Args>(args)...)) {
  return f(std::forward<Args>(args)...);
}
```

## 函数指针

The constexpr function pointer can be used as a function alias.

```cpp
namespace bar
{
    int f();
}

constexpr auto g = bar::f;
```

It is highly likely (but not guaranteed by the language) that using `g` uses `bar::f` directly.
Specifically, this depends on compiler version and optimization level.

In particular, this is the case for:

GCC 4.7.1+, without optimization,
Clang 3.1+, without optimization,
MSVC 19.14+, with optimization.

See [assembly generated by these compilers](https://godbolt.org/z/2XjiQJ).

## others

[How do I assign an alias to a function name in C++?](https://stackoverflow.com/questions/3053561/how-do-i-assign-an-alias-to-a-function-name-in-c)

There are different approaches:

With C++11 with non-template non-overloaded functions you can simply use:

```cpp
const auto& new_fn_name = old_fn_name;
```

If this function has multiple overloads you should use `static_cast`:

```cpp
const auto& new_fn_name = static_cast<OVERLOADED_FN_TYPE>(old_fn_name);
```

Example: there are two overloads of function std::stoi

```cpp
int stoi (const string&, size_t*, int);
int stoi (const wstring&, size_t*, int);
```

If you want to make an alias to the first version you should use the following:

```cpp
const auto& new_fn_name = static_cast<int(*)(const string&, size_t*, int)>(std::stoi);
```

Note: there is no way to make an alias to overloaded function 
such that all its overloaded versions work, 
so you should always specify which exact function overload you want.

With C++14 you can go even further with constexpr template variables. That allows you to alias templated functions:

```cpp
template<typename T>
constexpr void old_function(/* args */);

template<typename T>
constexpr auto alias_to_old = old_function<T>;
```

Moreover, starting with C++11 you have a function called `std::mem_fn` 
that allows to alias member functions. See the following example:

```cpp
struct A {
   void f(int i) {
      std::cout << "Argument: " << i << '\n';
   }
};


A a;

auto greet = std::mem_fn(&A::f); // alias to member function
// prints "Argument: 5"
greet(a, 5); // you should provide an object each time you use this alias

// if you want to bind an object permanently use `std::bind`
greet_a = std::bind(greet, a, std::placeholders::_1);
greet_a(3); // equivalent to greet(a, 3) => a.f(3);
```
