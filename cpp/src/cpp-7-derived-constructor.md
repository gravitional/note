# 派生类的构造函数

    默认情况

        基类的构造函数不被继承;

        派生类需要定义自己的构造函数.

    C++11规定

        using B::B;

        派生类新增成员可以通过类内初始值进行初始化.

        可用using语句继承基类构造函数.

        但是只能初始化从基类继承的成员.

        语法形式:

建议

    如果派生类有自己新增的成员, 且需要通过构造函数初始化, 则派生类要自定义构造函数.

若不继承基类的构造函数

    派生类新增成员: 派生类定义构造函数初始化;

    继承来的成员: 自动调用基类构造函数进行初始化;

    派生类的构造函数需要给基类的构造函数传递参数.

单继承

    派生类只有一个直接基类的情况, 是单继承. 单继承时, 派生类的构造函数只需要给一个直接基类构造函数传递参数.

单继承时构造函数的定义语法

派生类名::派生类名(基类所需的形参, 本类成员所需的形参):
基类名(参数表), 本类成员初始化列表
{
    //其他初始化;
};

单继承时的构造函数举例(补7-3)

```cpp
#include<iostream>
using namespace std;
class B {
public:
    B();
    B(int i);
    ~B();
    void print() const;
private:
    int b;
};

B::B() {
    b=0;
    cout << "B's default constructor called." << endl;
}
B::B(int i) {
    b=i;
    cout << "B's constructor called." << endl;
}
B::~B() {
    cout << "B's destructor called." << endl;
}
void B::print() const {
    cout << b << endl;
}

class C: public B {
public:
    C();
    C(int i, int j);
    ~C();
    void print() const;
private:
    int c;
};
C::C() {
    c = 0;
    cout << "C's default constructor called." << endl;
}
C::C(int i,int j): B(i), c(j){
    cout << "C's constructor called." << endl;
}

C::~C() {
    cout << "C's destructor called." << endl;
}
void C::print() const {
    B::print();
    cout << c << endl;
}

int main() {
    C obj(5, 6);
    obj.print();
    return 0;
}
```

## 多继承

    多继承时, 有多个直接基类, 如果不继承基类的构造函数, 派生类构造函数需要给所有基类构造函数传递参数. 我们来看一下语法规定

多继承时构造函数的定义语法

派生类名::派生类名(参数表) :
基类名1(基类1初始化参数表),
基类名2(基类2初始化参数表),
...
基类名n(基类n初始化参数表),
本类成员初始化列表
{
        //其他初始化;
};

派生类与基类的构造函数

    当基类有默认构造函数时

        派生类构造函数可以不向基类构造函数传递参数.

        构造派生类的对象时, 基类的默认构造函数将被调用.

    如需执行基类中带参数的构造函数

        派生类构造函数应为基类构造函数提供参数.

多继承且有对象成员时派生的构造函数定义语法

派生类名::派生类名(形参表):
基类名1(参数), 基类名2(参数), ..., 基类名n(参数),
本类成员(含对象成员)初始化列表
{
        //其他初始化
};

构造函数的执行顺序

    调用基类构造函数.

        顺序按照它们被继承时声明的顺序(从左向右).

    对初始化列表中的成员进行初始化.

        顺序按照它们在类中定义的顺序.

        对象成员初始化时自动调用其所属类的构造函数. 由初始化列表提供参数.

    执行派生类的构造函数体中的内容.
