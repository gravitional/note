# Cpp 语法理解

## C++中引用传递与指针传递区别

[https://www.iteye.com/blog/xinklabi-653643](https://www.iteye.com/blog/xinklabi-653643)

从概念上讲. 指针从本质上讲就是存放变量地址的一个变量,
在逻辑上是独立的, 它可以被改变,
包括其所指向的地址的改变和其指向的地址中所存放的数据的改变.

而引用是一个别名, 它在逻辑上不是独立的,
它的存在具有依附性, 所以引用必须在一开始就被初始化,
而且其引用的对象在其整个生命周期中是不能被改变的(自始至终只能依附于同一个变量).

在C++中, 指针和引用经常用于函数的参数传递,
然而, 指针传递参数和引用传递参数是有本质上的不同的:

指针传递参数本质上是值传递的方式, 它所传递的是一个地址值.
值传递过程中, 被调函数的形式参数作为被调函数的局部变量处理,
即在栈中开辟了内存空间以存放由主调函数放进来的实参的值,
从而成为了实参的一个副本.
值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行,
不会影响主调函数的实参变量的值. (这里是在说实参指针本身的地址值不会变)

而在引用传递过程中,
被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间,
但是这时存放的是由主调函数放进来的实参变量的地址.
被调函数对形参的任何操作都被处理成间接寻址,
即通过栈中存放的地址访问主调函数中的实参变量.
正因为如此, 被调函数对形参做的任何操作都影响了主调函数中的实参变量.

引用传递和指针传递是不同的,
虽然它们都是在被调函数栈空间上的一个局部变量,
但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量.
而对于指针传递的参数, 如果改变被调函数中的指针地址,
它将影响不到主调函数的相关变量.
如果想通过指针参数传递来改变主调函数中的相关变量,
那就得使用指向指针的指针, 或者指针引用.

为了进一步加深大家对指针和引用的区别,
下面我从编译的角度来阐述它们之间的区别:

程序在编译时分别将指针和引用添加到符号表上,
符号表上记录的是变量名及变量所对应地址.
指针变量在符号表上对应的地址值为指针变量的地址值,
而引用在符号表上对应的地址值为引用对象的地址值.
符号表生成后就不会再改,
因此指针可以改变其指向的对象(指针变量中的值可以改), 而引用对象则不能修改.

### 相同点和不同点

最后, 总结一下 `指针` 和 `引用` 的相同点和不同点:

+ 相同
    + 都是地址的概念;
    + 指针指向一块内存, 它的内容是所指内存的地址;而引用则是某块内存的别名.

+ 不同点
    + 指针是一个实体, 而引用仅是个别名;
    + 引用只能在定义时被初始化一次, 之后不可变;
        指针可变;引用"从一而终", 指针可以"见异思迁";

    + 引用没有const, 指针有const, const的指针不可变;
        (具体指没有int& const a这种形式, 而const int& a是有 的,
        前者指引用本身即别名不可以改变, 这是当然的,
        所以不需要这种形式, 后者指引用所指的值不可以改变)

    + 引用不能为空, 指针可以为空;

    + "sizeof 引用"得到的是所指向的变量(对象)的大小,
        而"sizeof 指针"得到的是指针本身的大小;

    + 指针和引用的自增(++)运算意义不一样;
    + 引用是类型安全的, 而指针不是 (`引用` 比指针多了 `类型检查`)

## 引用的概念

引用引入了对象的一个 `同义词`.
定义引用的表示方法与定义指针相似, 只是用 `&` 代替了 `*`.
例如:

```cpp
Point pt1(10,10);
Point &pt2=pt1;
```

定义了pt2为pt1的引用. 通过这样的定义, pt1和pt2表示同一对象.
需要特别强调的是引用并不产生对象的副本, 仅仅是对象的同义词.
因此, 当下面的语句执行后:

```cpp
pt1.offset(2, 2);
```

pt1和pt2都具有(12, 12)的值.
引用必须在定义时马上被初始化, 因为它必须是某个东西的同义词.
你不能先定义一个引用后才初始化它.
例如下面语句是非法的:

```cpp
Point &pt3;
pt3=pt1;
```

那么既然引用只是某个东西的同义词, 它有什么用途呢?
下面讨论引用的两个主要用途: 作为函数参数以及从函数中返回左值.

### 引用参数

1, 传递可变参数

传统的 `c` 中, 函数在调用时参数是通过值来传递的,
这就是说函数的参数不具备返回值的能力.
所以在传统的c中, 如果需要函数的参数具有返回值的能力,
往往是通过 `指针` 来实现的.
比如, 实现两整数变量值交换的c程序如下:

```cpp
void swapint(int *a,int *b)
{
int temp;
temp=*a;
*a=*b;
*b=temp;
}
```

使用引用机制后, 以上程序的 `c++` 版本为:

```cpp
void swapint(int &a,int &b)
{
int temp;
temp=a;
a=b;
b=temp;
}
```

调用该函数的 `c++` 方法为:

```cpp
swapint(x,y);
```

`c++` 自动把 `x`, `y` 的地址作为参数传递给 `swapint` 函数.

2, 给函数传递大型对象

当大型对象被传递给函数时,
使用引用参数可使参数传递效率得到提高,
因为引用并不产生对象的副本, 也就是参数传递时, 对象无须复制.
下面的例子定义了一个有限整数集合的类:

```cpp
const maxCard=100;
Class Set
{
int elems[maxCard]; // 集和中的元素, maxCard 表示集合中元素个数的最大值.
int card; // 集合中元素的个数.
public:
Set () {card=0;} //构造函数
friend Set operator * (Set ,Set ) ; //重载运算符号*, 用于计算集合的交集 用对象作为传值参数
// friend Set operator * (Set & ,Set & ) 重载运算符号*, 用于计算集合的交集 用对象的引用作为传值参数
...
}
先考虑集合交集的实现
Set operator *( Set Set1,Set Set2)
{
Set res;
for(int i=0;i<Set1.card;++i)
for(int j=0;j>Set2.card;++j)
if(Set1.elems[i]==Set2.elems[j])
{
res.elems[res.card++]=Set1.elems[i];
break;
}
return res;
}
```

由于重载运算符不能对指针单独操作, 我们必须把运算数声明为 Set 类型而不是 Set * .
每次使用*做交集运算时, 整个集合都被复制, 这样效率很低. 我们可以用引用来避免这种情况.

```cpp
Set operator *( Set &Set1,Set &Set2)
{ Set res;
for(int i=0;i<Set1.card;++i)
for(int j=0;j>Set2.card;++j)
if(Set1.elems[i]==Set2.elems[j])
{
res.elems[res.card++]=Set1.elems[i];
break;
}
return res;
}
```

### 引用返回值

如果一个函数返回了引用, 那么该函数的调用也可以被赋值.
这里有一函数, 它拥有两个引用参数并返回一个双精度数的引用:

```cpp
double &max(double &d1,double &d2)
{
return d1>d2?d1:d2;
}
```

由于max()函数返回一个对双精度数的引用, 那
么我们就可以用 `max()` 来对其中较大的双精度数加 `1`:

```cpp
max(x,y)+=1.0;
```

## c++语言的声明以及类型

### const int* 与 int const*

[C++里 const int* 与 int const* 有什么区别?](https://www.zhihu.com/question/443195492/answer/1723886545)

不管 `const` 写成如何, 读懂别人写的 const 和 `*` 满天飞的类型的金科玉律是

    const 默认作用于其左边的东西, 否则作用于其右边的东西:

    const applies to the thing left of it.
    If there is nothing on the left then it applies to the thing right of it.[1]

例如,

```cpp
const int*
```

`const` 只有右边有东西, 所以 `const` 修饰 `int` 成为常量整型, 然后 `*` 再作用于常量整型.
所以这是 `a pointer to a constant integer`
(指向一个整型, 不可通过该指针改变其指向的内容, 但可改变指针本身所指向的地址)

```cpp
int const *
```

再看这个, `const` 左边有东西, 所以 `const` 作用于 `int`,
`*` 再作用于 `int const` 所以这还是 `a pointer to a constant integer`(同上)

```cpp
int* const
```

这个 `const` 的左边是 `*`, 所以 `const` 作用于指针(不可改变指向的地址),
所以这是 `a constant pointer to an integer`,
可以通过指针改变其所指向的内容, 但只能指向该地址, **不可指向别的地址**.

```cpp
const int* const
```

这里有两个 `const`.
左边的 `const` 的左边没东西, 右边有 `int` 那么此 `const` 修饰 `int`.
右边的 `const` 作用于 `*` 使得指针本身变成 `const`(不可改变指向地址),
那么这个是 `a constant pointer to a constant integer`,
不可改变指针本身所指向的地址也不可通过指针改变其指向的内容.

```cpp
int const * const
```

这里也出现了两个 `const`, 左边都有东西,
那么左边的 `const` 作用于 `int`, 右边的 `const` 作用于 `*`,
于是这个还是是 `a constant pointer to a constant integer`

```cpp
int const * const *
```

懒得分析了, 照葫芦画瓢,
a pointer to a constant pointer to a constant integer,
其实就是指向上边那个的东西的指针.

```cpp
int const * const * const
```

上边的指针本身变成 `const`,
a constant pointer to a constant pointer to a constant integer.

再扯两句, 因为 `const` 的作用机理和阅读习惯,
码农之间产生了两种写 `const` 的流派, 一个是所谓的 `western const style`,
也即把 `const` 写在西边(左边), 例如 `const int`, 符合人类语言习惯;

另一个流派叫 `eastern const style`,
遵照上边的规则把 `const` 写在东边(右边), 例如 `int const`.
从代码可读性易维护性出发, 强烈推荐把 `const` 写在右边
(包括自己学的时候老师如是安利. . . ),
可以跟指针的作用范围很好地统一起来不至于混乱.

[const-before-or-const-after](https://stackoverflow.com/questions/5503352/const-before-or-const-after)

### 从右往左读

[如何理解c/c++语言的声明以及类型-invalid s](https://www.zhihu.com/question/49673652/answer/117197517)

`const int*` 与 `int const*` 有什么区别:

>唯一区别是后者无脑从右往左读就行.

```cpp
int const: pointer to const int
int const *const: const pointer to const int
int *const: const pointer to int
int *const *: pointer to const pointer to int
```

## Reading C type declarations

[Reading C type declarations](http://unixwiz.net/techtips/reading-cdecl.html)

很简单, 从 `被声明的标识符` 开始, 先右后左, 遇括号返回.

```cpp
int A;
```

很简单, `A` 是一个 `int`

```cpp
int *A;
```

从 `A` 开始: `A` 是一个变量, `*` 表示它是一个指针变量,
`int` 表示这个指针变量指向 `int`.

```cpp
int **A;
```

`A` 是一个变量, `*` 表示它是一个指针变量,
第二个 `*` 表示前一个指针变量指向的类型还是 `指针`,
`int` 表示 `A` 这个指针变量指向的指针变量指向 `int`.

```cpp
int A[5];
```

`A` 是一个变量,
(向右)这个变量是一个有 `5` 个元素的数组, (向左)这个数组存储 `int`

```cpp
int *A[5];
```

`A` 是一个变量,
(向右)这个变量是一个有5个元素的数组,
(向左)这个数组存储指针, 指针指向的类型是int

```cpp
int **A[5];
```

`A` 是一个变量,
(向右)这个变量是一个有 `5` 个元素的 `数组`, (向左)这个 `数组` 存储指针,
指针指向的类型还是一个 `指针`, 最终指向的数据类型是 `int`

当然还有很多更为复杂, 连老鸟都能搞晕的写法.
那些就属于魔道了.
真需要作复杂的声明时, 建议用 `typedef` 一层层定义别名,
最后用 `typedef` 的别名完成声明.
这样写出的声明易懂, 无歧义, 便于阅读.

[C语言复杂声明解析](https://blog.csdn.net/wangweixaut061/article/details/6549768)

## c++语言的声明以及类型2

[如何理解c/c++语言的声明以及类型 Colliot的回答](https://www.zhihu.com/question/49673652/answer/1044845311)

C 语言的类型声明, 由于某些历史局限性, 在某些情况下显得相当复杂.
下面让我们来渐渐深入 C 语言类型声明的谜团, 一探究竟.

### 指针和数组

#### 一重声明

以下这些问题, 我相信即使是最基本的初学者也不会有太大困难:
你会声明数组吗?

```cpp
int a[5]; // 包含 5 个元素.
```

你会声明指针吗?

```cpp
int *a;
```

#### 二重声明

你会声明双重指针吗?

```cpp
int **a;
```

你会声明二维数组吗?

```cpp
// 第一维长 5, 第二维长 7
int a[5][7];
```

那你会声明 `指针` 的 `数组` 吗?

```cpp
// 数组的长度为 7
int *a[7];
```

你会声明`(指向)数组` 的 `指针` 吗?

```cpp
int (*a)[5];
```

思考题 1: 二维数组, 数组的指针, 指针的数组,
这些东西是一样的吗?有相同的吗?还是各不相同?

一定要注意, 用 `指针类型` 代替 `数组` 是错误的做法——
对于 `多重数组` 和 `多重指针` , 它们下标的语义是不一样的.
无论 `几维数组`, 它们的内存布局总是 `线性` 的,
`指针` 却不然, 有多少重就会真的做多少次跳转.

#### 三重声明

你会声明 `[数组的指针]的数组` 吗?

```cpp
int (*a[9])[5];
```

你会声明 `指向 [指针的数组] 的指针` 吗?

```cpp
int *(*a)[5];
```

让我们来试着验证一下. 怎么验证呢?
只要按照概念(比如 `数组的指针的数组` ), 一步一步构造并且赋值,
最后能编译通过, 没有警告, 就说明我们从概念到代码的翻译是对的.

```cpp
int a1 = 1;
int a2 = 2;
int a3 = 3;
int a4 = 4;
int a5 = 5;

int aa1[5] = {1, 2, 3, 4, 5};
int aa2[5] = {1, 2, 3, 4, 5};
int aa3[5] = {1, 2, 3, 4, 5};
// 二维
int *aa[5] = {&a1, &a2, &a3, &a4, &a5};
int (*aa1d)[5] = &aa1;
// 三维
int *(*a)[5] = &aa;
int (*b[3])[5] = {&aa1, &aa2, &aa3};
```

看明白了吗?这背后的原理是什么呢?

实际上这体现了某种 `递归性`——

+ 变量声明就是不断扩充变量的定语(对变量的描述)的过程.
+ 假设变量 `ident`(只是个名字), 包含在一坨复杂的形式 `D` 中,
+ 我们约定 `T D` 的意思是, 在定语中增加 `T 类型`,
+ 再看声明 `T *D`,  那么 `T *D` 声明的 `ident`,
除了已存在的定语, 还要加上一句, `它是指向 T类型 的指针`.

+ 此外我们还约定, 如果声明形如 `T D[n]` (仍然假设变量 `ident` 在 `D` 中),
则 `T D[n]` 声明了长度为 `n` 的, 类型为 `T` 的 `[定语 + 数组]` 的 `ident`.

有些晦涩, 是不是?让我们再拿例子回顾一下.
比如 `int (*b[3])[5]` 中:

+ `D` 就是 `(*b[3])`, `T D` 则是 `int (*b[3])`,
说明 `a` 是一个长度为 `5` 的,
如果说 `int (*b[3])` 声明了 `[xx] of int` 的话,
`int (*b[3])[5]` 就声明了 `[xx]的, 长度=5的数组of` int,

+ 再拆解得 `int b[3]`, 很简单, 表示 `[长度为3的数组]of int` (这里 `T` 是 `int`),
那么 `int (*b[3])` 声明了 `[长度=3的数组]`,
它的元素是啥呢?元素是 `[指向 int 的指针]`,
我们总的表示成 `[长度=3的数组 of] [指向 int 的指针]`

从而上文的 `[xx]` , 可以表示为 `[长度为3的数组 of 指向 <上层> 的指针]`,
我们留下的占位符 `<上层>`, 刚好用来插入 `这个定语` 要修饰的上层对象.
让我们把第一步的 `[长度为 5 数组 of int]` 填进这个 `<上层>`,
就会得到

    [长度为 3 数组 of 指向
        [长度为 5 数组 of int]
            的指针]

用人话说,  `int (*b[3])[5]` 就是长度为 `3` 的数组,
它包含的是一些 `指针`, 这些指针指向长度为 `5` 的 `int 数组`.
这和我们的代码 `int (*b[3])[5] = {&aa1, &aa2, &aa3}` 也是一致的.

以上便是标准中对类型的 `递归`定义.
这看起来对人类太不友好了, 但是我们也更人性化的等价解读——`替换`.

比如还是对这个 `int (*b[3])[5]`:
注意 `[3]` 的优先级比 `*` 要高.
我们先把 `b[3]` 替换成 `c`, 那么 `b` 的类型就会是含有 `3` 个元素的, `c` 的类型的数组.
`int (*c)[5]`, 由于括号的存在, 我们这时候会替换 `*c`, 而不是 `c[5]`.
假设替换为 `d`, 从而 `int d[5]`, 那么 `c` 是一个指向 `d` 类型(的变量)的指针.
`d` 类型就很简单了, 是  `5 个元素的 int 数组`.
那么我们将以上串联起来——
`b 是 [含有 3 个元素的] [元素是［指向〔有 5 个元素的 int 数组〕的指针］] 的数组`.
看, 还是一样的吧.

实际上这就是 `自底向上`, 而不是 `自顶向下` 解读那样的递归解析规则罢了.

而如果我们不慎多加了一个括号,
比如 `int (*a[9])[5]` 变成了` int ((*a)[9])[5]`, 那么结果就会变味了.
拆解到 `int ((*a)[9])` 的时候, 会优先拆解成数组,
从而最后变成了指向 `数组的数组`(二维数组)的 `指针` 了.

比如 `int *(*a)[5]`——

我们可以把 `(*a)` 替换成 `b`, 这样 `a` 便是指向 `b` 被定义的类型的指针.
而 `int *b[5]`, 我们又可以把 `b[5]` 替换成 c(可以看出,
这样的理解下, 「下标」要比「解引用」, 就是小星星, 优先级更高),
那么 b 便是容纳 c 的类型的, 长度为 5 的数组.
最后 `int *c`, 则 c 是指向整数的指针.
从而原本声明的 a 是一个指向长度为 5 的,
元素是整数指针的数组的指针, 也就是指针的数组的指针.

思考题 2: 为什么 `int *a[7]` 和 `int (*a)[5]` 一个是指针的数组,
一个是数组的指针?括号是怎么起作用的?

这样的思想, 同样可以套用到函数类型上(因为函数类型也是这样递归定义的).

### 函数

你会声明一个函数吗?想必大家都会.

```cpp
int func(int, int);
```

这就声明了一个名为 `func`, 接收两个 `int` 型参数的变量, 可以这么用:

```cpp
int result = func(1, 2);
```

那么你会声明一个函数类型的变量吗?
嗯哼?

等一下 `?变量?` 其实你在你声明函数的时候, 就已经等于在声明了一个函数类型的变量了.
只不过函数 `变量` 不支持用等号 `赋值`.
要修改它的  `值`, 必须通过花括号语法, 撰写 `函数体`, 比如:

```cpp
int func(int a, int b) {
 return a + b;
}
```

这是大家熟知的内容.
这样, 我们连函数类型  `变量` 的声明也知晓了——它就是我们熟习的函数声明.
可是既然它不可以赋值, 也只能定义至多一次, 它就不是个 `变`量了, 那么会写它的类型又有什么用呢?

其实, 我们还可以拿来传参呀!
比如上面的 `func`, 就是把两个参数加起来.
现在我们想利用这个函数, 构造一个把单个整数加  `1`  的函数.
我们该怎么接收这个函数作为变量的?这时候我们就需要它的类型了:

```cpp
int apply_on_1(int func(int, int), int);

int apply_on_1(int func(int, int), int b) {
 return func(1, b);
}
```

原来函数类型也可以这么用啊!

### 复杂函数

现在问题又来了, 你会声明返回以上各种类型的函数吗?
你会把这些类型(包括函数)随意组合起来吗?
比如一个接收「(数组的指针)的数组」, 返回「数组的指针」的函数.
一个最简单的实现就是返回这个「(数组的指针)的数组」的第一个元素,
它必然是一个「数组的指针」.

内容知道了, 可是类型又该如何写呢?参数类型是好写的,
我们只要把「(数组的指针)的数组」类型依样照搬到参数列表里就行:

```cpp
some_type return_first(int (*a[9])[5]);
```

问题就化归到了 some_type 怎么写上.
实际上, 我们还是只要牢记「递归」或者说「替换」原则. 我们把

```cpp
return_first(int (*a[9])[5])
```

这个整体当作一个变量, 它如果是一个「数组的指针」.
它会处在什么位置呢?回顾「数组的指针」的声明:

```cpp
int (*a)[5];
```

这时候我们只要把 `return_first(int (*a[9])[5])` 作为一个整体, 替换到上面的 a 中去, 就成功了:

```cpp
int (*return_first(int (*a[9])[5]))[5];
```

很简单舒畅是不是?
其实作为在函数声明中, 参数名是可以省略的, 即使它是被「包裹」在中间的.
这就是说, 以上定义等价于

```cpp
int (*return_first(int(*[9])[5]))[5];
```

而如果我们有一个接收以上类型, 返回 `double` 的函数, 我们就可以把 `return_first` 也省掉, 比如

```cpp
double complex_func(int(*(int(*[9])[5]))[5]);
```

这样太吓人了.

### 函数指针

有人会问, 为什么只谈函数指针, 不谈函数数组呢?
C 语言不允许声明函数数组.
想想前文, 函数不能赋值, 只能定义, 如果声明了函数数组, 我们根本就无法操作啊.
但是函数是可以取地址的, 所以我们可以定义并广泛使用函数指针.

函数指针, 其实很简单. 你已经知道声明 int 类型的指针是:

```cpp
int *p_int;
```

那么声明 int func(int, int) 类型的指针 p_func,
就应该是把 `*p_func` 当作是 func 一样带入进 int func(int, int), 也就是:

```cpp
int (*p_func)(int, int);
```

为什么要加括号?
这是因为函数参数列表的优先级相较指针声明的优先级为高,
如果不加括号, p_func 就首先会被认为是一个函数.
我们前面已经探讨过这个问题了. 为什么是把指针带入进函数声明,
不是反过来, 把函数带入进指针声明, 也就是假装 func(int, int) 是一个 `int *`?
那就是声明一个返回整数指针的函数了, 而不是一个函数的指针.

### 函数和函数指针

函数和函数指针有什么区别?最显著的区别就是函数指针也是指针, 可以赋值. 比如:

```cpp
int func2(int a, int b) {
 return a * b;
}

int (*p_func)(int, int) = &func2;
int (*another_p_func)(int, int) = func2;
```

有人会问, 第二个是什么?
为什么不用「取地址」就可以把一个「函数」赋给「函数指针」?
这正是「函数」的种种特殊性之一——
对于所有除了「取地址」(&) 和「取大小」(sizeof) 之外的操作(实际上并不允许 sizeof 作用于函数),
函数总是会隐式地转换为指向它的指针.
所以当你把函数赋给一个变量, 实际上把它的地址赋给那个变量,
当你把函数的地址赋给一个变量, 你还是在把它的地址赋给那个变量.

从此, 我们就知晓了「数组」, 「指针」和「变量」任意混合的类型声明.

### 修饰符

所谓修饰符, 就是 `cv-qualifiers`, 也就是 `const` 和 `volatile`.

`volitile` 是一个如果不面向硬件编程就不太接触到的东西,
它表示变量可能被程序之外的东西修改(你可以不用管它).
`const` 则是较常见的修饰符. 它表示所指向的对象是不可修改的. 比如:

```cpp
int const a = 0;
a = 1; // 会报错, 因为 a 是 `const` 的.
const int b = 0;
b = 1; // 同样会报错, 因为 b 是 `const` 的.
```

我们可以看到, `const` 可以放在类型前后, 如 `int const` 和 `const int`, 效果一样.
同样的:

```cpp
int * const a;
// 和
const int * b;
int const * c;
```

全然不同.

让我们套用「替换」的观点——
`int const * c` 表示 `*c` 是一个 `int const`(相应地, 对于 b 是 const int, 也就是 int const),
就是说, `c` 是一个指向整数常量的指针, 但是 `c` 本身不是一个常量, 是可以随便改的.

```cpp
int v = 5;
int const * c = &v; // NULL 表示 0. 不会报错, 因为 c 可变.
*c = 7; // 会报错, 因为 `*c` 不可变.
```

而 `int * const a`, 则是被 `const` 修饰的 `int *`,
也就是不可变的整数指针, a 本身是常量, 不能改, 指向的地方倒是可以改.

那么 const 如何描述一个「不可变」数组?
`const` 该放到数组声明哪里呢?好像没有地方可以放哦.

什么?常量数组?不存在这种东西. 我们知道数组是不可赋值的,
只能至多定义一次, 它本身就是不可变的, 所以没有 const 也很科学.

「不可变」函数也是不存在的, 理由同上.
当然函数的返回类型和参数类型都可以是 const 的, 很容易举一反三.

### typedef

typedef 很有用, 它可能是我们"可读"地声明这些复杂类型的方案. 那么如何 typedef 这些复杂类型的?

你可能见过

typedef int a;

它把 a 声明作 int 类型的别名.  你也可能见过

typedef long long LL;

它把 LL 声明作 long long 类型(注意 long long 是一个类型)的别名.

这些都是简单类型, 那么复杂类型呢?其实和上面一模一样就可以了.
你可以把任何一个变量声明语句之前加上 typedef, 从而获得一个类型别名声明. 本来要声明的「变量」名, 就是现在声明的「类型别名」. 比如:

typedef int (*a[9])[5];

就是把 a 声明作数组的指针的数组. 以后可以像

a v_a;

这样声明一个名为 v_a 的「数组的指针的数组」. 为了增加可读性, 你可以多使用渐进的 typedef, 每次只多定义一层——比如第一次定义一个数组类型, 第二次定义指向第一次那类型的指针, 第三次定义第二次那类型的数组:

typedef int int_array[5];
typedef int_array * ptr_to_int_array;
typedef ptr_to_int_array array_of_ptr_to_int_[7];

(说实话, 工程上这样有多大意义, 甚至是否需要这样的复杂类型, 都是有争议的. 不同的人有不同的看法. 比如 Linux 内核那一卦的人就不主张对 struct 进行 typedef, 而 libuv 里这样的 typedef 又满天飞. 又比如很多人不主张对指针类型进行 typedef. 工程习惯上的争论, 是永不过时的议题. )
网易笔试题

前一阵子, 某网易校招笔试题引起了轩然大波, 受到广泛吐槽. 对题目的价值取向我们暂且不表, 不妨用刚刚讨论过的内容来试着分析一下. 它是 C++, 不过不超出 C 的范畴(C++ 引入了类和模板, 相关情形对类型的解析会复杂得多). 题目是分析这几个类型的意义:

int *ptr[n];

int (*)ptr[n];

int *ptr();

int (*)ptr();

int(*((*ptr(int, int))))(int);

我们先概览一下, 其中有两个显著的错误——`(*)` 是非法的,
 把一个这样的碎片单独括起来是没有意义的.
(引用标准)实际上标准中也不允许出现这样的情况, 所以编译器当然也会报错了.
我们不妨猜测一下, 原本的面貌是 `(*ptr)` 而不是 `*(ptr)`,
这就很有意义了, 2, 5 改过之后看起来也不跟别的选项重复, 很合理.

我们来看改过后的样貌:

```cpp
int *ptr[n];

int (*ptr)[n];

int *ptr();

int (*ptr)();

int(*((*ptr(int, int))))(int);
```

这么看来, 第 1, 2 项我们在最开始就讨论完了.
第 3, 4 项也都是最基本的情形.
看看第五项, 我们应该从内而外地看, ptr 是一个函数(我们前面说过,
参数列表比星号更高级, 这里不是 (*ptr)(int, int), 而是 *ptr(int, int).

它接收两个都为 int 类型的参数. 那么它的返回类型是什么呢?
记住我们当时是怎么声明函数类型的?把 ptr(int, int) 看作一个整体,
它被声明的类型, 就是它的返回类型. 我们用 c 代表它的话:

```cpp
int(*((*c)))(int);
```

可以看到, 有两对多余的括号, 我们来删减它:

```cpp
int(**c)(int);
```

c 是一个指向`[函数指针]`的指针(二重指针), 这次我们不想一步一步写了, 就脑补吧.
这个`[函数指针]`指向的函数接收一个 int 类型的参数, 返回一个 int 类型的结果.

综上所述, ptr 是一个函数, 这个函数接收两个类型为 int 的参数,
 返回一个指向`[函数指针]`的指针, 第二个函数接收一个类型为 int 的参数, 返回一个 int 类型的结果.

这对吗?我们不妨用代码来确证, 如果按照这样的思路写出的代码能编译, 我们就对了:

```cpp
int unary(int a) {
 return a + 1;
}

int (*p_unary)(int a) = unary;

int(*((*ptr(int a, int b))))(int) {
 return &p_unary;
}
```

编译通过, 大功告成!

### 牢骚

C 语言的类型声明, 带来了许多像这样的麻烦.
诸如 `Scala` 和 `TypeScript` 之类的一部分现代语言, 选择了后置类型声明,
比如 `a : int = 3`(示意, 不是这两种语言的代码)代替了 `int a = 3`,
而 `char func(int a, double b)` 则被 `func (a: int, b: double) -> char` 代替.
一个返回函数的函数, 可能可以写作 `d_func(a: int) -> (func(b: int) -> int)`.

当然 C 语言里不可以这么做, 函数是不可以返回的.
只能返回函数指针, 比如 `int (*(d_func(int a)))(int b)`

其实后置的好处倒没有那么主要, 虽然向右的箭头更符合大多数人的阅读习惯,
毕竟前置可以看成是后置的完全对偶. C 语言的麻烦在于两个:

一个是, 虽然左右可以完全对偶, 但是 C 语言的参数列表在右边,
类型却在左边, 参数的类型, 它们被函数名分开了, 无法建立箭头那么直观的认识.
如果参数列表前置倒也好: `int <- (int b) (*( <- (int a) d_func))`.
虽然从右向左有些不习惯, 但是是不是好像有些感觉了?

另一个是, 数组的声明, 元素类型在左边, 长度却在右边.
这其实跟第一个麻烦是一回事,
所以很多语言引入了形如 `int[5] a` 的语法, `[5]` 直接修饰 `int`,
看起来就要直观得多, 比如 `int (*a[9])[5] 就变成了 ((int[5])*)[9] a`,
这样看起来毫不费力, 非常直观, 不需要任何学习.

当然很多其他语言都没有指针, 这也会让类型声明看起来更简洁.
不过这不是主要的, 因为 C 语言的指针声明, 基本还是合理的.
当然 TypeScript 还是略有繁琐, 它的类型声明必须要指出参数名, 比如:

```cpp
function map<A, B>(func: (a: A) => B, elem: A): B;
```

这无疑是增加了阅读难度, 虽然比起 C 已经很低了,
但是面对高阶函数类型, 还是显得力不从心
(C 语言根本没这个需求, 因为它不支持就地地, 嵌套地创建函数,
虽然可以有高阶函数签名, 但是根本没有实用价值.
虽然有一些 GNU 扩展, 但是手动管理内存也会让高阶函数苦不堪言).

`Scala` 虽然支持不需要对高阶函数标注参数名,
但函数本身的参数列表和类型签名还是耦合的.
而诸如 `OCaml` 之类的 `ML` 系语言, 以及深受其影响的 `Haskell`(家族, 包括 Idris, Agda 等),
采取了更激进的, 函数类型签名和函数实体完全分开的策略,
可以轻松声明复杂类型, 比如最常用的函数 `foldr` 长这样:

```cpp
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

类型之间的关系显得十分清晰明了.
这将我们带入了一个玩弄类型的世界. 不过这都是后话了.

从这点上来看, 由于声明时可以完全省略参数名,  C 语言反而显得比 Scala 和 TypeScript 先进.
可是在后续实现这个函数的时候, 还是要照抄类型,
而不能根据参数位置自动推导出(不写会被默认为 int), 不免显得有些遗憾——
然而这之中也有必然. 个中详情, 足够畅谈数日, 这里无暇叙述.

### 练习

在 [C Puzzle: Pointer Monster][] 定义各种复杂类型, 进行下标运算, 并通过测试.

### 后记

以上内容, 都是基于 C 语言标准演绎而成([C11 draft N1548][], 免费, 正式版是付费的).
作为一篇入门级的小品文, 为了阅读效果, 我选择不详述过程和原文. 水平有限, 错误之处在所难免, 欢迎读者指正.

[C Puzzle: Pointer Monster]: https://www.codewars.com/kata/c-puzzle-pointer-monster/train/c
[C11 draft N1548]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
