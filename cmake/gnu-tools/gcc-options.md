# gcc 编译选项汇总

[gcc 编译选项汇总](https://zhuanlan.zhihu.com/p/347611674)

常用编译选项
`gcc` 和 `g++` 分别是 gnu 的 `c` 和 `c++`编译器,
gcc/g++在执行编译工作的时候, 总共需要4步

1. 预处理,生成.i的文件[预处理器cpp]
2. 将预处理后的文件不转换成汇编语言,生成文件.s[编译器egcs]
3. 有汇编变为目标代码(机器代码)生成.o的文件[汇编器as]
4. 连接目标代码,生成可执行程序[链接器ld]

## gcc 命令的常用选项

选项 解释

+ `-ansi`; 只支持 ANSI 标准的 C 语法.
这一选项将禁止 GNU C 的某些特色, 例如 asm 或 typeof 关键词.
+ `-m486`; 针对 486 进行代码优化.

+ `-DMACRO`; 以字符串"1"定义 MACRO 宏.
+ `-DMACRO=DEFN`; 以字符串"DEFN"定义 MACRO 宏.
+ `-UMACRO`; 取消对 MACRO 宏的定义.

+ `-o FILE`; 生成指定的输出文件. 用在生成可执行文件时.
+ `-c`; 只编译并生成目标文件(object).

    ```bash
    gcc -c test.s -o test.o
    ```

+ `-E`; 只运行 `C预编译器`.
+ `-g`; 生成调试信息. GNU 调试器可利用该信息.

头文件/库

+ `-IDIRECTORY`; 指定额外的 `头文件搜索路径的目录`. 大写 `-I`, `Inclue`.
+ `-LDIRECTORY`; 指定额外的 `函数库搜索路径的目录`. 大写 `-L`, `Library directory`.
+ `-lLIBRARY`; 连接时搜索指定的 `函数库` `lIBRARY`. 小写 `-l`, `libraray`.

+ `-O0`; 不进行优化处理.
+ `-O`; 或 `-O1` 优化生成代码.
+ `-O2`; 进一步优化.
+ `-O3`; 比 `-O2` 更进一步优化, 包括 `inline` 函数.

+ `-shared`; 生成共享目标文件. 通常用在建立共享库时.
+ `-static`; 禁止使用共享连接.

+ `-w`; 不生成任何警告信息.
+ `-Wall`; 生成所有警告信息.

## -fPIC, -fpic

[关于-fPIC, -fpic, -fpie, -fPIE的一点理解](https://blog.csdn.net/mao_hui_fei/article/details/106810977)

## -fPIC, -fpic, -fpie, -fPIE异同

-fPIC与-fpic都是在编译时加入的选项, 用于生成位置无关的代码(Position-Independent-Code).
这两个选项都是可以使代码在加载到内存时使用相对地址, 所有对固定地址的访问都通过全局偏移表(GOT)来实现.
-fPIC和-fpic最大的区别在于是否对GOT的大小有限制.
-fPIC对GOT表大小无限制, 所以如果在不确定的情况下, 使用-fPIC是更好的选择.

-fPIE与-fpie是等价的. 这个选项与-fPIC/-fpic大致相同, 不同点在于:
-fPIC用于生成动态库, -fPIE用与生成可执行文件.
再说得直白一点: -fPIE用来生成位置无关的可执行代码.

### pic 与PIC的异同

相同点: 都是为了在动态库中生成位置无关的代码.
通过全局偏移表(GOT)访问所有常量地址. 程序启动时动态加载程序解析GOT条目.

不同点: 如果链接的可执行文件的GOT大小超过计算机特定的最大大小,
则会从链接器收到错误消息, 指示-fpic不起作用;在这种情况下,
请使用-fPIC重新编译. GOT大小根据操作系统的不同而大小不一样,
SPARC上为8k, 在AArch64上为28k, 在m68k和 RS/6000 上为32k. x86没有此限制.

### 总结

为了兼容各个系统, 在生成位置无关的代码的时候, 应该使用-fPIC参数.

## 优化选项

[Optimize Options](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)

### `-Og`

优化调试体验.
在标准的 编辑-编译-调试 循环中, `-Og` 应该是首选的优化级别,
它能提供合理的优化级别, 同时保持快速编译和良好的调试体验.
在生成可调试代码方面, 它是比 `-O0` 更好的选择,
因为在 `-O0` 时, 一些收集调试信息的 compiler passes 被禁用.

与 `-O0` 类似, `-Og` 也会完全禁用一些优化passes,
因此控制这些传递的单个选项不会产生任何影响.
否则, `-Og` 会启用所有 `-O1` 优化标志, 但可能干扰调试的flags除外:

```bash
-fbranch-count-reg  -fdelayed-branch
-fdse  -fif-conversion  -fif-conversion2
-finline-functions-called-once
-fmove-loop-invariants  -fmove-loop-stores  -fssa-phiopt
-ftree-bit-ccp  -ftree-dse  -ftree-pta  -ftree-sra
```

### `-Oz`

积极优化 大小 而非 速度.
如果指令编码所需的字节数较少, 这可能会增加执行指令的数量.
`-Oz` 的行为与 `-Os` 类似, 包括启用大多数 `-O2` 优化.

### 总结

如果使用多个 `-O` 选项, 无论是否有level numbers,
最后一个选项都有效.

格式为 `-fflag` 的选项指定了与机器无关的标志.
大多数标志都有正反两种形式, `-ffoo` 的反面形式是 `-fno-foo`.
在下表中, 只列出了其中一种形式--你通常使用的形式.
你可以通过删除 `no-` 或添加 `no-` 来得到另一种形式.

以下选项控制特定的优化.
它们要么由 `-O` 选项激活, 要么与激活的选项相关.
在极少数情况下, 如果需要对要执行的优化进行 `微调`, 可以使用以下标记.

## Debug option 3.10 调试程序的选项

几乎在所有情况下, 您只需在其他选项中添加 `-g` 选项,
即可让 GCC 输出额外信息供调试器使用.
某些调试格式可以同时存在(如 `DWARF` 和 `CTF`),
只要在其他选项中添加相应的命令行选项, 就可以明确启用每一种调试格式.

GCC 允许将 `-g` 与 `-O` 一起使用.
优化后的代码所采取的快捷方式有时可能会出人意料:
你声明的一些变量可能根本不存在;控制流可能会短暂地移动到你意想不到的地方;
一些语句可能不会被执行, 因为它们计算的是常量结果, 或者它们的值已经在手;
一些语句可能会在不同的地方执行, 因为它们被移出了循环.
尽管如此, 还是可以调试优化后的输出.
因此, 在可能存在错误的程序中使用优化器是合理的.

如果不使用其他优化选项,
可以考虑使用 `-Og`(参见控制优化的选项)和 `-g`. 即

```bash
gcc  -o test test.c -Og -g
```

如果完全不使用 `-O` 选项, 一些收集调试信息的编译器传递就根本不会运行,
因此 `-Og` 可能会带来更好的调试体验.

### `-g`

以操作系统的本地格式(`stabs`, `COFF`, `XCOFF` 或 `DWARF`)生成调试信息.
`GDB` 可以使用这些调试信息.

在大多数使用 `stabs` 格式的系统上,
`-g` 可以启用只有 `GDB` 才能使用的额外调试信息;
这些额外信息可以使 GDB 的调试工作做得更好,
但可能会使其他调试器崩溃或拒绝读取程序.
如果要确定是否生成额外信息, 请使用 `-gvms`(见下文).

### `-ggdb`

生成供 GDB 使用的调试信息.
这意味着要使用现有的最具表现力的格式
(DWARF, stabs; 如果这两种格式都不支持的话, 就使用本地格式),
包括 GDB 扩展(如果可能的话).

### -fno-eliminate-unused-debug-symbols

默认情况下, 不会为实际未使用的符号生成调试信息.
如果需要所有符号的调试信息, 请使用此选项.

### -femit-class-debug-always

一个 C++ 类的调试信息不会只在一个 object文件中显示,
而是会在所有使用该类的 object文件中显示.
该选项仅适用于某些 debuggers, 它们无法处理GCC通常为类生成调试信息的方式的,
因为使用该选项 会使调试信息的大小增加 两倍之多.
