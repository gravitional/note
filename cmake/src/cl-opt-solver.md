# clang 选项 solver

## `/D`

+ `/wd4819`
https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4819

编译器警告(等级 1)C4819
该文件包含不能在当前代码页(数字)中表示的字符.  以 Unicode 格式保存该文件防止数据丢失.

在不能表示文件中所有字符的代码页的系统上编译 ANSI 源文件时, 出现 C4819.

有多种方法可解决此问题.
一个简单的方法是删除冒犯字符, 如果不需要该字符, 比如它在批注中.
可以将"控制面板"中的系统代码页设置为支持源代码使用的字符集.
可以使用 Unicode 转义序列创建仅使用源代码中基本 ANSI 字符集的字符或字符串.
最后, 可以使用签名以 Unicode 格式保存文件, 也称为字节顺序标记 (BOM).

若要以 Unicode 格式保存文件, 请在 Visual Studio 中, 选择 "文件">"另存为".
在"将文件另存为"对话框中, 选择"保存"按钮旁的下拉菜单, 然后选择"保存时使用编码".
如果保存到同一文件名, 可能需要确认要替换该文件.
在"高级保存选项"对话框中, 选择可表示该文件中所有字符的编码
例如, Unicode(带签名的 UTF-8)- Codepage 65001, 然后选择"确定".

+ `/D_DEBUG`
[processor-definitions]https://learn.microsoft.com/en-us/cpp/build/reference/d-preprocessor-definitions?view=msvc-170

定义源文件的预处理符号.

语法

```cmd
/D[ ]name[= | # [{ string | number }] ]" /D[ ]"name[= | # [{ string | number }] ]
/D[ ]"name[= | # [{ string | number }] ]"
```

备注
可以将此符号与 #if 或 #ifdef 一起使用, 有条件地编译源代码.
符号定义一直有效, 直到在代码中重新定义或被 `#undef` 指令解除定义.

`/D` 与源代码文件开头的 #define 指令效果相同.
不同之处在于, /D 会在命令行中删除引号, 而 #define 指令会保留引号.
`/D` 和符号之间可以有空白. 符号和等号之间, 或等号和任何赋值之间不能有空白.

默认情况下, 与符号相关的值为 1, 例如, `/D name` 相当于 `/D name=1`.
在本文末尾的示例中, TEST 的定义显示为打印 1.

使用 /D name= 进行编译会导致符号名称没有相关值.
虽然该符号仍可用于有条件地编译代码, 但在其他情况下, 它的值为零.
在示例中, 如果使用 /DTEST= 进行编译, 就会出现错误. 这种行为类似于使用 #define 的情况, 无论是否带值.

`/D` 选项不支持类似函数的宏定义. 要插入无法在命令行中定义的定义, 可以考虑使用 /FI(强制包含文件名)编译器选项.
可以在命令行中多次使用 /D 来定义更多符号. 如果同一符号被定义多次, 则使用最后一次定义.
此命令定义了 TEST.c 中的符号 DEBUG:

```cmd
cl /ddebug test.c
```

此命令将删除 TEST.c 中所有出现的关键字 `__far`:

```cmd
CL /D __far= TEST.C
```

CL 环境变量不能设置为包含等号的字符串.
要将 /D 与 CL 环境变量一起使用, 必须指定数字符号 (#) 而不是等号:

```cmd
SET CL=/DTEST#0
```

在命令提示符下定义预处理符号时, 要同时考虑编译器解析规则和 shell 解析规则.
例如, 要在程序中定义百分号预处理符号 (%), 请在命令提示符下指定两个百分号字符 (%%).
如果只指定一个, 则会出现解析错误.

```cmd
CL /DTEST=%% TEST.C
```

### 要在 Visual Studio 开发环境中设置此编译器选项

打开 "项目属性页 "对话框. 有关详细信息,
请参阅在 Visual Studio 中设置 C++ 编译器和构建属性.

选择配置属性 > C/C++ > 预处理器属性页.
打开预处理器定义属性的下拉菜单并选择编辑.
在 "预处理器定义 "对话框中, 添加, 修改或删除一个或多个定义, 每行一个.
选择 "确定 "保存更改.

在此指定的定义无需包含"/D "选项前缀. 在属性页面中, 定义之间用分号 (;) 分隔.

以编程方式设置编译器选项, 请参阅 PreprocessorDefinitions.

### 示例

```C++
// cpp_D_compiler_option.cpp
// 编译时使用:  cl /EHsc /DTEST cpp_D_compiler_option.cpp
#include <stdio.h>

int main( )
{
#ifdef TEST
    printf_s("TEST defined %d\n", TEST);
#else
    printf_s("TEST not defined\n");
#endif
}
```

输出

```
TEST defined 1
```

## /Zi,/ZI

[/Z7, /Zi, /ZI(调试信息格式)](https://learn.microsoft.com/en-us/cpp/build/reference/z7-zi-zi-debug-information-format?view=msvc-170)

Z7, /Zi 和 /ZI 编译器选项指定为程序创建的调试信息的类型,
以及这些信息是保存在对象文件中还是保存在程序数据库 (PDB) 文件中.

语法
/Z7
/Zi
/ZI

### 备注

指定调试选项后, 编译器会生成函数和变量的符号名称, 类型信息和行位置, 供调试器使用.
这些符号调试信息可以包含在编译器生成的对象文件(.obj 文件)中, 也可以包含在可执行文件的单独 PDB 文件(.pdb 文件)中.
调试信息格式选项将在以下章节中介绍.

### None

默认情况下, 如果未指定调试信息格式选项, 编译器不会生成调试信息, 因此编译速度更快.

### `/Z7`

/Z7 选项生成的对象文件也包含完整的符号调试信息, 可与调试器一起使用.
这些对象文件和由其构建的任何库可能比没有调试信息的文件大得多.
符号调试信息包括变量, 函数和行号的名称和类型. 编译器不会生成 PDB 文件.
不过, 如果链接器通过 `/DEBUG` 选项, 仍可从这些对象文件或库生成 PDB 文件.

对于第三方库调试版本的发布者来说, 没有 PDB 文件是有好处的.
不过, 任何预编译头文件的对象文件在库链接阶段和调试时都是必要的.
如果 .pch 对象文件中只有类型信息(没有代码),
则还必须使用 /Yl(为调试库注入 PCH 参考)选项, 该选项在构建库时默认已启用.

指定 `/Z7` 时, 已过时的 `/Gm`(启用最小重建)选项不可用.

### `/Zi`

/Zi 选项会生成一个单独的 `PDB` 文件, 其中包含调试器使用的所有符号调试信息.
调试信息不包含在目标文件或可执行文件中, 因此它们的体积要小得多.

使用 `/Zi` 不会影响优化. 不过, `/Zi` 意味着 `/debug`. 更多信息, 请参阅 /DEBUG(生成调试信息).

同时指定 /Zi 和 /clr 时, DebuggableAttribute 属性不会放在程序集元数据中.
如果需要, 必须在源代码中指定. 该属性会影响应用程序的运行性能. 有关 Debuggable 属性如何影响性能以及如何修改性能影响的详细信息, 请参阅使图像更易于调试.

编译器会将 PDB 文件命名为 <project>.pdb, 其中 <project> 是项目的名称.
如果在项目之外编译文件, 编译器会创建一个名为 VC<x>.pdb 的 PDB 文件, 其中 <x> 是所用编译器版本的主版本号和次版本号的连接.
编译器会在使用该选项创建的每个对象文件中嵌入 PDB 名称和带有时间戳的识别签名.
该名称和签名将调试器指向符号和行号信息的位置.
PDB 文件中的名称和签名必须与可执行文件一致, 符号才能加载到调试器中.
WinDBG 调试器可以使用 .symopt+0x40 命令加载不匹配的符号. Visual Studio 没有类似的选项来加载不匹配的符号.

如果使用 /Zi 编译的对象创建一个库, 那么当库链接到程序时, 相关的 PDB 文件必须可用.
也就是说, 如果要分发程序库, 也必须同时分发 PDB 文件. 要创建包含调试信息的库而不使用 PDB 文件, 必须选择 /Z7 选项.
如果使用预编译头文件选项, 预编译头文件和其他源代码的调试信息都会放在 PDB 文件中.

### `/ZI`

`/ZI` 选项与 `/Zi` 类似, 但它生成的 PDB 文件格式支持编辑和继续功能. 要使用编辑和继续调试功能, 必须使用该选项.
`编辑和继续` 功能对提高开发人员的工作效率很有用, 但可能会导致代码大小, 性能和编译器一致性方面的问题.
由于大多数优化与编辑和继续功能不兼容, 因此使用 /ZI 会禁用代码中的任何 #pragma 优化语句.
/ZI 选项还与 `__LINE__` 预定义宏的使用不兼容;
使用 /ZI 编译的代码不能使用 `__LINE__` 作为非类型模板参数, 尽管 `__LINE__` 可以在宏扩展中使用.

`/ZI` 选项强制在编译时使用 /Gy(启用函数级链接)和 /FC(诊断中源代码文件的完整路径)选项.

`/ZI` 与 `/clr`(通用语言运行时编译)不兼容.

## /Oi

[/Oi(生成内在函数)](https://learn.microsoft.com/en-us/cpp/build/reference/oi-generate-intrinsic-functions?view=msvc-170)

用函数的 固有形式(intrinsic) 或其他特殊形式替换某些函数调用, 以帮助应用程序更快地运行.

语法; `/Oi[-]`
备注 使用固有函数的程序速度更快, 因为它们没有函数调用的开销, 但由于创建了额外的代码, 程序可能会更大.

有关哪些函数具有固有形式的更多信息, 请参阅 intrinsic.

/Oi 只是请求编译器使用本征函数替换某些函数调用;如果这样做能提高性能, 编译器可能会调用函数(而不是使用本征函数替换函数调用).

### x86 专用

本征浮点函数不对输入值进行任何特殊检查, 因此只能在受限的输入范围内工作, 而且其异常处理和边界条件与同名库例程不同.
使用真正的固有形式意味着失去 IEEE 异常处理, 失去 _matherrr 和 errno 功能;后者意味着失去 ANSI 一致性.
不过, 本征形式可以大大加快浮点密集型程序的运行速度, 对于许多程序来说, 一致性问题的实际价值不大.

你可以使用 Za 编译器选项来覆盖生成真正的内在浮点选项.
在这种情况下, 函数将作为库例程生成, 直接将参数传递给浮点芯片, 而不是将其推入程序堆栈.

### ENDx86专用

您还可以使用 intrinsic 创建内在函数, 或使用 function(C/C++)显式强制调用函数.

要在 Visual Studio 开发环境中设置此编译器选项
打开项目的属性页对话框. 有关详情, 请参阅在 Visual Studio 中设置 C++ 编译器和构建属性.
选择配置属性 > C/C++ > 优化属性页.
修改 Enable Intrinsic Functions 属性.

## /Os, /Ot

[/Os, /Ot(赞成小编码, 赞成快编码)](https://learn.microsoft.com/en-us/cpp/build/reference/os-ot-favor-small-code-favor-fast-code?view=msvc-170)

编译器选项 /Os 和 /Ot 可指定在优化代码时是偏重大小 (/Os) 还是速度 (/Ot).

语法
/Os
/Ot

备注
/Os(偏重小代码)通过指示编译器偏重代码大小而非速度, 最大限度地减小 EXE 和 DLL 的大小.
编译器可将许多 C 和 C++ 结构缩减为功能相似的机器代码序列.
有时, 这些差异会在大小与速度之间产生权衡. 通过 /Os 和 /Ot 选项, 您可以指定偏好其中之一:

/Ot(偏好快速代码)通过指示编译器偏好速度而非大小, 最大限度地提高 EXE 和 DLL 的速度.
启用优化时, /Ot 是默认设置. 编译器可以将许多 C 和 C++ 结构缩减为功能相似的机器代码序列.
有时, 这些差异会带来大小与速度的权衡. /Ot选项由/O2(速度最大化)选项隐含. /O2 选项结合了多个选项以产生更快的代码.

注意事项

如果指定了 /Ob, /Os 或 /Ot, 从剖析测试运行中收集到的信息会覆盖任何优化. 更多信息, 请参阅配置文件引导的优化.

### 特定于 x86 的示例

以下示例代码演示了 /Os(支持小代码)选项和 /Ot(支持快速代码)选项之间的区别:

>注意
本示例描述了使用 /Os 或 /Ot 时的预期行为. 不过, 不同版本的编译器行为可能会导致下面代码的优化结果不同.

```C
/* differ.c
  该程序实现了一个乘法运算符
  使用 /Os 进行编译, 以乘法运算器的形式明确实现乘法运算.
  用 /Ot 编译, 以一系列移位和 LEA 指令实现.
*/
int differ(int x)
{
    return x * 71;
}
```

如下面的机器代码片段所示, 当 differ.c 被编译为 size (/Os) 时,
编译器会将返回语句中的乘法表达式明确地作为乘法来实现, 从而产生一个简短但较慢的代码序列:

```asm
mov    eax, DWORD PTR _x$[ebp]
imul   eax, 71                  ; 00000047H
```

另外, 在对 differ.c 进行快速编译 (/Ot) 时,
编译器会将返回语句中的乘法表达式作为一系列移位和 `LEA` 指令来执行,
从而生成较长但速度较快的代码序列:

```asm
mov    eax, DWORD PTR _x$[ebp]
mov    ecx, eax
shl    eax, 3
lea    eax, DWORD PTR [eax+eax*8]
sub    eax, ecx
```

要在 Visual Studio 开发环境中设置该编译器选项
打开项目的 "属性页 "对话框. 有关详细信息, 请参阅在 Visual Studio 中设置 C++ 编译器和构建属性.

选择配置属性 > C/C++ > 优化属性页.
修改 Favor Size 或 Speed 属性.

以编程方式设置该编译器选项, 请参阅 FavorSizeOrSpeed.

## /GL

[/GL(整个程序优化)](https://learn.microsoft.com/en-us/cpp/build/reference/gl-whole-program-optimization?view=msvc-170)

语法
/GL[-]

备注
整个程序优化允许编译器利用程序中所有模块的信息执行优化.
如果不使用整个程序优化, 则按模块(compiland)进行优化.

整个程序优化默认为 `关闭`, 必须显式启用. 不过, 也可以使用 /GL- 明确禁用.

有了所有模块的信息, 编译器就可以

+ 优化 `跨函数边界` 寄存器 register 的使用.
+ 更好地跟踪对全局数据的修改, 从而减少加载和存储的次数.
+ 跟踪 `指针解引用` 可能修改的项目集, 从而减少所需的加载和存储.
+ 在`模块`中内联`函数`, 即使该函数是在另一个模块中定义的.

使用 /GL 生成的 .obj 文件不能被 EDITBIN 和 DUMPBIN 等链接器工具使用.
如果使用 /GL 和 /c 编译程序, 则应使用 /LTCG 连接器选项来创建输出文件.
/ZI 不能与 /GL 一起使用

当前版本中使用 /GL 生成的文件格式通常无法被后续版本的 Visual Studio 和 MSVC 工具集读取. 除非您愿意为您希望用户现在和将来使用的所有 Visual Studio 版本提供 .lib 文件的副本, 否则不要提供由 /GL 生成的 .obj 文件组成的 .lib 文件. 有关详细信息, 请参阅二进制兼容性限制.

由 /GL 生成的 .obj 文件和预编译头文件不应被用于构建 .lib 文件, 除非 .lib 文件是在生成 /GL .obj 文件的同一台机器上链接的. 链接时需要 .obj 文件预编译头文件中的信息.

有关整个程序优化的可用优化和限制的更多信息, 请参阅 /LTCG. /GL 还提供配置文件引导优化. 在编译配置文件引导优化时, 如果希望从配置文件引导优化中获得函数排序, 则必须使用 /Gy 或暗示 /Gy 的编译器选项进行编译.

在 Visual Studio 开发环境中设置此链接器选项
有关如何在开发环境中指定 /GL 的详细信息, 请参阅 /LTCG(链接时代码生成).

## /LTCG

[/LTCG (Link-time code generation)](https://learn.microsoft.com/en-us/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170)

另请参见
使用 `/LTCG` 执行全程序优化, (whole-program optimization)
或创建配置文件引导的优化 (PGO) 工具, 执行训练并创建配置文件引导的优化构建.

语法

```cmd
/ltcg[:{incremental|nostatus|status|off}]
```

从 Visual Studio 2015 开始, 这些选项已被弃用:

```cmd
/ltcg:{pginstrument|pgoptimize|pgupdate}.
```

### 参数

+ `INCREMENTAL`
(可选)指定链接器仅对受编辑影响的文件而非整个项目应用整个程序优化或链接时代码生成(LTCG).
默认情况下, 当指定 /LTCG 时, 该标志不会被设置, 整个项目将通过整个程序优化进行链接.

+ `NOSTATUS | STATUS`
(可选)指定链接器是否显示进度指示器, 以显示链接完成的百分比. 默认情况下, 不显示此状态信息.

+ `OFF`
(可选)禁用链接时代码生成.
链接器将使用 /GL 编译的所有模块视为未使用该选项编译的模块, 任何 MSIL 模块都会导致链接失败.

+ `PGINSTRUMENT`
(可选)从 Visual Studio 2015 开始, 该选项已被弃用. 取而代之的是使用 /LTCG 和 /GENPROFILE 或 /FASTGENPROFILE 生成仪器化构建, 以进行配置文件引导的优化. 从仪器运行中收集的数据将用于创建优化映像. 更多信息, 请参阅曲线引导优化. 该选项的简写为 /LTCG:PGI.

+ `PGOPTIMIZE`
(可选)从 Visual Studio 2015 开始, 该选项已被弃用. 请使用 /LTCG 和 /USEPROFILE 构建优化的映像. 更多信息, 请参阅 "配置文件引导的优化". 该选项的简称是 /LTCG:PGO.

+ `PGUPDATE`
(可选)从 Visual Studio 2015 开始, 该选项已被弃用. 取而代之的是使用 /LTCG 和 /USEPROFILE 来重建优化后的映像. 更多信息, 请参阅 "配置文件引导的优化". 该选项的简写为 /LTCG:PGU.

备注
/LTCG 选项告诉链接器调用编译器并执行全程序优化. 您也可以执行配置文件引导优化. 更多信息, 请参阅 "配置文件引导优化".

除了以下例外情况, 您不能在 /LTCG 和 /USEPROFILE 的 PGO 组合中添加链接器选项,
这些选项在之前的 /LTCG 和 /GENPROFILE 选项的 PGO 初始化组合中没有指定:

/BASE
/FIXED
/LTCG
/MAP
/MAPINFO
/NOLOGO
/OUT
/PGD
/PDB
/PDBSTRIPPED
/STUB
/VERBOSE

在使用 /LTCG 和 /USEPROFILE 构建 PGO 时,
不必指定与用于初始化 PGO 的 /LTCG 和 /GENPROFILE 选项一起指定的链接器选项;它们是隐含的.

本文其余部分将讨论 `/LTCG` 所完成的链接时代码生成.

`/LTCG` 是与 `/GL` 一起隐含的.

如果链接器通过一个使用 /GL 或 MSIL 模块编译的模块(请参阅作为链接器输入的 .netmodule 文件),
就会调用链接时代码生成. 如果在向链接器传递 /GL 或 MSIL 模块时没有明确指定 /LTCG,
链接器最终会检测到这种情况, 并使用 /LTCG 重新启动链接.
将 /GL 和 MSIL 模块传递给链接器时, 请明确指定 /LTCG, 以获得最快的编译性能.

要获得更快的性能, 请使用 `/LTCG:INCREMENTAL`.
该选项会告诉链接器只重新优化受源文件更改影响的文件, 而不是整个项目.
该选项可以大大减少所需的链接时间. 该选项与 `incremental linking` 并不相同.
如果移除 /LTCG:INCREMENTAL 选项, 也请移除任何 /LTCGOUT 选项, 以改善联编时间和磁盘利用率.

`/LTCG` 与 /INCREMENTAL 搭配使用无效.

当 /LTCG 用于链接使用 /Og, /O1, /O2 或 /Ox 编译的模块时, 将执行以下优化:

跨模块内联
程序间寄存器分配(仅限 64 位操作系统)
自定义调用约定(仅限 x86)
小 TLS 移位(仅限 x86)
堆栈双重对齐(仅限 x86)
改进的内存消歧功能(为全局变量和输入参数提供更好的干扰信息)

备注
链接器会确定编译每个函数时使用了哪些优化, 并在链接时应用相同的优化.

使用 /LTCG 和 /O2 会导致双重对齐优化.

如果指定了 /LTCG 和 /O1, 则不会执行双重对齐. 如果应用程序中的大部分函数都是为速度编译的, 只有少数函数是为大小编译的(例如, 通过使用 optimize pragma), 那么编译器会对为大小优化的函数进行双重对齐, 如果这些函数调用了需要双重对齐的函数.

如果编译器能识别函数的所有调用点, 编译器就会忽略显式调用约定修改器, 并尝试优化函数的调用约定:

在寄存器中传递参数
重新排列参数对齐方式
删除未使用的参数
如果函数是通过函数指针调用的, 或者函数是从使用 /GL 编译的模块外部调用的, 编译器不会尝试优化函数的调用约定.

注意

如果使用 /LTCG 并重新定义 mainCRTStartup, 应用程序可能会出现无法预测的行为, 这些行为与全局对象初始化前执行的用户代码有关. 有三种方法可以解决这个问题: 不要重新定义 mainCRTStartup, 不要使用 /LTCG 编译包含 mainCRTStartup 的文件, 或者静态初始化全局变量和对象.

### /LTCG 和 MSIL 模块

使用 /GL 和 /clr 编译的模块在指定 /LTCG 时可用作链接器的输入.

/LTCG 可以接受本地对象文件和本地/托管混合对象文件(使用 /clr 编译). /clr:pure 和 /clr:safe 编译器选项在 Visual Studio 2015 中已被弃用, 在 Visual Studio 2017 及更高版本中也不支持.

/LTCG:PGI不接受使用/GL和/clr编译的本地模块

### 要在 Visual Studio 开发环境中设置该编译器选项

`Whole Program Optimization` 属性设置了多个编译器和链接器选项, 包括 `/LTCG`.
我们建议您使用该属性来更改整个构建配置的设置. 为项目设置整个程序优化:

打开 "项目属性页 "对话框. 更多信息, 请参阅设置编译器和构建属性.

选择 "配置属性">"常规 "属性页.
修改 "整个程序优化 "属性. 选择 "确定 "或 "应用 "保存更改.
您还可以在菜单栏上选择 "构建">"配置文件引导的优化",
或在项目的快捷菜单上选择配置文件引导的优化选项之一, 将 /LTCG 应用于特定的构建.

单独启用链接时间代码生成或设置特定的链接时间代码生成选项:

打开项目属性页对话框.
选择 "配置属性">"链接器">"优化 "属性页.
将链接时间代码生成属性修改为以下选项之一:

默认
使用快速链接时间码生成 (LTCG:incremental)
使用链接时间码生成 (LTCG)
配置文件引导优化 - 仪器 (LTCG:PGInstrument)
配置文件引导的优化 - 优化 (LTCG:PGOptimize)
配置文件引导的优化 - 更新 (LTCG:PGUpdate)
选择 "确定 "或 "应用 "保存更改.

指定链接器是否显示链接时间代码生成的进度指示器:

Open the project Property Pages dialog box.
Select the Configuration Properties > Linker > General property page.
Modify the Link Status property. Choose OK or Apply to save your changes.

To set this compiler option programmatically
See LinkTimeCodeGeneration.

## `/fp`

[/fp(指定浮点行为)](https://learn.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170)

指定编译器如何处理浮点表达式, 优化和异常.
/fp 选项指定生成的代码是否允许浮点环境更改舍入模式, 异常掩码和次正常行为, 以及浮点状态检查是否返回当前的准确结果.
它控制编译器生成的代码是否保持源操作和表达式顺序, 是否符合 NaN 传播标准.
或者, 编译器会生成更高效的代码,
这些代码可能会重新排序或组合操作, 并使用 IEEE-754 标准不允许的简化代数变换.

语法
/fp:contract
/fp:except[-]
/fp:fast
/fp:precise
/fp:strict

### 参数

`/fp:contract`
当指定 /fp:precise 和 /fp:except 选项时, /fp:contract 选项允许编译器生成浮点收缩. 收缩指令是一种结合浮点运算的机器指令, 例如融合乘加(FMA). FMA 被 IEEE-754 定义为基本运算, 在进行加法运算之前不会对中间积进行舍入, 因此运算结果可能与单独的乘法运算和加法运算不同. 由于它是作为一条指令实现的, 因此比单独的指令更快. 但这种速度的代价是, 运算结果不能精确到位, 而且无法检查中间值.

默认情况下, /fp:fast 选项启用 /fp:contract. /fp:contract选项与/fp:strict不兼容.

/fp:contract 选项是 Visual Studio 2022 中新增的选项.

`/fp:precise`
默认情况下, 编译器使用 /fp:precise 行为.

在 /fp:precise 下, 编译器在为目标机器生成和优化目标代码时, 会保留浮点代码的源表达式排序和四舍五入属性. 在表达式求值过程中, 编译器会在四个特定点将四舍五入到源代码精度: 赋值, 类型转换, 浮点参数传递给函数调用以及函数调用返回浮点值. 中间计算可按机器精度进行. 类型转换可用于显式舍入中间计算.

编译器不会对浮点表达式执行代数变换, 如重新关联或分配, 除非它能保证变换产生的结果是位相同的. 涉及特殊值(NaN, +无穷大, -无穷大, -0.0)的表达式将根据 IEEE-754 规范进行处理. 例如, 如果 x 为 NaN, 则 x != x 的运算结果为 true. 在 /fp:precise 下默认不生成浮点收缩. 这种行为是 Visual Studio 2022 的新特性. 以前的编译器版本可在 /fp:precise 下默认生成缩位.

编译器生成的代码将在默认浮点运算环境中运行. 它还假定浮点环境在运行时不会被访问或修改. 也就是说, 它假定代码: 不屏蔽浮点异常, 不读写浮点状态寄存器, 不改变舍入模式.

如果你的浮点运算代码不依赖于浮点运算语句中的运算顺序和表达式(例如, 如果你不关心 a * b + a * c 是否计算为 (b + c) * a 或 2 * a 是否计算为 a + a), 请考虑使用 /fp:fast选项, 它可以产生更快, 更高效的代码. 如果你的代码既依赖于运算顺序和表达式, 又访问或改变浮点环境(例如, 改变舍入模式或捕获浮点异常), 请使用 /fp:strict.

`/fp:strict`
/fp:strict 的行为与 /fp:precise 类似, 即编译器在为目标机器生成和优化目标代码时, 会保留浮点代码的源排序和舍入属性, 并在处理特殊值时遵守标准. 程序还可以在运行时安全地访问或修改浮点运算环境.

在 /fp:strict 下, 编译器生成的代码允许程序安全地解除浮点异常屏蔽, 读取或写入浮点状态寄存器或更改舍入模式. 在表达式求值过程中, 编译器会在四个特定点将四舍五入到源代码精度: 赋值, 类型转换, 浮点参数传递给函数调用以及函数调用返回浮点值. 中间计算可按机器精度进行. 类型转换可用于显式舍入中间计算. 编译器不会对浮点表达式进行任何代数变换, 如重新关联或分配, 除非它能保证变换产生的结果是位相同的. 涉及特殊值(NaN, +无穷大, -无穷大, -0.0)的表达式将根据 IEEE-754 规范进行处理. 例如, 如果 x 为 NaN, 则 x != x 的运算结果为 true. 浮点收缩不会在 /fp:strict 下生成.

/fp:strict在计算上比/fp:precise更昂贵, 因为编译器必须插入额外的指令来捕获异常, 并允许程序在运行时访问或修改浮点环境. 如果您的代码不使用这种功能, 但需要源代码排序和舍入, 或依赖于特殊值, 请使用 /fp:precise. 否则, 请考虑使用 /fp:fast, 它可以生成更快, 更小的代码.

`/fp:fast`
/fp:fast 选项允许编译器重新排列, 组合或简化浮点运算, 以优化浮点代码的速度和空间. 编译器可以省略赋值语句, 类型转换或函数调用中的四舍五入. 编译器还可以对操作重新排序或进行代数变换, 例如使用关联法和分配法. 即使这种变换会导致明显不同的舍入行为, 它也可以对代码重新排序. 由于这种增强的优化, 某些浮点运算的结果可能与其他 /fp 选项产生的结果不同. 特殊值(NaN, +无穷大, -无穷大, -0.0)可能不会传播, 也不会严格按照 IEEE-754 标准执行. 在 /fp:fast 下可以生成浮点收缩. 在 /fp:fast 下, 编译器仍受底层架构的约束, 使用 /arch 选项可能会获得更多优化.

在 /fp:fast 下, 编译器生成的代码将在默认浮点运算环境中运行, 并假定运行时不会访问或修改浮点运算环境. 也就是说, 它假定代码: 保持浮点异常屏蔽, 不读写浮点状态寄存器, 不改变舍入模式.

/fp:fast 适用于不需要严格的源代码排序和浮点表达式舍入, 也不依赖于处理 NaN 等特殊值的标准规则的程序. 如果您的浮点运算代码要求保留源代码排序和四舍五入, 或依赖特殊值的标准行为, 请使用 /fp:recise. 如果您的代码访问或修改浮点环境, 以改变舍入模式, 解除浮点异常屏蔽或检查浮点状态, 请使用 /fp:strict.

`/fp:except`
/fp:except选项生成代码, 以确保任何未屏蔽的浮点异常都会在发生时准确触发, 并且不会触发其他浮点异常. 默认情况下, /fp:strict 选项启用 /fp:except, 而 /fp:precise 选项不启用. /fp:except选项与/fp:fast不兼容. 可以使用 /fp:except- 明确禁用该选项.

就其本身而言, /fp:except 并不能启用任何浮点异常. 不过, 程序需要使用它来启用浮点异常. 有关如何启用浮点运算异常的更多信息, 请参阅 _controlfp.

>备注
在同一编译器命令行中可以指定多个 /fp 选项. 每次只能使用 /fp:strict, /fp:fast 和 /fp:precise 选项中的一个. 如果在命令行中指定了一个以上的选项, 则后一个选项优先, 编译器会发出警告. /fp:strict 和 /fp:except 选项与 /clr 不兼容.

`/Za`(ANSI 兼容)选项与 `/fp` 不兼容.

### 使用编译器指令控制浮点行为

编译器提供了三个 pragma directives 来覆盖命令行中指定的浮点行为:
float_control, fenv_access 和 fp_contract.
您可以使用这些指令在函数级(而非函数内部)控制浮点行为.
这些指令与 /fp 选项并不直接对应. 本表显示了 /fp 选项和 pragma 指令之间的映射关系.
更多信息, 请参阅各个选项和 pragma 指令的文档.

选项 `float_control(precise, *)`, `float_control(except, *)`, `fenv_access(*)`, `fp_contract(*)`
/fp:fast    off     off     off     on
/fp:precise     on      off     off     off*
/fp:strict      on      on      on      off

>在 Visual Studio 2022 之前的 Visual Studio 版本中, /fp:precise 行为默认为 fp_contract(on).

默认浮点运算环境
进程初始化时, 会设置默认浮点运算环境. 该环境会屏蔽所有浮点运算异常,
将四舍五入模式设置为四舍五入至最近(FE_TONEAREST),
保留次正常(反常)值, 对浮点, 双倍和长双倍值使用默认的符号(尾数)精度,
并在支持的情况下将无穷大控制设置为默认的仿射模式.

## `/utf-8`

[/utf-8(将源字符集和执行字符集设置为 UTF-8)](https://learn.microsoft.com/en-us/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8)

备注
[在 Visual Studio 中或以编程方式设置选项](https://learn.microsoft.com/en-us/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8)

另请参见
[将源字符集和执行字符集都指定为 UTF-8](https://learn.microsoft.com/en-us/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8)

语法
/utf-8

备注
可以使用 /utf-8 选项指定源字符集和执行字符集, 并使用 UTF-8 编码.
这等同于在命令行中指定 `/source-charset:utf-8 /execution-charset:utf-8`.
默认情况下, 这些选项中的任何一个也会启用 /validate-charset 选项.
有关支持的代码页标识符和字符集名称列表, 请参阅代码页标识符.

默认情况下, Visual Studio 会检测字节序标记, 以确定源文件是否为 Unicode 编码格式, 例如 UTF-16 或 UTF-8.
如果找不到字节序标记, 它就会假定源文件是以当前用户代码页编码的,
除非你使用/utf-8或/source-charset选项指定了代码页.
Visual Studio 允许你以多种字符编码中的任何一种保存 C++ 源代码. 有关源代码和执行字符集的信息, 请参阅语言文档中的字符集.

在 Visual Studio 中或通过编程设置该选项
要在 Visual Studio 开发环境中设置此编译器选项
打开项目属性页对话框. 有关更多信息, 请参阅在 Visual Studio 中设置 C++ 编译器和构建属性.

选择配置属性 > C/C++ > 命令行属性页.

在 "附加选项 "中, 添加 /utf-8 选项以指定首选编码.

选择 "确定 "保存更改.

要以编程方式设置该编译器选项
请参见 AdditionalOptions.
