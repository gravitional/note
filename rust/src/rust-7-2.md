# 定义模块来控制作用域和私有性

在本节, 我们将讨论`模块`, 和模块系统的一些其他部分,

+ `路径`(paths), 允许你称呼某些项;
+ `use` 关键字, 用来将`路径`引入作用域 ;
+ `pub` 关键字, 用来使`项` 变成 `公有的`.
+ 我们还将讨论 `as` 关键字, `外部包`, 和 `glob` 运算符.

现在, 让我们把注意力放在模块上!

`modules` 可以让我们对`crate` 中的代码进行分组, 以提高 `可读性` 与`重用性`.
`模块` 还可以控制项的 `私有性`, 即决定 `项` 是否能被外部代码使用(`public`/`private`), 即是否仅作为`内部实现`.

例如, 我们写一个`library crate`, 来实现饭店的功能. 我们将定义`函数签名`, 但不填充具体的`函数体`.
这样可以集中注意力在代码的组织上, 而不是饭店代码的实现细节.

在餐饮业, 餐馆中会有一些地方被称之为 `前台`(front of house), 还有另外一些地方被称之为 `后台`(back of house).
前台是招待顾客的地方, 在这里, 店主可以为顾客安排座位, 服务员接受顾客下单和付款, 调酒师会制作饮品.
后台则由厨师工作的厨房, 洗碗工的工作地点, 以及经理做行政工作的地方组成.

为了让 `crate` 的组织结构, 与实际的餐厅结构相同, 我们把函数放到嵌套的 `module`s 中.
通过执行 `cargo new --lib restaurant`, 来创建一个新的名为 `restaurant` 的库.
然后将示例 7-1 中的代码放入 `src/lib.rs` 中, 来定义一些 `module`s 和`函数`.

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn server_order() {}

        fn take_payment() {}
    }
}
```

示例 7-1: 包含了其他内置了`函数`的`模块`的 `front_of_house` 模块

我们定义一个`module`, 以 `mod` 关键字为起始,  然后指定模块的`名字`(本例中叫做 `front_of_house`), 并且用`花括号`包围模块的`主体`.
在模块内, 我们还可以定义其他的模块, 就像本例中的 `hosting` 和 `serving` 模块.
模块还可以保存一些定义的其他项, 比如 `结构体`, `枚举`, `常量`, `特性`, 或者像上面那样, 保存`函数`.

通过使用`模块`, 我们可以将相关的定义分组到一起, 并指出他们为什么相关.
程序员可以通过使用这段代码, 更加容易地找到他们想要的定义, 因为他们可以基于`组`来浏览代码, 而不需要阅读所有的定义.
程序员向这段代码添加新的功能时, 也容易知道代码应该放置在何处, 从而保持程序的组织性.

在前面我们提到了, `src/main.rs` 和 `src/lib.rs` 叫做 `crate root`.
之所以这样叫它们, 是因为在 `crate root` 位置, 这两个文件的内容分别形成了名为 `crate` 的模块, 该结构被称为 `模块树`(module tree).

示例 7-2 展示了示例 7-1 中的模块树的结构.

```log
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

示例 7-2: 示例 7-1 中代码的模块树

这个树展示了某些`模块`是如何被嵌入到另一个模块中的(例如, `hosting` 嵌套在 `front_of_house` 中).
这个树还展示了, 一些模块是互为 `兄弟`(siblings) 的, 这意味着它们定义在同一模块中(`hosting` 和 `serving` 被一起定义在 `front_of_house` 中).
继续沿用家庭关系的比喻, 如果模块 `A` 被包含在模块 `B` 中, 我们将  `A` 称为 `B `的 `子`(child),  `B` 则是 `A` 的 `父`(parent).
注意, 整个 `模块树` 都根植于一个隐式的 `module`, 它的名称就是字面的 `crate`.

这个`模块树`可能会令你想起电脑上`文件系统`的目录树; 这是一个非常恰当的比喻!
就像文件系统的目录, 你可以使用`模块`来组织你的代码. 并且, 就像目录中的文件, 我们需要一种方法来找到模块.
