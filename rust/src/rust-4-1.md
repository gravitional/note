# 认识所有权

[Understanding Ownership](https://github.com/rust-lang/book/blob/main/src/ch04-00-understanding-ownership.md)

`所有权(系统)` 是 `Rust` 最为与众不同的特性, 它让 `Rust` 无需`垃圾回收`(garbage collector)即可保障 `内存安全`. 
因此, 理解 `Rust` 中 `所有权` 如何工作是十分重要的. 
本章, 我们将讲到所有权以及相关功能: `借用`, `slice` 以及 `Rust` 如何在 `内存` 中布局数据.

## 什么是所有权?

`Rust` 的核心功能(之一)是 `所有权`(ownership). 虽然该功能很容易解释, 但它对语言的其他部分有着深刻的影响.

所有运行的程序都必须管理其使用计算机`内存`的方式. 一些语言中具有`垃圾回收`机制, 在程序运行时不断地寻找不再使用的内存; 
在另一些语言中, 程序员必须亲自 `分配` 和 `释放` 内存. 
`Rust` 则选择了第三种方式: 通过 `所有权系统` 管理内存, 编译器在编译时会根据一系列的规则进行检查. 
在运行时, `所有权系统` 的任何功能都不会减慢程序.

因为 `所有权` 对很多程序员来说都是一个新概念, 需要一些时间来适应. 
好消息是随着你对 `Rust` 和 `所有权系统` 的规则越来越有经验, 你就越能自然地编写出安全和高效的代码. 持之以恒!

当你理解了 `所有权`, 你将有一个坚实的基础来理解那些使 `Rust` 独特的功能. 
在本章中, 你将通过完成一些示例来学习所有权, 这些示例基于一个常用的数据结构: `字符串`.

>## 栈(Stack)与堆(Heap)
>    
>在很多语言中, 你并不需要经常考虑到 `栈` 与 `堆`. 
不过在像 `Rust` 这样的系统编程语言中, 值是位于 `栈` 上还是 `堆` 上, 在更大程度上影响了语言的行为, 以及为何必须做出这样的抉择. 
我们会在本章的稍后部分描述, `所有权` 与 `栈` 和 `堆` 相关的内容, 所以这里只是一个用来预热的简要解释.
>
>`栈` 和 `堆` 都是代码在运行时可供使用的内存, 但是它们的结构不同. 
`栈`以放入值的`顺序`存储值并以 `相反顺序` 取出值. 这也被称作 `后进先出`(last in, first out). 
想象一下一叠盘子: 当增加更多盘子时, 把它们放在盘子堆的顶部, 当需要盘子时, 也从顶部拿走. 不能从中间也不能从底部增加或拿走盘子! 
增加数据叫做 `进栈`(pushing onto the stack), 而移出数据叫做 `出栈`(popping off the stack).
>
>栈中的所有数据都必须占用 `已知` 且 `固定的` 大小. 在编译时大小未知或大小可能变化的数据, 要改为存储在 `堆` 上. 
`堆` 是缺乏组织的: 当向堆放入数据时, 你要请求一定大小的空间. 
`操作系统` 在 `堆` 的某处找到一块足够大的空位, 把它标记为 `已使用`, 并返回一个表示该 `位置地址` 的 `指针`(pointer). 
这个过程称作 `在堆上分配内存`(allocating on the heap), 有时简称为 `分配`(allocating). 
将数据 `推入栈中` 并不被认为是 `分配`. 
因为指针的大小是 `已知` 并且 `固定的`, 你可以将 `指针` 存储在栈上, 不过当需要实际数据时, 必须 `访问指针`.
>
>想象一下去餐馆就座吃饭. 当进入时, 你说明有几个人, 餐馆员工会找到一个够大的空桌子并领你们过去. 
如果有人来迟了, 他们也可以通过询问来找到你们坐在哪.
>
>入栈比在堆上分配内存要快, 因为(入栈时)操作系统无需为存储新数据去 `搜索内存空间`; 其位置总是在 `栈顶`. 
相比之下, ` 在堆上分配内存` 则需要更多的工作, 这是因为操作系统必须首先找到一块足够存放数据的内存空间, 并接着 `做一些记录` 为下一次分配做准备.
>
>访问堆上的数据比访问栈上的数据慢, 因为必须通过 `指针` 来访问. 现代处理器在内存中跳转越少就越快(缓存).
继续类比, 假设有一个服务员在餐厅里处理多个桌子的点菜. 在一个桌子报完所有菜后再移动到下一个桌子是最有效率的. 
从桌子 A 听一个菜, 接着桌子 B 听一个菜, 然后再桌子 A, 然后再桌子 B 这样的流程会更加缓慢. 
出于同样原因, 处理器处理挨得近的数据(比如在 `栈上`)更容易, 相比于处理离得远的数据(比如可能在堆上). 在堆上分配大量的空间也可能消耗时间.
>
>当你的代码调用一个函数时, 传递给函数的 `值` (包括可能 `指向堆上数据` 的 `指针` )和函数的 `局部变量` 被压入栈中. 
当函数结束时, 这些值被移出栈.
>
>跟踪哪部分代码正在使用 `堆上` 的哪些数据, 最大限度的减少堆上的 `重复数据` 的数量, 
以及 `清理堆上不再使用的数据` 确保不会耗尽空间, 这些问题正是所有权系统要处理的. 
一旦理解了 `所有权`, 你就不需要经常考虑 `栈` 和 `堆` 了, 不过明白了 `所有权` 的存在就是为了管理 `堆数据`, 能够帮助解释为什么 `所有权` 要以这种方式工作.

### 所有权规则

首先, 让我们看一下所有权的规则. 当思考下面的例子时, 请谨记这些规则:

+ `Rust` 中的每一个 `值` 都对应一个`变量`, 该 `变量` 称为该 `值` 的 `所有者(owner)`.
+ `值` 在任一时刻有且只有一个 `所有者`.
+ 当 `所有者(变量)` 离开 `作用域`, 这个 `值` 将被丢弃.

### 变量作用域

我们已经在第二章完成一个 `Rust` 程序示例. 既然我们已经掌握了基本语法, 将不会在之后的例子中包含 `fn main() {` 代码, 
所以如果你是一路跟过来的, 必须手动将之后例子的代码放入一个 `main` 函数中. 
这样, 例子将显得更加简明, 使我们可以关注实际细节而不是样板代码.

在 `所有权` 的第一个例子中, 我们看看一些变量的 `作用域(scope)`. 
`作用域` 是一个 `项(item)` 在程序中有效的范围. 假设有这样一个变量:

```rust
let s = "hello";
```

变量 `s` 绑定到了一个 `字符串字面值`, 这个字符串值是硬编码进程序代码中的. 
这个变量从声明的点开始直到当前 `作用域` 结束时都是有效的. 
示例 4-1 的注释标明了变量 `s` 在何处是有效的.

```rust
{                      // s 在这里无效, 它尚未声明
    let s = "hello";   // 从此处起, s 是有效的

    // 使用 s
}                      // 此作用域已结束, s 不再有效
```

示例 4-1: 一个变量和其有效的作用域

换句话说, 这里有两个重要的时间点:

+ 当 `s 进入作用域` 时, 它就是有效的.
+ 这一直持续到它 `离开作用域` 为止.

目前为止, 变量是否有效与 `作用域` 的关系跟其他编程语言是类似的. 现在我们在此基础上介绍 `String` 类型.

### String 类型

为了演示所有权的规则, 我们需要一个比第三章 `数据类型` 中讲到的都要复杂的 `数据类型`. 
前面介绍的类型都是存储在 `栈上` 的并且当离开 `作用域` 时被移出栈, 
不过我们需要寻找一个存储在 `堆上` 的数据来探索 `Rust` 是如何知道该在何时 `清理数据`的.

这里使用 `String` 作为例子, 并专注于 `String` 与所有权相关的部分. 
这些方面也同样适用于 `标准库` 提供的或你自己创建的其他 `复杂数据类型`. 在第八章会更深入地讲解 `String`.

我们已经见过 `字符串字面值`, 即被硬编码进程序里的 `字符串值`. 
`字符串字面值` 是很方便的, 不过它们并不适合使用文本的每一种场景. 原因之一就是它们是不可变的. 
另一个原因是并非所有字符串的值都能在编写代码时就知道: 例如, 要是想获取用户输入并存储该怎么办呢? 
为此, Rust 有第二个字符串类型, `String`. 这个类型被分配到堆上, 所以能够存储在 `编译时未知大小` 的文本. 
可以使用 `from` 函数基于 `字符串字面值` 来创建 `String`, 如下:

```rust
let s = String::from("hello");
```

这两个`冒号`(::)是运算符, 允许将特定的 `from` 函数置于 `String` 类型的 `命名空间(namespace)` 下, 而不需要使用类似 `string_from` 这样的名字. 
在第五章的 `方法语法` 部分会着重讲解这个语法,
而且在第七章的 `路径用于引用模块树中的项` 中会讲到模块的 `命名空间`.

可以 修改此类字符串 :

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 在字符串后追加字面值

println!("{}", s); // 将打印 `hello, world!`
```

那么这里有什么区别呢? 为什么 `String` 可变而 `字面值` 却不行呢? 区别在于两个类型对内存的处理上.

### 内存与分配

就 `字符串字面值` 来说, 我们在编译时就知道其内容, 所以文本被直接硬编码进最终的可执行文件中. 
这使得 `字符串字面值` 快速且高效. 不过这些特性都只得益于字符串字面值的不可变性. 
不幸的是, 我们不能为了每一个在编译时大小未知的文本而将一块内存放入 `二进制文件` 中, 并且它的大小还可能随着程序运行而改变.

对于 `String` 类型, 为了支持一个可变, 可增长的文本片段, 需要在堆上分配一块在编译时未知大小的内存来存放内容. 这意味着:

+ 必须在运行时向操作系统请求内存.
+ 需要一个当我们处理完 `String` 时将内存 `返回` 给操作系统的方法.

第一部分由我们完成: 当调用 `String::from` 时, 它的 `实现` (implementation) 请求其所需的内存. 这在编程语言中是非常通用的.

然而, 第二部分实现起来就各有区别了. 
在有 `垃圾回收` (garbage collector, GC) 的语言中,  `GC` 记录并清除不再使用的内存, 而我们并不需要关心它.
没有 `GC` 的话, 识别出不再使用的内存并调用代码 `显式释放` 就是我们的责任了, 跟请求内存的时候一样. 
从历史的角度上说正确处理 `内存回收` 曾经是一个困难的编程问题. 如果忘记回收了会浪费内存. 
如果过早回收了, 将会出现 `无效变量`. 如果重复回收, 这也是个 `bug`. 
我们需要精确的为一个 `allocate` 配对一个 `free`.

`Rust` 采取了一个不同的策略: 内存在拥有它的 `变量` 离开 `作用域后` 就被 `自动释放`. 
下面是示例 4-1 中作用域例子的一个使用 `String` 而不是字符串字面值的版本:

```rust
{
    let s = String::from("hello"); // 从此处起, s 是有效的

    // 使用 s
}                                  // 此作用域已结束,
                                   // s 不再有效
```

这是一个将 `String` 需要的内存返回给操作系统的很自然的位置: 当 `s` 离开作用域的时候. 
当变量离开 `作用域`, `Rust` 为我们调用一个特殊的函数. 这个函数叫做 `drop`, 在这里 `String` 的作者可以放置释放内存的代码. 
`Rust` 在结尾的 `}` 处自动调用 `drop`.

>注意: 在 `C++` 中, 这种 `item` 在 `生命周期结束时释放资源` 的模式有时被称作 `资源获取即初始化`(Resource Acquisition Is Initialization (RAII)).
如果你使用过 `RAII` 模式的话应该对 `Rust` 的 `drop` 函数并不陌生.

这个模式对编写 `Rust` 代码的方式有着深远的影响. 现在它看起来很简单, 不过在更复杂的场景下代码的行为可能是不可预测的, 
比如当有多个变量使用在 `堆上` 分配的内存时. 现在让我们探索一些这样的场景.

### 变量与数据交互的方式(一): 移动

在 `Rust` 中, `多个变量` 可以采取不同的方式与 `同一数据` 进行交互. 让我们看看示例 4-2 中一个使用整型的例子.

```rust
let x = 5;
let y = x;
```

示例 4-2: 将变量 `x` 的整数值赋给 `y`

我们大致可以猜到这在干什么: "将 `5` 绑定到 `x`; 接着生成一个值 `x` 的拷贝并绑定到 `y`". 
现在有了两个变量, `x` 和 `y`, 都等于 `5`. 
这也正是事实上发生了的, 因为整数是有 `已知固定大小` 的简单值, 所以这两个 `5` 被放入了 `栈` 中.

现在看看这个 `String` 版本:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

这看起来与上面的代码非常类似, 所以我们可能会假设他们的运行方式也是类似的: 
也就是说, 第二行可能会生成一个 `s1` 的拷贝并绑定到 `s2` 上. 不过, 事实上并不完全是这样.

看看图 4-1 以了解 `String` 的底层会发生什么. 
`String` 由三部分组成, 如图左侧所示: 一个指向存放 `字符串内容` 的内存的 `指针`, 一个 `长度`, 和一个 `容量`. 
这一组数据存储在 `栈上`. 右侧则是堆上存放内容的内存部分.

![String in memory](https://kaisery.github.io/trpl-zh-cn/img/trpl04-01.svg)

图 4-1: 将值 `"hello"` 绑定给 `s1` 的 `String` 在内存中的表现形式

`长度` 表示 `String` 的内容当前 `使用` 了多少字节的内存. 
`容量` 是 `String` 从操作系统 `总共` 获取了多少字节的内存. 
`长度` 与 `容量` 的区别是很重要的, 不过在当前上下文中并不重要, 所以现在可以忽略 `容量`.

当我们将 `s1` 赋值给 `s2`, `String` 的数据被复制了, 这意味着我们从 `栈上` 拷贝了它的 `指针`, `长度` 和 `容量`. 
我们并没有复制指针指向的 `堆上数据`. 换句话说, 内存中数据的表现如图 4-2 所示.

![s1 and s2 pointing to the same value](https://kaisery.github.io/trpl-zh-cn/img/trpl04-02.svg)

<span class="caption"> 图 4-2: 变量 `s2` 的内存表现, 它有一份 `s1` 指针, 长度和容量的拷贝</span>

这个表现形式看起来 并不像 图 4-3 中的那样, 如果 `Rust` 也拷贝了堆上的数据, 那么内存看起来就是这样的. 
如果 `Rust` 这么做了, 那么操作 `s2 = s1` 在堆上数据比较大的时候, 会对运行时性能造成非常大的影响.

![s1 and s2 to two places](https://kaisery.github.io/trpl-zh-cn/img/trpl04-03.svg)

图 4-3: 另一个 `s2 = s1` 时可能的内存表现, 如果 `Rust` 同时也拷贝了堆上的数据的话

之前我们提到过当 `变量离开作用域` 后, `Rust` 自动调用 `drop` 函数并清理变量的 `堆内存`. 
不过图 4-2 展示了两个数据 `指针` 指向了同一位置. 
这就有了一个问题: 当 `s2` 和 `s1` 离开作用域, 他们都会尝试释放相同的内存. 
这是一个叫做 `二次释放`(double free)的错误, 也是之前提到过的 `内存安全性 bug` 之一. 
两次释放(相同)内存会导致 `内存污染`, 它可能会导致潜在的安全漏洞.

为了确保内存安全, 这种场景下 `Rust` 的处理有另一个细节值得注意. 
与其尝试拷贝被分配的内存, `Rust` 则认为 s1 不再有效, 因此 `Rust` 不需要在 `s1` 离开作用域后清理任何东西. 
看看在 `s2` 被创建之后尝试使用 `s1` 会发生什么; 这段代码不能运行:

```rust,ignore,does_not_compile
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```

你会得到一个类似如下的错误, 因为 `Rust` 禁止你使用无效的引用.

```log
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

如果你在其他语言中听说过术语 `浅拷贝`(shallow copy)和 `深拷贝`(deep copy), 那么拷贝指针, 长度和容量, 而不拷贝数据可能听起来像 `浅拷贝`. 
不过因为 `Rust` 同时使第一个变量无效了, 这个操作被称为 `移动`(move), 而不是 `浅拷贝`. 
上面的例子可以解读为 `s1` 被 移动 到了 `s2` 中. 那么具体发生了什么, 如图 4-4 所示.

![s1 moved to s2](https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg)
图 4-4: s1 无效之后的内存表现

这样就解决了我们的问题! 因为只有 `s2` 是有效的, 当其离开 `作用域`, 它就释放自己的内存, 完毕.

另外, 这里还隐含了一个设计选择: `Rust` 永远也不会自动创建数据的 `深拷贝`.
因此, 任何 `自动` 的复制可以被认为对 `运行时性能` 影响较小.

### 变量与数据交互的方式(二): 克隆

如果我们 `确实` 需要深度复制 `String` 中堆上的数据, 而不仅仅是 `栈上` 的数据, 可以使用一个叫做 `clone` 的通用函数. 
第五章会讨论 `方法语法`, 不过因为 `方法` 在很多语言中是一个常见功能, 所以之前你可能已经见过了.

这是一个实际使用 `clone` 方法的例子:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

这段代码能正常运行, 并且明确产生图 4-3 中行为, 这里堆上的数据 `确实` 被复制了.

当出现 `clone` 调用时, 你知道一些特定的代码被执行而且这些代码可能相当消耗资源. 
你很容易察觉到一些不寻常的事情正在发生.

### 只在栈上的数据: 拷贝

这里还有一个没有提到的小窍门. 下面的代码使用了整型并且是有效的, 他们是示例 4-2 中的一部分:

```rust
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y);
```

但这段代码似乎与我们刚刚学到的内容相矛盾: 没有调用 `clone`, 不过 `x` 依然有效且没有被移动到 `y` 中.

原因是像 `整型` 这样的在编译时已知大小的类型被整个存储在 `栈上`, 所以 `拷贝` 其实际的值是快速的. 
这意味着没有理由在创建变量 `y` 后使 `x` 无效. 
换句话说, 这里没有 `深浅拷贝` 的区别, 所以这里调用 `clone` 并不会与通常的 `浅拷贝` 有什么不同, 我们可以不用管它.

`Rust` 有一个叫做 `Copy` trait 的特殊 `注解`, 可以用在类似 `整型` 这样的存储在栈上的类型上(第十章详细讲解 `trait`). 
如果一个类型拥有 `Copy` trait, 一个旧的变量在将其赋值给其他变量后仍然可用. 
`Rust` 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait. 
如果某个类型的值在离开 `作用域` 需要特殊处理, 而我们对它使用了 `Copy` 注解, 将会出现一个 `编译时` 错误. 
要学习如何为你的类型增加 `Copy` 注解, 请阅读附录 C 中的 `可派生的 trait`.

那么什么类型是 `Copy` 的呢? 可以查看给定 `类型` 的文档来确认, 不过作为一个通用的规则, 
任何 `简单标量值` 的组合可以是 `Copy` 的, 不需要 `分配内存` 或某种形式的资源的类型是 `Copy` 的. 
如下是一些 `Copy` 的类型:

+ 所有整数类型, 比如 `u32`.
+ 布尔类型, `bool`, 它的值是 `true` 和 `false`.
+ 所有浮点数类型, 比如 `f64`.
+ 字符类型, `char`.
+ 元组, 当且仅当其包含的类型也都是 `Copy` 的时候. 比如, `(i32, i32)` 是 `Copy` 的, 但 `(i32, String)` 就不是.

### 所有权与函数

将 `值` 传递给 `函数`, 在语义上与 `给变量赋值` 相似. 向函数传递值可能会 `移动` 或者 `复制`, 就像赋值语句一样. 
示例 4-3 使用注释展示变量何时进入和离开作用域:

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里,
                                    // 但 i32 是 Copy 的, 所以在后面可继续使用 x

} // 这里, x 先移出了作用域, 然后是 s. 但因为 s 的值已被移走,
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里, some_string 移出作用域并调用 `drop` 方法. 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里, some_integer 移出作用域. 不会有特殊操作
```

示例 4-3: 带有所有权和作用域注释的函数

在调用 `takes_ownership` 后, 若尝试使用 `s`, `Rust` 会抛出一个编译时错误. 这些 `静态检查` 使我们免于犯错. 
试试在 `main` 函数中添加使用 `s` 和 `x` 的代码来看看哪里能使用他们, 以及 `所有权规则` 会在哪里阻止我们这么做.

### 返回值与作用域

`返回值`也可以转移 `所有权`. 示例 4-4 与示例 4-3 一样带有类似的注释.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃. s2 也移出作用域, 但已被移走,
  // 所以什么也不会发生. s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

示例 4-4: 转移返回值的所有权

变量的 `所有权` 总是遵循相同的模式: 将值赋给另一个变量时移动它. 
当持有 `堆中数据值` 的变量离开作用域时, 其值将通过 `drop` 被清理掉, 除非数据被移动为另一个变量所有.

在每一个函数中都获取 `所有权` 并接着 `返回所有权` 有些啰嗦. 
如果我们想要函数使用一个值但 `不获取所有权` 该怎么办呢? 如果我们还要接着使用这个 `值`, 
每次都传进去再返回来就有点烦人了, 除此之外, 我们也可能想返回 `函数体` 中产生的一些数据.

我们可以使用 `元组` 来返回多个值, 如示例 4-5 所示.

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
```

示例 4-5: 返回参数的所有权

但是这未免有些形式主义, 而且这种场景应该很常见. 幸运的是, `Rust` 对此提供了一个功能, 叫做 `引用`(references). 


