# 通过 Deref trait 将智能指针当作常规引用处理

实现 `Deref` trait 允许我们重载 `解引用运算符`(dereference operator)`*`(区别于 `乘法运算符`或`通配符`).
通过这种方式实现 `Deref` trait 的 `智能指针`, 可以被当作 `常规引用` 来对待,
可以编写操作 `引用` 的代码, 并用于智能指针.

让我们首先看看 `解引用运算符` 如何处理常规引用,
接着尝试定义我们自己的类似 `Box<T>` 的类型, 并观察为何 `解引用` 运算符此时不能正常工作.

我们会探索如何实现 `Deref` trait, 使得 `智能指针` 能够以类似 `引用` 的方式工作.
最后, 我们会讨论 Rust 的 Deref强制转换(deref coercions)功能以及它是如何处理引用或智能指针的.

>我们将要构建的 `MyBox<T>` 类型与真正的 `Box<T>` 有个很大的区别: 我们的版本不会在 `堆上` 储存数据.
>这个例子重点关注 `Deref`, 所以其数据实际存放在何处不算重要.

## 通过解引用运算符追踪指针的值

`常规引用` 是 `指针` 类型, 一种理解指针的方式是, 将其看成指向储存在其他某处值的`箭头`.
在示例 15-6 中, 创建了 `i32 值` 的 `引用`, 接着使用 `解引用运算符` 来跟踪所引用的数据:

文件名: src/main.rs

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

示例 15-6: 使用 `解引用运算符` 来跟踪 `i32` 值的`引用`

变量 `x` 存放了 `i32` 值 `5`. `y` 等于 `x` 的`引用`, 可以断言 `x` 等于 `5`.
然而, 如果希望对 `y` 的值做出 `断言`, 必须使用 `*y` 来追踪`引用`所指向的值(也就是 `解引用`).
一旦 `解引用` 了 `y`, 就可以访问 `y` 所指向的`整型值`, 并可以与 `5` 做比较.

相反如果尝试编写 `assert_eq!(5, y);`, 则会得到如下编译错误:

```log
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for
  `{integer}`
```

不允许比较 `数字的引用` 与 `数字`, 因为它们是不同的`类型`.
必须使用 `解引用运算符` 追踪引用所指向的值.

## 像引用一样使用 `Box<T>`

可以使用 `Box<T>` 代替`引用`来重写示例 15-6 中的代码, `解引用` 运算符也一样能工作, 如示例 15-7 所示:

文件名: src/main.rs

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

示例 15-7: 在 `Box<i32>` 上使用`解引用`运算符

相比示例 15-6, 示例 15-7 唯一不同的地方就是, 将 `y` 设置为一个指向 `x 值` 的 `box` 实例, 而不是指向 `x` 值的`引用`.
在最后的断言中, 可以使用 `解引用` 运算符, 以类似的方式追踪 `box` 指针.
接下来让我们通过实现自己的 `box 类型` 来探索 `Box<T>` 能这么做的缘由.

## 自定义智能指针

为了体会默认情况下 `智能指针` 与 `引用` 的区别, 让我们创建类似于`标准库`提供的 `Box<T>` 类型的`智能指针`.
接着学习如何增加 `使用解引用运算符` 的功能.

从根本上说, `Box<T>` 被定义为包含一个元素的`元组结构体`, 所以示例 15-8 以相同的方式定义了 `MyBox<T>` 类型.
我们还定义了 `new` 函数, 来对应定义于 `Box<T>` 的 `new` 函数:

文件名: src/main.rs

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

示例 15-8: 定义 `MyBox<T>` 类型

这里定义了结构体 `MyBox`, 并声明了泛型参数 `T`, 因为我们希望其可以存放任何类型的值.
`MyBox` 是个包含 `T类型` 元素的 `元组结构体`.
`MyBox::new` 函数获取 `T` 类型的参数, 并返回存放传入值的 `MyBox` 实例.

尝试将示例 15-7 中的代码加入示例 15-8 中, 并修改 `main`, 以我们定义的 `MyBox<T>` 类型代替 `Box<T>`.
示例 15-9 中的代码不能编译, 因为 `Rust` 不知道如何解引用 `MyBox`:

文件名: src/main.rs

```rust
[这些代码不能编译! ]
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

示例 15-9: 尝试以类似 `引用`和 `Box<T>` 的方式使用 `MyBox<T>`
得到的编译错误是:

```log
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
```

`MyBox<T>` 类型不能 `解引用`, 因为我们尚未在该类型实现这个功能.
为了启用 `*` 运算符的 `解引用` 功能, 需要实现 `Deref` trait.

## 通过实现 `Deref` trait 将某类型像引用一样处理

如第十章所讨论的, 为了实现 `trait`, 需要提供 trait 所需的`方法实现`.
`Deref` trait 由`标准库`提供, 要求实现名为 `deref` 的方法, 它 `借用 self` 并返回内部数据的`引用`.
示例 15-10 实现了定义于 `MyBox` 之上的 `Deref`:

文件名: src/main.rs

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T { // deref trait, 将 box 解引用到 &self.0
        &self.0
    }
}
```

示例 15-10: `MyBox<T>` 上的 `Deref` 实现

`type Target = T;` 语法定义了用于此 `trait` 的 `关联类型`.
`关联类型` 是定义 `泛型参数` 的略微不同的方式, 现在还无需过多的担心它; 第十九章会详细介绍.

`deref` 方法体中写入了 `&self.0`, 这样当我们用 `*` 运算符访问值时, `deref` 返回值的 `引用`.
示例 15-9 中的 `main` 函数中, 对 `MyBox<T>` 值的 `*` 调用现在可以编译, 并能通过断言了!

没有 `Deref` trait 的话, 编译器只会解引用 `& 引用` 类型.
`deref` 方法向编译器提供了能力, 对于任何实现 `Deref` trait 的类型,  编译器可以获取它的值,
并且调用这个类型的 `deref` 方法, 来获取普通 `& 引用` -- 它的解引用方式编译器早就熟悉了.

当我们在示例 15-9 中输入 `*y` 时, 事实上 `Rust` 在底层运行了如下代码:

```rust
*(y.deref())
```

`Rust` 将 `*` 运算符替换为: 先调用 `deref` 方法, 再进行普通解引用,
如此我们便不用担心是否还需手动调用 `deref` 方法了.
`Rust` 的这个特性可以让我们写出行为一致的代码, 无论面对 `常规引用`, 还是实现了 `Deref` 的类型.

`deref` 方法返回 `值的引用`, 和  `*(y.deref())` 括号外边的 `普通解引用` 仍然必须存在的原因是 `所有权`.
如果 `deref` 方法直接返回 `值`, 而不是`值的引用`, 其 `值`(的所有权)将被移出 `self`.
在这里, 以及大部分使用 `解引用运算符` 的情况下, 我们并不希望获取 `MyBox<T>` 内部值的`所有权`.

注意, 每次当我们在代码中使用 `*` 时,  `*` 运算符都被替换成:

+ 先调用 `deref` 方法, 再使用 `*` 解引用的操作,
+ 且只会发生一次, 不会对 `*` 操作符无限递归替换,

`解引用` 出上面 `i32` 类型的值就停止了, 这个值与示例 15-9 中 `assert_eq!` 的 `5` 相匹配.

## 函数和方法的隐式 Deref强制转换

`Deref强制转换`(deref coercions)是 Rust 在 `函数` 或 `方法` 传参上提供的便利.

对于实现了 `Deref` 的类型,  它将 `此类型的引用` 转换为 `原始类型` 的引用,
当 `函数`或 `方法` 的形参与实参的具体类型不匹配时, `Deref强制转换` 将自动发生, 如果 `Deref` 能够做到这种转换的话.
这时会调用一系列的 `deref` 方法, 把我们传入的 `类型` 转换成 `参数` 需要的类型.

`Deref强制转换` 的加入方便了 Rust 程序员调用 函数和方法, 无需添加过多显式的 `&` 和 `*`(引用和解引用).
这个功能也使得我们的代码, 可以同时作用于 `引用` 或 `智能指针`.

作为展示 `Deref强制转换` 的实例, 让我们使用示例 15-8 中定义的 `MyBox<T>`, 以及示例 15-10 中增加的 `Deref` 实现.
示例 15-11 定义了含有 `字符串slice` 参数的函数:

文件名: src/main.rs

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
```

示例 15-11: `hello` 函数有着 `&str` 类型的参数 `name`

可以使用 `字符串slice` 作为参数调用 `hello` 函数, 比如 `hello("Rust");`.
`Deref强制转换` 允许使用 `MyBox<String>` 类型值的`引用`调用 `hello`, 如示例 15-12 所示:

文件名: src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

示例 15-12: 因为 `Deref强制转换`, 可使用 `MyBox<String>` 的`引用`调用 `hello`

这里使用 `&m` 调用 `hello` 函数, 它是 `MyBox<String>值` 的`引用`.
因为示例 15-10 中在 `MyBox<T>` 上实现了 `Deref` trait, `Rust` 可以调用 `deref` 将 `&MyBox<String>` 变为 `&String`.
`标准库`中提供了 `String` 上的 `Deref` 实现, 它会返回 `字符串slice`, 这可以在 `Deref` 的API文档中看到.
`Rust` 再次调用 `deref` 将 `&String` 变为 `&str`, 这就符合 `hello` 函数的定义了.

如果 `Rust` 没有实现 `Deref强制转换`, 为了使用 `&MyBox<String>` 类型的值调用 `hello`,
则必须编写示例 15-13 中的代码, 来代替示例 15-12:

文件名: src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

示例 15-13: 如果 Rust 没有 `Deref强制转换`, 则必须使用这些代码

`(*m)` 将 `MyBox<String>` 解引用为 `String`.
接着 `&` 和 `[..]` 获取了整个 `String` 的 `字符串slice` 来匹配 `hello` 的签名.
没有 `Deref强制转换`, 所有这些符号混在一起将更难以读写和理解.
`Deref强制转换` 使得 Rust 自动的帮我们处理这些转换.

当所涉及到的类型定义了 `Deref` trait, Rust 会分析这些类型, 并使用任意多次 `Deref::deref` 调用以获得匹配参数的类型.
这些解析都发生在编译时, 所以利用 `Deref强制转换` 并没有运行时惩罚!

## Deref强制转换如何与可变性交互

类似于使用 `Deref` trait 重载 `不可变引用` 的 `*` 运算符,
`Rust` 提供了 `DerefMut` trait 用于重载 `可变引用` 的 `*` 运算符.
`Rust` 在发现 `类型` 和 `trait` 实现满足三种情况时, 会进行 `Deref强制转换`:

+ 当 `T: Deref<Target=U>` 时,从 `&T` 到 `&U`.
+ 当 `T: DerefMut<Target=U>` 时, 从 `&mut T` 到 `&mut U`.
+ 当 `T: Deref<Target=U>` 时, 从 `&mut T` 到 `&U`.

头两个情况除了 `可变性` 之外是相同的:
第一种情况表明如果有个 `&T`, 而 `T` 实现了返回 `U 类型` 的 `Deref`, 则可以直接得到 `&U`.
第二种情况表明对于`可变引用`也有着相同的行为.

第三个情况有些微妙: Rust 也会将 `可变引用` 强转为 `不可变引用`.
但是反之是 `不可能` 的: `不可变引用` 永远也不能强转为 `可变引用`.

因为根据 `借用规则`, 如果有个 `可变引用`, 它必须是数据的 `唯一引用`(否则程序将无法编译).
将 `可变引用` 转换为 `不可变引用` 永远也不会打破 `借用规则`.
将 `不可变引用转换` 为 `可变引用` 则需要数据只能有一个 `不可变引用`, 而 `借用规则` 无法保证这一点.
因此, Rust 无法假设可以将 `不可变引用` 转换为 `可变引用`.
