# 变量和可变性

正如第二章中 `使用变量储存值` 部分提到的那样, 变量默认是`不可改变的`(immutable).
这是 `Rust` 提供给你的众多优势之一, 让你得以充分利用 `Rust` 提供的`安全性`和简单`并发性`来编写代码.
不过, 你仍然可以使用`可变变量`. 让我们探讨一下 `Rust` 为何及如何鼓励你利用不可变性, 以及何时你会选择不使用`不可变性`.

当变量`不可变`时, 一旦值被绑定一个名称上, 你就不能改变这个值.
为了对此进行说明, 使用 `cargo new variables` 命令在 `projects` 目录生成一个叫做 `variables` 的新项目.

接着, 在新建的 `variables` 目录, 打开 `src/main.rs` 并将代码替换为如下代码, 这些代码还不能编译:

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

保存并使用 `cargo run` 运行程序. 应该会看到一条错误信息, 如下输出所示:

```log
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
...
```

这个例子展示了`编译器`如何帮助你找出程序中的错误.
虽然`编译错误`令人沮丧, 但那只是表示程序不能`安全`的完成你想让它完成的工作;
并 **不能** 说明你不是一个好程序员! 经验丰富的 `Rustacean` 们一样会遇到编译错误.

错误信息指出错误的原因是 `不能对不可变变量 x 二次赋值`(cannot assign twice to immutable variable `x` ), 因为你尝试对不可变变量 `x` 赋第二个值.

在尝试改变预设为`不可变`的值时, 产生`编译时错误`是很重要的, 因为这种情况可能导致 bug.
如果一部分代码假设一个值永远也不会改变, 而另一部分代码改变了这个值, 第一部分代码就有可能以不可预料的方式运行.
不得不承认这种 bug 的起因难以跟踪, 尤其是第二部分代码只是 **有时** 会改变值.

`Rust` 编译器保证, 如果声明一个值不会变, 它就真的不会变.
这意味着当阅读和编写代码时, 不需要追踪一个值如何和在哪可能会被改变, 从而使得代码易于推导.

不过`可变性`也是非常有用的. 变量只是默认不可变;
正如在第二章所做的那样, 你可以在变量名之前加 `mut` 来使其可变.
除了允许改变值之外, `mut` 向读者`表明`了其他代码将会改变这个变量值的意图.

例如, 让我们将 `src/main.rs` 修改为如下代码:

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

现在运行这个程序, 出现如下内容:

```log
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

通过 `mut`, 允许把绑定到 `x` 的值从 `5` 改成 `6`.
在一些情况下, 你会想用可变变量, 因为与只用不可变变量相比, 它会让代码更容易编写.

除了防止出现 `bug` 外, 还有很多地方需要权衡取舍.
例如, 使用大型数据结构时, 适当地使用`可变变量`, 可能比`复制`和`返回`新分配的实例更快.
对于较小的数据结构, 总是创建新实例, 采用更偏向`函数式`的编程风格, 可能会使代码更易理解, 为可读性而牺牲性能或许是值得的.

## 变量和常量的区别

不允许`改变值`的变量, 可能会使你想起另一个大部分编程语言都有的概念:` 常量`(constants).
类似于`不可变变量`, `常量`是绑定到一个名称的不允许改变的值, 不过`常量`与`变量`还是有一些区别.

首先, 不允许对`常量`使用 `mut`. 常量不光默认不能变, 它总是不能变.

声明常量使用 `const` 关键字而不是 `let`, 并且 **必须** 注明值的类型.
在下一部分, "数据类型" 中会介绍`类型`和`类型注解`, 现在无需关心这些细节, 记住总是`标注类型`即可.

`常量`可以在任何`作用域`中声明, 包括`全局作用域`, 这在一个值需要被很多部分的代码用到时很有用.

最后一个区别是, `常量`只能被设置为`常量表达式`, 而不可以是其他任何只能在`运行时`计算出的值.

下面是一个声明常量的例子, 常量的名称是 `THREE_HOURS_IN_SECONDS`,
它的值被设置为 `60`(一分钟内的秒数)乘以 `60`(一小时内的分钟数)再乘以` 3`(我们在这个程序中要计算的小时数)的结果:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

`Rust` 对常量的命名约定是在单词之间使用`全大写`加`下划线`.
编译器能够在`编译时`计算一组有限的操作, 这使我们可以选择以更容易理解和验证的方式写出此值, 而不是将此常量设置为值`10,800`.
有关声明常量时可以使用哪些操作的详细信息, 请参阅 `Rust Reference` 的常量求值部分.

在声明它的作用域之中, 常量在整个程序生命周期中都有效, 此属性使得常量可以作为多处代码使用的全局范围的值, 例如一个游戏中所有玩家可以获取的最高分或者光速.

将遍布于应用程序中的`硬编码`值声明为常量, 能帮助后来的代码维护人员了解值的意图.
如果将来需要修改`硬编码`值, 也只需修改汇聚于一处的`硬编码值`.

## 隐藏(Shadowing)

正如在第二章猜猜看游戏的 "比较猜测的数字和秘密数字" 中所讲, 我们可以定义一个与之前变量`同名`的新变量.
`Rustacean` 们称之为第一个变量被第二个 **隐藏** 了, 这意味着程序使用这个变量时会看到`第二个值`.
可以用相同变量名称来隐藏一个变量, 以及重复使用 `let` 关键字来多次隐藏, 如下所示:

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

这个程序首先将 `x` 绑定到值 `5` 上. 接着通过 `let x =` 隐藏 `x`, 获取初始值并加 `1`, 这样 `x` 的值就变成 `6` 了.
然后, 在内部作用域内, 第三个 `let` 语句也隐藏了 `x`, 将之前的值乘以 `2`, `x` 得到的值是 `12`.
当该作用域结束时, 内部 `shadowing` 的作用域也结束了, `x` 又返回到 `6`. 运行这个程序, 它会有如下输出:

```log
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```

`隐藏`与将变量标记为 `mut` 是有区别的.
当不小心尝试对变量`重新赋值`时, 如果没有使用 `let` 关键字, 就会导致`编译时`错误.
通过使用 `let`, 我们可以用这个值进行一些计算, 不过计算完之后变量仍然是`不可变的`.

`mut` 与`隐藏`的另一个区别是, 当再次使用 `let` 时, 实际上创建了一个新变量, 我们可以改变`值的类型`, 但复用这个名字.
例如, 假设程序请求用户输入空格字符, 来说明希望在文本之间显示多少个空格,
然而我们真正需要的是, 将用户输入存储成`数字`(多少个空格):

```rust
let spaces = "   ";
let spaces = spaces.len();
```

这里允许第一个 `spaces` 变量是`字符串类型`, 而第二个 `spaces` 变量, 它是一个恰巧与第一个变量同名的崭新变量, 是`数字类型`.
隐藏使我们不必使用不同的名字, 如 `spaces_str` 和 `spaces_num`; 相反, 我们可以复用 `spaces` 这个更简单的名字.
然而, 如果尝试使用 `mut`, 将会得到一个编译时错误, 如下所示:

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

这个错误说明, 我们不能改变变量的类型:

```log
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`
...
```

现在我们已经了解了变量如何工作, 让我们看看变量可以拥有的更多`数据类型.`
