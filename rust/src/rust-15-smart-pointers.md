# 智能指针

`指针` (`pointer`)是个通用概念, 意思是包含 `内存地址` 的 `变量`.
这个地址 `引用` 或 `指向` (points at)其他数据.

`Rust` 中最常见的指针是第四章介绍的 `引用`(reference).
`引用` 以 `&` 符号为标志, 并 `借用` 了他们所指向的值, 除了引用数据外, 没有任何其他特殊功能.
它们也没有任何额外开销, 所以应用得最多.

另一方面, `智能指针`(smart pointers)是一类 `数据结构`, 他们的表现类似 `指针`, 但是也拥有额外的 `元数据` 和 `功能`.
`智能指针` 的概念并不为 Rust 所独有; 其起源于 `C++` 并存在于其他语言中.

Rust 标准库中不同的 `智能指针`提供了`引用` 之外的功能.
本章将会探索的例子之一是 `引用计数` (reference counting)智能指针类型, 它允许`数据`有多个`所有者`.
`引用计数智能指针` 记录总共有多少个`所有者`, 并负责在 `所有者` 都消失时 `清理数据`.

在 Rust 中, `普通引用` 和 `智能指针` 的一个额外的区别是, `引用` 是一类只`借用`数据的指针;
相反, 在大部分情况下 智能指针 `拥有` 他们指向的数据.

实际上本书中已经出现过一些 `智能指针`, 比如第八章的 `String` 和 `Vec<T>`, 虽然当时我们并不这么称呼它们.
这些类型都属于 `智能指针`, 因为它们拥有一些`数据`, 并允许你修改它们.
它们也带有 `元数据`(比如他们的 `容量`)和额外的功能, 或 `保证`(`String` 的数据总是有效的 `UTF-8 编码`).

`智能指针` 通常使用结构体实现.
`智能指针` 区别于常规 `结构体` 的显著特性在于, 其实现了 `Deref` 和 `Drop` trait.

+ `Deref` trait 允许 `智能指针` 这种结构体的实例, 表现的像 `引用` 一样,
这样我们编写的代码即可用于 `引用`, 又可用于`智能指针`.
+ `Drop` trait 允许我们自定义一些代码, 在 `智能指针` 离开 `作用域` 时运行它们.

本章会讨论这些 trait, 以及它们对于智能指针的重要性.

考虑到 `智能指针` 是在 Rust 经常被使用的通用设计模式, 本章并不会覆盖所有现存的 `智能指针`.
很多库都有自己的 `智能指针`, 而你也可以编写属于你自己的智能指针.
这里将会讲到的是来自标准库中最常用的一些:

+ `Box<T>`, 用于在 `堆`(heap) 上分配值
+ `Rc<T>`, `引用计数` 类型, 其数据可以有多个`所有者`
+ `Ref<T>` 和 `RefMut<T>`, 通过 `RefCell<T>` 访问. ( `RefCell<T>` 类型在 `运行时` 而不是在 `编译时` 执行`借用规则`).

另外我们会涉及 `内部可变性`(interior mutability)模式, 这是 `不可变类型` 暴露出的, 改变其`内部值`的 API.
我们也会讨论 `引用循环`(reference cycles)缘何会泄漏内存, 以及如何避免.

让我们开始吧!
