# 使用Box <T>指向堆上的数据

最简单直接的 `智能指针` 是 `box`, 其类型是 `Box<T>`.
`box` 允许你将 `值` 放在`堆上`而不是`栈上`. 留在 `栈上` 的则是指向`堆数据`的 `指针`.
如果你想回顾 `栈`与`堆`的区别, 请参考第四章.

除了数据被储存在 `堆` 上而不是 `栈` 上之外, `box` 没有性能损失.
不过它也没有很多额外的功能. 它们多用于如下场景:

+ 某个类型在 `编译时` 未知大小, 而我们又想在 `确切大小` 的上下文中使用它
+ 当有大量数据, 并希望在确保数据不被拷贝的情况下, 转移 `所有权` 的时候
+ 只关心某个`值`的 `类型` 是否实现了特定 `trait`, 而不关心它的类型具体是什么

我们会在 `box 允许创建递归类型` 部分展示第一种场景.

在第二种情况中, 转移大量数据的 `所有权` 可能会花费很长的时间, 因为数据在`栈`上进行了`拷贝`.
为了改善这种情况下的性能, 可以通过 `box` 将这些数据储存在`堆`上.
接着, 只在`栈`上拷贝少量的 `指针数据`.

第三种情况被称为 `trait对象`(trait object), 第十七章刚好有一整节 `为使用不同类型的值而设计的 trait对象` 专门讲解这个主题.
所以这里所学的内容会在第十七章再次用上!

## 使用 `Box<T>` 在堆上储存数据

在讨论 `Box<T>` 的用例之前, 让我们熟悉一下语法, 以及如何与 `Box<T>` 中储存的值进行交互.
示例 15-1 展示了, 如何使用 `box` 在`堆`上储存 `i32`:

文件名: src/main.rs

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

示例 15-1: 使用 `box` 在堆上储存 `i32` 值

这里定义了`变量 b`, 其`值` 是 `Box`, 指向被分配在`堆`上的 `值 5`. 这个程序会打印出 `b = 5`;

在这个例子中, 我们可以像访问 `栈上` 数据那样, 访问 `box` 中的数据.
正如任何拥有数据 `所有权` 的 `值` 那样, 像 `b` 这样的 `box` 在 `main` 的末尾离开 `作用域` 时, 它将被释放.
这个 `释放过程` 作用于 `box` 本身(位于`栈上`)和它所指向的`数据`(位于`堆上`).

将单独的`值`存放在`堆`上并不是很有意义, 所以像示例 15-1 这样单独使用 `box` 并不常见.
将单个 `i32` 这样的`值`储存在`栈`上, 也就是其默认存放的地方在大部分使用场景中更为合适.
让我们看一个必须使用 `box` 定义的类型的例子.

## Box 允许创建递归类型

`Rust` 需要在编译时知道 `类型` 占用多少空间.
一种无法在`编译时`知道大小的类型是 `递归类型`(recursive type), 它的值的一部分可以是`同类型`的另一个值.
理论上, 这种`值`的嵌套可以无限的进行下去, 所以 `Rust` 不知道 `递归类型` 需要多少空间.
不过 `box` 的大小是已知的, 所以通过在 `循环类型` 定义中插入 `box`, 就可以创建 `递归类型` 了.

让我们探索一下 `cons list` 来展示 `递归类型` 的概念, 它是 `函数式编程语言` 中的常见类型,
除了 `递归` 之外,  `cons list` 类型的含义是很直白的,
所以这个例子中的概念, 即使在任何更为复杂的场景也很实用.

## cons list 的更多内容

`cons list` 是一个来源于 `Lisp` 编程语言及其方言的数据结构.
在 `Lisp` 中, `cons` 函数("construct function" 的缩写)利用两个参数来构造`新的列表`,
他们通常是一个单独的`值`和另一个`列表`.

`cons` 函数的概念涉及到更常见的函数式编程术语;
`将 x 与 y 连接` 通常意味着构建新的容器, 将 `x` 的元素放在新容器的开头, 其后则是容器 `y` 的元素.

`cons list` 的每一项都包含两个元素: `当前项` 的值和 `下一项`.
它的最后一项包含叫做 `Nil` 的值, 且没有下一项. `cons list` 通过递归调用 `cons` 函数产生.

代表递归的 `终止条件`(base case)的规范名称是 `Nil`, 它宣布列表的终止.
注意这不同于第六章中的 `null` 或 `nil` 的概念, 他们代表 `无效` 或 `缺失` 的值.

注意虽然函数式编程语言经常使用 `cons list`, 但是它并不是 Rust 中常见的类型.
在 `Rust` 中需要列表的时候, 大部分情况 `Vec<T>` 是更好的选择.
其他更为复杂的 `递归数据类型` 确实 在 Rust 的很多场景中很有用,
不过通过以 `cons list` 作为开始, 我们可以探索如何使用 `box`, 毫不费力的定义`递归数据类型`.

示例 15-2 包含 `cons list` 的枚举定义.
注意这还不能编译因为这个类型没有已知的大小, 之后我们会展示:

文件名: src/main.rs

```rust
[这些代码不能编译! ]
enum List {
    Cons(i32, List),
    Nil,
}
```

示例 15-2: 第一次尝试定义代表 `i32` 值的 `cons list` 数据结构的`枚举`

>注意: 出于示例的需要我们选择实现只存放 `i32` 值的 `cons list`.
>也可以用`泛型`, 正如第十章讲到的, 来定义可以存放任何值 的 `cons list` 类型.

使用此 `cons list` 来储存列表 `1, 2, 3`, 看起来将会如示例 15-3:

文件名: src/main.rs

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

示例 15-3: 使用 `List` 枚举储存列表 `1, 2, 3`

第一个 `Cons` 储存了 `1` 和另一个 `List` 值.
这个 `List` 是一个包含 `2` 的 `Cons` 值, 和下一个 `List` 值.
接着又有另一个存放了 `3` 的 `Cons` 值, 和最后一个值为 `Nil` 的 `List`, `非递归成员` 代表了列表的结尾.

如果尝试编译示例 15-3 的代码, 会得到如示例 15-4 所示的错误:

```log
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

示例 15-4: 尝试定义 `递归枚举时` 得到的错误

这个错误表明这个类型 `有无限的大小`.
其原因是 `List` 的一个`成员`被定义为是`递归的`: 它直接存放了另一个相同类型的`值`.
这意味着 `Rust` 无法计算为了存放 `List` 值, 到底需要多少空间.
让我们逐步分析: 首先来了解 Rust 如何决定存放 `非递归类型`, 所需要的空间.

## 计算非递归类型的大小

回忆一下第六章讨论枚举定义时, 示例 6-2 中定义的 `Message` 枚举:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

当 Rust 需要为 `Message` 值分配一些空间时, 它可以检查每个成员, 并发现:
`Message::Quit` 不需要任何空间, `Message::Move` 需要足够储存两个 `i32` 值的空间, 依此类推.
因为 `enum` 实际上只会使用其中的单个成员, 所以 `Message` 值所需的空间等于它最大成员的所需空间.

与此相对, 当 Rust 编译器检查 示例 15-2 中的 List 这样的`递归类型`时,
`编译器` 尝试计算出储存 `List 枚举` 需要多少内存, 并开始检查 `Cons` 成员, 而 `Cons` 需要的空间等于 `i32` 的大小加上 `List` 的大小.
为了计算 `List` 需要多少内存, 它检查其成员, 再次从 `Cons` 成员开始.
`Cons` 成员储存了一个 `i32` 值和一个 `List` 值, 这样的计算将无限进行下去, 如图 15-1 所示:

![An infinite Cons list](https://kaisery.github.io/trpl-zh-cn/img/trpl15-01.svg)

图 15-1: 包含无限个 `Cons` 成员的`无限 List`

## 使用 `Box<T>` 给递归类型已知的大小

Rust 无法计算出要为定义为`递归`的类型分配多少空间, 所以编译器给出了示例 15-4 中的错误. 这个错误也包括了有用的建议:

```log
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

在建议中, `indirection` 意味着不直接储存`值`, 而是间接储存指向`值`的`指针`.
因为 `Box<T>` 是个指针, 我们总是知道它需要多少空间: `指针`的大小并不会根据其指向的`数据量`而改变.

这意味着可以将 `Box` 放入 `Cons` 成员中, 而不是直接存放另一个 `List 值`.
`Box` 会指向另一个位于`堆上`的 `List 值`, 而不是存放在 `Cons 成员` 中.
从概念上讲, 我们仍然通过 `嵌套存放列表` 来创建列表, 只不过现在的实现方式更像是一项挨着另一项, 而不是一项包含另一项.

我们可以修改示例 15-2 中 List 枚举的定义, 和示例 15-3 中对 List 的应用,
如示例 15-65 所示, 现在是可以编译的:

文件名: src/main.rs

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

示例 15-5: 为了给出确定大小, 而使用 `Box<T>` 的 `List` 定义

`Cons 成员`需要的空间是 `i32` 的大小, 加上储存 `box 指针` 所需的空间. `Nil 成员` 不储存`值`, 所以它需要的空间比 `Cons 成员` 更少.
现在我们知道了任何 `List 值` 最多需要 `i32` 加上 `box 指针数据`的大小.
通过使用 `box` , 打破了 `无限递归` 的连锁, 这样编译器就能够计算出储存 `List 值`需要的大小了.
图 15-2 展示了现在 `Cons 成员` 的概略图:

![A finite Cons list](https://kaisery.github.io/trpl-zh-cn/img/trpl15-02.svg)

图 15-2: 因为 `Cons` 存放 `Box`, 所以 `List` 不是无限大小的了

`box` 只提供了 `间接存储` 和 `堆分配`;  他们并没有任何其他特殊的功能, 之后我们会在其他 `智能指针`中看到.
它们也没有这些 `特殊功能` 带来的性能损失,  所以他们可以用于像 `cons list` 这样的场景, 其中只用到了 `间接存储` 功能.
我们还将在第十七章看到 `box` 的更多应用.

`Box<T>` 类型是一个 `智能指针`, 因为它实现了 `Deref` trait, 它允许 `Box<T>` 值被当作 `引用` 对待.
当 `Box<T> 值`离开作用域时, 由于 `Box<T>` 类型 `Drop` trait 的实现, `box` 所指向的 `堆数据` 也会被清除.

让我们更详细的探索下这两个 `trait`. 对于本章后续讨论中的其他 `智能指针` 所提供的功能, 这两个 `trait`  将会更为重要.
