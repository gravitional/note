# 数据类型

在 `Rust` 中, 每一个值都属于某一个 **数据类型**(data type), 这告诉 `Rust` 它被指定为何种数据, 以便明确数据处理方式.
我们将看到两类数据类型子集: `标量`(scalar)和 `复合`(compound).

记住, `Rust` 是 **静态类型**(statically typed)语言, 也就是说在编译时就必须知道所有变量的类型.
根据值及其使用方式, `编译器` 通常可以推断出我们想要用的类型.
当多种类型均有可能时, 比如第二章的 "比较猜测的数字和秘密数字"中, 使用 `parse` 将 `String` 转换为数字时, 必须增加 `类型注解`, 像这样:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

这里如果不添加 `类型注解` (annotation), `Rust` 会显示如下错误, 这说明编译器需要我们提供更多信息, 来了解我们想要的类型:

```rust
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
...
```

你会看到其它数据类型的各种`类型注解`.

## 标量类型

`标量`(scalar)类型代表一个单独的值.
`Rust` 有四种基本的标量类型: `整型`, `浮点型`, `布尔类型` 和 `字符类型`. 你可能在其他语言中见过它们.
让我们深入了解它们在 Rust 中是如何工作的.

### 整型

**整数** 是一个没有小数部分的数字. 我们在第二章使用过 `u32` 整数类型.
该类型声明表明, 它关联的值应该是一个占据 `32 比特位`的无符号整数`(有符号整数`类型以 `i` 开头而不是 `u`).
表格 3-1 展示了 `Rust` 内建的整数类型. 在`有符号列`和`无符号列中` 的每一个变体(例如, `i16`)都可以用来声明`整数值`的类型.

表格 3-1: `Rust` 中的整型

|长度|有符号|无符号 |
|---|---|---|
| 8-bit  |  `i8`    | `u8` |
| 16-bit  |  `i16`    | `u16` |
| 32-bit  |  `i32`    | `u32` |
| 64-bit  |  `i64`    | `u64` |
| 128-bit  |  `i128`    | `u128` |
| arch  |  `isize`  |   `usize` |

每一个变体都可以是 `有符号` 或 `无符号` 的, 并有一个明确的 `大小` .
`有符号` 和 `无符号` 代表数字能否为 `负值`, 换句话说, 这个数字是否有可能是负数(有符号数), 或者永远为正而不需要符号(无符号数).
这有点像在纸上书写数字: 当需要考虑符号的时候, 数字以`加号`或`减号`作为前缀; 然而, 可以安全地假设为正数时, 加号前缀通常省略.
有符号数以 `补码` 形式(two's complement representation) 存储.

每一个有符号的变体可以储存包含从 $-(2^{n - 1})$ 到 $2^{n - 1} - 1$  在内的数字, 这里 `n` 是变体使用的`位数`.
所以 `i8` 可以储存从 $-(2^7)$ 到 $2^7 - 1$ 在内的数字, 也就是从 $-128$ 到 $127$.
无符号的变体可以储存从 $0$ 到 $2^n - 1$ 的数字, 所以 `u8` 可以储存从 $0$ 到 $2^8 - 1$ 的数字, 也就是从 $0$ 到 $255$.

另外, `isize` 和 `usize` 类型依赖运行程序的计算机架构: `64` 位架构上它们是 `64` 位的,  `32` 位架构上它们是 `32` 位的.

可以使用表格 3-2 中的任何一种形式编写数字字面值.
请注意可以是多种`数字类型`的`数字字面值`允许使用`类型后缀`,
例如 `57u8` 来指定类型, 同时也允许使用 `_` 做为分隔符以方便读数, 例如 `1_000`, 它的值与你指定的 `1000` 相同.

表格 3-2: `Rust` 中的整型字面值

|数字字面值|例子|
|---|---|
|   Decimal (十进制)    |   `98_222` |
|   Hex (十六进制)    |     `0xff`   |
|   Octal (八进制)    |     `0o77`   |
|   Binary (二进制)    |  `0b1111_0000`  |
|   Byte (单字节字符)(仅限于 `u8`)  |      `b'A'`   |

那么该使用哪种类型的数字呢?
如果拿不定主意, `Rust` 的默认类型通常是个不错的起点, 数字类型默认是 `i32`.
`isize` 或 `usize` 主要作为某些集合的索引.

>### 整型溢出
>
>比方说有一个 `u8` , 它可以存放从`0`到 `255` 的值.
>那么当你将其修改为 `256` 时会发生什么呢? 这被称为 `整型溢出`("integer overflow" ), 关于这一行为 Rust 有一些有趣的规则.
>当在 `debug` 模式编译时, `Rust` 检查这类问题并使程序 `panic`, 这个术语被 `Rust` 用来表明`程序因错误而退出`.
>第九章 `panic! 与不可恢复的错误` 部分会详细介绍 `panic`.
>
>在 `release` 构建中, `Rust` 不检测溢出, 相反会进行一种被称为`二进制补码包装`(two"s complement wrapping)的操作.
>简而言之, 值 `256` 变成 `0`, 值 `257` 变成 `1`, 依此类推. 依赖`整型溢出`被认为是一种错误, 即便可能出现这种行为.
>如果你确实需要这种行为, 标准库中有一个类型显式提供此功能, `Wrapping`.
>为了显式地处理`溢出`的可能性, 你可以使用标准库在`原生数值类型`上提供的以下方法:
>
>+ 所有模式下都可以使用 `wrapping_*` 方法进行包装, 如 `wrapping_add`
>+ 如果 `check_*` 方法出现溢出, 则返回 `None值`
>+ 用 `overflowing_*` 方法返回`值`和一个`布尔值`, 表示是否出现`溢出`
>+ 用 `saturating_*` 方法在值的`最小值`或`最大值处`进行饱和处理

### 浮点型

`Rust` 也有两个原生的 `浮点数`(floating-point numbers)类型, 它们是带小数点的数字.
`Rust` 的浮点数类型是 `f32` 和 `f64`, 分别占 `32` 位和 `64` 位.
默认类型是 `f64`, 因为在现代 `CPU` 中, 它与 `f32` 速度几乎一样, 不过`精度`更高.

这是一个展示浮点数的实例:

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数采用 `IEEE-754` 标准表示. `f32` 是单精度浮点数, `f64` 是双精度浮点数.

### 数值运算

`Rust` 中的所有数字类型都支持基本数学运算: `加法`, `减法`, `乘法`, `除法` 和 `取余`.
`整数除法`会向下舍入到最接近的整数. 下面的代码展示了如何在 `let` 语句中使用它们:

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // 结果为 0

    // 取余
    let remainder = 43 % 5;
}
```

这些语句中的每个表达式使用了一个数学运算符并计算出了一个值, 然后绑定给一个变量.
附录 B 包含 `Rust` 提供的所有运算符的列表.

### 布尔型

正如其他大部分编程语言一样, `Rust` 中的布尔类型有两个可能的值: `true` 和 `false`. `Rust` 中的布尔类型使用 `bool` 表示. 例如:

```rust
fn main() {
    let t = true;

    let f: bool = false; // 显式指定类型注解
}
```

使用布尔值的主要场景是条件表达式, 例如 `if` 表达式.
在 `控制流`("Control Flow") 部分将介绍 `if` 表达式在 `Rust` 中如何工作.

### 字符类型

目前为止只使用到了数字, 不过 `Rust` 也支持字母.
`Rust` 的 `char` 类型是语言中最原生的字母类型, 如下代码展示了如何使用它.
(注意 `char` 由`单引号`指定, 不同于`字符串`使用`双引号`. )

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

`Rust` 的 `char` 类型的大小为`四个字`节(four bytes), 并代表了一个 `Unicode 标量值`(Unicode Scalar Value), 这意味着它可以比 `ASCII` 表示更多内容.
在 `Rust` 中, `拼音字母`(Accented letters), `中文`, `日文`, `韩文`等字符, `emoji`(绘文字)以及`零长度`的`空白`字符都是有效的 `char` 值.
`Unicode` 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000` 到 `U+10FFFF` 在内的值.
不过, `字符` 并不是一个 `Unicode` 中的概念, 所以人直觉上的 `字符` 可能与 `Rust` 中的 `char` 并不符合.
第八章的 "使用字符串存储 UTF-8 编码的文本" 中将详细讨论这个主题.

## 复合类型

复合类型(Compound types)可以将`多个值`组合成一个类型.
`Rust` 有两个原生的复合类型: `元组`(tuple)和 `数组`(array).

### 元组类型

`元组`是一个将`多个其他类型`的值组合进一个复合类型的主要方式.
元组`长度固定`: 一旦声明, 其长度不会增大或缩小.

我们使用包含在`圆括号`中的`逗号`分隔的值列表来创建一个元组.
元组中的每一个位置都有一个类型, 而且这些不同值的类型也不必是相同的.
这个例子中使用了可选的`类型注解`:

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

`tup` 变量绑定到整个元组上, 因为元组是一个`单独的`复合元素.
为了从元组中获取`单个值`, 可以使用`模式匹配`(pattern matching)来`解构`(destructure)元组值, 像这样:

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

程序首先创建了一个元组并绑定到 `tup` 变量上.
接着使用了 `let` 和一个模式将 `tup` 分成了三个不同的变量, `x`, `y` 和 `z`.
这叫做 `解构`(destructuring), 因为它将一个元组拆成了三个部分.
最后, 程序打印出了 `y` 的值, 也就是 `6.4`.

除了使用`模式匹配`解构外, 也可以使用`点号`(`.`)后跟值的`索引`来直接访问它们. 例如:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

这个程序创建了一个元组, `x`, 并接着使用索引为每个元素创建新变量.
跟大多数编程语言一样, 元组的第一个索引值是 `0`.

没有任何值的元组 `()`, 是一种特殊的`type`, 这种类型只有一个`值`, 也写成 `()`.
该类型被称为 `单元类型`(unit type), 这种值被称为 `单元值`(unit value).
如果表达式不返回任何其他值, 则会`隐式`返回`单元值`.

### 数组类型

另一个包含多个值的方式是 `数组`(array). 与 `元组` 不同, `数组` 中的每个元素的类型必须相同.
`Rust` 中的`数组`与一些其他语言中的`数组`不同, 因为 `Rust` 中的`数组`是固定长度的: 一旦声明, 它们的长度`不能`增长或缩小.

`Rust` 中, `数组`中的值位于`中括号`(`[]`)内的逗号分隔的列表中:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

当你想要在`栈`(stack)而不是在`堆`(heap)上为数据分配空间(第四章将讨论`栈`与`堆`的更多内容),
或者是想要确保总是有`固定数量`的元素时, `数组`非常有用.

但是`数组`并不如 `vector` 类型灵活. `vector` 类型是标准库提供的一个 允许 `增长` 和 `缩小` 长度的类似数组的`集合类型`.
当不确定是应该使用数组还是 `vector` 的时候, 你可能应该使用 `vector`. 第八章会详细讨论 `vector`.

一个你可能想要使用`数组`而不是 `vector` 的例子是, 当程序需要知道一年中`月份`的名字时.
程序不大可能会去增加或减少月份. 这时你可以使用`数组`, 因为我们知道它总是包含 `12` 个元素:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

可以像这样编写`数组`的类型: 在方括号中包含每个元素的`类型`, 后跟`分号`, 再后跟数组元素的`数量`.

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

这里, `i32` 是每个元素的类型. `分号`之后, 数字 `5` 表明该数组包含`五个`元素.

以这种方式编写数组的类型, 看起来类似于初始化数组的另一种语法:
如果要为每个元素创建包含相同值的数组, 可以指定`初始值`, 后跟`分号`, 然后在方括号中指定数组的`长度`, 如下所示:

```rust
let a = [3; 5];
```

变量名为 `a` 的数组将包含 `5` 个元素, 这些元素的值最初都将被设置为 `3`.
这种写法与 `let a = [3, 3, 3, 3, 3];` 效果相同, 但更简洁.

### 访问数组元素

`数组`是可以在`堆栈`上分配的, 已知固定大小的`单个内存块`. 可以使用`索引`来访问数组的元素, 像这样:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

在这个例子中, 叫做 `first` 的变量的值是 `1`, 因为它是数组 `索引 [0]` 的值.
变量 `second` 将会是数组`索引 [1]` 的值 `2`.

### 无效的数组元素访问

如果我们访问数组结尾之后的元素会发生什么呢?
比如你将上面的例子改成下面这样, 它使用类似于第 2 章中的猜数字游戏的代码从用户那里获取数组索引:

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

此代码编译成功. 如果您使用 `cargo run` 运行此代码并输入 `0`, `1`, `2`, `3` 或 `4`, 程序将在数组中的索引处打印出相应的值.
如果你输入一个超过数组末端的数字, 如 `10`, 你会看到这样的输出:

```log
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrac
```

程序在 `索引` 操作中使用一个无效的值时导致 `运行时` 错误.
程序带着 `错误信息` 退出, 并且没有执行最后的 `println!` 语句.
当尝试用`索引`访问一个元素时, `Rust` 会检查指定的索引是否小于数组的长度.
如果索引超出了数组长度, `Rust` 会 `panic`, 这是 `Rust` 术语, 它用于`程序因为错误而退出`的情况.
这种检查必须在`运行时`进行. 特别是在这种情况下, 因为编译器不可能知道用户在以后运行代码时将输入什么值.

这是第一个在实战中遇到的 `Rust` 安全原则的例子.
在很多底层语言中, 并没有进行这类检查, 这样当提供了一个不正确的索引时, 就会访问无效的内存.
通过`立即退出`而不是允许内存访问并继续执行, `Rust` 让你避开此类错误.

第九章会讨论更多 `Rust` 的错误处理.
