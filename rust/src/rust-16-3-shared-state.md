# 共享状态并发

虽然消息传递是一个很好的处理并发的方式, 但并不是唯一的方式.
再一次思考一下 Go 编程语言文档中口号的这一部分: "不要通过共享内存来通讯"("do not communicate by sharing memory."):

>What would communicating by sharing memory look like? In addition, why would message passing enthusiasts not use it and do the opposite instead?
>
>通过`共享内存` 通讯看起来如何? 除此之外, 为何消息传递的拥护者并不使用它, 并反其道而行之呢?

在某种程度上, 任何编程语言中的`通道`都类似于`单所有权`, 因为一旦将一个`值`传送到`通道`中, 将`无法`再使用这个`值`.
`共享内存`类似于`多所有权`: 多个线程可以同时访问相同的内存位置.

第十五章介绍了`智能指针`如何使得多所有权成为可能, 然而这会增加额外的复杂性, 因为需要以某种方式管理这些不同的所有者.
Rust 的类型系统和所有权规则, 极大的协助了正确地管理这些所有权.
作为一个例子, 让我们看看`互斥器`, 一个更为常见的`共享内存`并发原语(primitive).

## 互斥器一次只允许一个线程访问数据

`互斥器`(mutex)是 `mutual exclusion` 的缩写, 也就是说, 任意时刻, 其只允许一个线程访问某些数据.

为了访问互斥器中的数据, 线程首先需要通过获取互斥器的 `锁`(lock)来表明其希望访问数据.
`锁`是一个作为互斥器一部分的数据结构, 它记录谁有数据的`排他性访问权`.
因此, 我们描述互斥器为通过锁系统 `保护`(guarding)其数据.

互斥器以难以使用著称, 因为你不得不记住:

+ 在使用数据之前, 尝试`获取锁`.
+ 处理完被互斥器所保护的数据之后, 必须`解锁`数据, 这样其他线程才能够获取锁.

作为一个现实中互斥器的例子, 想象一下在某个会议的一次小组座谈会中, 只有一个麦克风.
如果一位成员要发言, 他必须请求或表示希望使用麦克风.
一旦得到了麦克风, 他可以畅所欲言, 然后将麦克风交给下一位希望讲话的成员.
如果一位成员结束发言后忘记将麦克风交还, 其他人将无法发言.
如果对共享麦克风的管理出现了问题, 座谈会将无法如期进行!

正确的管理互斥器异常复杂, 这也是许多人之所以热衷于`通道`的原因.
然而, 在 Rust 中, 得益于类型系统和所有权, 我们不会在`锁`和`解锁`上出错.

## `Mutex<T>`的 API

作为展示如何使用`互斥器`的例子, 让我们从在单线程上下文使用`互斥器`开始, 如示例 16-12 所示:

文件名: src/main.rs

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```

示例 16-12: 出于简单的考虑, 在一个单线程上下文中探索 `Mutex<T>` 的 API

像很多类型一样, 我们使用关联函数 `new` 来创建一个 `Mutex<T>`.
使用 `lock` 方法获取锁, 以访问互斥器中的数据.
这个调用会`阻塞`当前线程, 直到我们拥有锁为止.

如果另一个线程拥有锁, 并且那个线程 `panic` 了, 则 `lock` 调用会失败.
在这种情况下, 没人能够再获取锁, 所以这里选择 `unwrap` 并在遇到这种情况时使线程 `panic`.

一旦获取了`锁`, 就可以将`返回值`(在这里是 `num`)视为指向其内部数据的可变引用了.
`类型系统` 确保了我们在使用 `m` 中的值之前获取锁: `Mutex<i32>` 并不是一个 `i32`,
所以 `必须` 获取`锁`才能使用其中的 `i32` 值.
我们是不会忘记这么做的, 因为否则类型系统将拒绝访问内部的 `i32` 值.

正如你所怀疑的, `Mutex<T>` 是一个`智能指针`.
更准确的说, `lock` 调用 `返回` 一个叫做 `MutexGuard` 的`智能指针`.
这个`智能指针` 实现了 `Deref` 来指向其内部数据;

其也提供了一个 `Drop` 实现当 `MutexGuard` 离开作用域时自动释放锁, 这正发生于示例 16-12 内部作用域的结尾.
为此, 我们不会冒忘记`释放锁`, 因此不会有`阻塞互斥器`, 让其它线程不能使用的风险, 因为`锁的释放`是自动发生的.

丢弃了锁之后, 可以打印出`互斥器`的值, 并发现能够将其内部的 `i32` 改为 `6`.

## 在线程间共享 `Mutex<T>`

现在让我们尝试使用 `Mutex<T>` 在多个线程间共享值.
我们将启动十个线程, 并在各个线程中对同一个计数器值加一, 这样计数器将从 `0` 变为 `10`.
示例 16-13 中的例子会出现编译错误, 而我们将通过这些错误来学习如何使用 `Mutex<T>`, 以及 Rust 又是如何帮助我们正确使用的.

文件名: src/main.rs

```rust
[这些代码不能编译! ]
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap()); // 这里需要解引用
}
```

示例 16-13: 程序启动了 10 个线程, 每个线程都通过 `Mutex<T>` 来增加计数器的值

这里创建了一个 `counter` 变量, 来存放内含 `i32` 的 `Mutex<T>`, 类似示例 16-12 那样.
接下来遍历 `range` 创建了 `10` 个线程. 使用了 `thread::spawn` 并对所有线程使用了相同的闭包:
他们每一个都将调用 `lock` 方法来获取 `Mutex<T>` 上的锁, 接着将互斥器中的值加一.
当一个线程结束执行, `num` 会离开闭包作用域, 并释放锁, 这样另一个线程就可以获取它了.

在主线程中, 我们像示例 16-2 那样收集了所有的 `join` 句柄, 调用它们的 `join` 方法来确保所有线程都会结束.
这时, 主线程会获取`锁`, 并打印出程序的结果.

之前提示过这个例子不能编译, 让我们看看为什么!

```log
error[E0382]: use of moved value: `counter`
  --> src/main.rs:9:36
   |
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here,
in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure
   |
   = note: move occurs because `counter` has type `std::sync::Mutex<i32>`,
which does not implement the `Copy` trait
```

错误信息表明 `counter` 值在上一次循环中被移动了. 所以 `Rust` 告诉我们不能将 `counter 锁`的所有权移动到多个线程中.
让我们通过一个第十五章讨论过的`多所有权`手段来修复这个编译错误.

## 多线程和多所有权

在第十五章中, 通过使用智能指针 `Rc<T>` 来创建引用计数的值, 以便拥有多所有者. 让我们在这也这么做看看会发生什么.
将示例 16-14 中的 `Mutex<T>` 封装进 `Rc<T>` 中, 并在将所有权移入线程之前克隆 `Rc<T>`.
现在我们理解了所发生的错误, 同时也将代码改回使用 `for` 循环, 并保留闭包的 `move` 关键字:

文件名: src/main.rs

```rust
[这些代码不能编译! ]
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

示例 16-14: 尝试使用 `Rc<T>` 来允许多个线程拥有 `Mutex<T>`

再一次编译并...出现了不同的错误! 编译器真是教会了我们很多!

```log
error[E0277]: `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
  --> src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc<std::sync::Mutex<i32>>`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 14:10
counter:std::rc::Rc<std::sync::Mutex<i32>>]`, the trait `std::marker::Send`
is not implemented for `std::rc::Rc<std::sync::Mutex<i32>>`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 14:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`
   = note: required by `std::thread::spawn`
```

哇哦, 错误信息太长不看!
这里是一些需要注意的重要部分: 第一行错误表明

    `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely.

编译器也告诉了我们原因 `` the trait bound `Send` is not satisfied ``.
下一部分会讲到 `Send`: 这是确保所使用的类型 可被用于并发环境的 `trait` 之一.

不幸的是, `Rc<T>` 并不能安全的在线程间共享.
当 `Rc<T>` 管理引用计数时, 它必须在每一个 `clone` 调用时增加计数, 并在每一个克隆被丢弃时减少计数.
`Rc<T>` 并没有使用任何 `并发原语`, 来确保改变计数的操作不会被其他线程`打断`.

在计数出错时可能会导致诡异的 `bug`, 比如可能会造成`内存泄漏`, 或在使用结束之前就丢弃一个值.
我们所需要的是一个完全类似 `Rc<T>`, 又以一种线程安全的方式改变引用计数的类型.

## 原子引用计数 `Arc<T>`

所幸 `Arc<T>` 正是 这么一个类似 `Rc<T>` 并可以安全的用于并发环境的类型.
字母 `"a"` 代表 `原子性`(atomic), 所以这是一个`原子引用计数`(atomically reference counted)类型.
`原子性`是另一类这里还未涉及到的`并发原语`: 请查看标准库中 `std::sync::atomic` 的文档来获取更多细节.
其中的要点就是: `原子性类型`工作起来类似原始类型, 不过可以`安全的在线程间共享`.

你可能会好奇为什么不是所有的`原始类型`都是`原子性`的?
为什么不是所有标准库中的类型都默认使用 `Arc<T>` 实现?
原因在于`线程安全`带有`性能惩罚`, 我们希望只在必要时才为此买单.
如果只是在单线程中对值进行操作, 原子性提供的保证并无必要, 代码可以因此运行的更快.

回到之前的例子: `Arc<T>` 和 `Rc<T>` 有着相同的 API, 所以修改程序中的 `use` 行和 `new` 调用.
示例 16-15 中的代码最终可以编译和运行:

文件名: src/main.rs

```rust
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0)); // 新建互斥器
    let mut handles = vec![]; // 新建数组用来储存 多线程 handles

    for _ in 0..10 {
        let counter = Arc::clone(&counter); // 原子引用计数克隆, atomic reference count
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap(); // 获取锁, 返回 MutexGuard 智能指针
            *num += 1; // 解引用, ++
        });
        handles.push(handle); // 将 handle push 入 数组
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

示例 16-15: 使用 `Arc<T>` 包装一个 `Mutex<T>` 能够实现在多线程之间共享所有权

这会打印出:

```log
Result: 10
```

成功了! 我们从 `0` 数到了 `10`, 这可能并不是很显眼, 不过一路上我们确实学习了很多关于 `Mutex<T>` 和线程安全的内容!
这个例子中构建的结构可以用于比增加计数更为复杂的操作. 使用这个策略, 可将计算分成独立的部分, 分散到多个线程中,
接着利用 `Mutex<T>`, 使每个线程用各自的计算结果, 更新最终的答案.

## `RefCell<T>`/`Rc<T>` 与 `Mutex<T>`/`Arc<T>` 的相似性

你可能注意到了, 尽管 `counter` 是不可变的, 不过可以获取其内部值的`可变引用`;
这意味着 `Mutex<T>` 提供了内部可变性, 就像 `Cell` 系列类型那样.
正如第十五章中使用 `RefCell<T>` 可以改变 `Rc<T>` 中的内容那样, 同样的可以使用 `Mutex<T>` 来改变 `Arc<T>` 中的内容.

另一个值得注意的细节是 `Rust` 不能避免使用 `Mutex<T>` 的全部逻辑错误.
回忆一下第十五章使用 `Rc<T>` 就有造成引用循环的风险, 这时两个 `Rc<T>` 值相互引用, 造成内存泄漏.
同理, `Mutex<T>` 也有造成 `死锁`(deadlock) 的风险.
这发生于: 当一个操作需要锁住两个资源, 而两个线程各持一个锁, 这会造成它们永远相互等待.
如果你对这个主题感兴趣, 尝试编写一个带有死锁的 Rust 程序,
接着研究任何其他语言中使用`互斥器`的时候, 遵循的死锁规避策略, 并尝试在 Rust 中实现他们.
标准库中 `Mutex<T>` 和 `MutexGuard` 的 API 文档会提供有用的信息.

接下来, 为了丰富本章的内容, 让我们讨论一下 `Send` 和 `Sync` trait,  以及如何对自定义类型使用他们.
