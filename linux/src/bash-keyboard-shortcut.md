# bash 快捷键

[Bash 快捷键大全 ](https://linux. cn/article-5660-1. html)
[vim , vi总是卡死, 终于找到原因了. ](https://www. cnblogs. com/cocoliu/p/6369749. html)

+ `Alt+tab`:切换程序
+ `` Alt+` ``:切换程序的不同窗口

在`vim`下, 有时候不小心按下了`CTRL-S`--`Suspend(XOFF)`, 会冻结终端的输入, 表现为按什么键都没有反应, 这时候按下`CTRL-Q`即可恢复.

## 常用的

快捷键   ;  快捷键说明

+ `CTRL-/`;  撤消操作, Undo.
+ `ALT-B`;  光标往回跳一个词, 词以非字母为界(跳动到当前光标所在词的开头).
+ `ALT-F`;  光标往前跳一个词(移动到光标所在词的末尾).
+ `ALT-D`;  删除光标所在位置到光标所在词的结尾位置的所有内容
+ `ALT-BASKSPACE`;  删除光标所在位置到词开头的所有内容.

+ `ALT-数值`;  这个数值可以是正或者是负, 这个键单独没有作用, 必须后面再接其他内容, 如果后面是字符, 则表示重复次数.
    如:`[ALT-9, k]`则光标位置会插入`9`个`k`字符(负值在这种情况下无效);
    如果后面接的是命令, 则数字会影响后面命令的执行结果, 如:`[ALT-9, CTRL-D]` 则向 `CTRL-D` 默认方向相反(负数)的方向执行`9`次操作.

+ `ALT-<`;  移动到历史记录中的第一行命令.
+ `ALT->`;  移动到历史的最后一行, 即当前正在输入的行(没有输入的情况下为空).
+ `ALT-P`;  从当前行开始向前搜索, 有必要则向"上"移动, 移动时, 使用非增量搜索查找用户提供的字符串.
+ `ALT-N`;  从当前行开始向后搜索, 如果有必要向"下"移动, 移动时, 使用非增量搜索查找用户提供的字符串.
+ `ALT-?`;  列出能够补全标志点前的条目.
+ `ALT-C`;  将光标所在位置的字母转为大写
+ `ALT-U`;  将光标所在位置到词尾的所有字母转为大写.
+ `ALT-L`;  将光标位置到词尾的所有字母转为小写.
+ `ALT-R`;  取消所有变更, 并将当前行恢复到在历史记录中的原始状态
+ `ALT-T`;  当光标两侧都存在词的时候, 交换光标两侧词的位置. 如:`abc <ALT-T>bcd -> bcd abc|`
+ `ALT-. `;  使用前一次命令的最后一个词(命令本身也是一个词, 参见后一篇的Bang命令中的词指示符概念).

+ `CTRL-A`;  将光标移到行首(在命令行下)
+ `CTRL-C`;  中断, 终结一个前台作业.
+ `CTRL-E`;  将光标移动到行尾(在命令行下)
+ `CTRL-K`;  在控制台或 xterm 窗口输入文本时, `CTRL-K`会删除从光标所在处到行尾的所有字符.
+ `CTRL-U`;  擦除从光标位置开始到行首的所有字符内容.
+ `CTRL-W`;  `CTRL-W` 会删除从在光标处往回的第一个空白符之间的内容
+ `CTRL-Y`;  将之前已经清除的文本粘贴回来(主要针对`CTRL-U`或`CTRL-W`).
+ `CTRL-N`;  每按一次, 是更接近的一条命令.
+ `CTRL-P`;  此快捷键召回的顺序是由近及远的召回,
+ `ALT-*`;  把能够补全[`ALT-?`]命令能生成的所有文本条目插入到标志点前.
+ `CTRL-Q`;  `Resume (XON)`. 恢复/解冻, 这个命令是恢复终端的stdin用的, 可参见`CTRL-S`.

+ `CTRL-R`;  回溯搜索(Backwards search)history缓冲区内的文本(在命令行下).
注意:按下之后, 提示符会变成`(reverse-i-search)'':`输入的搜索内容出现在单引号内, 同时冒号后面出现最近最匹配的历史命令.

+ `CTRL-S`;  `Suspend(XOFF)`, 挂起. 这个是冻结终端的`stdin`. 要恢复可以按`CTRL-Q`.
+ `CTRL-T`;  交换光标位置与光标的前一个位置的字符内容(在命令行下)
+ `CTRL-\`;  退出. 和`CTRL-C`差不多, 也可能dump一个"core"文件到你的工作目录下(这个文件可能对你没用).

### 终端快捷键

+ 快捷键 ;  快捷键说明
+ ------------- ;  ----------------------
+ `Ctrl+Shift+t`;  new tab
+ `Ctrl+Shift+n`;  new window
+ `Ctrl+Shift+w`;  close tab
+ `Ctrl+Shift+q`;  close window
+ `Ctrl+page up`;  switch to previous tab
+ `Ctrl+Shift+page up`;  switch to the left

## 其他快捷键

快捷键  ;  快捷键说明

+ `CTRL-A` ;  将光标移到行首(在命令行下)
+ `CTRL-B` ;  退格 (非破坏性的), 这个只是将光标位置往回移动一个位置.
+ `CTRL-C` ;  中断, 终结一个前台作业.
+ `CTRL-D` ;  "EOF" (文件结尾:end of file). 它用于表示标准输入(`stdin`)的结束.
+ `CTRL-E` ;  将光标移动到行尾(在命令行下)
+ `CTRL-F` ;  将光标向前移动一个字符(在命令行下)
+ `CTRL-G` ;  `BEL`. 在一些老式打印机终端上, 这会引发一个响铃. 在xterm终端上可能是哔的一声.
+ `CTRL-H` ;  擦除(Rubout)(破坏性的退格). 在光标往回移动的时候, 同时擦除光标前的一个字符.
+ `CTRL-I` ;  水平制表符.
+ `CTRL-J` ;  新行(`换行[line feed]`并到行首). 在脚本中, 也可能表示为八进制形式(`'\012'`)或十六进制形式(`'\x0a'`).
+ `CTRL-K` ;  垂直制表符(Vertical tab). 在控制台或 xterm 窗口输入文本时, `CTRL-K`会删除从光标所在处到行尾的所有字符.
+ `CTRL-L` ;  跳纸, 换页(Formfeed), 清屏. 清空终端屏幕.
在终端上, 这个命令的作用和`clear`命令一样. 但当这个命令发送到打印机时, `Ctrl-L`会直接跳到纸张(Paper sheet)的末尾.

+ `CTRL-M` ;  回车(Carriage return).
+ `CTRL-N` ;  擦除从history缓冲区召回的一行文本(在命令行下). 如果当前输入是历史记录中选择的时候, 这个是从这个历史记录开始, 每按一次, 是更接近的一条命令.
+ `CTRL-O` ;  产生一个新行(在命令行下).
+ `CTRL-P` ;  从history缓冲区召回上一次的命令(在命令行下).
此快捷键召回的顺序是由近及远的召回, 即按一次, 召回的是前一次的命令, 再按一次, 是召回上一次之前的命令,
这和`CTRL-N`都是以当前的输入为起点, 但是两个命令操作刚好相反, `CTRL-N`是从起点开始由远及近(如果起点是历史命令的话).

+ `CTRL-Q` ;  `Resume (XON)`. 恢复/解冻, 这个命令是恢复终端的stdin用的, 可参见`CTRL-S`.
+ `CTRL-R` ;  回溯搜索(Backwards search)history缓冲区内的文本(在命令行下).
注意:按下之后, 提示符会变成`(reverse-i-search)'':`输入的搜索内容出现在单引号内, 同时冒号后面出现最近最匹配的历史命令.

+ `CTRL-S` ;  `Suspend(XOFF)`, 挂起. 这个是冻结终端的`stdin`. 要恢复可以按`CTRL-Q`.
+ `CTRL-T` ;  交换光标位置与光标的前一个位置的字符内容(在命令行下). 比如:`echo $var;`, 假设光标在`a`上, 那么, 按下`C-T`之后, `v`和`a`将会交换位置:`echo $avr;`.
+ `CTRL-U` ;  擦除从光标位置开始到行首的所有字符内容. 在某些设置下, `CTRL-U`会不以光标位置为参考而删除整行的输入.
+ `CTRL-V` ;  在输入文本的时候, 按下`C-V`之后, 可以插入控制字符. 比如:`echo -e '\x0a';`和`echo <CTRL-V><CTRL-J>;`这两种效果一样. 这点功能在文本编辑器内非常有效.
+ `CTRL-W` ;  当在控制台或一个xterm窗口敲入文本时, `CTRL-W` 会删除从在光标处往后(回)的第一个空白符之间的内容.
在某些设置里, `CTRL-W` 删除光标往后(回)到第一个非文字和数字之间的字符.

+ `CTRL-X` ;  在某些文字处理程序中, 这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中.
+ `CTRL-Y` ;  将之前已经清除的文本粘贴回来(主要针对`CTRL-U`或`CTRL-W`).
+ `CTRL-Z` ;  暂停一个前台的作业; 在某些文本处理程序中也作为替换操作; 在MSDOS文件系统中作为EOF(End-of-file)字符.
+ `CTRL-\` ;  退出. 和`CTRL-C`差不多, 也可能dump一个"core"文件到你的工作目录下(这个文件可能对你没用).
+ `CTRL-/` ;  撤消操作, Undo.
+ `CTRL-_` ;  撤消操作.
+ `CTRL-xx`       ;  在行首和光标两个位置间进行切换, 此处是两个`"x"`字符.
+ `ALT-B`  ;  光标往回跳一个词, 词以非字母为界(跳动到当前光标所在词的开头).
+ `ALT-F`  ;  光标往前跳一个词(移动到光标所在词的末尾).
+ `ALT-D`  ;  删除光标所在位置到光标所在词的结尾位置的所有内容(如果光标是在词开头, 则删除整个词).
+ `ALT-BASKSPACE` ;  删除光标所在位置到词开头的所有内容.
+ `ALT-C`  ;  将光标所在位置的字母转为大写(如果光标在一个词的起始位置或之前, 则词首字母大写).
+ `ALT-U`  ;  将光标所在位置到词尾的所有字母转为大写.
+ `ALT-L`  ;  将光标位置到词尾的所有字母转为小写.
+ `ALT-R`  ;  取消所有变更, 并将当前行恢复到在历史记录中的原始状态(前提是当前命令是从历史记录中来的, 如果是手动输入, 则会清空行).
+ `ALT-T`  ;  当光标两侧都存在词的时候, 交换光标两侧词的位置. 如:`abc <ALT-T>bcd -> bcd abc|`
+ `ALT-. `  ;  使用前一次命令的最后一个词(命令本身也是一个词, 参见后一篇的Bang命令中的词指示符概念).
+ `ALT-_`  ;  同`ALT-. `.
+ `ALT-数值`      ;  这个数值可以是正或者是负, 这个键单独没有作用, 必须后面再接其他内容, 如果后面是字符, 则表示重复次数.
如:`[ALT-10, k]`则光标位置会插入`10`个`k`字符(负值在这种情况下无效);
如果后面接的是命令, 则数字会影响后面命令的执行结果, 如:`[ALT--10, CTRL-D]`则向`CTRL-D`默认方向相反(负数)的方向执行`10`次操作.

+ `ALT-<`  ;  移动到历史记录中的第一行命令.
+ `ALT->`  ;  移动到历史的最后一行, 即当前正在输入的行(没有输入的情况下为空).
+ `ALT-P`  ;  从当前行开始向前搜索, 有必要则向"上"移动, 移动时, 使用非增量搜索查找用户提供的字符串.
+ `ALT-N`  ;  从当前行开始向后搜索, 如果有必要向"下"移动, 移动时, 使用非增量搜索查找用户提供的字符串.

+ `ALT-CTRL-Y`    ;  在标志点上插入前一个命令的第一个参数(一般是前一行的第二个词).
如果有参数`n`, 则插入前一个命令的第`n`个词(前一行的词编号从`0`开始, 见历史扩展).
负的参数将插入冲前一个命令的结尾开始的第n个词.
参数`n`通过`M-No. `的方式传递, 如:`[ALT-0, ALT-CTRL-Y]`插入前一个命令的第`0`个词(命令本身).

+ `ALT-Y`  ;  轮询到删除环, 并复制新的顶端文本. 只能在`yank[CTRL-Y]`或者`yank-pop[M-Y]`之后使用这个命令.
+ `ALT-?`  ;  列出能够补全标志点前的条目.
+ `ALT-*`  ;  把能够补全[`ALT-?`]命令能生成的所有文本条目插入到标志点前.
+ `ALT-/`  ;  试图对标志点前的文本进行文件名补全. `[CTRL-X, /]`把标志点前的文本当成文件名并列出可以补全的条目.
+ `ALT-~`  ;  把标志点前的文本当成用户名并试图进行补全. `[CTRL-X, ~]`列出可以作为用户名补全标志点前的条目.
+ `ALT-$`  ;  把标志点前的文本当成Shell变量并试图进行补全. `[CTRL-X, $]`列出可以作为变量补全标志点前的条目.
+ `ALT-@`  ;  把标志点前的文本当成主机名并试图进行补全. `[CTRL-X, @]`列出可以作为主机补全标志点前的条目.
+ `ALT-!`  ;  把标志点前的文本当成命令名并试图进行补全.
进行命令名补全时会依次使用别名, 保留字, Shell函数, shell内部命令, 最后是可执行文件名.
+ `[CTRL-X, !]`把标志点前的文本当成命令名并列出可补全的条目.

+ `ALT-TAB`;  把标志点前的文本与历史记录中的文本进行比较以寻找匹配的并试图进行补全.
+ `ALT-{` ;  进行文件名补全, 把可以补全的条目列表放在大括号之间, 让shell可以使用.

***

+ 在控制台或`xterm` 窗口输入文本时, `CTRL-D` 删除在光标下的字符. 从一个shell中退出 (类似于`exit`).
如果没有字符存在, ``CTRL-D`` 则会登出该会话. 在一个xterm窗口中, 则会产生关闭此窗口的效果.

+ `CTRL-K`; 在脚本中, 也可能表示为八进制形式(`'\013'`)或十六进制形式(`'\x0b'`).
在脚本中, `CTRL-K`可能会有不一样的行为, 下面的例子给出其不一样的行为:

```bash
#!/bin/bash
## 一个`CTRL-K`垂直制表符的例子
var=$'\x0aBottom Line\x0bTop line\x0a'
## 直接输出
echo "$var"
## 使用col来过滤控制字符
echo "$var" | col
## 上面的显示将会不一样
exit 0
```

## 图形界面快捷键

+ 不同`workspace`导航; ubuntu: `Super+PageUp/PageDown`; manjaro: `Ctrl+Super+Left/Right/Up/Down`
+ 将应用窗口移动到不同的`workspace`; ubuntu: `Shit+Super+ PageUp/PageDown`; manjaro: `Ctrl+Shift+Super+Left/Right/Up/Down`
