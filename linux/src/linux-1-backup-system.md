# ubuntu 备份和恢复

教程中排除的目录

```bash
--exclude=/proc
--exclude=/tmp
# --exclude=/home
--exclude=/lost+found
--exclude=/media
--exclude=/mnt
--exclude=/run
--exclude=/sys
```

## 备份方法1

### 分区信息

可以用 `ubuntu18.04` 自带软件`gnome-disks`查看自己系统分区情况:
在新电脑上, 可以用`GParted`对硬盘进行分区.
首先记录一些重要的硬件 id 信息.

+ 分区 id 记录

设备 挂载点 原始uuid 分区格式 新uuid new设备

`/boot/efi` 2EEE-149A `FAT (32-bit version)`
`none` 3278e9ef-8c04-4eaa-bfde-af2313f36545 `Swap`
`/`  7aba3e2f-f94d-454c-9ad6-9098d658401a `Ext4`

### 制作备份

+ 首先启动 `live CD`, 选择`try Ubuntu`;

+ 挂载需要备份的分区, 但无需挂载`swap`, 它只是用作虚拟内存.
结合我们之前创建的表, 更容易理解下面的挂载命令:

    ```bash
    #获取最高权限
    sudo su
    # 在 mnt 下创建 root 目录和 efi 目录, 分别用来挂载原系统的 root 分区和 efi 分区
    mkdir /mnt/root   /mnt/efi  /mnt/home
    # 将原系统根分区挂载到 /mnt/root 目录
    mount /dev/sdb5   /mnt/root
    #将原系统的 boot/efi 分区挂载到 /mnt/efi 目录
    mount /dev/sda2   /mnt/efi
    # 将原系统的 home 分区挂载到 /mnt/home
    mount /dev/sdb6   /mnt/home
    ```

+ 插入U盘或硬盘开始备份:

    ```bash
    # 将 root, home 和 efi 分区分别备份到硬盘中
    mksquashfs /mnt/root    /media/ubuntu/<移动硬盘/备份目录>/root.sfs
    mksquashfs /mnt/efi     /media/ubuntu/<移动硬盘/备份目录>/efi.sfs
    mksquashfs /mnt/home    /media/ubuntu/<移动硬盘/备份目录>/home.sfs
    # 确保改动写入硬盘
    sync
    # 卸载刚刚挂载的分区和硬盘
    umount /media/ubuntu/* /mnt/*
    ```

`root`, `home`和`efi`分区备份完成.

### 对新硬盘进行分区

在新电脑上启动live CD, 选择试用, 打开live CD中自带分区工具`GParted`, 对新电脑进行分区, 分区大小根据个人情况而定, 参照之前填的表:

```bash
efi分区
swap分区,如果不需要休眠, 其实不用分这个, 而且固态硬盘不分这个比较好
root分区(主分区或逻辑分区无所谓)
home分区(主分区或逻辑分区无所谓)
```

### 将备份文件恢复到各个分区

使用`live CD`自带软件`gnome-disks`查看新分区的信息, 完善之前的表, 我的情况如下:

插入存有备份文件的移动硬盘开始恢复备份:

```bash
sudo su
#-- 在mnt下创建root, home和efi目录, 分别用来挂载新电脑的root, home和efi分区
mkdir /mnt/root /mnt/efi  /mnt/home
#-- 挂载新电脑的根分区到/mnt/root目录
mount /dev/sdc5 /mnt/root
#-- 挂载新电脑的efi分区到/mnt/efi
mount /dev/sdc1 /mnt/efi
#-- 挂载新电脑home分区到/mnt/home
mount /dev/sdc6 /mnt/home
#-- 新建/backup/root/, /backup/home和/backup/efi目录,使用loop模式将之前准备好的sfs文件挂载到对应的目录下
mkdir /backup
cd /backup
mkdir root efi home
mount -o loop /media/ubuntu/存放备份文件的路径/root.sfs /backup/root
mount -o loop /media/ubuntu/存放备份文件的路径/efi.sfs  /backup/efi
mount -o loop /media/ubuntu/存放备份文件的路径/home.sfs  /backup/home
#-- 开始恢复
cp -a /backup/root/* /mnt/root
cp -a /backup/efi/* /mnt/efi
cp -a /backup/home/* /mnt/home
# -- 同步数据并取消挂载
sync
umount /backup/*
umount /mnt/*
umount /media/ubuntu/*
```

### 启动引导修复

恢复完成之后, 开始来修改引导文件.
首先使用 `/mnt` 目录来挂载新电脑完整的 `文件系统`, 再次掏出我们之前填好的表:

```bash
sudo su
# -- 移除之前创建的临时文件夹
rm -r /mnt/root /mnt/efi /mnt/home
# -- 首先挂载新电脑的根目录
mount /dev/sdc5 /mnt
#-- 挂载efi
mount /dev/sdc1 /mnt/boot/efi
# -- 挂载home
mount /dev/sdc6 /mnt/home
# 接下来挂载虚拟文件系统, 为后面的修复做准备
mount --o bind /dev   /mnt/dev
mount --o bind /proc   /mnt/proc
mount --o bind /sys   /mnt/sys
# 将 liveCD 的根目录改为新电脑的根目录确保之后的操作安全. (这里也请大佬指点, 是否只是安全? )
# chroot /mnt
```

接下来要修改两个文件, 分别位于新电脑的`/etc/fstab`和`/boot/grub/grub.cfg`(不用手动修改), 
接下来我们再次掏出我们的表:

```bash
# -- 用nano编辑器打开/etc/fstab
nano /etc/fstab
```

按照提示和`uuid`变化的对照表, 修改 `root`, `/boot/efi`, `/home` 等的 `uuid`
`/boot/grub/grub.cfg` 这个文件是用 `grub-mkconfig` 自动生成的, 所以不需要手动修改.

然后一定要更新 `grub` 引导:

```bash
# -- grub安装到efi分区
grub-install /dev/sdc1
update-grub
sync #确保数据写入硬盘
#-- 退出chroot
exit
umount /mnt/*/media/ubuntu/*
exit
reboot
```

系统重启后拔出你的 `live CD`, 不出意外电脑开机将会进入你备份恢复完成的新电脑.

>refs:[GRUB#Generated_grub.cfg](https://wiki.archlinux.org/title/GRUB#Generated_grub.cfg)
>It is automatically generated by grub-mkconfig using templates  from /etc/grub.d and settings from /etc/default/grub

### mksquashfs 命令

`mksquashfs`; 创建和追加到 `squashfs` 文件系统的工具

+ 说明

    ```bash
    mksquashfs SOURCE [SOURCE2 ...] DESTINATION [OPTIONS].
    ```

+ 描述; `Squashfs` 是用于 `Linux` 的高度压缩的 `只读文件系统`.
它使用 `zlib` 压缩技术来压缩 `files,`, `inodes` 和 `目录`.
此文件系统中的 `inodes` 非常小, 所有的块都被打包以减少数据开销(data overhead).
支持大于 `4K` 的 `块`(Block), 最大为 `64K`.

`Squashfs` 旨在用于一般的 `只读文件系统`, 用于 `存档`(即可使用 `.tar.gz` 文件的情况),
以及在需要低开销的受限 `块设备`/`内存系统`(如 `嵌入式系统`)中.

### 问题排查

如果 无法开机/开机时间过长, 首先确保`/etc/fstab`中的硬盘`uuid`没有写错 (使用 liveCD进入系统查看).

使用下面命令查看问题

```bash
systemd-analyze
systemd-analyze blame
systemd-analyze critical-chain
## 以及
sudo cat /var/log/boot.log | less
```

如果之前有`swap`分区, 还原的时候没有 `swap` 分区, 修改 `initramfs`配置:

```bash
sudo vim /etc/initramfs-tools/conf.d/resume
#在文件中添加一行
RESUME=none
sudo update-grub
sudo update-initramfs -u
```

以下命令在排除错误时可能用到

```bash
sudo blkid
sudo fdisk -l
sudo dmesg
```

[Ubuntu 18.04 如何添加或删除 SWAP 交换分区](https://www.sysgeek.cn/ubuntu-18-04-swap/)
[Linux系统制作Ubuntu18.04启动盘](https://blog.csdn.net/xiaoma_2018/article/details/85059930)

```bash
# 插入U盘, 在Linux系统中打开终端, 查看 U 盘信息:
sudo fdisk -l
# 然后卸载掉 U 盘:
sudo umount /dev/sdb*
# U 盘格式化:
sudo mkfs.vfat /dev/sdb -I # 使用 -I 选项创建
#完成格式化后查看磁盘信息:
# 最后使用 dd 命令制作启动盘:
sudo dd if=ubuntu-18.04.1-desktop-amd64.iso of=/dev/sdb bs=10M
```

## 备份说明2

[Ubuntu系统备份](https://zhuanlan.zhihu.com/p/51827233)

备份前可以先清理一下缓存

```bash
# 清理旧版本的软件缓存
sudo apt-get autoclean
# 清理所有软件缓存
sudo apt-get clean
# 删除系统不再使用的孤立软件
sudo apt-get autoremove
```

ubuntu 秉承一切皆文件的思想, 系统备份就相当于把整个 `/`(根目录)所有文件打包压缩保存

主要有两种方式备份还原:

+ `tar` 命令
+ `livecd` 模式

首先介绍下 `tar` 命令备份

```bash
# 备份前先切换到root用户, 避免权限问题
sudo su
# 再切换到 /(根目录)
cd /
# 备份系统
tar -cvpzf /media/Disk/myDisk/ubuntu_backup@ $(date +%Y-%m+%d).tar.gz --exclude=/proc --exclude=/tmp --exclude=/home --exclude=/lost+found --exclude=/media --exclude=/mnt --exclude=/run /
```

***

tar命令参数:

+ `-c`:  新建一个备份文档
+ `-v`:  显示详细信息
+ `-p`:  保存权限, 并应用到所有文件
+ `-z`:  用 `gzip` 压缩备份文档, 减小空间
+ `-f`:  指定压缩包名称(带路径), 只能做最后一个参数
+ `–exclude`:  排除指定目录, 不进行备份

注意, 如果没有把`/home`或者`/boot`目录单独分一个区, 一定不要加`–exclude=/home`或`–exclude=/boot`参数!

### 文件目录介绍

`/proc`: 一个虚拟文件系统, 系统运行的每一个进程都会自动在这个目录下面创建一个进程目录. 既然是系统自动创建, 也就没必要备份的必要了.
`/tmp`: 一个临时文件夹, 系统的一些临时文件会放在这里.
`/lost+found`: 系统发生错误时(比如非法关机), 可以在这里找回一些丢失文件.
`/media`: 多媒体挂载点, 像u盘, 移动硬盘, windons分区等都会自动挂载到这个目录下.
`/mnt`: 临时挂载点, 你可以自己挂载一些文件系统到这里.
`/run`: 系统从启动以来产生的一些信息文件.
`/home`: 用户家目录, 存放用户个人文件和应用程序.
`/boot`: 和系统启动相关的文件, 像grub相关文件都放在这里, 这个目录很重要!

为了保险起见, 也可以对`/home`和`/boot`备份, 但是备份频率完全没必要和/分区一样高.
比如`/`分区每周备份一次, 那`/home`和`/boot`完全可以一个月备份一次, 因为这两个分区出问题的概率真的很小, 而且变动也不会太频繁.

```bash
tar -cvpzf /media/Disk/my_Disk/ubuntu_home_backup@`date +%Y-%m-%d`.tar.gz /home
tar -cvpzf /media/Disk/myDisk/ubuntu_boot_backup@`date +%Y-%m-%d`.tar.gz /boot
```

***

打包过程中会遇到如下错误或警告信息

```bash
tar: Exiting with failure status due to previous errors
```

这个问题其实不是真正的错误信息,  真正的错误信息混杂在标准输出(stout)中, 重新执行命令并把`v`参数去掉即可看到真正问题所在.

```bash
tar: Removing leading '/' from member names
#或
tar: Removing leading '/' from hard link targets
```

这个问题其实不影响程序的执行, 产生的原因是`tar`在压缩的过程中自动帮我们去掉了路径前的`/`, 也就是tar压缩后的包是按照相对路径压缩的.
 当我们恢复时,  就需要通过 `-C` 参数手动指定解压到 `/` 目录,  如:

```bash
tar zxvpf ubuntu_20170120_11.tar.bz2 -C /
```

可以使用`-P`参数来指定按照绝对路径打包:

```bash
tar -cvpzf /media/Disk/myDisk/ubuntu_backup@`date +%Y-%m+%d`.tar.gz --exclude=/proc --exclude=/tmp --exclude=/home --exclude=/lost+found --exclude=/media --exclude=/mnt --exclude=/run -P /
```

另外, 如果出现

```bash
tar: /dev/shm: file changed as we read it
或
tar: /run/udev/control: socket ignored
```

这个 `socket ignored` 产生的原因是压缩的过程中文件正在使用, 无需理会, 不影响压缩.

```bash
tar: /run/user/1000/gvfs: Cannot stat: Permission denied
```

这个问题不用理会, 与虚拟文件系统有关, 不影响压缩.

### Ubuntu系统U盘方式备份(livecd)

启动过程中从U盘启动, 采用试用Ubuntu系统的方式, 进入`livecd`模式(试用ubuntu)

```bash
sudo su
fdisk -l
```

其中`boot`分区为`/dev/sda5`,`home`分区为`/dev/sda7`,主分区`/`为`/dev/sda8`.

分别进行挂载:

```bash
mount /dev/sda5 /boot
mount /dev/sda7 /home
mount /dev/sda8 /mnt
```

再对移动硬盘进行挂载:

```bash
mount /media/ubuntu/移动硬盘对应盘符 /data
```

进行备份:

```bash
mksquashfs /mnt /data/ubuntu_main.sfs(文件名任意)
mksquashfs /home /data/ubuntu_home.sfs(文件名任意)
mksquashfs /boot /data/ubuntu_boot.sfs(文件名任意)
sync(让系统保存一下数据)
```

卸载硬盘:

```bash
umount /data
umount /mnt
umount /home
umount /boot
```

到此备份成功.

## 系统还原

系统备份的意义就在于系统哪天发生意外时可以系统还原拯救回来

这里有两种还原方式, 如果你系统出问题了, 但是还可以进入终端, 那就可以直接解压备份文件进行还原.
但是如果你连系统都不能登录了, 就要使用`LiveCD`(U盘启动盘)进行还原了.

### tar命令还原系统

```bash
# 备份前先切换到`root`用户, 避免权限问题
sudo su
# 再切换到/(根目录)
cd /
# 还原
tar -xvpzf /media/Disk/myDisk/ubuntu_backup@2016-6-6.tar.gz -C /
```

注意先创建一个临时目录用于挂载你的`/`根目录分区, `sdaX`代表你的`/`根目录分区,
如果不知道就用`fdisk -l`查看一下, 另外如果你的移动硬盘没有被自动挂载, 你也需要手动创建一个临时目录进行挂载.

Note:
因为 tar还原是只会覆盖相同的文件, 但是这种方法只是恢复备份时的文件, 就是说如果某些文件丢失或损坏了, 这样可以恢复修复这些文件, 但不能删除自备份到恢复前这期间所生成的其它文件.
假如你备份系统时有`1234`这四个文件, 如果三天后, 由于某些原因变成了`1234'5`(`4`改变了), 你恢复后, 就会变成`12345`, 其中`4'`恢复成备份时的文件, `5`保留.
所以大家要是想彻底还原成备份时候的样子最好彻底删除根目录下的所有文件, 然后再还原, 这样就可以还原成备份时的样子了.
删除整个文件系统, 比如运行命令`rm -fr /*`, 那么你还原系统后一定要把你之前没有备份的目录手动创建, 不然重启系统是有问题的.

```bash
mkdir proc tmp lost+found media mnt run
```

***
进入 LiveCD 之后 还原系统

```bash
#切换到root用户
sudo su
#进入到 / 目录
cd /
mkdir /mnt/sys
mount /dev/sdaX /mnt/sys
tar -xvpzf /media/myDisk/ubuntu_boot_backup@2016-6-6.tar.gz -C /mnt/sys
```

执行恢复命令之前请再确认一下你所键入的命令是不是你想要的, 执行恢复命令可能需要一段不短的时间.

恢复命令结束时, 你的工作还没完成, 别忘了重新创建那些在备份时被排除在外的目录:

```bash
mkdir proc
mkdir lost+found
mkdir mnt
mkdir sys
```

当你重启电脑, 你会发现一切东西恢复到你创建备份时的样子了!

### livecd 还原

还有一个稍微复杂点的`livecd`方式还原, 如下:

先要对之前的启动文件和分区文件做一个备份, 分别为`/etc/fstab`,`/etc/fstab.d`(可能没有),`/boot/grub/grub.cfg`:

```bash
cp /etc/fstab /media/用户名/移动硬盘对应盘符/
cp /boot/grub/grub.cfg /media/用户名/移动硬盘对应盘符/
```

接下来进行恢复系统, 同样利用系统`u`盘进入`livecd`模式. 同样进入`root`模式, 查看分区情况

假设分区情况如上: `/dev/sda1`为`boot`分区, `/dev/sda2`为主分区, `/dev/sda3`为`home`分区. 对`home`分区和主分区进行格式化:

```bash
sudo su
mkfs.ext4 /dev/sda2 # root
mkfs.ext4 /dev/sda3 # home
```

然后分别进行挂载:

```bash
mount /dev/sda2 /mnt #挂载 root
# 新建home和boot文件:
mkdir /mnt/home
mkdir /mnt/boot
#挂载其他两个盘:
mount /dev/sda1 /mnt/boot #挂载 boot
mount /dev/sda3 /mnt/home # 挂载 home
# 挂载数据盘:
mkdir /rescovery/mnt
mkdir /rescovery/home
mkdir /rescovery/boot
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_main.sfs /rescovery/mnt  # 这里使用了 loop mount, 循环挂载
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_home.sfs /rescovery/home
mount -o loop /media/ubuntu/移动硬盘盘符/ubuntu_boot.sfs /rescovery/boot
```

```bash
cp -a /recovery/mnt/* /mnt
cp -a /recovery/home/* /mnt/home
cp -a /recovery/boot/* /mnt/boot
# 然后拷贝之前的fstab和grub.cfg文件到硬盘:
cp /media/ubuntu/移动硬盘盘符/fstab /mnt/etc/
cp /media/ubuntu/移动硬盘盘符/grub.cfg /mnt/boot/grub/
# 挂载虚拟文件系统, 这是为了后面修复引导做准备.
mount --bind /dev /mnt/dev
mount --bind /proc /mnt/proc
mount --bind /sys /mnt/sys
# chroot进入已经还原的操作系统.
chroot /mnt
```

## 查看当前UUID

由于我们格式化了分区, 所以`UUID`发生了变化, 若不修改, 系统将无法正常挂载分区, 导致启动异常.
故需要修改本机系统的`UUID`设置,当前终端不要关闭, 新建一个终端, 输入`blkid`:

在`fstab`文件中更新上面两个新硬盘的`UUID`,在`chroot`过的端口输入:

```bash
nano /etc/fstab
# 更改两个UUID, ctrl+x退出, Y保存. 进行grub的更新:
grub-install /dev/sda
update-grub
退出并卸载盘:
exit
umount /mnt/dev
umount /mnt/sys
umount /proc
sync
```

重启即可

## mount 简介

`-o --options opts`:使用指定的安装选项.  `opts`参数是用逗号分隔的列表.  例如:

```bash
mount LABEL=mydisk -o noatime,nodev,nosuid
```

复制文件:

在其他位置重新挂载文件结构的一部分.  语法是:

```bash
mount --bind olddir newdir
```

或使用以下`fstab`条目:

```bash
/olddir /newdir none bind
```

调用之后, 可以在两个位置访问相同的内容.

重要的是要理解`bind`不会在`kernel VFS`中创建任何`second-class `或`special node`.
`bind`只是`attach`文件系统的另一种操作. 没有一个特定的地方去记录哪些文件系统是通过`bind`附加到系统上的.
`olddir` 和 `newdir` 是独立的, 并且可以卸载`olddir`.

也可以将单个文件重新挂载(在单个文件上).  也可以使用`bind`从常规目录创建`mountpoint`, 例如:

```bash
mount --bind foo foo
```
