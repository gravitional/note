# linux-5

## 权限

Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统,区别在于它们不仅是多任务系统,而且也是多用户系统.
这到底意味着什么?它意味着多个用户可以在同一时间使用同一台计算机.

例如,如果一台 计算机连接到一个网络或者因特网,那么远程用户通过`ssh`(安全 shell)可以登录并操纵这台电脑.
事实上,远程用户也能运行图形界面应用程序,并且图形化的输出结果会出现在远端的显示器上.
`X`窗口系统把这个作为基本设计理念的一部分,并支持这种功能.

在这一章中,我们将看看这一系统安全的本质部分,会介绍以下命令:

+ `id` – 显示用户身份号
+ `chmod` – 更改文件模式
+ `umask` – 设置默认的文件权限
+ `su` – 以另一个用户的身份来运行 shell
+ `sudo` – 以另一个用户的身份来执行命令
+ `chown` – 更改文件所有者
+ `chgrp` – 更改文件组所有权
+ `passwd` – 更改用户密码

### 拥有者,组成员,和其他人

在第四章探究文件系统时,当我们试图查看一个像`/etc/shadow`那样的文件的时候,我们会遇到一个问题.

```bash
file /etc/shadow
/etc/shadow: regular file, no read permission
less /etc/shadow
/etc/shadow: Permission denied
```

产生这种错误信息的原因是,作为一个普通用户,我们没有权限来读取这个文件.

在 Unix 安全模型中,一个用户可能拥有文件和目录.
当一个用户拥有一个文件或目录时, 用户可以设置这个文件或目录的访问权限.
用户,反过来又属于用户组(由一个或多个用户组成),文件和目录的owner 可以对用户组成员授予对这些文件和目录的访问权限.
除了对一个用户组授予权限之外,owner 还能给其他人授予一些权限.在 Unix 术语中,每个人 是指整个世界.

可以用 `id` 命令,来找到关于你自己身份的信息:

```bash
id
uid=500(me) gid=500(me) groups=500(me)
```

让我们看一下输出结果.
当用户创建帐户之后,系统会给用户分配一个号码,叫做用户 `ID` 或者 `uid`,然后,为了符合人类的习惯,这个 `ID` 映射到一个用户名.

系统又会给这个用户分配一个原始的组 `ID` 或者是 `gid`,这个 `gid` 可能属于另外的组.

上面的例子来自于 `Fedora` 系统, 比方说 `Ubuntu` 的输出结果可能看起来有点儿不同:

```bash
id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
```

正如我们能看到的,两个系统中用户的 `uid` 和 `gid` 号码是不同的.
原因很简单,因为 `Fedora` 系统 从500开始进行普通用户帐户的编号,而 `Ubuntu` 从1000开始.
我们也能看到 `Ubuntu` 的用户属于 更多的用户组.这和`Ubuntu` 管理系统设备和服务权限的方式有关系.

那么这些信息来源于哪里呢?像 `Linux` 系统中的许多东西一样,来自一系列的文本文件.

用户帐户定义在 `/etc/passwd` 文件里面,用户组定义在` /etc/group` 文件里面.

当用户帐户和用户组创建以后, 这些文件随着文件 `/etc/shadow` 的变动而修改,文件 /`etc/shadow` 包含了关于用户密码的信息.

对于每个用户帐号,文件`/etc/passwd` 定义了用户(登录)名,`uid`,`gid`,帐号的真实姓名,家目录, 和登录 `shell`.如果你查看一下文件`/etc/passwd` 和文件`/etc/group` 的内容,你会注意到除了普通 用户帐号之外,还有超级用户(`uid 0`)帐
号,和各种各样的系统用户.

在下一章中,当我们讨论进程时,你会知道这些其他的`用户`是谁,实际上,他们相当忙碌.

然而许多像 Unix 的系统会把普通用户分配到一个公共的用户组中,例如`users`,
现在的 Linux 会创建一个独一无二的,只有一个成员的用户组,这个用户组与用户同名.
这样使某种类型的 权限分配更容易些.

### 读取,写入,和执行

对于文件和目录的访问权力是根据读访问,写访问,和执行访问来定义的.
如果我们看一下 `ls` 命令的输出结果,我们能得到一些线索,这是怎样实现的:

```bash
> foo.txt
ls -l foo.txt
-rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt
```

列表的前十个字符是文件的属性.这十个字符的第一个字符表明文件类型.
下表是你可能经常看到 的文件类型(还有其它的,不常见类型):

***
属性 文件类型

+ `-` 一个普通文件
+ `d` 一个目录
+ `l` 一个符号链接.注意对于符号链接文件,剩余的文件属性总是`rwxrwxrwx`,而且都是 虚拟值.
真正的文件属性是指符号链接所指向的文件的属性.
+ `c` 一个字符设备文件.这种文件类型是指按照字节流,来处理数据的设备. 比如说终端机,或者调制解调器
+ `b` 一个块设备文件.这种文件类型是指按照数据块,来处理数据的设备,例如一个硬盘,或者 CD-ROM 盘.

剩下的九个字符,叫做文件模式,代表着**文件所有者**,**文件组所有者**,和**其他人**的**读**,**写**,**执行**权限.

### chmod - 更改文件模式

更改文件或目录的模式(权限),可以利用 `chmod` 命令.
注意只有文件的所有者或者超级用户才能更改文件或目录的模式.
`chmod` 命令支持两种不同的方法来改变文件模式:八进制数字表示法,或 符号表示法.

首先我们讨论一下八进制数字表示法.
虽然我们能知道二进制的意义(因为计算机只有一个手指),但是八进制和十六进制对什么 好处呢?
答案是为了人类的便利.许多时候,在计算机中,一小部分数据以二进制的形式表示.

以 `RGB` 颜色为例来说明.
大多数的计算机显示器,每个像素由三种颜色组成:`8`位红色,`8`位绿色, `8`位蓝色.
这样,一种可爱的中蓝色就由24位数字来表示:`010000110110111111001101`

我不认为你每天都喜欢读写这类数字.另一种数字系统对我们更有帮助.
每个十六进制 数字代表四个二进制.在八进制中,每个数字代表三个二进制数字.
那么代表中蓝色的`24`位 二进制能够压缩成`6`位十六进制数:`436FCD`

因为十六进制中的两个数字对应二进制的`8`位数字,我们可以看到`43`代表红色,`6F`代表绿色,`CD`代表蓝色.

现在,十六进制表示法(经常叫做`hex`)比八进制更普遍,但是我们很快会看到,
用八进制 来表示`3`个二进制数非常有用处...

通过八进制表示法,我们使用八进制数字来设置所期望的权限模式.
因为每个八进制数字代表了`3`个二进制数字,这种对应关系,正好映射到用来存储文件模式所使用的方案上.
下表展示了 我们所要表达的意思:

Octal Binary File Mode

+ `0` `000` `---`
+ `1` `001` `--x`
+ `2` `010` `-w-`
+ `3` `011` `-wx`
+ `4` `100` `r--`
+ `5` `101` `r-x`
+ `6` `110` `rw-`
+ `7` `111` `rwx`

+ `r`:`4`
+ `w`:`2`
+ `x`:`1`

通过使用`3`个八进制数字,我们能够设置**文件所有者**,**文件的用户组**,和**其他人**的权限:

```bash
> foo.txt
ls -l foo.txt
chmod 600 foo.txt
```

通过传递参数 `600`,我们能够设置文件所有者的权限为读写权限,而删除**用户组**和**其他人**的所有权限.
虽然八进制到二进制的映射看起来不方便,但通常只会用到一些常见的映射关系:

+ `7`: `rwx`
+ `6` :`rw-`
+ `5`: `r-x`
+ `4`:`r--`
+ `0`:`---`

`chmod` 命令支持一种符号表示法,来指定文件模式.

符号表示法分为三部分: 更改会影响谁, 要执行哪个操作,要设置哪种权限.
通过字符 `u`,`g`,`o`,和 `a`的组合来指定 要影响的对象,如下所示:

+ `u` `user`的简写,意思是文件或目录的所有者.
+ `g` 用户组
+ `o` `others`的简写,意思是其他所有的人
+ `a` `all`的简写,是`u`, `g`和`o`三者的联合

如果没有指定字符,则假定使用`all`.

执行的操作可能是一个`+`字符,表示加上一个权限,
一个`-`,表示删掉一个权限,
或者是一个`=`,表示只有指定的权限可用,其它所有的权限被删除.
权限由 `r`,`w`,和 `x` 来指定.

这里是一些符号表示法的实例:

+ `u+x` 为文件所有者添加可执行权限.
+ `u-x` 删除文件所有者的可执行权限.
+ `+x` 为文件所有者,用户组,和其他所有人添加可执行权限. 等价于 `a+x`.
+ `o-rw` 除了文件所有者和用户组,删除其他人的读权限和写权限.
+ `go=rw` 给群组的主人和任意文件拥有者的人读写权限.如果群组的主人或全局之前已
经有了执行的权限,他们将被移除.
+ `u+x,go=rw` 给文件拥有者执行权限并给组和其他人读和执行的权限.多种设定可以用逗号分开.

一些人喜欢使用八进制表示法, 而另些人真正地喜欢符号表示法.
符号表示法的优点是, 允许你设置文件模式的单个组成部分的属性,而没有影响其他的部分.

要注意`chmod`的`--recursive`选项: 它可以同时作用于文件和目录, 所以它并不是如我们期望的那么有用处,
因为我们很少希望文件和目录拥有同样的权限.

### umask - 设置默认权限

当创建一个文件时,`umask` 命令控制着文件的默认权限.
`umask` 命令使用八进制表示法来表达从文件模式属性中删除一个位掩码.大家看下面的例子:

```bash
rm -f foo.txt
umask
:0002
>foo.txt
ls -l foo.txt
:-rw-rw-r-- 1 me me 0 2008-03-06 14:53 foo.txt
```

首先,删除文件`foo.txt`,确保我们从新开始.下一步,运行不带参数的 `umask` 命令, 看一下当前的掩码值.
`umask`的数值是`0002`(`0022`是另一个常用值),这个数值是掩码的八进制表示形式.
下一步,我们创建文件`foo.txt`,并且保留它的权限.

我们可以看到文件所有者和用户组都得到读权限和写权限,而其他人只是得到读权限.
其他人没有得到写权限的原因是由掩码值决定的.重复我们的实验,这次自己设置掩码值:

```bash
rm foo.txt
umask 0000
> foo.txt
ls -l foo.txt
-rw-rw-rw- me me 0 2008-03-06 14:58 foo.txt
```

当掩码设置为`0000`(实质上是关掉它)之后,我们看到其他人能够读写文件.
为了弄明白这是 怎么回事,我们需要看一下掩码的八进制形式.把掩码展开成二进制形式,然后与文件属性相比较,看看有什么区别:

| | |
|---|---|
| Original file mode | `--- rw- rw- rw-` |
| Mask | `000 000 000 010` |
| Result | `--- rw- rw- r--` |

此刻先忽略掉开头的三个零(我们一会儿再讨论),注意掩码中若出现一个数字`1`,
则 删除文件模式中和这个`1`在相同位置的属性,在这是指其他人的写权限.这就是掩码要完成的任务.
掩码的二进制形式中,出现数字`1`的位置,相应地关掉一个文件模式属性.

看一下掩码0022的作用:

| | |
|---|---|
| Original file mode | `--- rw- rw- rw-` |
| Mask| `000 000 010 010`|
| Result | `--- rw- r-- r--` |

又一次,二进制中数字`1`出现的位置,相对应的属性被删除.
再试一下其它的掩码值(一些带数字7的) ,习惯于掩码的工作原理.当你实验完成之后,要记得清理现场:

```bash
rm foo.txt; umask 0002
```

大多数情况下,你不必修改掩码值,系统提供的默认掩码值就很好了.
然而,在一些高安全级别下,你要能控制掩码值.

### 一些特殊权限

虽然我们通常看到 `八进制` 的 `权限掩码` 用三位数字来表示,但是从技术层面上来讲, 用四位数字来表示它更确切些.
为什么呢? 因为,除了 `读取`,`写入`,和 `执行` 权限之外,还有其它的,较少用到的权限设置.

+ 其中之一是 `setuid` 位(八进制`4000`).
当 `普通用户` 运行 `程序`, 而此 `程序` 由根用户(`root`) 所有, 并设置了 `setuid` 位(`4000`),
那么这个程序运行时就具有超级用户的特权, 这样程序就可以访问普通用户禁止访问的文件和目录.

+ 第二个是 `setgid` 位(八进制`2000`),这个类似 `setuid` 位.
如果设置了 **目录** 的`setgid`位, 则目录中 `新建文件` 的 `用户组` 继承自`父目录`.

+ 第三个是 `sticky` 位(八进制`1000`).
它继承自Unix, 在 Unix 中,它可能把 `可执行文件` 标志为`不可交换的`.
在 Linux 中会忽略文件的 `sticky` 位, 但是如果目录设置了 `sticky` 位, 那么它能阻止用户 `删除` 或 `重命名` 文件,
除非用户是这个 `目录`(文件)的 `所有者`,或是 `超级用户`.
这个经常用来控制访问 `共享目录`,比方说`/tmp`.

这里有一些例子,使用`chmod`命令和符号表示法, 来设置这些特殊的权限.
首先, 授予程序 `setuid` 权限.

```bash
chmod u+s program
```

下一步,授予目录 `setgid` 权限:

```bash
chmod g+s dir
```

最后,授予目录 `sticky` 权限:

```bash
chmod +t dir
```

当浏览 `ls` 命令的输出结果时,你可以确认这些特殊权限.

+ 具有 `setuid`属性的程序:`-rwsr-xr-x`
+ 具有 `setgid`属性的目录:`drwxrwsr-x`
+ 具有 `sticky` 属性的目录:`drwxrwxrwt`

### 更改身份

在不同的时候,我们会发现很有必要具有另一个用户的身份.
经常地,我们想要得到超级 用户特权,来执行一些管理任务,但是也有可能变为另一个普通用户,比如说测试一个帐号.
有三种方式,可以拥有多重身份:

1. 注销系统并以其他用户身份重新登录系统.
2. 使用 `su` 命令.
3. 使用 `sudo` 命令.

我们将跳过第一种方法,因为我们知道怎样使用它,并且它缺乏其它两种方法的方便性.
在我们自己的 `shell` 会话中, `su` 命令允许你,
假定为另一个用户的身份,以这个用户的 `ID` 启动一个新的 `shell` 会话,或者是以这个用户的身份来发布一个命令.

`sudo` 命令允许管理员设置一个叫做`/etc/sudoers`的配置文件,并且定义了一些具体命令,特殊用户可以执行这些命令.
选择使用哪个命令,很大程度上是由你使用的 `Linux` 发行版来决定的.
你的发行版可能这两个命令都包含,但系统配置可能会偏袒其中之一.我们先介绍 `su` 命令.

#### su - 以其他用户身份和组ID运行一个shell

su 命令用来以另一个用户的身份来启动 shell.这个命令语法看起来像这样:

```bash
su [-[l]] [user]
```

如果包含`-l`选项,那么会为指定用户启动一个需要登录的 `shell` .
这意味着会加载此用户的 `shell` 环境, 并且工作目录会更改到这个用户的家目录.这通常是我们所需要的.
如果不指定用户,那么就假定是超级用户.
注意,选项`-l`可以缩写为`-`,这是经常用到的形式.启动超级用户的 shell, 我们可以这样做:

```bash
su -
Password:
[root@linuxbox ~]#
```

按下回车符之后,`shell` 提示我们输入超级用户的密码.
如果密码输入正确,出现一个新的 `shell` 提示符, 这表明这个 `shell` 具有超级用户特权(提示符的末尾字符是`#`而不是`$`),
并且当前工作目录是超级用户的家目录 (通常是`/root`).
一旦进入一个新的 `shell`,我们能执行超级用户所使用的命令.当工作完成后, 输入`exit`,则返回到原来的 `shell`:

```bash
[root@linuxbox ~]# exit
[me@linuxbox ~]$
```

以这样的方式使用 `su` 命令,也可以只执行单个命令,而不是启动一个新的可交互的 shell:

```bash
su -c 'command'
```

使用这种模式,命令传递到一个新 `shell` 中执行.
把命令用单引号引起来很重要,因为我们不想命令在我们的 `shell` 中展开,但需要在新 `shell` 中展开.

```bash
su -c 'ls -l /root/*'
```

#### sudo - 以另一个用户身份执行命令

`sudo` 命令在很多方面都相似于 `su` 命令,但是 `sudo` 还有一些非常重要的功能.

管理员能够配置 `sudo` 命令,从而允许一个普通用户以不同的身份(通常是超级用户),通过一种非常可控的方式来执行命令.
尤其是,只有一个用户可以执行一个或多个特殊命令时,(更体现了 `sudo` 命令的方便性).

另一个重要差异是 `sudo` 命令不要求超级用户的密码.使用 `sudo` 命令时,用户使用他/她自己的密码 来认证.
比如说,例如,`sudo` 命令经过配置,允许我们运行一个虚构的备份程序,叫做`backup_script`, 这个程序要求超级用户权限.
通过 `sudo` 命令,这个程序会像这样运行:

```bash
sudo backup_script
Password:
System Backup Starting...
```

按下回车键之后,`shell` 提示我们输入我们的密码(不是超级用户的).一旦认证完成,则执行 具体的命令.

`su` 和 `sudo` 之间的一个重要区别是 `sudo` 不会重新启动一个 `shell`,也不会加载另一个 用户的 `shell` 运行环境.
这意味者命令不必用单引号引起来.注意通过指定各种各样的选项,这 种行为可以被推翻.
详细信息,阅读 `sudo` 手册页.

想知道 `sudo` 命令可以授予哪些权限,使用`-l`选项,列出所有权限:

```bash
sudo -l
User me may run the following commands on this host:
(ALL) ALL
```

> Ubuntu 与 sudo

`Unix` 采取的方法是只有在需要的时候,才授予普通用户超级用户权限.这样,普遍会 用到 `su` 和 `sudo` 命令.

几年前,大多数的 Linux 发行版都依赖于 `su` 命令,来达到目的.`su` 命令不需要 `sudo` 命令 所要求的配置, `su` 命令拥有一个 `root` 帐号,是 Unix 中的传统.

但这会引起问题.所有用户会企图以 `root` 用户帐号来操纵系统.
事实上,一些用户专门以 `root` 用户帐号来操作系统, 因为这样做,的确消除了所有那些讨厌的权限
被拒绝的消息.相比于 `Windows` 系统安全性而言, 这样做,你就削弱了 `Linux` 系统安全性能.

当引进 `Ubuntu` 的时候,它的创作者们采取了不同的策略.
默认情况下,`Ubuntu` 不允许用户登录到 `root`帐号(因为不能为 `root` 帐号设置密码),而是使用 `sudo` 命令授予普通用户超级用户权限.

通过 `sudo` 命令,最初的用户可以拥有超级用户权限,也可以授予随后的用户帐号相似的权力.

### chown - 更改文件所有者和用户组

`chown` 命令被用来更改文件或目录的 `所有者` 和 `用户组`.使用这个命令需要超级用户权限.
`chown` 命令 的语法看起来像这样:

```bash
chown [owner][:[group]] file...
```

`chown ` 命令可以更改文件所有者和/或文件用户组,
依据于这个命令的第一个参数. 这里有 一些例子:

***
参数 结果

+ `bob` 把文件所有者从当前属主更改为用户`bob`
+ `bob:users` 把文件所有者改为用户 `bob`, 文件用户组改为用户组 `users`.
+ `:admins` 把文件用户组改为组 `admins`, 文件所有者不变.
+ `bob:` 文件所有者改为用户 `bob`, 文件用户组改为`bob` 登录系统时所属的用户组.

比方说, 我们有两个用户: `janet`(拥有超级用户访问权限),`tony`(没有).

用户`janet`想要从 她的家目录复制一个文件到用户 `tony` 的家目录.
因为用户 `janet` 想要 `tony`能够编辑这个文件, `janet` 把这个文件的所有者更改为`tony`:

```bash
$ sudo cp myfile.txt ~tony
$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root root 8031 2008-03-20 14:30 /home/tony/myfile.txt
$ sudo chown tony: ~tony/myfile.txt
$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
```

这里,我们看到用户 `janet` 把文件从她的目录复制到 `tony` 的家目录.
下一步,`janet` 把文件所有者 从 `root`(因为使用了`sudo` 命令)改到 `tony`.
通过在第一个参数中使用末尾的`:`字符,`janet` 同时把文件用户组改为`tony` 登录系统时所属的用户组(也叫`tony`).

注意,第一次使用 `sudo` 命令之后,为什么(`shell`)没有提示 `janet` 输入她的密码?
这是因为在 大多数的配置中,`sudo` 命令会相信你几分钟,直到计时结束.

### chgrp - 更改用户组所有权

在旧版 Unix 系统中,`chown` 命令只能更改文件所有权, 而不是用户组所有权.
为了达到目的, 使用一个独立的命令, `chgrp` 来完成.
除了限制多一点之外, `chgrp` 命令与 `chown` 命令使用起来很相似.

### 练习使用权限

我们将展示一个常见问题的解决方案,这个问题是如何设置一个共享目录.
假想我们有两个用户, 他们分别是 `bill` 和 `karen`. 他们都有音乐 CD 收藏品,也愿意设置一个共享目录.
在这个共享目录中,他们分别以 `Ogg Vorbis` 或 `MP3` 的格式来存储他们的音乐文件.
通过 `sudo` 命令, 用户 `bill` 具有超级用户访问权限.

我们需要做的第一件事,是创建一个以 `bill` 和 `karen` 为成员的用户组.
下一步,`bill` 创建了存储音乐文件的目录:`sudo mkdir /usr/local/share/Music`

因为 `bill` 正在他的家目录之外操作文件,所以需要超级用户权限.
这个目录创建之后,它具有以下所有权和权限:

```bash
ls -ld /usr/local/share/Music
drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music
```

正如我们所见到的,这个目录由 `root` 用户拥有,并且具有权限`755`.
为了使这个目录共享,允许(用户 `karen`)写入,`bill` 需要更改目录用户组所有权和权限:

```bash
[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music
[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music
```

那么这是什么意思呢? 它的意思是,现在我们拥有一个目录,`/usr/local/share/Music`,
这个目录由 `root` 用户拥有,并且允许用户组 `music` 读取和写入.

用户组 `music` 有两个成员 `bill` 和 `karen`,这样 `bill` 和 `karen` 能够在目录 `/usr/local/share/Music` 中创建文件.其他用户能够列出目录中的内容,但是不能在其中创建文件.

但是我们仍然会遇到问题.
通过我们目前所拥有的权限,在 `Music` 目录中创建的文件,只具有用户 `bill` 和 `karen` 的普通权限:

```bash
[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill bill 0 2008-03-24 20:03 test_file
```

实际上,存在两个问题.
第一个,系统中默认的掩码值是`0022`,这会禁止用户组成员编辑属于同组成员的文件.
如果共享目录中只包含文件,这就不是个问题,但是因为这个目录将会存储音乐, 通常音乐会按照艺术家和唱片的层次结构来组织分类.
所以用户组成员需要在同组其他成员创建的目录中创建文件和目录.
我们将把用户 `bill` 和 `karen` 使用的掩码值改为`0002`.

第二个问题是,`bill`创建的文件(或目录)的用户组会被设置为`bill`,而不是`music`用户组 .
通过设置此目录的 `setgid` 位来解决这个问题:

```bash
[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music
```

现在测试一下,看看是否新的权限解决了这个问题.
`bill` 把他的掩码值设为`0002`,删除 先前的测试文件,并创建了一个新的测试文件和目录:

```bash
[bill@linuxbox ~]$ umask 0002
[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file
[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill music 4096 2008-03-24 20:24 test_dir
-rw-rw-r-- 1 bill music 0 2008-03-24 20:22 test_file
```

现在,创建的文件和目录都具有正确的权限,允许用户组 `music` 的所有成员在目录 `Music` 中创建文件和目录.

剩下一个问题是关于 `umask` 命令的.
`umask` 命令设置的掩码值只能在当前 `shell` 会话中生效,若当前 `shell` 会
话结束后,则必须重新设置.在这本书的第三部分,我们将看一下,怎样使掩码值永久生效.

### 更改用户密码

这一章最后一个话题,我们将讨论自己帐号的密码(和其他人的密码,如果你具有超级用户权限).
使用 `passwd` 命令,来设置或更改用户密码.命令语法如下所示:

```bash
passwd [user]
```

只要输入 `passwd` 命令,就能更改你的密码.`shell` 会提示你输入你的旧密码和你的新密码:

```bash
passwd
(current) UNIX password:
New UNIX password:
```

passwd 命令将会试着强迫你使用`强`密码.
这意味着,它会拒绝接受太短的密码,与先前相似的密码, 字典中的单词作为密码,或者是太容易猜到的密码:

如果你具有超级用户权限,你可以指定一个用户名作为 `passwd` 命令的参数,这样可以设置另一个用户的密码.

还有其它的 `passwd` 命令选项对超级用户有效,允许帐号锁定,密码失效,等等.
详细内容,参考 passwd 命令的手册页.

## Linux 用户和用户组管理

[Linux 用户和用户组管理](https://www.runoob.com/linux/linux-user-manage.html)

`Linux`系统是一个多用户多任务的分时操作系统,任何一个要使用系统资源的用户, 都必须首先向系统管理员申请一个账号,然后以这个账号的身份进入系统.

用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪,并控制他们对系统资源的访问;
另一方面也可以帮助用户组织文件,并为用户提供安全性保护.
每个用户账号都拥有一个唯一的用户名和各自的口令.用户在登录时键入正确的用户名和口令后,就能够进入系统和自己的主目录.

实现用户账号的管理,要完成的工作主要有如下几个方面:

+ 用户账号的添加, 删除与修改.
+ 用户口令的管理.
+ 用户组的管理.

### Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加, 修改和删除.

添加用户账号就是在系统中创建一个新账号,然后为新账号分配用户号, 用户组, 主目录和登录Shell等资源.
刚添加的账号是被锁定的,无法使用.

***
添加新的用户账号使用useradd命令,其语法如下:

```bash
useradd 选项 用户名
```

选项:

+ `-c comment`  指定一段注释性描述.
+ `-d 目录`  指定用户主目录,如果此目录不存在,则同时使用`-m`选项,可以创建主目录.
+ `-g 用户组`  指定用户所属的用户组.
+ `-G用户组,用户组` 指定用户所属的附加组.
+ `-s Shell文件`  指定用户的登录Shell.
+ `-u 用户号`  指定用户的用户号,如果同时有`-o`选项,则可以重复使用其他用户的标识号.

用户名:   指定新账号的登录名.

***
实例1

```bash
useradd –d  /home/sam -m sam
```

此命令创建了一个用户`sam`,其中`-d`和`-m`选项用来为登录名`sam`产生一个主目录 `/home/sam`
(`/home`为默认的用户主目录所在的父目录)

***
实例2

```bash
useradd -s /bin/sh -g group –G adm,root gem
```

此命令新建了一个用户`gem`,该用户的登录`Shell`是` /bin/sh`,
它属于`group`用户组,同时又属于`adm`和`root`用户组,其中`group`用户组是其主组.

这里可能新建组:`groupadd group`及`groupadd adm`

增加用户账号就是在`/etc/passwd`文件中为新用户增加一条记录,同时更新其他系统文件如`/etc/shadow`, `/etc/group`等.

Linux提供了集成的系统管理工具`userconf`,它可以用来对用户账号进行统一管理.

### 删除帐号

如果一个用户的账号不再使用,可以从系统中删除.
删除用户账号就是要将`/etc/passwd`等系统文件中的该用户记录删除,必要时还删除用户的主目录.

删除一个已有的用户账号使用`userdel`命令,其格式如下:

```
userdel 选项 用户名
```

常用的选项是 `-r`,它的作用是把用户的主目录一起删除.例如:

```bash
userdel -r sam
```

此命令删除用户`sam`在系统文件中(主要是`/etcpasswd/`, `/etc/shadow`, `/etc/group`等)的记录,同时删除用户的主目录.

## 修改帐号

修改用户账号就是根据实际情况更改用户的有关属性,如用户号, 主目录, 用户组, 登录Shell等.

修改已有用户的信息使用`usermod`命令,其格式如下:

```bash
usermod 选项 用户名
```

常用的选项包括`-c,` `-d`, `-m`,` -g`,` -G`,` -s`,`-u`以及`-o`等,这些选项的意义与`useradd`命令中的选项一样,可以为用户指定新的资源值.

另外,有些系统可以使用选项:`-l 新用户名`
这个选项指定一个新的账号,即将原来的用户名改为新的用户名.

例如:

```bash
usermod -s /bin/ksh -d /home/z –g developer sam
```

此命令将用户`sam`的登录`Shell`修改为`ksh`,主目录改为`/home/z`,用户组改为`developer`.

### 用户口令的管理

用户管理的一项重要内容是用户口令的管理.
用户账号刚创建时没有口令,但是被系统锁定,无法使用,必须为其指定口令后才可以使用,即使是指定空口令.

指定和修改用户口令的Shell命令是`passwd`.
超级用户可以为自己和其他用户指定口令,普通用户只能用它修改自己的口令.命令的格式为:

```bash
passwd 选项 用户名
```

可使用的选项:

+ `-l` 锁定口令,即禁用账号.
+ `-u` 口令解锁.
+ `-d` 使账号无口令.
+ `-f` 强迫用户下次登录时修改口令.

如果默认用户名,则修改当前用户的口令.

例如,假设当前用户是`sam`, 则下面的命令修改该用户自己的口令:

```bash
$ passwd
Old password:******
New password:*******
Re-enter new password:*******
```

如果是超级用户,可以用下列形式指定任何用户的口令:

```bash
passwd sam
New password:*******
Re-enter new password:*******
```

普通用户修改自己的口令时,`passwd`命令会先询问原口令,验证后再要求用户输入两遍新口令,
如果两次输入的口令一致,则将这个口令指定给用户;而超级用户为用户指定口令时,就不需要知道原口令.

为了系统安全起见,用户应该选择比较复杂的口令,例如最好使用`8`位长的口令,口令中包含有大写, 小写字母和数字,并且应该与姓名, 生日等不相同.

为用户指定空口令时,执行下列形式的命令:

```bash
passwd -d sam
```

此命令将用户 `sam` 的口令删除,这样用户 `sam` 下一次登录时,系统就不再允许该用户登录了.

`passwd` 命令还可以用 `-l(lock)` 选项锁定某一用户,使其不能登录,例如:

```bash
passwd -l sam
```

### Linux系统用户组的管理

每个用户都有一个用户组,系统可以对一个用户组中的所有用户进行集中管理.
不同Linux 系统对用户组的规定有所不同,如 ubuntu 下的用户属于与它同名的用户组,这个用户组在创建用户时同时创建.

用户组的管理涉及用户组的添加, 删除和修改.组的增加, 删除和修改实际上就是对`/etc/group`文件的更新.

***
增加一个新的用户组使用`groupadd`命令.其格式如下:

```bash
groupadd 选项 用户组
```

可以使用的选项有:

+ `-g` `GID` 指定新用户组的组标识号(GID).
+ `-o` 一般与`-g`选项同时使用,表示新用户组的GID可以与系统已有用户组的GID相同.

***
实例1:

```bash
groupadd group1
```

此命令向系统中增加了一个新组`group1`,新组的组标识号是在当前已有的最大组标识号的基础上加`1`.

实例2:

```bash
groupadd -g 101 group2
```

此命令向系统中增加了一个新组`group2`,同时指定新组的组标识号是`101`.

***
如果要删除一个已有的用户组,使用`groupdel`命令,其格式如下:

```bash
groupdel 用户组
```

例如:

```bash
groupdel group1
```

此命令从系统中删除组`group1`.

***
修改用户组的属性使用`groupmod`命令.其语法如下:

```bash
groupmod 选项 用户组
```

常用的选项有:

+ `-g GID` 为用户组指定新的组标识号.
+ `-o`  与`-g`选项同时使用,用户组的新`GID`可以与系统已有用户组的`GID`相同.
+ `-n 新用户组`  将用户组的名字改为新名字

实例1:

```bash
groupmod -g 102 group2
```

此命令将组`group2`的组标识号修改为102.

实例2:

```bash
groupmod –g 10000 -n group3 group2
```

此命令将组`group2`的标识号改为`10000`,组名修改为`group3`.

***
如果一个用户同时属于多个用户组,那么用户可以在用户组之间切换,以便具有其他用户组的权限.
用户可以在登录后,使用命令`newgrp`切换到其他用户组,这个命令的参数就是目的用户组.例如:

```bash
$ newgrp root
```

这条命令将当前用户切换到`root`用户组,前提条件是`root`用户组确实是该用户的主组或附加组.
类似于用户账号的管理,用户组的管理也可以通过集成的系统管理工具来完成.

### 与用户账号有关的系统文件

完成用户管理的工作有许多种方法,但是每一种方法实际上都是对有关的系统文件进行修改.

与用户和用户组相关的信息都存放在一些系统文件中,这些文件包括`/etc/passwd`, `/etc/shadow`, `/etc/group`等.

下面分别介绍这些文件的内容.

#### /etc/passwd文件

`/etc/passwd`文件是用户管理工作涉及的最重要的一个文件

Linux系统中的每个用户都在`/etc/passwd`文件中有一个对应的记录行,它记录了这个用户的一些基本属性.

这个文件对所有用户都是可读的.它的内容类似下面的例子:

```bash
＃ cat /etc/passwd
root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh
```

从上面的例子我们可以看到,`/etc/passwd`中一行记录对应着一个用户,
每行记录又被冒号(`:`)分隔为7个字段,其格式和具体含义如下:

`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell`

1. `用户名`是代表用户账号的字符串.

通常长度不超过`8`个字符,并且由大小写字母或数字组成.登录名中不能有冒号(`:`),因为冒号在这里是分隔符.
为了兼容起见,登录名中最好不要包含点字符(`.`),并且不使用连字符(`-`)和加号(`+`)打头.

1. `口令`一些系统中,存放着加密后的用户口令字.

虽然这个字段存放的只是用户口令的加密串,不是明文,但是由于`/etc/passwd`文件对所有用户都可读,所以这仍是一个安全隐患.
因此,现在许多Linux 系统(如`SVR4`)都使用了 `shadow` 技术,把真正的加密后的用户口令字存放到`/etc/shadow`文件中,而在`/etc/passwd`文件的口令字段中只存放一个特殊的字符,例如`x`或者`*`.

3. `用户标识号`是一个整数,系统内部用它来标识用户.
一般情况下它与用户名是一一对应的.
如果几个用户名对应的用户标识号是一样的,系统内部将把它们视为同一个用户,但是它们可以有不同的口令, 不同的主目录以及不同的登录Shell等.

通常用户标识号的取值范围是`0`~`65 535`.`0`是超级用户`root`的标识号,`1`~`99`由系统保留,作为管理账号,普通用户的标识号从`100`开始.在Linux系统中,这个界限是`500`.

4. `组标识号`字段记录的是用户所属的用户组.

它对应着`/etc/group`文件中的一条记录.

5. `注释性描述`字段记录着用户的一些个人情况.

例如用户的真实姓名, 电话, 地址等,这个字段并没有什么实际的用途.在不同的Linux 系统中,这个字段的格式并没有统一.
在许多Linux系统中,这个字段存放的是一段任意的注释性描述文字,用做`finger`命令的输出.

6. `主目录`,也就是用户的起始工作目录.

它是用户在登录到系统之后所处的目录.
在大多数系统中,各用户的主目录都被组织在同一个特定的目录下,而用户主目录的名称就是该用户的登录名.
各用户对自己的主目录有读, 写, 执行(搜索)权限,其他用户对此目录的访问权限则根据具体情况设置.

7. 用户登录后,要启动一个进程,负责将用户的操作传给内核,这个进程是用户登录到系统后运行的命令解释器或某个特定的程序,即`Shell`.

`Shell`是用户与Linux系统之间的接口.Linux的`Shell`有许多种,每种都有不同的特点.
常用的有`sh`(Bourne Shell), `csh`(C Shell), `ksh`(Korn Shell), `tcsh`(TENEX/TOPS-20 type C Shell), `bash`(Bourne Again Shell)等.

系统管理员可以根据系统情况和用户习惯为用户指定某个`Shell`.
如果不指定`Shell`,那么系统使用`sh`为默认的登录`Shell`,即这个字段的值为`/bin/sh`.

用户的登录`Shell`也可以指定为某个特定的程序(此程序不是一个命令解释器).
利用这一特点,我们可以限制用户只能运行指定的应用程序,在该应用程序运行结束后,用户就自动退出了系统.
有些`Linux`系统要求只有那些在系统中登记了的程序才能出现在这个字段中.

8. 系统中有一类用户称为伪用户(pseudo users).

这些用户在`/etc/passwd`文件中也占有一条记录,但是不能登录,因为它们的登录`Shell`为空.
它们的存在主要是方便系统管理,满足相应的系统进程对文件属主的要求.

常见的伪用户如下所示:

+ `bin`:  拥有可执行的用户命令文件
+ `sys`:  拥有系统文件
+ `adm`:  拥有帐户文件
+ `uucp`:  `UUCP`使用
+ `lp`:  `lp`或`lpd`子系统使用
+ `nobody`:  `NFS`使用

#### 拥有帐户文件

+ 除了上面列出的伪用户外,还有许多标准的伪用户,例如:`audit`, `cron`, `mail`, `usenet`等,它们也都各自为相关的进程和文件所需要.

由于`/etc/passwd`文件是所有用户都可读的,如果用户的密码太简单或规律比较明显的话,一台普通的计算机就能够很容易地将它破解.
因此对安全性要求较高的Linux系统都把加密后的口令字分离出来,单独存放在一个文件中,这个文件是`/etc/shadow`文件. 有超级用户才拥有该文件读权限,这就保证了用户密码的安全性.

+ `/etc/shadow`中的记录行与`/etc/passwd`中的一一对应,它由`pwconv`命令根据`/etc/passwd`中的数据自动产生,
它的文件格式与`/etc/passwd`类似,由若干个字段组成,字段之间用`:`隔开.这些字段是:
`登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`

1. `登录名`是与`/etc/passwd`文件中的登录名相一致的用户账号
2. `口令`字段存放的是加密后的用户口令字,长度为`13`个字符.如果为空,则对应用户没有口令,登录时不需要口令;
如果含有不属于集合` { ./0-9A-Za-z }`中的字符,则对应的用户不能登录.
3. `最后一次修改时间`表示的是从某个时刻起,到用户最后一次修改口令时的天数.时间起点对不同的系统可能不一样.
例如在`SCO Linux `中,这个时间起点是`1970年1月1日`.
4. `最小时间间隔`指的是两次修改口令之间所需的最小天数.
5. `最大时间间隔`指的是口令保持有效的最大天数.
6. `警告时间`字段表示的是从系统开始警告用户到用户密码正式失效之间的天数.
7. `不活动时间`表示的是用户没有登录活动但账号仍能保持有效的最大天数.
8. `失效时间`字段给出的是一个绝对的天数,如果使用了这个字段,那么就给出相应账号的生存期.期满后,该账号就不再是一个合法的账号,也就不能再用来登录了.

下面是`/etc/shadow`的一个例子:

```bash
＃ cat /etc/shadow

root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::
adm:*::0:0::::
uucp:*::0:0::::
nuucp:*::0:0::::
auth:*::0:0::::
cron:*::0:0::::
listen:*::0:0::::
lp:*::0:0::::
sam:EkdiSECLWPdSa:9740:0:0::::
```

+ 用户组的所有信息都存放在`/etc/group`文件中.

将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段.
每个用户都属于某个用户组;一个组中可以有多个用户,一个用户也可以属于不同的组.
当一个用户同时是多个组中的成员时,在`/etc/passwd`文件中记录的是用户所属的主组,也就是登录时所属的默认组,而其他组称为附加组.

用户要访问属于附加组的文件时,必须首先使用`newgrp`命令使自己成为所要访问的组中的成员.
用户组的所有信息都存放在`/etc/group`文件中.此文件的格式也类似于`/etc/passwd`文件,由冒号(`:`)隔开若干个字段,这些字段有:

`组名:口令:组标识号:组内用户列表`

+ `组名`是用户组的名称,由字母或数字构成.与`/etc/passwd`中的登录名一样,组名不应重复.
+ `口令`字段存放的是用户组加密后的口令字.一般Linux 系统的用户组都没有口令,即这个字段一般为`空`,或者是`*`.
+ `组标识号`与用户标识号类似,也是一个整数,被系统内部用来标识组.
+ `组内用户列表`是属于这个组的所有用户的列表,不同用户之间用逗号(`,`)分隔.这个用户组可能是用户的主组,也可能是附加组.

`/etc/group`文件的一个例子如下:

```bash
root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
```

### 添加批量用户

添加和删除用户对每位Linux系统管理员都是轻而易举的事,比较棘手的是如果要添加几十个, 上百个甚至上千个用户时,我们不太可能还使用useradd一个一个地添加,必然要找一种简便的创建大量用户的方法.
Linux系统提供了创建大量用户的工具,可以让您立即创建大量用户,方法如下:

1. 先编辑一个文本用户文件.

每一列按照`/etc/passwd`密码文件的格式书写,要注意每个用户的用户名, `UID`, 宿主目录都不可以相同,其中密码栏可以留做空白或输入`x`号.一个范例文件`user.txt`内容如下:

```bash
user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
...
```

2. 以root身份执行命令 `/usr/sbin/newusers`,从刚创建的用户文件`user.txt`中导入数据,创建用户:

```bash
newusers < user.txt
```

然后可以执行命令 `vipw` 或 `vi /etc/passwd` 检查`/etc/passwd` 文件是否已经出现这些用户的数据,并且用户的宿主目录是否已经创建.

3. 执行命令`/usr/sbin/pwunconv`.

将 `/etc/shadow` 产生的 `shadow` 密码解码,然后回写到` /etc/passwd` 中,并将`/etc/shadow`的`shadow`密码栏删掉.
这是为了方便下一步的密码转换工作,即先取消 `shadow password` 功能.

```bash
pwunconv
```

4. 编辑每个用户的密码对照文件.

格式为:`用户名:密码`

实例文件 `passwd.txt` 内容如下:

```bash
user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456
```

5. 以 `root` 身份执行命令 `/usr/sbin/chpasswd`.

创建用户密码,`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏.

```bash
chpasswd < passwd.txt
```

6. 确定密码经编码写入`/etc/passwd`的密码栏后.

执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`,并将结果写入 `/etc/shadow`.

```bash
pwconv
```

这样就完成了大量用户的创建了,之后您可以到`/home`下检查这些用户宿主目录的权限设置是否都正确,并登录验证用户密码是否正确.
