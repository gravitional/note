# learn.language.md

原文链接:  [origin](https://blog.csdn.net/u013252047/article/details/85724940) , 版权归原作者所有

## 动态语言

动态语言是在运行时才确定数据类型的语言. 变量使用之前不需要类型声明, 通常变量的类型是被赋值的那个值的类型.
例如`PHP, ASP, Python, SQL, JavaScript, Unix Shell`等等.

动态语言的优势: 思维不受束缚, 可以任意发挥, 把更多的精力放在产品本身上.

## 静态语言

静态语言是在编译时变量的数据类型就可确定的语言, 多数静态类型语言要求在使用变量之前必须声明数据类型.
例如: `C, C++, Golang, Java, C#`等.

静态语言优势:
由于类型的强制声明, 使得`IDE`有很强的代码感知能力, 所以在实现复杂的业务逻辑, 开发大型商业系统, 以及那些生命周期很长的应用中, 依托`IDE`对系统的开发很有保障;
由于静态语言相对比较封闭, 使得第三方开发包对代码的侵害性可以降到最低.

## 解释型语言

我们都知道能让机器识别的是机器语言, 也就是`01`这样的二进制代码, 高级语言机器是不能识别的.
解释型语言是不需要在运行前进行编译成机器语言, 而是程序在运行时先翻译成中间代码, 再由解释器对中间代码进行解释运行.
这样解释型语言每执行一次就要翻译一次, 效率比较低.

常见的解释型语言包括: `Java, C#, PHP, JavaScript, Python, VBScript, Perl, Ruby, MATLAB`等.

解释型语言的优点:

+ 解释型语言提供了极佳的调试支持.
+ 解释器比编译器容易实现.
+ 中间语言代码的大小比编译型可执行代码小很多. 例如, `C/C++`的`.exe`文件要比同样功能的`Java`的`.class`文件大很多.
+ 可移植性好, 只要有解释环境, 可以在不同的操作系统上运行. 比如在解释执行时可以动态改变变量的类型, 对程序进行修改以及在程序中插入良好的调试诊断信息等, 而将解释器移植到不同的系统上, 则程序不用改动就可以在移植了解释器系统上运行.
+ 解释型语言也可以保证高度的安全性---这是互联网应用迫切需要的.

解释型语言的缺点:

+ 运行需要解释环境, 程序严重依赖平台.
+ 运行起来比编译的要慢, 占用的资源也要多一些, 代码效率低. 因为不仅要给用户程序分配空间, 解释器本身也占用了宝贵的系统资源.
+ 由于解释型应用的`decode-fetch-execute`(解码-抓取-执行)的周期, 它们比编译型程序慢很多.

## 编译型语言

运行编译型语言是相对于解释型语言存在的, 编译型语言首先将源代码编译生成机器语言, 再由机器运行机器码(二进制).

常见的编译型语言有: `C, C++`等.

编译型语言的优点: 运行速度快, 代码效率高, 编译后程序不可以修改, 保密性好.

编译型语言的缺点:

+ 代码需要经过编译方可运行, 可移植性差, 只能在兼容的操作系统上运行.
+ 安全性不如解释性语言, 一个编译型的程序可以访问内存的任何区域, 并且可以对你的`PC`做它想做的任何事情(大部分病毒是使用编译型语言编写的).

## 脚本语言

脚本语言又被称为扩建的语言, 或者动态语言, 是一种编程语言, 用来控制软件应用程序, 脚本通常以文本保存, 只在被调用时进行解释或编译.

脚本语言有: `PHP, Python, JavaScript, Lua, Scala, VBScript, ActionScript, MAXScript, ASP, JSP, SQL, Perl, Shell, Ruby, JavaFX, AutoIt`等

脚本语言是一种解释性的语言, 它不象`c/c++`等可以编译成二进制代码, 以可执行文件的形式存在, 脚本语言不需要编译, 可以直接用, 由解释器来负责解释.

### 运行时

[What is "runtime"](https://stackoverflow.com/questions/3900549/what-is-runtime)

`Runtime`描述的是在你的程序运行时执行的`软件`/`指令`, 特别是那些你没有明确写的指令, 但对于你的代码的正常执行是必要的.
像`C`这样的低级语言的`Runtime`非常小(如果有的话). 像`Objective-C`这样更复杂的语言, 允许动态消息传递, 有更庞大的`runtime`.

你是对的, `runtime`代码是`library`代码, 但`library`代码是一个更普遍的术语, 描述任何`library`产生的代码.
`Runtime`代码具体是指实现语言本身的功能所需的代码.

***

在计算机编程中, `runtime`库是一个特殊的程序库, 由编译器使用, 用于在计算机程序的运行(执行)期间实现编程语言中的功能.
这通常包括输入和输出的功能, 或用于内存管理.

`run-time system`(也称为`runtime system `或只是`runtime`)是为支持以某种计算机语言编写的计算机程序的执行而设计的软件. 运行时系统包含基本低级命令的实现, 也可能实现高级命令, 并可能支持`类型检查`, `调试`, 甚至是代码生成和优化.
运行时系统的一些服务可以通过应用编程接口(API)被程序员访问, 但其他服务(如`任务调度`和`资源管理`)可能是不可访问的.

***

`runtime`是一个通用术语, 指的是你的代码运行依托的任何`库`, `框架`或`平台`.

`C`和`C++`的`运行时`是函数的集合.
`.NET`的`运行时`包含中间语言解释器, 垃圾收集器, 以及更多.

`运行时`或`执行环境`是语言实现中执行代码的部分, 在运行期间存在; 实现`编译期`的部分在C标准中称为`翻译环境`.
举例来说:

+ `Java`运行时由`虚拟机`和`标准库`组成
+ 普通的`C`语言运行时由`loader`(操作系统的一部分)和`运行时库`组成,
`运行时库`实现了`C`语言中没有被`编译器`构建到可执行文件中的部分; 在`hosted`环境中, 这包括`标准库`的大部分部分

## 词法分析, 语法分析, 语义分析

[JackYang](https://www.cnblogs.com/BlogNetSpace/p/5108845.html)

### 词法分析(Lexical analysis或Scanning)和词法分析程序(Lexical analyzer或Scanner)

词法分析阶段是编译过程的第一个阶段.
这个阶段的任务是从左到右一个字符一个字符地读入源程序,
即对构成源程序的字符流进行扫描, 然后根据构词规则识别单词(也称单词符号或符号).
词法分析程序实现这个任务. 词法分析程序可以使用lex等工具自动生成.

### 语法分析(Syntax analysis或Parsing)和语法分析程序(Parser)

语法分析是编译过程的一个逻辑阶段.
语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语, 如"程序", "语句", "表达式"等等.
语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.

### 语义分析(Syntax analysis)

语义分析是编译过程的一个逻辑阶段.
语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查, 进行类型审查.
例如一个C程序片断:

```c
int arr[2],b;
b = arr * 10;
```

源程序的结构是正确的.

语义分析将审查类型并报告错误:不能在表达式中使用一个数组变量,赋值语句的右端和左端的类型不匹配.

### Lex

一个词法分析程序的自动生成工具.
它输入描述构词规则的一系列正规式,然后构建有穷自动机和这个有穷自动机的一个驱动程序,进而生成一个词法分析程序.

### Yacc

一个语法分析程序的自动生成工具.
它接受语言的文法,构造一个LALR(1)分析程序.
因为它采用语法制导翻译的思想,还可以接受用C语言描述的语义动作,从而构造一个编译程序.
Yacc 是 Yet another compiler compiler的缩写.

### 源语言(Source language)和源程序(Source program)

被编译程序翻译的程序称为源程序,书写该程序的语言称为源语言.

### 目标语言(Object language or Target language)和目标程序(Object program or Target program)

编译程序翻译源程序而得到的结果程序称为目标程序, 书写该程序的语言称为目标语言.

### 中间语言(中间表示)(Intermediate language(representation))

在进行了语法分析和语义分析阶段的工作之后,
有的编译程序将源程序变成一种内部表示形式, 这种内部表示形式叫做中间语言或中间表示或中间代码.

所谓"中间代码"是一种结构简单, 含义明确的记号系统,
这种记号系统复杂性介于源程序语言和机器语言之间, 容易将它翻译成目标代码.
另外, 还可以在中间代码一级进行与机器无关的优化.

## 文法(Grammars)

[文法的基本概念](https://blog.csdn.net/abc123lzf/article/details/103773591)

文法是用于描述语言的语法结构的形式规则.

`文法G` 定义为四元组`(VT, VN, P, S)`, 其中

+ `VT​` 为终结符集合
+ `VN` ​为非终结符集合
+ `P` 为产生式集合
+ `S` 为开始符号, 也叫开始符, 是一个非终结符, 至少要在一条规则中作为左部出现.

何为终结符? 在编程语言中, 终结符可以理解为不能再进行拆分的基本符号.
例如C语言中的 `if`, `else`, `while` 关键字, 也可以是一个`变量名`, `数字`.

和终结符相反, 非终结符就是可以再进行拆分的符号, 它可以推出其它的语法成分.
如果要对一个非终结符进行语法分析, 就需要对它需要进行递归分析.
在 C 语言的 `if-else` 文法中, `if` 或者 `else` 后面跟着的代码块可以看成是非终结符.

一个文法含有一个或多个`产生式`, 产生式描述了将终结符集合和非终结符集合组合成串的方法.
其一般形式为 $\alpha\to\beta$, 其中:

+ $\alpha$ 称之为产生式的头或左部, 并且 $\alpha \in (VT \cup VN)^+$, 表示至少要包含 $(VT \cup VN)$ 中的一个元素.
+ $\beta$ 称之为产生式的体或右部, 并且 $\beta \in (VT \cup VN)^*$, 表示可以包含零个或多个 $(VT \cup VN)$ 中的元素.

很多时候不显示写出四元组, 只写出产生式.
一般约定: 第一条产生式左部是`识别符`; 尖括号括起来的是非终结符, 不用尖括号括起来的是终结符,
或用大写字母表示非终结符, 小写字母表示终结符.
也可将文法 `G` 写成 `G[S]`, 其中 `S` 是识别符.

### 约定

对于文法产生式当中的符号, 我们约定终结符为:

+ 英文小写字母, 如 `a`, `b`, `c`等
+ 运算符, 如`+`, `*`等
+ 标点符号, 如逗号, 括号等
+ 数字
+ 粗体字符串, 如 `if`, `else` 等
+ 希腊字母$\varepsilon$为空串, 即零个终结符号组成的串.

非终结符约定为:

+ 英文大写字母, 如 `A`, `B`, `C`等. 其中字母 `S` 通常表示为开始符号.
+ 小写, 斜体的名字, 如 $expr$, $stmt$ 等
+ 代表程序构造的大写字母. 如`E`(表达式), `T`(项)和 `F`(因子)
+ 字母表中排在后面的大写字母(如 `X`, `Y`, `Z`) 表示文法符号(即终结符或非终结符)
+ 字母表中排在后面的小写字母(主要是`u`, `v`, ... , `z`)表示终结符号串(包括空串)
+ 小写希腊字母, 如$\alpha$, $\beta$, $\gamma$, 表示文法符号串(包括空串)

如非特别说明, 第一个产生式的左部就是开始符号.

### 文法分类(A hierarchy of Grammars)

著名语言学家Noam Chomsky定义了四类文法和四种形式语言类,
文法分为0型, 1型, 2型, 3型四种, 它们之间的差别在于对产生式施加的不同限制, 形似于数据库不同范式之间的差异.
我们在判断时, 一般先核对该文法是否是3型文法, 如果不是再核对是否是2型文法, 依次往下推.

#### 0型文法

当文法 `G = (VT,VN, P, S)` 的每个产生式 $\alpha\to\beta$ 满足以下条件:

+ $\alpha \in (VT \cup VN)^*$
+ $\\beta \in (VT \cup VN)^*$
+ 至少含有一个非终结符

则称文法`G` 为`0`型文法.
`0`型文法又称短语文法, 任何 `0`型语言都是递归可枚举的, 反过来也成立.

#### 1型文法

文法 `G = (VT,VN, P, S)` 的每个产生式在 $\alpha\to\beta$  满足 `0` 型文法的要求外, 还满足以下要求:

+ $|\beta| \ge  | \alpha |$ (绝对值符号代表, 集合中元素的个数)
+ $S\to\varepsilon$ 除外

则称文法 `G` 为 `1型文法`, 又称上下文有关文法.

例如文法 `G = (VT,VN, P, S)`, `VN={S, B, E}`, `VT={a, b, e}` 的产生式为:

+ $S \to aSBE$
+ $SS \to aBE$
+ $EB \to BE$
+ $aB \to ab$
+ $bB \to bb$
+ $bE \to be$
+ $eE \to ee$

因为每个产生式都满足`右部元素数量`大于等于`左部数量`, 并且没有产生式为$S\to\varepsilon$, 所以文法 `G` 是一个 `1` 型文法.

#### 2型文法

文法 `G = (VT,VN, P, S)` 的每个产生式 $\alpha\to\beta$  在满足1型文法的要求外, 还满足以下要求:

+ $\alpha$  仅仅是一个非终结符
+ $\beta \in (VT \cup VN)^*$

则称此文法是`2`型文法, 又称上下文无关文法.

例如文法`G = (VT,VN, P, S)`,  `VN = {S}` , `VT = {0, 1}` , 产生式为:

$S\to 0S1 | 01$

等价于两个产生式:  $S\to 0S1$  和 $S\to 01$, 符号`|`含义为`或`
该文法就是一个 `2` 型文法.

#### 3型文法

文法 `G = (VT,VN, P, S)` 的每个产生式满足2型文法外, 还满足以下要求:

+ 形如$A\to a$ 和 $A\to aB$,
+ `A`, `B` 都是非终结符
+ $a \in VT^*$, 即 a为非终结符的零个或多个元素

则称文法 `G` 为`3` 型文法, 又称正规文法.

### 语法树

语法树又称语法分析树或分析树.
给定文法 `G = (VT,VN, P, S)`, 对于 `G` 的任何句型都能够构造出与之相关的语法树, 这颗树满足4个条件:

+ 每个结点都有一个标记, 这个标记属于`VT` 或者 `VN`
+ 根的标记是 `S`
+ 若一个结点 `A` 至少有一个子结点, 那么 $A \in VN$
+ 如果结点 `n` 的直接子节点从左到右的顺序为 $n_1, n_2, n_3, \ldots, n_k$ ​, 其标记分别为$A_1, A_2, A_3, \ldots, A_k$​, 那么产生式 $A_1, A_2, A_3, \ldots, A_k$ 一定是文法 `G` 产生式集合 `P` 中的元素.

语法树表示了在推导过程中, 所应用的`产生式` 和 `产生式应用的对象`(非终结符),
它并没有表明产生式应用的`顺序`.
根据语法树定义, 我们可以画出文法 `G` 的语法树.

例题: 给出文法 `G = ({S, A}, {a, b}, P, S)`, 其中 `P` 包含:

+ $S \to aAS$
+ $A\to SbA$
+ $A \to SS$
+ $S \to a$
+ $A \to ba$

上述文法可以有三种推导方式:

+ $S \Rightarrow aAS \Rightarrow aAa \Rightarrow aSbAa \Rightarrow aSbbaa \Rightarrow aabbaa$
    该推导总是选择最右边的非终结符`X`, 并找出以`X` 为左部的产生式进行递归推导, 该推导方式为最右推导, 也被称之为规范推导.
+ $S \Rightarrow aAS\Rightarrow aSbAS\Rightarrow aabAS\Rightarrow aabbaS\Rightarrow aabbaa$
    该推导总是选择最左边的非终结符`X`, 并找出以`X`为左部的产生式进行递归推导, 该推导方式为最左推导.
+ $S\Rightarrow aAS\Rightarrow aSbAS\Rightarrow aSbAa\Rightarrow aabAa\Rightarrow aabba$
    该推导则是根据情况选择不同的产生式来替换非终结符

上述三种推导方式得到的语法树都为:

![语法树](https://wx2.sinaimg.cn/mw2000/c4587b00gy1gwodm5ybd7j20ak0c8dhk.jpg)

如果一个文法存在某个句子对应两棵语法树, 那么则称该文法是二义的.
根据现有理论, 无法判断一个文法是否是二义的, 因为这个问题是递归不可解的.
