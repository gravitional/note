# 重定向

cmdline 第七章 重定向

+ `cat` --连接文件
+ `sort`--排序文本行
+ `uniq`--报道或忽略重复行
+ `grep`--打印匹配行
+ `wc`--打印文件中换行府, 字, 和字节个数
+ `head`--输出文件第一部分
+ `tail`--输出文件最后一部分

## 标准输入, 输出和错误

Unix`一切皆文件`, 程序, 比如说`ls`, 把它们的运行结果输送到一个叫做标准输出(`stdout`)的特殊文件,
把它们的状态信息送到另一个叫做标准错误(`stderr`)的文件. 默认情况下, 标准输出和标准错误都连接到屏幕, 而不是保存到磁盘文件.

此外, 许多程序从一个叫做标准输入(`stdin`)的设备得到输入. 默认情况下, 标准输入连接到键盘.

`I/O` 重定向允许我们可以更改输出走向和输入来向.
一般地,输出送到屏幕,输入来自键盘, 但是通过 `I/O` 重定向,我们可以改变输入输出方向.

## 重定向标准输出

`I/O` 重定向允许我们来重定义标准输出送到哪里.

重定向标准输出到另一个文件,我们使用 `>` 重定向符,其后跟着文件名.
把重定向结果追加到文件内容后面,而不是从开头重写文件, 我们使用`>>`重定向符,像这样:

```bash
ls -l /usr/bin >> ls-output.txt
```

## 重定向标准错误

重定向标准错误缺乏专用的重定向操作符. 重定向标准错误,我们必须参考它的文件描述符.
一个程序可以在几个编号的文件流中的任一个上产生输出.
然而我们必须把这些文件流的前三个看作标准输入,输出和错误, shell内部给它们的文件描述符分别为`0`,`1`和`2`.

可能有这种情况,我们希望捕捉一个命令的所有输出到一个文件.
为了完成这个,我们 必须同时重定向标准输出和标准错误. 有两种方法.

第一个,传统的方法, 在旧版本 shell 中也有效:

```bash
ls -l /bin/usr > ls-output.txt 2>&1
```

使用这种方法,我们完成两个重定向.
首先重定向标准输出到文件 `ls-output.txt`,然后 重定向文件描述符`2`(标准错误)到文件描述符`1`(标准输出)使用表示法`2>&1`. 注意重定向的顺序安排非常重要. 标准错误的重定向必须总是出现在标准输出重定向之后,要不然它不起作用.

现在的 bash 版本提供了第二种方法,更精简合理的方法来执行这种联合的重定向.

```bash
ls -l /bin/usr &> ls-output.txt
```

在这个例子里面,我们使用单单一个表示法 `&>` 来重定向标准输出和错误到文件 `ls-output.txt`.

## 处理不需要的输出

有时候`沉默是金`,我们不想要一个命令的输出结果,只想把它们扔掉.

系统为我们提供了解决问题的方法,通过重定向输出结果 到一个特殊的叫做`/dev/null`的文件.
这个文件是系统设备,叫做位存储桶,它可以接受输入,并且对输入不做任何处理.
为了隐瞒命令错误信息,我们这样做:

```bash
ls -l /bin/usr 2> /dev/null
```

>Unix 文化中的/dev/null
>位存储桶是个古老的 Unix 概念,由于它的普遍性,它的身影出现在 Unix 文化的 许多部分.
>当有人说他/她正在发送你的评论到`/dev/null`,现在你应该知道那是 什么意思了.
>更多的例子,可以阅读 Wikipedia 关于`/dev/null`的文章.

## 重定向标准输入

`cat - 连接文件`

`cat `命令读取一个或多个文件,然后复制它们到标准输出,就像这样:`cat [file]`

`cat` 经常被用来显示简短的文本文件. 因为 `cat` 可以 接受不只一个文件作为参数,所以它也可以用来把文件连接在一起.

比方说我们下载了一个大型文件,这个文件被分离成多个部分(`USENET` 中的多媒体文件经常以这种方式分离), 我们想把它们连起来.

```bash
cat movie.mpeg.0* > movie.mpeg
```

如果 `cat` 没有给出任何参数,它会从标准输入读入数据,因为标准输入,默认情况下,连接到键盘.
 它正在等待我们输入数据!试试这个:

```bash
cat
The quick brown fox jumped over the lazy dog.
```

下一步,输入 `Ctrl-d`(按住 `Ctrl` 键同时按下`d`),来告诉 `cat`,在标准输入中, 它已经到达文件末尾(EOF):
由于文件名参数的缺席,`cat` 复制标准输入到标准输出,所以我们看到文本行重复出现.
我们可以使用这种行为来创建简短的文本文件. 比方说,我们想创建一个叫做`lazy_dog.txt` 的文件,这个文件包含例子中的文本.
我们这样做:

```bash
cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

输入命令,其后输入要放入文件中的文本. 记住,最后输入`Ctrl-d`. 通过使用这个命令,我们实现了世界上最低能的文字处理器!

现在我们知道怎讲接受标准输入:

```bash
cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

使用`<`重定向操作符,我们把标准输入源从键盘改到文件 `lazy_dog.txt`.

`2.05b`版本以后, `bash`可以用下列语法重定向标准输入至字符串(称为here string/here-string):

```bash
command <<< "string to be read as standard input"
```

如果字符串包括空格就需要用引号包裹字符串

## 管道线

命令可以从**标准输入**读取数据,然后再把数据输送到**标准输出**,
命令的这种能力被 一个 `shell` 特性所利用,这个特性叫做管道线.

使用管道操作符`|`(竖杠),一个命令的标准输出可以管道到另一个命令的标准输入:

```bash
command1 | command2
```

我们用 less 来一页一页地显示任何命令的输出,命令把它的运行结果输送到标准输出:

```bash
ls -l /usr/bin | less
```

这极其方便!使用这项技术,我们可以方便地检测会产生标准输出的任一命令的运行结果.

## 过滤器

管道线经常用来对数据完成复杂的操作. 有可能会把几个命令放在一起组成一个管道线.
通常,以这种方式使用的命令被称为过滤器. 过滤器接受输入,以某种方式改变它,然后 输出它.

### sort

第一个我们想试验的过滤器是 `sort`.

```bash
ls /bin /usr/bin | sort | less
```

因为我们指定了两个目录`(/bin` 和`/usr/bin`),`ls` 命令的输出结果由有序列表组成, 各自针对一个目录.
通过在管道线中包含 `sort`,我们改变输出数据,从而产生一个 有序列表.

## uniq - 报道或忽略重复行

`uniq` 命令经常和 `sort` 命令结合在一起使用.
`uniq` 从标准输入或单个文件名参数接受数据有序列表(详情查看`uniq`手册页),默认情况下,从数据列表中删除任何重复行.

```bash
ls /bin /usr/bin | sort | uniq | less
```

在这个例子中,我们使用 `uniq` 从 `sort` 命令的输出结果中,来删除任何重复行.

如果我们想看到 重复的数据列表,让 uniq 命令带上`-d`选项,就像这样:

```bash
ls /bin /usr/bin | sort | uniq -d | less
```

## wc - 打印行,字和字节数

`wc`(字计数)命令是用来显示文件所包含的行,字和字节数. 例如:

```bash
wc ls-output.txt
7902 64566 503634 ls-output.txt
```

`wc` 打印出来三个数字:包含在文件 `ls-output.txt` 中的行数,单词数和字节数,.
正如我们先前的命令,如果 `wc` 不带命令行参数,它接受标准输入.
`-l`选项限制命令输出只能报道行数.

添加 `wc` 到管道线来统计数据,是个很便利的方法.

```bash
ls /bin /usr/bin | sort | uniq | wc -l
2728
```

## grep - 打印匹配行

grep 是个很强大的程序,用来找到文件中的匹配文本. 这样使用 `grep` 命令:

```bash
grep pattern [file...]
```

当 grep 遇到一个文件中的匹配`模式`,它会打印出包含这个类型的行.
grep 能够匹配的模式可以很复杂(正则表达式),但是现在我们把注意力集中在简单文本匹配上面.

比如说,我们想在我们的程序列表中,找到文件名中包含单词`zip`的所有文件.
这样一个搜索, 可能让我们了解系统中的一些程序与文件压缩有关系. 这样做:

```bash
ls /bin /usr/bin | sort | uniq | grep zip
```

grep 有一对方便的选项:
`-i`导致 `grep` 忽略大小写当执行搜索时(通常,搜索是大小写 敏感的),
`-v`选项会告诉 `grep` 只打印不匹配的行.

## head/tail - 打印文件开头部分/结尾部分

有时候你不需要一个命令的所有输出. 可能你只想要前几行或者后几行的输出内容.
`head` 命令打印文件的前十行,而 `tail` 命令打印文件的后十行.
默认情况下,两个命令 都打印十行文本,但是可以通过`-n`选项来调整命令打印的行数.

```bash
head -n 5 ls-output.txt
tail -n 5 ls-output.txt
```

它们也能用在管道线中:

```bash
ls /usr/bin | tail -n 5
```

`tail` 有一个选项允许你实时的浏览文件. 当观察日志文件的进展时,这很有用,因为它们同时在被写入.

在以下的例子里,我们要查看目录`/var/log`里面的信息文件.
在 一些 Linux 发行版中,要求有超级用户权限才能阅读这些文件,因为文件`/var/log/messages`可能包含安全信息.

```bash
tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
```

使用`-f`选项,`tail`命令继续监测这个文件,当新的内容添加到文件后,它们会立即出现在屏幕上.
这会一直继续下去直到你输入`Ctrl-c`.

## tee - 从 Stdin 读取数据,并同时输出到 Stdout 和文件

为了和我们的管道隐喻保持一致,Linux 提供了一个叫做 `tee` 的命令,这个命令制造了 一个`tee`,安装到我们的管道上.

`tee` 程序从标准输入读入数据,并且同时复制数据到**标准输出**(相当于允许数据继续随着管道线流动)和一个或多个文件.
当在某个中间处理阶段来捕捉一个管道线的内容时,这很有帮助.

这里,我们重复执行一个先前的例子, 这次包含 `tee` 命令,在 `grep` 过滤管道线的内容之前,来捕捉整个目录列表到文件 ls.txt:

```bash
ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```
