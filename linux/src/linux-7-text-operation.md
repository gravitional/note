# linux-7

## 第二十章:正则表达式

追溯到 `Unix` 刚刚开发的时候,它只知道 `ASCII` 字符. 在 `ASCII` 中,前`32`个字符 (数字`0-31`)都是控制码(如 `tabs`,`backspaces`,和`回车`). 
随后的`32`个字符(`32-63`)包含可打印的字符, 包括大多数的标点符号和数字`0`到`9`. 
再随后的`32`个字符(`64-95`)包含大写字符和一些更多的标点符号.  最后的`31`个字符(`96-127`)包含小写字母和更多的标点符号. 
基于这种安排方式,系统使用这种排序规则 的 `ASCII`:

```bash
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
```

而普通的字典顺序像这样:

```bash
aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
```

随着 `Unix` 系统的知名度在美国之外的国家传播开来,就需要支持不在 U.S.英语范围内的字符.  
于是就扩展了`ASCII` 字符表,使用了整个`8`位,添加了字符(数字`128-255`),这样就 容纳了更多的语言. 
为了支持这种能力,`POSIX` 标准介绍了一种叫做 `locale` 的概念,其可以被调整,来为某个特殊的区域, 选择所需的字符集. 通过使用下面这个命令,我们能够查看到我们系统的语言设置:

```bash
[me@linuxbox ~]$ echo $LANG
en_US.UTF-8
```

通过这个设置,`POSIX` 相容的应用程序将会使用字典排列顺序而不是 `ASCII` 顺序. 当`[A-Z]`字符区域按照字典顺序解释的时候,包含除了小写字母`a`之外的所有字母. 
为了部分地解决这个问题,`POSIX` 标准包含了大量的字符集,其提供了有用的字符区域.  下表中描述了它们:

表20-2: POSIX 字符集
字符集 说明

+ `[:alnum:]`:   字母数字字符. 在 `ASCII` 中,等价于:`[A-Za-z0-9]`
+ `[:word:]`:   与`[:alnum:]`相同, 但增加了下划线字符. 
+ `[:alpha:]`:   字母字符. 在 `ASCII` 中,等价于:`[A-Za-z]`
+ `[:blank:]`:   包含`空格`和 `tab` 字符. 
+ `[:cntrl:]`:   `ASCII` 的控制码. 包含了`0`到`31`,和`127`的 `ASCII` 字符. 
+ `[:digit:]`:   数字`0`到`9`
+ `[:graph:]`: 可视字符. 在 `ASCII` 中,它包含`33`到`126`的字符. 
+ `[:lower:]`:   小写字母. 
+ `[:punct:]`:   标点符号字符. 在 `ASCII` 中
+ `[:print:]`:   可打印的字符. 在`[:graph:]`中的所有字符,再加上`空格`字符. 
+ `[:space:]`:   空白字符,包括`空格`,`tab`,`回车`,`换行`,`vertical tab`, 和 `form feed`.在`ASCII` 中, 等价于:`[ \t\r\n\v\f]`
+ `[:upper:]`:   大写字母. 
+ `[:xdigit:]`: 用来表示十六进制数字的字符. 在`ASCII` 中,等价于:`[0-9A-Fa-f]`

### 用 find 筛选不规范文件名

`find` 命令支持一个基于正则表达式的测试. 
当某一行包含的字符串匹配上了一个表达式的时候,`grep` 命令会打印出这一行,然而 `find` 命令要求路径名精确地匹配这个正则表达式. 
在下面的例子里面,我们将使用带有一个正则表达式的 `find` 命令,来查找每个路径名,其包含的任意字符都不是以下字符集中的一员. 

```bash
[-\_./0-9a-zA-Z]
```

这样一种扫描会发现包含空格和其它潜在不规范字符的路径名:

```bash
[me@linuxbox ~]$ find . -regex '.*[^-\_./0-9a-zA-Z].*'
```

由于要精确地匹配整个路径名,所以我们在表达式的两端使用了`.*`来匹配零个或多个字符.  在表达式中间,我们使用了否定的中括号表达式,其包含了我们一系列可接受的路径名字符. 

### 用 locate 查找文件

`locate` 程序支持基本的(`--regexp` 选项)和扩展的(`--regex` 选项)正则表达式. 

```bash
[me@linuxbox ~]$ locate --regex 'bin/(bz|gz|zip)'
```

通过使用 `alternation`,我们搜索包含 `bin/bz`,`bin/gz`,或`/bin/zip` 字符串的路径名. 

## 第二十一章:文本处理

### cat

`cat` 程序具有许多有趣的选项. 其中许多选项用来帮助更好的可视化文本内容. 
一个例子是`cat -A`可以用来显示文本中的非打印字符.
`tab` 字符在我们的文本中由 `^I` 字符来表示. 这是一种常见的表示方法,意思是`Control-I`,结果证明,它和 `tab`字符是一样的

`cat` 程序也包含用来修改文本的选项. 
最著名的两个选项是`-n`,其给文本行添加行号. 以及`-s`, 禁止输出多行空白. 

### sort

`sort` 程序对标准输入或命令行中指定的一个或多个文件进行排序,然后把排序结果发送到标准输出. 
`sort` 程序能接受命令行中的多个文件作为参数,所以有可能把多个文件合并成一个有序的文件. 例如:

```bash
sort file1.txt file2.txt file3.txt > final_sorted_list.txt
```

`sort` 程序有几个有趣的选项. 这里只是一部分列表:
表21-1: 常见的 sort 程序选项
选项 长选项 描述

`-b`,`--ignore-leading-blanks`:默认情况下,排序从每行的第一个字符开始. 这个选项导致 `sort` 程序忽略空格,从第一个非空白字符开始排序. 
`-f`,`--ignore-case`:让排序不区分大小写. 
`-n`:`--numeric-sort`:默认基于字符串的长度来排序. 使用此选项允许根据数字值执行排序,而不是字母值. 
`-r`,`--reverse`:  按相反顺序排序. 结果按照降序排列,而不是升序. 
`-k`,`--key=field1[,field2]` 对从 `field1` 到 `field2` 之间的字符排序,而不是整个文本行. 看下面的讨论. 
`-m`,`--merge`: 把每个参数看作是一个预先排好序的文件. 把多个文件合并成一个排好序的文件,而没有执行额外的排序. 
`-o`,`--output=file`: 把排好序的输出结果发送到文件,而不是标准输出. 
`-t`,`--field-separator=char`: 定义域分隔字符. 默认情况下,域由空格或制表符分隔. 

首先,让我们看一下 `-n` 选项,被用做数值排序. 通过这个选项,可以基于数值进行排序. `du` 命令可以确定最大的磁盘空间用户. 通常 `du` 命令列出的输出结果按照路径名来排序:

```bash
[me@linuxbox ~]$ du -s /usr/share/* | head
68K  /usr/share/a11y-profile-manager
28K  /usr/share/accounts
40K  /usr/share/accountsservice
...
```

我们能够产生一个按数值排序的列表,来显示 `10` 个最大的空间占据者:

```bash
[me@linuxbox ~]$ du -s /usr/share/* | sort -nr | head
1020K  /usr/share/speech-dispatcher
1008K  /usr/share/rubygems-integration
972K  /usr/share/pandoc
...
```

通过使用`-nr` 选项,我们产生了一个反向的数值排序,最大数值排列在第一位. 这种排序起作用是因为数值出现在每行的开头. 
但是如果我们想要基于文件行中的某个数值排序,又会怎样呢? 例如,命令 `ls -l` 的输出结果:

```bash
[me@linuxbox ~]$ ls -lh /usr/bin | head
-rwxr-xr-x 1 root   root      59K 9月   5  2019 [
-rwxr-xr-x 1 root   root       96 3月   8 21:02 2to3-2.7
-rwxr-xr-x 1 root   root     9.9K 4月  23  2016 411toppm
...
```

此刻,忽略 `ls` 程序也能按照文件大小排序,我们使用 `sort` 程序来完成此任务:

```bash
[me@linuxbox ~]$ ls -l /usr/bin | sort -nr -k 5 | head
-rwxr-xr-x 1 root   root    1023K 3月  26  2020 x86_64-linux-gnu-gcc-7
-rwxr-xr-x 1 root   root     1019 4月  20  2020 wine-stable
-rwxr-xr-x 1 root   root     1007 8月  22  2020 dvipdf
...
```

`sort` 程序的许多用法都涉及到处理表格数据,例如上面 `ls` 命令的输出结果. 
如果我们把数据库的术语应用到上面的表格中,每行是一条记录,并且每条记录由多个字段组成, 例如文件属性,链接数,文件名,文件大小等等. 
`sort` 程序能够处理独立的字段. 在数据库术语中, 我们能够指定一个或者多个关键字段,来作为排序的关键值. 
在上面的例子中,我们指定 `n` 和 `r` 选项来执行相反的数值排序,并且指定 `-k 5`,让 `sort` 程序使用第五字段作为排序的关键值. 

`sort` 程序允许多个 `-k` 选项的实例,所以可以指定多个排序关键值. 下面是多键值排序的语法:

```bash
[me@linuxbox ~]$ sort --key=1,1 --key=2n distros.txt
```

虽然为了清晰,我们使用了选项的长格式,但是 `-k 1,1 -k 2n` 格式是等价的. `1,1`意味着始于并且结束于第一个字段. 
在第二个实例中,我们指定了 `2n`,表示按第二个字段排序, 并且按照数值排序. 键值说明符的末尾可以附上一个选项字母, 用来指定排序的种类. 
这些选项字母和 `sort` 程序的全局选项一样:`b`(忽略开头的空格),`n`(数值排序),`r`(逆向排序),等等. 

对于日期格式, 在计算机中,日期通常设置为 `YYYY-MM-DD` 格式, 这样按时间顺序排序变得容易,但有时我们的日期为`MM/DD/YYYY`的格式. 
幸运地是, `key` 选项允许在字段中指定偏移量,所以我们能在字段中定义键值. 

[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt

通过指定 `-k 3.7`,我们指示 `sort` 程序使用一个排序键值,其始于第三个字段中的第七个字符,对应于年的开头. 
同样地,我们指定 `-k 3.1` 和 `-k 3.4` 来分离日期中的月和日.  我们也添加了 `n` 和 `r` 选项来实现一个逆向的数值排序. 
`b` 选项用来删除日期字段中开头的空格( 行与行之间的空格数迥异,因此会影响 `sort` 程序的输出结果). 

一些文件不会使用 `tabs` 和`空格`做为字段界定符;例如, `/etc/passwd` 文件.`sort` 程序提供 了一个 `-t` 选项来定义分隔符. 
按照第七个字段(帐户的默认 `shell`)来排序此 `passwd` 文件,我们可以这样做:

```bash
[me@linuxbox ~]$ sort -t ':' -k 7 /etc/passwd | head
```

### uniq

与 `sort` 程序相比,`uniq` 程序是个轻量级程序.  `uniq` 执行一个看似琐碎的认为. 当给定一个排好序的文件(包括标准输出),`uniq` 会删除任意重复行,并且把结果发送到标准输出.  
它常常和 `sort` 程序一块使用,来清理重复的输出. 
`uniq` 程序是一个传统的 `Unix` 工具,经常与 `sort` 程序一块使用, `GNU` 版本的 `sort` 程序支持一个 `-u` 选项,其可以从排好序的输出结果中删除重复行.  `uniq` 只会删除相邻的重复行.

表21-2: 常用的 `uniq` 选项
选项 说明

+ `-c` 输出所有的重复行,并且每行开头显示重复的次数. 
+ `-d` 只输出重复行,而不是特有的文本行. 
+ `-f n` 忽略每行开头的 `n` 个字段,字段之间由空格分隔, 不同于 `sort` 程序, `uniq` 没有选项来设置备用的字段分隔符. 
+ `-i` 在比较文本行的时候忽略大小写. 
+ `-s n` 跳过(忽略)每行开头的 `n` 个字符. 
+ `-u` 只是输出独有的文本行. 这是默认的

### 切片和切块

下面我们将要讨论的三个程序用来从文件中获得文本列,并且以有用的方式重组它们. 

### cut

`cut` 程序被用来从文本行中抽取文本,并把其输出到标准输出. 它能够接受多个文件参数或者 标准输入. 从文本行中指定要抽取的文本有些麻烦,使用以下选项:

表21-3: cut 程序选择项
选项 说明

+ `-c char_list` 从文本行中抽取由 `char_list` 定义的文本. 这个列表由一个或多个逗号分隔开的数值区间组成. 
+ `-f field_list` 从文本行中抽取一个或多个由 `field_list`定义的字段. 列表包括一个或多个字段,或由逗号分隔开的字段区间. 
+ `-d delim_char` 当指定`-f` 选项之后,使用 `delim_char`做为字段分隔符. 默认情况下, 字段之间必须由单个 `tab` 字符分隔开. 
+ `--complement` 抽取整个文本行,除了那些由`-c` 和/或`-f` 选项指定的文本. 

正如我们所看到的,`cut` 程序抽取文本的方式相当不灵活. `cut` 命令最好用来从其它程序产生的文件中抽取文本,而不是从人们直接输入的文本中抽取, 例子为:

```bash
cut -f 3 distros.txt #抽取第三个字段
cut -f 3 distros.txt | cut -c 7-10 # 再抽取位置为7到10的字符
```

`Coreutils` 软件包有一个工具`expand`可以将`tab`转换成相应数目的空格, `unexpand`把空格替换成`tab`. 使用 `-d` 选项,我们能够指定冒号做为字段分隔符. 

```bash
[me@linuxbox ~]$ cut -d ':' -f 1 /etc/passwd | head
```

### paste

`paste` 命令的功能正好与 `cut` 相反. 它会添加一个或多个文本列到文件中. 它通过读取多个文件,然后把每个文件中顺序对应的行合并, 写入标准输出. 

### join

在某些方面,`join` 命令类似于 `paste`,它会往文件中添加列,但是它使用了独特的方法来完成.  
`join`会合并具有相同`key`的条目. 例如下面两个文件

```bash
[me@linuxbox ~]$ head distros-key-names.txt
11/25/2008 Fedora
10/30/2008 Ubuntu
06/19/2008 SUSE

[me@linuxbox ~]$ head distros-key-vernums.txt
11/25/2008 10
10/30/2008 8.10
06/19/2008 11.0
```

使用`join`可以把它们连接起来:

```bash
[me@linuxbox ~]$ join distros-key-names.txt distros-key-vernums.txt | head
11/25/2008 Fedora 10
10/30/2008 Ubuntu 8.10
06/19/2008 SUSE 11.0
```

现在我们有两个具有共享`key`( `发行日期` )的文件. 有必要指出,为了使 `join` 命令 能正常工作, 所有文件必须按照`key`排序. 
默认情况下,`join` 命令使用空白字符做为输入字段的界定符,`一个空格`作为输出字段的界定符.

### 比较文本

通常比较文本文件的版本很有帮助. 对于系统管理员和软件开发者来说,这个尤为重要.  一名系统管理员可能需要拿现有的配置文件与先前的版本做比较,来诊断一个系统错误.  
同样的,一名程序员经常需要查看程序的修改. 

### comm

`comm` 程序会比较两个文本文件,并且会显示每个文件特有的文本行和共有的文本行. 

```bash
[me@linuxbox ~]$ comm file1.txt file2.txt
```

`comm` 命令产生三列输出. 第一列包含第一个文件独有的文本行;第二列是第二个文件独有的;第三列包含两个文件共有的文本行. 
`comm` 支持 `-n` 形式的选项,这里 `n` 代表 `1`,`2` 或 `3`. 这些选项使用的时候,指定了要隐藏的列. 
例如,如果我们只想输出两个文件共享的文本行, 我们将隐藏第一列和第二列的输出结果:

```bash
[me@linuxbox ~]$ comm -12 file1.txt file2.txt
```

### diff

类似于 `comm` 程序,`diff` 程序被用来监测文件之间的差异. 然而,`diff` 是一款更加复杂的工具,它支持许多输出格式,并且一次能处理许多文本文件. 
软件开发员经常使用 `diff` 程序来检查不同程序源码版本之间的更改,`diff` 能够递归地检查源码目录,经常称之为源码树. 
`diff` 程序的一个常见用例是创建 `diff` 文件或者补丁,它会被其它程序使用,例如 `patch` 程序(我们一会儿讨论),来把文件从一个版本转换为另一个版本. 
如果我们使用 `diff` 程序,来查看我们之前的文件实例:

```bash
[me@linuxbox ~]$ diff file1.txt file2.txt
1d0
< a
4a4
> e
```

我们看到 `diff` 程序的默认输出风格:对两个文件之间差异的简短描述. 在默认格式中, 每组的更改之前都是一个更改命令,其形式为 `range operation range` , 
用来描述要求更改的位置和类型,从而把第一个文件转变为第二个文件:

表21-4: `diff` 更改命令
改变 说明

+ `r1ar2`: `add`, 把第二个文件中位置 `r2` 处的文件行添加到第一个文件中的 `r1` 处, 
+ `r1cr2`: `cover`, 用第二个文件中位置 `r2` 处的文本行覆盖位置 `r1` 处的文本行
+ `r1dr2`:`delete`, 删除第一个文件中位置 `r1` 处的文本行,这些文本行对应第二个文件中位置 `r2` 处

在这种格式中,一个范围就是由逗号分隔开的开头行和结束行的列表. 
然这种格式是默认情况(主要是为了服从 `POSIX` 标准且向后与传统的 `Unix diff` 命令兼容), 但是它并不像其它可选格式一样被广泛地使用. 
最流行的两种格式是上下文模式和统一模式. 当使用上下文模式(带上` -c` 选项),我们将看到这些:

```bash
[me@linuxbox ~]$ diff -c file1.txt file2.txt
*** file1.txt 2008-12-23 06:40:13.000000000 -0500
--- file2.txt 2008-12-23 06:40:34.000000000 -0500
...
```

这个输出结果以两个文件名和它们的时间戳开头. 第一个文件用`星号`做标记,第二个文件用`短横线`做标记.  
这些标记将象征它们各自代表的文件. 下一步,我们看到几组修改, 包括默认的周围上下文行数. 在第一组中,我们看到:
`*** 1,4 ***`其表示第一个文件中从第一行到第四行的文本行. `--- 1,4 ---`这表示第二个文件中从第一行到第四行的文本行. 
在更改组内,文本行以四个指示符之一开头:

表21-5: `diff` 上下文模式更改指示符
指示符 意思

+ `blank`:  上下文显示行, 表示没有差异
+ `-`:  删除行. 第一个文件中有, 第二个没有. 
+ `+`:  添加行. 第一个文件中没有, 第二个有. 这一行将会出现在第二个文件内,而不是第一个文件中. 
+ `!`:  更改行. 两个文件的本行的内容不同. 

统一模式相似于上下文模式,但是更加简洁. 通过 `-u` 选项来指定它:

```bash
[me@linuxbox ~]$ diff -u file1.txt file2.txt
--- file1.txt 2008-12-23 06:40:13.000000000 -0500
+++ file2.txt 2008-12-23 06:40:34.000000000 -0500
@@ -1,4 +1,4 @@
```

上下文模式和统一模式之间最显著的差异就是重复上下文的消除,这就使得统一模式的输出结果要比上下文模式的输出结果简短. 
在我们上述实例中,我们看到类似于上下文模式中的文件时间戳,其紧紧跟随字符串 `@@ -1,4+1,4 @@`. 
这行字符串表示了在更改组中描述的第一个文件中的文本行和第二个文件中的文本行.  这行字符串之后就是文本行本身,与三行默认的上下文. 每行以可能的三个字符中的一个开头:

表21-6: `diff` 统一模式更改指示符
字符 意思

+ `空格`:  两个文件都包含这一行.
+ `-`:  在第一个文件中删除这一行.
+ `+`:  添加这一行到第一个文件中.

### patch

`patch` 程序被用来把更改应用到文本文件中. 它接受从 `diff` 程序的输出,并且通常被用来把较老的文件版本转变为较新的文件版本. 

让我们考虑一个著名的例子. `Linux` 内核是由一个 大型的,组织松散的贡献者团队开发而成,这些贡献者会提交固定的少量更改到源码包中.  
`Linux` 内核由几百万行代码组成,虽然每个贡献者每次所做的修改相当少. 对于一个贡献者来说,每做一个修改就给每个开发者发送整个的内核源码树,这是没有任何意义的. 
相反, 提交一个 diff 文件. 一个 `diff` 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异.  
然后一个接受者使用 `patch` 程序,把这些更改应用到他自己的源码树中. 使用 `diff/patch` 组合提供了 两个重大优点:

1. 一个 diff 文件非常小,与整个源码树的大小相比较而言. 
2. 一个 diff 文件简洁地显示了所做的修改,从而允许程序补丁的审阅者能快速地评估它. 

当然,`diff/patch` 能工作于任何文本文件,不仅仅是源码文件. 它同样适用于配置文件或任意其它文本. 
准备一个 `diff` 文件供 `patch` 程序使用,`GNU` 文档(查看下面的拓展阅读部分)建议这样使用 `diff` 命令:

```bash
diff -Naur 旧文件 新文件 > 补丁文件
```

`旧文件` 和 `新文件` 可以是单个文件也可以是包含文件的目录. `r` 选项支持递归目录树. 一旦创建了 `diff` 文件,我们就能应用它,把旧文件修补成新文件. 

```bash
patch < 补丁文件
```

我们不需要指定要修补的目标文件,因为 `diff` 文件(在统一模式中)已经 在标题行中包含了文件名. 
`patch` 程序有大量的选项,而且还有额外的实用程序可以被用来分析和编辑补丁. 

+ `-N, --new-file`:  认为缺失文件为空. 
+ `-a, --text`: 将所有文件当成文本格式
+ `-u, -U NUM, --unified[=NUM]`: 在统一模式下, 共同内容的行数(默认为`3`)
+ `-r, --recursive`:  递归地比较子文件夹

### tr

一般的文本编辑器是交互式的,意思是我们手动移动光标,然后输入我们的修改.  然而,也有非交互式的方法来编辑文本. 有可能,例如,通过单个命令把一系列修改应用到多个文件中. 

`tr` 程序被用来更改字符. 我们可以把它看作是一种基于字符的查找和替换操作. 换字是一种把字符从一个字母转换为另一个字母的过程. 例如,把小写字母转换成大写字母就是换字. 
我们可以通过 `tr` 命令来执行这样的转换,如下所示:

```bash
[me@linuxbox ~]$ echo "lowercase letters" | tr a-z A-Z
LOWERCASE LETTERS
```

正如我们所见,`tr` 命令操作标准输入,并把结果输出到标准输出. `tr` 命令接受两个参数:要被转换的字符集以及相对应的转换后的字符集. 字符集可以用三种方式来表示:

1. 一个枚举列表. 例如, `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
2. 一个字符域. 例如,`A-Z` . 注意这种方法有时候面临与其它命令相同的问题,归因于语系的排序规则,因此应该谨慎使用. 
3. `POSIX` 字符类. 例如,`[:upper:]`

大多数情况下,两个字符集应该长度相同;然而,有可能第一个集合大于第二个,尤其如果我们想要把多个字符转换为单个字符:

```bash
[me@linuxbox ~]$ echo "lowercase letters" | tr [:lower:] A
AAAAAAAAA AAAAAAA
```

除了换字之外,`tr` 命令能允许字符从输入流中简单地被删除. 在之前的章节中,我们讨论了转换 `MS-DOS` 文本文件为 `Unix` 风格文本的问题. 
为了执行这个转换,每行末尾的回车符需要被删除.  这个可以通过 `tr` 命令来执行,如下所示:

```bash
tr -d '\r' < dos_file > unix_file
```

这里的 `dos_file` 是需要被转换的文件,`unix_file` 是转换后的结果. 这种形式的命令使用转义序列 `\r `来代表回车符. 查看 `tr` 命令所支持地完整的转义序列和字符类别列表,试试下面的命令:

```bash
[me@linuxbox ~]$ tr --help
```

***
ROT13: 不那么秘密的加密

`tr` 命令的一个有趣的用法是执行 `ROT13` 文本编码. 把 ROT13称为`加密`有点夸张, `文本模糊处理`更准确些. 
这个方法就是简单地把每个字符在字母表中向前移动`13`位. 因为移动的位数是可能的`26`个字符的一半, 所以对文本再次执行这个算法,就恢复到了它最初的形式. 
通过 `tr` 命令来执行这种编码:

```bash
echo  "secret text"  | tr a-zA-Z n-za-mN-ZA-M |
frperg grkg
```

再次执行相同的过程,得到翻译结果:

```bash
echo "frperg grkg" | tr a-zA-Z n-za-mN-ZA-M+ |
secret text
```

`tr` 也可以完成另一个技巧. 使用 `-s` 选项,`tr` 命令能"挤压"(删除)重复的字符实例:

```bash
[me@linuxbox ~]$ echo "aaabbbccc" | tr -s ab
abccc
```

这里我们有一个包含重复字符的字符串. 通过给 `tr` 命令指定字符集`ab`,我们能够消除字符集中字母的重复实例,对字符集之外字符(`c`)不作用.
注意重复的字符必须是相邻的.  如果它们不相邻,那么挤压会没有效果. 

### sed

`sed` 是 `stream editor`(流编辑器)的简称. 它对文本流进行编辑,或是一系列指定的文件,或是标准输入. 
`sed` 是一款强大的,并且有些复杂的程序(有整本内容都是关于 `sed` 程序的书籍), 所以在这里我们不会详尽的讨论它. 
总之, `sed` 的工作方式可以是给出单个编辑命令(在命令行中), 也可以是包含多个命令的脚本文件名, 然后它就按行来执行这些命令. 这里有一个非常简单的 `sed` 实例:

```bash
[me@linuxbox ~]$ echo "front" | sed 's/front/back/'
back
```

在这个例子中,我们使用 `echo` 命令产生了一个单词的文本流,然后把它管道给 `sed` 命令. `sed`依次对流文本执行指令 `s/front/back/`,随后输出`back`. 
我们也能够把这个命令认为是相似于 `vi` 中的`替换` (查找和替代)命令. 

`sed` 中的命令开始于单个字符. 在上面的例子中,这个替换命令由字母 `s` 来代表,其后跟着`查找`和`替代`字符串,`斜杠`字符做为分隔符. 
分隔符的选择是随意的. 按照惯例,经常使用斜杠字符, 但是 `sed` 将会接受紧随命令之后的任意字符做为分隔符. 我们可以按照这种方式来执行相同的命令:

```bash
[me@linuxbox ~]$ echo "front" | sed 's_front_back_'
back
```

通过紧跟命令之后使用`下划线`字符,则它变成界定符. `sed` 可以设置界定符的能力,使命令的可读性更强, 正如我们将看到的.
`sed` 中的大多数命令之前都会带有一个地址,其指定了输入流中要被编辑的文本行. 如果省略了地址, 然后会对输入流的每一行执行编辑命令. 
最简单的地址形式是一个行号. 我们能够添加一个地址 到我们例子中:

```bash
[me@linuxbox ~]$ echo "front" | sed '1s/front/back/'
back
```

给我们的命令添加地址 `1`,就导致只对仅有一行文本的输入流的第一行执行替换操作. 如果我们指定另一 个数字:

```bash
[me@linuxbox ~]$ echo "front" | sed '2s/front/back/'
front
```

我们看到没有执行这个编辑命令,因为我们的输入流没有第二行. 地址可以用许多方式来表达. 这里是最常用的:

表21-7: `sed` 地址表示法
地址 说明

+ `n`: 行号,`n` 是一个正整数. 
+ `$`: 最后一行. 
+ `/regexp/`: 所有匹配一个 `POSIX` 基本正则表达式的文本行, 表达式通过斜杠界定. 正则表达式可以有备用字符界定,例如`\cregexpc`,这里 `c` 就是一个备用的字符. 
+ `addr1,addr2`: 从 `addr1` 到 `addr2` 范围内的文本行,包含地址 `addr2` 在内. 地址可能是上述任意单独的地址形式. 
+ `first~step`: 匹配由数字 `first` 代表的文本行,然后随后的每个在 `step` 间隔处的文本行. 例如 `1~2` 是指每个位于奇数行号的文本行,`5~5` 则指第五行和之后每五行位置的文本行. 
+ `addr1,+n`: 匹配地址 `addr1` 和随后的 `n` 个文本行. 
+ `addr!`: 匹配所有的文本行,除了 `addr` 之外,`addr` 可能是上述任意的地址形式. 

例如打印`1`到`5`行, 

```bash
[me@linuxbox ~]$ sed -n '1,5p' distros.txt
```

一般为了高效,我们必须指定选项 `-n`(不自动打印选项), 让 `sed` 不要默认地打印每一行, `p` 命令, 其就是简单地把匹配的文本行打印出来. 

```bash
$ sed -n '/SUSE/p' distros.txt
```

通过包含由斜杠界定的正则表达式 `/SUSE/`,我们能够孤立出包含它的文本行,和 `grep` 程序的功能是相同的. 
最后,我们将试着否定上面的操作,通过给这个地址添加一个感叹号:

```bash
[me@linuxbox ~]$ sed -n '/SUSE/!p' distros.txt
```

目前为止,我们已经知道了两个 sed 的编辑命令,`s` 和 `p`. 这里是一个更加全面的基本编辑命令列表:

表21-8: `sed` 基本编辑命令
命令 说明

+ `=`: 输出当前的行号. 
+ `a`: 在当前行之后追加文本. 
+ `d`: 删除当前行. 
+ `i`: 在当前行之前插入文本. 
+ `p`: 打印当前行. 默认情况下,`sed` 程序打印每一行. 通过指定 `-n` 选项,这个默认的行为能够被忽略. 
+ `q`: 退出 `sed`,不再处理更多的文本行. 如果不指定 `-n` 选项,输出当前行. 
+ `Q`: 退出 `sed`,不再处理更多的文本行. 
+ `s/regexp/replacement/`: 只要找到一个 `regexp` 匹配项,就替换为 `replacement` 的内容. `replacement`可以是`&`, 就是`regexp`匹配到的文本. 
另外, `replacement` 可能包含序列 `\1`到`\9`,也就是反向引用. 在 `replacement` 末尾的斜杠之后,可以指定一个 可选的标志,来修改 `s` 命令的行为. 
+ `y/set1/set2`:  执行字符转写操作,通过把 `set1` 中的字符转变为相对应的 `set2` 中的字符. 注意不同于 `tr` 程序,`sed` 要求两个字符集合具有相同的长度. 

到目前为止,`s` 命令是最常使用的编辑命令. 例如 文件中的日期格式是`MM/DD/YYYY`,但如果格式是 `YYYY-MM-DD` 会更好一些(利于排序). 
手动修改 日期格式不仅浪费时间而且易出错,但是有了 `sed`,只需一步就能完成修改:

```bash
[me@linuxbox ~]$ sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
```

哇!这个命令看起来很丑陋. 但是它起作用了. 仅用一步,我们就更改了文件中的日期格式.  它也是一个例子: 有时候我们会开玩笑地把正则表达式称为是"只写"的. 
我们能写正则表达式,但是有时候我们不能读它们. 在我们恐惧地忍不住要逃离此命令之前,让我们看一下 怎样来构建它. 

因为日期是 `MM/DD/YYYY` 格式,并且出现在文本行的末尾,我们可以使用这样的表达式:

```bash
([0-9]{2})/([0-9]{2})/([0-9]{4})$
```

此表达式匹配两位数字,一个斜杠,两位数字,一个斜杠,四位数字,以及行尾. 圆括号包围的是子表达式, 稍后可以使用反向引用,现在我们就可以构建`replacement`,如下所示:

```bash
\3-\1-\2
```

此表达式给出了`年份-月份-日期`.合起来就是 `sed 's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt`. 

我们还有两个问题. 第一个是在我们表达式中额外的斜杠将会迷惑 `sed`.第二个是在默认情况下,`sed`只接受基本的正则表达式,在表达式中的几个字符会 被当作文字字面值,而不是元字符. 
我们能够通过反斜杠的自由应用来转义令人不快的字符:`sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt`. 你掌握了吧!

`s` 命令的另一个功能是使用可选标志,其跟随替代字符串. 一个最重要的可选标志是 `g` 标志,其 指示 `sed` 对某个文本行全范围地执行查找和替代操作,不仅仅是对第一个实例,例如: 

```bash
[me@linuxbox ~]$ echo "aaabbbccc" | sed 's/b/B/'
aaaBbbccc
```

我们看到虽然执行了替换操作,但是只针对第一个字母 `b` 实例,然而剩余的实例没有更改. 

```bash
[me@linuxbox ~]$ echo "aaabbbccc" | sed 's/b/B/g'
aaaBBBccc
```

目前为止,通过命令行我们只让 `sed` 执行单个命令. 使用 `-f` 选项,也有可能在一个脚本文件中构建更加复杂的命令.  
我们需要编写一个脚本,所以我们将打开文本编辑器,然后输入以下文字:

```bash
# sed script to produce Linux distributions report
1 i\
\
Linux Distributions Report\
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
```

我们将把 `sed` 脚本保存为 `distros.sed` 文件,然后像这样运行它:

```bash
[me@linuxbox ~]$ sed -f distros.sed distros.txt
```

让我们分析一下脚本文件. 我们将使用 `cat` 来给每行文本编号:

```bash
[me@linuxbox ~]$ cat -n distros.sed
1 # sed script to produce Linux distributions report
2
3 1 i\
4 \
5 Linux Distributions Report\
6
7 s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
```

我们脚本文件的第一行是一条注释. 如同 `Linux` 系统中的许多配置文件和编程语言一样,注释以`#`字符开始, 然后是人类可读的文本. 
第二行是一个空行. 正如注释一样,添加空白行是为了提高程序的可读性. 

许多 `sed` 命令支持行地址. 这些行地址被用来指定对输入文本的哪一行执行操作. 行地址可能被 表示为单独的行号,行号范围,以及特殊的行号`$`,它表示输入文本的最后一行. 
从第三行到第六行所包含地文本要被插入到地址 `1` 处,也就是输入文本的第一行中. 这个 `i` 命令 之后是反斜杠回车符,来产生一个转义的回车符,或者就是所谓的连行符. 
这个序列能够 被用在许多环境下,包括 `shell` 脚本,从而允许把回车符嵌入到文本流中,而没有通知解释器(在这是指 `sed` 解释器)已经到达了文本行的末尾. 
`i` 命令,同样地,命令 `a`(追加文本, 而不是插入文本)和 `c`(取代文本)命令都允许多个文本行,只要每个文本行,除了最后一行,以一个 连行符结束. 
实际上,脚本的第六行是插入文本的末尾,它以一个普通的回车符结尾,而不是一个 连行符,通知解释器 `i` 命令结束了. 

注意:一个连行符由一个`斜杠字符`其后紧跟一个`回车符`组成. 它们之间不允许有空白字符. 

第七行是我们的查找和替代命令. 因为命令之前没有添加地址,所以输入流中的每一行文本 都得服从它的操作. 
第八行执行小写字母到大写字母的字符替换操作. 注意不同于 `tr` 命令,这个 `sed` 中的 `y` 命令不 支持字符区域(例如,`[a-z]`),也不支持 `POSIX` 字符集. 
因为 `y` 命令之前不带地址, 所以它会操作输入流的每一行. 

`sed` 是一款非常强大的程序,它能够针对文本流完成相当复杂的编辑任务. 它最常用于简单的行任务,而不是长长的脚本. 
许多用户喜欢使用其它工具,来执行较大的工作.  在这些工具中最著名的是 `awk` 和 `perl` . 
它们不仅仅是工具,像这里介绍的程序,且延伸到 完整的编程语言领域. 特别是 `perl`,经常被用来代替 `shell`脚本,来完成许多系统管理任务, 同时它也是一款非常流行网络开发语言. 
`awk` 更专用一些. 其具体优点是其操作表格数据的能力.  虽然关于 `awk` 和 `perl` 的内容都超出了本书所讨论的范围, 但是对于 Linux 命令行用户来说,它们都是非常好的技能. 

### aspell

我们要查看的最后一个工具是 `aspell`,一款交互式的拼写检查器. `aspell` 程序是早先 `ispell` 程序的继承者,大多数情况下,它可以被用做一个替代品. 
虽然 `aspell` 程序大多被其它需要拼写检查能力的 程序使用,但它也可以作为一个独立的命令行工具使用. 
它能够智能地检查各种类型的文本文件, 包括 `HTML` 文件,`C/C++`程序,电子邮件和其它种类的专业文本. 拼写检查一个包含简单的文本文件,可以这样使用 `aspell`:

```bash
aspell check textfile
```

这里的 `textfile` 是要检查的文件名. 作为一个实际例子,让我们创建一个简单的文本文件,叫做 `foo.txt`, 包含一些故意的拼写错误:

```bash
[me@linuxbox ~]$ cat > foo.txt
The quick brown fox jimped over the laxy dog.
```

下一步我们将使用 `aspell` 来检查文件:

```bash
[me@linuxbox ~]$ aspell check foo.txt
```

`aspell` 在检查模式下是交互的,在显示屏的顶部,我们看到我们的文本中有一个拼写可疑且高亮显示的单词. 在中间部分,我们看到 十个拼写建议,序号从 `0` 到 `9`,然后是一系列其它可能的操作. 
最后,在最底部,我们看到一个提示符, 准备接受我们的选择. 如果我们按下 `1` 按键,`aspell` 会用单词 `jumped` 代替错误单词,然后移动到下一个拼写错的单词,就是`laxy`. 
一旦 aspell 结束操作,我们 可以检查我们的文件,会看到拼写错误的单词已经更正了. 

[me@linuxbox ~]$ cat foo.txt
The quick brown fox jumped over the lazy dog.

除非由命令行选项 `--dont-backup` 告诉 `aspell`,否则通过追加扩展名`.bak` 到文件名中, `aspell` 会创建一个包含原始文本的备份文件. 

对于`HTML`文件, 使用`-H(HTML)`检查模式选项,能够避免`aspell`认为`<HTML>`这样的标签是错误拼写. 

### 总结归纳

在这一章中,我们已经查看了一些操作文本的命令行工具. 我们将在随后的章节中发现这些工具组成 了解决实际问题的基本工具箱. 
这将是确定无疑的,当我们学习 shell 脚本的时候, 到时候这些工具将真正体现出它们的价值. 

还有一些更有趣的文本操作命令:`split`(把文件分割成碎片), `csplit`(基于上下文把文件分割成碎片),和 `sdiff`(并排合并文件差异). 
