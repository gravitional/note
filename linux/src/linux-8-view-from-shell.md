# 从shell眼中看世界

## 字符展开

传递到 `echo` 命令的任何参数都会在(屏幕上)显示出来.  让我们试一个例子:

```bash
echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```

为什么 `echo` 不打印` * `呢? 答案就是在 `echo` 命令被执行前,
shell 把` * `展开成了另外的东西(在这种情况下,就是在当前工作目录下的文件名字).

当回车键被按下时,`shell` 在命令被执行前在命令行上自动展开任何符合条件的字符, 所以 `echo` 命令从不会发现` * `,只把它展开成结果.
知道了这个以后,我们能看到 `echo` 执行的结果和我们想象的一样.

## 路径名展开

这种通配符工作机制叫做 `路径名展开`. 我们能够执行以下参数展开模式:

```bash
echo D*
Desktop Documents
```

和:

```bash
echo *s
Documents Pictures Templates Videos
```

```bash
甚至是:
echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos
```

查看家目录之外的目录:

```bash
echo /usr/*/share
/usr/kerberos/share /usr/local/share
```

## 隐藏文件路径名展开

正如我们知道的,以圆点字符开头的文件名是 `隐藏文件`. 路径名展开也尊重这种 行为. 像这样的展开:

```bash
echo *
```

不会显示隐藏文件. 要是展开模式以圆点开头,我们就能够在展开模式中包含隐藏文件,
而且隐藏文件可能会出现在第一位置,就像这样:

```bash
echo .*
```

然而,如果我们仔细检查一下输出结果,我们会看到名字`.` 和`..`也出现在结果中.
因为这些名字是指当前工作目录和它的父目录,使用这种 模式可能会产生不正确的结果.
我们能看到这样的结果,如果我们试一下这个命令:
`ls -d .* | less`
为了在这种情况下正确地完成路径名展开,我们应该使用一个更精确些的模式.  这个模式会正确地工作:
`ls -d .[!.]?*`
这种模式展开成为文件名,每个文件名以圆点开头,第二个字符不包含圆点,再包含至少一个字符, 并且这
个字符之后紧接着任意多个字符.

这将列出大多数的隐藏文件 (但仍将不能包含以多个圆点开头的文件名)

这个带有 `-A` 选项(`几乎所有`)的`ls`命令能够提供一份正确的隐藏文件清单:

```bash
ls -A
```

## 波浪线展开

可能你从我们对 cd 命令的介绍中回想起来,波浪线字符(` ~ `)有特殊的意思.
当它用在 一个单词的开头时,它会展开成指定用户的家目录名,如果没有指定用户名,则是当前用户的家目录:

```bash
echo ~
/home/me
```

如果有用户`foo`这个帐号,然后:

```bash
echo ~foo
/home/foo
```

## 算术表达式展开

`shell` 允许算术表达式通过展开来执行. 这允许我们把 `shell` 提示当作计算器来使用:

```bash
echo $((2 + 2))
4
```

算术表达式展开使用这种格式:`$((expression))`

算术表达式只支持整数(全部是数字,不带小数点),但是能执行很多不同的操作.
这里是 一些它支持的操作符:

***
操作符 说明

+ `+` 加
+ `-` 减
+ `*` 乘
+ `/` 除(但是记住,因为展开只是支持整数除法,所以结果是整数. )
+ `%` 取余,只是简单的意味着,`余数`
+ `**` 取幂

在算术表达式中空格并不重要,并且表达式可以嵌套. 例如,5的平方乘以3:

```
echo $(($((5**2)) * 3))
```

一对括号可以用来把多个子表达式括起来. 通过这个技术,我们可以重写上面的例子:

```bash
echo $(((5**2) * 3))
```

这是一个使用除法和取余操作符的例子. 注意整数除法的结果:

```bash
echo Five divided by two equals $((5/2))
Five divided by two equals 2
echo with $((5%2)) left over.
with 1 left over.
```

在35章会更深入的讨论算术表达式的内容.

## 花括号展开

可能最奇怪的展开是花括号展开. 通过它, 你可以从一个包含花括号的模式中创建多个文本字符串. 例:

```bash
echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

`花括号展开` 模式可能包含一个 开头部分叫做 `报头`,一个结尾部分叫做 `附言`.
花括号表达式本身可能包含一个由逗号分开的字符串列表,或者一系列整数,或者单个的字符串.
这种模式不能嵌入空白字符. 这个例题使用了一系列整数:

```bash
echo Number_{1..5}
```

一系列以倒序排列的字母:

```bash
echo {Z..A}
```

花括号展开可以嵌套(会自动展平):

```bash
echo a{A{1,2},B{3,4}}b
```

那么这对什么有好处呢?最普遍的应用是,创建一系列的文件或目录列表.

```bash
mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
```

## 参数展开

在这一章我们将会简单地介绍参数展开,只是皮毛而已.
这个特性在 `shell` 脚本中比直接在命令行中更有用. 它的许多性能和系统存储小块数据,并给每块数据命名的能力有关系.

许多像这样的小块数据, 更适当些应叫做变量,可以方便地检查它们.
例如,叫做`USER`的变量包含你的用户名. 唤醒参数展开,揭示 `USER` 中的内容,可以这样做:

```bash
echo $USER
me
```

查看有效的变量列表,试试这个:

```bash
printenv | less
```

你可能注意到其它展开类型,如果你误输入一个模式,展开就不会发生.
这时 `echo` 命令只简单地显示误键入的模式. 通过参数展开,如果你拼写错了一个变量名, 展开仍然会进行,只是展成一个空字符串:

```bash
echo $SUER
```

## 命令替换

命令替换允许我们把一个命令的输出作为一个展开模式来使用:

```bash
echo $(ls)
```

我最喜欢用的一行命令是像这样的:

```bash
ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

这里我们把 `which cp` 的执行结果作为一个参数传递给 `ls` 命令,因此要想得到 `cp` 程序的输出列表,
不必知道它完整的路径名.

我们不只限制于简单命令. 也可以使用整个管道线 (只展示部分输出):

```bash
file $(ls /usr/bin/* | grep zip)
....
```

在这个例子中,管道线的输出结果成为 `file` 命令的参数列表.

在旧版 shell 程序中,有另一种语法也支持命令替换,可与刚提到的语法换使用.
`bash` 也支持这种语法. 它使用倒引号来代替美元符号和括号:

```bash
ls -l `which cp`
```

我们已经知道 shell 有许多方式可以完成展开,现在是时候学习怎样来控制展开了.

## 双引号

我们将要看一下引用的第一种类型, `双引号`. 如果你把文本放在双引号中, `shell` 使用的特殊字符,
除了`\`(反斜杠),`$` ,和 `` ` ``(倒引号)之外, 则失去它们的特殊含义, 被当作普通字符来看待.

这意味着下列展开被禁止:

+ 单词分割, (`空格`)
+ 路径名展开, (`*``?`)
+ 波浪线展开,(`~`)
+ 和花括号展开(`{}`)

而下列展开仍然执行:

+ 参数展开(`$USER`)
+ 算术展开(`$(())`)
+ 命令替换`$()`

使用 `双引号`,我们可以处理包含空格的文件名. 比方说我们是不幸的名为 `two words.txt` 文件的受害者.
如果我们试图在命令行中使用这个 文件,**单词分割机制**会导致这个文件名被看作两个独自的参数,而不是所期望的单个参数:

```bash
ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```

使用双引号,我们可以阻止单词分割,得到期望的结果;进一步,我们甚至可以修复 破损的文件名.

```bash
ls -l `two words.txt`
mv `two words.txt` two_words.txt
```

记住,在双引号中,**参数展开**,**算术表达式展开**,和**命令替换**仍然有效:

```bash
echo `${USER} $((2+2)) $(cal)`
me 4
```

在默认情况下,单词分割机制会在单词中寻找**空格**,**制表符**,和**换行符**,并把它们看作单词之间的界定符. 它们只作为分隔符使用.

如果我们加上双引号,单词分割被禁止,内嵌的空格也不会被当作界定符,它们成为参数的一部分.
一旦加上双引号,我们的命令行就包含一个带有一个参数的命令.

考虑下面的例子:

```bash
echo $(cal)
echo `$(cal)`
```

在第一个实例中,没有引用的命令替换导致命令行包含`38`个参数.
在第二个例子中, 命令行只有一个参数,参数中包括嵌入的**空格**和**换行符**.

## 单引号

如果需要禁止所有的展开,我们使用单引号. 以下例子是无引用,双引号,和单引号的比较结果:

```bash
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
echo `text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER`
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
```

正如我们所看到的,随着引用程度加强,越来越多的展开被禁止.

## 转义字符

有时候我们只想引用单个字符. 我们可以在字符之前加上一个反斜杠,在这个上下文中叫做转义字符.
经常在双引号中使用转义字符,来有选择地阻止展开.

```bash
echo `The balance for user $USER is: \$5.00`
The balance for user me is: $5.00
```

使用转义字符来消除文件名中一个字符的特殊含义,是很普遍的. 例如,在文件名中可能使用一些对于 `shell` 来说,有特殊含义的字符.
这些字符包括`$`, `!`, `空格`等字符.
注意在单引号中,反斜杠失去它的特殊含义,它 被看作普通字符.

## 反斜杠转义字符序列

反斜杠除了作为转义字符外,反斜杠也是一种表示法的一部分,这种表示法代表某种特殊字符,叫做控制码.
`ASCII`编码表中前`32`个字符被用来把命令转输到像电报机一样的设备.

一些编码是众所周知的(制表符,退格符,换行符,和回车符),其它一些编码就不熟悉了(空值,传输结束码,和确认).

***
转义序列 含义

+ `\a` : 响铃(`警告`-导致计算机嘟嘟响)
+ `\b` : 退格符
+ `\n` : 新的一行. 在类 Unix 系统中,产生换行.
+ `\r` : 回车符
+ `\t` : 制表符

上表列出了一些常见的反斜杠转义字符.
反斜杠表示法背后的思想来源于 C 编程语言, 许多其它语言也采用了这种表示方法,包括 shell.

`echo` 命令带上 `-e` 选项,能够解释转义序列. 你可以把转义序列放在`$' '`里面.

以下例子,使用 `sleep` 命令,一个简单的程序,它会等待指定的秒数,然后退出.
我们可以创建一个简单的倒数计数器:

```bash
sleep 2; echo -e `Time's up\a`
```

我们也可以这样做:

```bash
sleep 2; echo `Time's up` /span>\a'
```
