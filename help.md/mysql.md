# MySQL

[liaoxuefeng.com/SQL教程](https://www.liaoxuefeng.com/wiki/1177760294764384/1218728424164736)

简单地说, `SQL`就是访问和处理关系数据库的计算机标准语言.
你可能还听说过`NoSQL`数据库, 也就是非`SQL`的数据库, 包括`MongoDB`, `Cassandra`, `Dynamo`等等, 它们都不是关系数据库.
有很多人鼓吹现代Web程序已经无需关系数据库了, 只需要使用`NoSQL` 就可以. 但事实上, `SQL`数据库从始至终从未被取代过

为什么需要数据库？
如果每个应用程序都各自写自己的读写数据的代码, 一方面效率低, 容易出错, 另一方面, 每个应用程序访问数据的接口都不相同, 数据难以复用.
所以, 数据库作为一种专门管理数据的软件就出现了. 应用程序不需要自己管理数据, 而是通过数据库软件提供的接口来读写数据. 至于数据本身如何存储到文件, 那是数据库软件的事情, 应用程序自己并不关心.

## 安装 SQL

[如何在 Ubuntu 20.04 上安装 MySQL](https://zhuanlan.zhihu.com/p/137339787)
[Mysql添加用户](https://blog.csdn.net/qq_39331713/article/details/81747188)

```bash
sudo apt update
sudo apt install mysql-server
```

在`MySQL 8.0`上, `root` 用户默认通过`auth_socket`插件授权.
`auth_socket`插件通过 `Unix socket` 文件来验证所有连接到`localhost`的用户. 这意味着你不能通过提供密码, 验证为`root`.
以 `root` 用户身份登录 `MySQL` 服务器, 输入；

```bash
sudo mysql
```

如果你想以 `root` 身份登录 `MySQL` 服务器, 使用其他的程序, 例如 `phpMyAdmin`, 你有两个选择.

第一个就是将验证方法从`auth_socket`修改成`mysql_native_password`. 你可以通过运行下面的命令实现：

```sql
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '密码';
FLUSH PRIVILEGES;
```

第二个选项, 推荐的选项, 就是创建一个新的独立管理用户, 拥有所有数据库的访问权限：

```sql
GRANT ALL ON *.* TO 'administrator'@'localhost' IDENTIFIED BY '密码';
```

### 创建用户

```sql
CREATE USER 'username'@'host' IDENTIFIED BY 'password';
```

`username` -你将创建的用户名说明:
`host` – 指定该用户在哪个主机上可以登陆,如果是本地用户可用`localhost`,  如 果想让该用户可以从任意远程主机登陆,可以使用通配符`%`
`password` –  该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登 陆服务器

例子：

```sql
CREATE USER 'javacui'@'localhost' IDENTIFIED BY '123456';
CREATE USER 'javacui'@'172.20.0.0/255.255.0.0' IDENDIFIED BY '123456';
CREATE USER 'javacui'@'%' IDENTIFIED BY '123456';
```

### 授权

```sql
GRANT privileges ON databasename.tablename TO 'username'@'host';
```

+ `privileges` – 用户的操作权限,如 `SELECT` , `INSERT` , `UPDATE`  等(详细列表见该文最后面).如果要授予所有的权限则使用`ALL`说明:
+ `databasename` –  数据库名
+ `tablename`-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用`*` 表示, 如`*.*`

例子:

```sql
GRANT SELECT, INSERT ON test.user TO 'javacui'@'%';
GRANT ALL ON *.* TO 'javacui'@'%';
```

```sql
GRANT All ON *.* TO 'tom'@'%' IDENTIFIED BY '9512';
```

注意:用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令

```sql
GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;
```

### 设置与更改用户密码

```sql
SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');
/* 如果是当前登陆用户用  */
SET PASSWORD = PASSWORD("newpassword");
```

### 撤销用户权限

```sql
REVOKE privilege ON databasename.tablename FROM 'username'@'host';
```

`privilege`, `databasename`, `tablename` – 同授权部分

假如你在给用户`'javacui'@'%'`授权的时候是这样的:

```sql
GRANT SELECT ON test.user TO 'javacui'@'%';
```

则在使用`REVOKE SELECT ON *.* FROM 'javacui'@'%';`命令并不能撤销该用户对`test`数据库中`user`表的`SELECT`操作.

相反,如果授权使用的是

```sql
GRANT SELECT ON  *.* TO 'javacui'@'%';
```

则`REVOKE SELECT ON test.user FROM  'javacui'@'%';`命令也不能撤销该用户对`test`数据库中`user`表的 `Select` 权限
具体信息可以用命令`SHOW GRANTS FOR 'javacui'@'%';`查看

### 删除用户

```sql
DROP USER 'username'@'host';
```

操作后切记刷新数据库

```sql
flush privileges;
```

## 关系数据库概述

### 数据模型

数据库按照数据结构来组织, 存储和管理数据, 实际上, 数据库一共有三种模型：

+ 层次模型
+ 网状模型
+ 关系模型

+ 层次模型就是以`上下级`的层次关系来组织数据的一种方式, 层次模型的数据结构看起来就像一颗树：
+ 网状模型把每个数据节点和其他很多节点都连接起来, 它的数据结构看起来就像很多城市之间的路网：
+ 关系模型把数据看作是一个二维表格, 任何数据都可以通过`行号+列号`来唯一确定, 它的数据模型看起来就是一个`Excel`表

随着时间的推移和市场竞争, 最终, 基于关系模型的关系数据库获得了绝对市场份额. 为什么关系数据库获得了最广泛的应用？
因为相比层次模型和网状模型, 关系模型理解和使用起来最简单.

`关系数据库`的关系模型是基于数学理论建立的. 我们把域(Domain)定义为一组具有相同数据类型的值的集合.
给定一组域`D1,D2,...,Dn`, 它们的笛卡尔集定义为`D1 X D2 X …… X Dn={(d1,d2,...,dn)|di∈Di,i=1,2,...,n}`,  而`D1 X D2 X …… X Dn`的`子集`叫作在域`D1,D2,...,Dn上`的关系,
表示为`R(D1,D2,...,Dn)`, 这里的`R`表示`$#%&^@!&$#;!~％¥%` :( ...... 算了, 根本讲不明白, 大家也不用理解.

什么是`SQL`？`SQL`是结构化查询语言的缩写, 用来访问和操作数据库系统.
`SQL`语句既可以查询数据库中的数据, 也可以添加, 更新和删除数据库中的数据, 还可以对数据库进行管理和维护操作.
不同的数据库, 都支持`SQL`, 这样, 我们通过学习`SQL`这一种语言, 就可以操作各种不同的数据库.

虽然`SQL`已经被`ANSI`组织定义为标准, 不幸地是, 各个不同的数据库对标准的`SQL`支持不太一致. 并且, 大部分数据库都在标准的`SQL`上做了扩展.
也就是说, 如果只使用标准`SQL`, 理论上所有数据库都可以支持, 但如果使用某个特定数据库的扩展`SQL`, 换一个数据库就不能执行了.
例如, `Oracle`把自己扩展的`SQL`称为`PL/SQL`, `Microsoft`把自己扩展的`SQL`称为`T-SQL`.

现实情况是, 如果我们只使用标准`SQL`的核心功能, 那么所有数据库通常都可以执行. 不常用的`SQL`功能, 不同的数据库支持的程度都不一样.
而各个数据库支持的各自扩展的功能, 通常我们把它们称之为`方言`.

总的来说, `SQL`语言定义了这么几种操作数据库的能力：

+ `DDL`：Data Definition Language. `DDL` 允许用户定义数据, 也就是创建表, 删除表, 修改表结构这些操作. 通常, DDL由数据库管理员执行.
+ `DML`：Data Manipulation Language. `DML`为用户提供添加, 删除, 更新数据的能力, 这些是应用程序对数据库的日常操作.
+ `DQL`：Data Query Language. `DQL`允许用户查询数据, 这也是通常最频繁的数据库日常操作.

### 语法特点

`SQL` 语言关键字不区分大小写！！！但是, 针对不同的数据库, 对于表名和列名, 有的数据库区分大小写, 有的数据库不区分大小写.
同一个数据库, 有的在`Linux`上区分大小写, 有的在`Windows`上不区分大小写.

所以, 本教程约定：`SQL`关键字总是大写, 以示突出, 表名和列名均使用小写.

### 安装MySQL

`MySQL`是目前应用最广泛的开源关系数据库. `MySQL`最早是由瑞典的`MySQL AB`公司开发, 该公司在2008年被`SUN`公司收购,
紧接着, `SUN`公司在2009年被`Oracle`公司收购, 所以`MySQL`最终就变成了`Oracle`旗下的产品.

和其他关系数据库有所不同的是, `MySQL`本身实际上只是一个`SQL`接口, 它的内部还包含了多种数据引擎, 常用的包括：

+ `InnoDB`：由`Innobase Oy`公司开发的一款支持事务的数据库引擎, 2006年被Oracle收购；
+ `MyISAM`：`MySQL`早期集成的默认数据库引擎, 不支持事务.

`MySQL`接口和数据库引擎的关系就好比某某浏览器和浏览器引擎(IE引擎或Webkit引擎)的关系.
对用户而言, 切换浏览器引擎不影响浏览器界面, 切换`MySQL`引擎不影响自己写的应用程序使用`MySQL`的接口.
使用`MySQL`时, 不同的表还可以使用不同的数据库引擎. 如果你不知道应该采用哪种引擎, 记住总是选择`InnoDB`就好了.

要在Windows或Mac上安装`MySQL`, 首先从`MySQL`官方网站下载最新的`MySQL Community Server`版本：[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
选择对应的操作系统版本, 下载安装即可. 在安装过程中, `MySQL`会自动创建一个`root`用户, 并提示输入`root`口令.

要在`Linux`上安装MySQL, 可以使用发行版的包管理器. 例如, `Debian`和`Ubuntu`用户可以简单地通过命令`apt-get install mysql-server`安装最新的`MySQL`版本.

### 运行MySQL

`MySQL`安装后会自动在后台运行. 为了验证`MySQL`安装是否正确, 我们需要通过`mysql`这个命令行程序来连接`MySQL`服务器.

在命令提示符下输入`mysql -u root -p`, 然后输入口令, 如果一切正确, 就会连接到`MySQL`服务器, 同时提示符变为`mysql>`.
输入`exit`退出`MySQL`命令行. 注意, `MySQL`服务器仍在后台运行.

## 关系模型

我们已经知道, 关系数据库是建立在关系模型上的. 而关系模型本质上就是若干个存储数据的二维表, 可以把它们看作很多`Excel`表.

+ 表的每一行称为`记录`(Record), 记录是一个逻辑意义上的数据.
+ 表的每一列称为`字段`(Column), 同一个表的每一行记录都拥有相同的若干字段.

`字段`定义了数据类型(整型, 浮点型, 字符串, 日期等), 以及是否允许为`NULL`. 注意`NULL`表示字段数据不存在.
一个整型字段如果为`NULL`不表示它的值为`0`, 同样的, 一个字符串型字段为`NULL`也不表示它的值为空串''.

`note:` 通常情况下, 字段应该避免允许为`NULL`. 不允许为`NULL`可以简化查询条件, 加快查询速度, 也利于应用程序读取数据后无需判断是否为`NULL`.

和Excel表有所不同的是, 关系数据库的表和表之间需要建立`一对多`, `多对一`和`一对一`的关系, 这样才能够按照应用程序的逻辑来组织和存储数据.

例如, 一个班级表：

    ID    名称    班主任
    201    二年级一班    王老师
    202    二年级二班    李老师

每一行对应着一个班级, 而一个班级对应着多个学生, 所以班级表和学生表的关系就是`一对多`：

    ID    姓名    班级ID    性别    年龄
    1    小明    201    M    9
    2    小红    202    F    8
    3    小军    202    M    8
    4    小白    201    F    9

反过来, 如果我们先在学生表中定位了一行记录, 例如`ID=1`的小明, 要确定他的班级, 只需要根据他的`班级ID`对应的值`201`找到班级表中`ID=201`的记录, 即二年级一班.
所以, 学生表和班级表是`多对一`的关系.

如果我们把班级表分拆得细一点, 例如, 单独创建一个教师表：

    ID    名称    年龄
    A1    王老师    26
    A2    张老师    39
    A3    李老师    32
    A4    赵老师    27

班级表只存储教师`ID`：

    ID    名称    班主任ID
    201    二年级一班    A1
    202    二年级二班    A3

这样, 一个班级总是对应一个教师, 班级表和教师表就是`一对一`关系.

在关系数据库中, 关系是通过`主键`和`外键`来维护的. 我们在后面会分别深入讲解.

### 主键

在关系数据库中, 一张表中的每一行数据被称为一条记录. 一条记录就是由多个字段组成的. 例如, `students` 表的两行记录：

    id    class_id    name    gender    score
    1    1    小明    M    90
    2    1    小红    F    95

每一条记录都包含若干定义好的字段. 同一个表的所有记录都有相同的字段定义.

对于关系表, 有个很重要的约束, 就是任意两条记录不能重复. 不能重复不是指两条记录不完全相同, 而是指不同的记录能够通过`某个字段`区分, 这个字段被称为`主键`.

例如, 假设我们把`name`字段作为主键, 那么通过名字`小明`或`小红`就能唯一确定一条记录. 但是, 这么设定, 就没法存储同名的同学了, 因为插入相同主键的两条记录是不被允许的.

对主键的要求, 最关键的一点是：记录一旦插入到表中, 主键最好不要再修改, 因为主键是用来唯一定位记录的, 修改了主键, 会造成一系列的影响.
由于主键的作用十分重要, 如何选取主键会对业务开发产生重要影响. 如果我们以学生的身份证号作为主键, 似乎能唯一定位记录.
然而, 身份证号也是一种业务场景, 如果身份证号升位了, 或者需要变更, 作为主键, 不得不修改的时候, 就会对业务产生严重影响.

所以, 选取主键的一个基本原则是：`不使用任何业务相关的字段作为主键`.
因此, `身份证号`, `手机号`, `邮箱地址`这些看上去可以唯一的字段, 均不可用作`主键`.

作为主键最好是完全业务无关的字段, 我们一般把这个字段命名为`id`. 常见的可作为`id`字段的类型有：

+ 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数, 这样我们就完全不用担心主键重复, 也不用自己预先生成主键；
+ 全局唯一`GUID`类型：使用一种全局唯一的字符串作为主键, 类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`. `GUID`算法通过网卡`MAC`地址, 时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的, 大部分编程语言都内置了`GUID`算法, 可以自己预算出主键.

对于大部分应用来说, 通常自增类型的主键就能满足需求. 我们在`students`表中定义的主键也是`BIGINT NOT NULL AUTO_INCREMENT`类型.
如果使用`INT自增`类型, 那么当一张表的记录数超过`2147483647`(约`21`亿)时, 会达到上限而出错. 使用BIGINT自增类型则可以最多约`922亿亿`条记录.

### 联合主键

关系数据库实际上还允许通过多个字段唯一标识记录, 即两个或更多的字段都设置为主键, 这种主键被称为联合主键.

对于联合主键, 允许一列有重复, 只要不是所有主键列都重复即可：

    id_num    id_type    other columns...
    1    A    ...
    2    A    ...
    2    B    ...

如果我们把上述表的`id_num`和`id_type`这两列作为联合主键, 那么上面的`3`条记录都是允许的, 因为没有两列主键组合起来是相同的.

没有必要的情况下, 我们尽量不使用联合主键, 因为它给关系表带来了复杂度的上升.

### 小结

+ 主键是关系表中记录的唯一标识. 主键的选取非常重要：主键不要带有业务含义, 而应该使用`BIGINT自增`或者`GUID`类型. 主键也不应该允许`NULL`.
+ 可以使用多个列作为联合主键, 但联合主键并不常用.

当我们用主键唯一标识记录时, 我们就可以在`students`表中确定任意一个学生的记录：

    id    name    other columns...
    1    小明    ...
    2    小红    ...

我们还可以在`classes`表中确定任意一个班级记录：
    id    name    other columns...
    1    一班    ...
    2    二班    ...

但是我们如何确定`students`表的一条记录, 例如, `id=1`的小明, 属于哪个班级呢？
由于一个班级可以有多个学生, 在关系模型中, 这两个表的关系可以称为`一对多`, 即一个`classes`的记录可以对应多个`students`表的记录.

为了表达这种一对多的关系, 我们需要在`students`表中加入一列`class_id`, 让它的值与`classes`表的某条记录相对应：

    id    class_id    name    other columns...
    1    1    小明    ...
    2    1    小红    ...
    5    2    小白    ...

这样, 我们就可以根据`class_id`这个列直接定位出一个`students`表的记录应该对应到`classes`的哪条记录.

例如：

+ 小明的`class_id`是`1`, 因此, 对应的`classes`表的记录是`id=1`的一班；
+ 小红的`class_id`是`1`, 因此, 对应的`classes`表的记录是`id=1`的一班；
+ 小白的`class_id`是`2`, 因此, 对应的`classes`表的记录是`id=2`的二班.

在`students`表中, 通过`class_id`的字段, 可以把数据与另一张表关联起来, 这种列称为`外键`.

外键并不是通过列名实现的, 而是通过定义外键约束实现的：

```sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

其中, 外键约束的名称`fk_class_id`可以任意, `FOREIGN KEY (class_id)`指定了`class_id` 作为外键, `REFERENCES classes (id)`指定了这个外键将关联到`classes`表的`id`列(即`classes`表的主键).
通过定义外键约束, 关系数据库可以保证无法插入无效的数据. 即如果`classes`表不存在`id=99`的记录, `students`表就无法插入`class_id=99`的记录.

由于外键约束会降低数据库的性能, 大部分互联网应用程序为了追求速度, 并不设置外键约束, 而是仅靠应用程序自身来保证逻辑的正确性.
这种情况下, `class_id`仅仅是一个普通的列, 只是它起到了外键的作用而已.

要删除一个外键约束, 也是通过`ALTER TABLE`实现的：

```sql
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

注意：删除外键约束并没有删除外键这一列. 删除列是通过`DROP COLUMN ...`实现的.

### 多对多

通过一个表的外键关联到另一个表, 我们可以定义出一对多关系. 有些时候, 还需要定义`多对多`关系.
例如, 一个老师可以对应多个班级, 一个班级也可以对应多个老师, 因此, `班级表`和`老师表`存在多对多关系.

`多对多`关系实际上是通过两个`一对多`关系实现的, 即通过一个中间表, 关联两个`一对多`关系, 就形成了`多对多`关系：

`teachers`表：

    id    name
    1    张老师
    2    王老师
    3    李老师
    4    赵老师

`classes`表：

id    name
1    一班
2    二班

中间表`teacher_class` 关联两个一对多关系：

    id    teacher_id    class_id
    1    1    1
    2    1    2
    3    2    1
    4    2    2
    5    3    1
    6    4    2

通过中间表`teacher_class`可知`teachers`到`classes`的关系：

+ `id=1`的张老师对应`id=1,2`的一班和二班；
+ `id=2`的王老师对应`id=1,2`的一班和二班；
+ `id=3`的李老师对应`id=1`的一班；
+ `id=4`的赵老师对应`id=2`的二班.

同理可知`classes`到`teachers`的关系：

+ `id=1`的一班对应`id=1,2,3`的张老师, 王老师和李老师；
+ `id=2`的二班对应`id=1,2,4`的张老师, 王老师和赵老师；

因此, 通过中间表, 我们就定义了一个`多对多`关系.

### 一对一

一对一关系是指, 一个表的记录对应到另一个表的唯一一个记录.

例如,  `students` 表的每个学生可以有自己的联系方式, 如果把联系方式存入另一个表 `contacts`, 我们就可以得到一个`一对一`关系：

    id    student_id    mobile
    1    1    135xxxx6300
    2    2    138xxxx2209
    3    5    139xxxx8086

有细心的童鞋会问, 既然是一对一关系, 那为啥不给`students`表增加一个`mobile`列, 这样就能合二为一了？

如果业务允许, 完全可以把两个表合为一个表. 但是, 有些时候, 如果某个学生没有手机号, 那么, `contacts` 表就不存在对应的记录.
实际上, 一对一关系准确地说, 是`contacts`表一对一对应`students`表.

还有一些应用会把一个大表拆成两个一对一的表, 目的是把经常读取和不经常读取的字段分开, 以获得更高的性能.
例如, 把一个大的用户表分拆为用户基本信息表`user_info`和用户详细信息表`user_profiles`, 大部分时候, 只需要查询`user_info`表, 并不需要查询`user_profiles`表, 这样就提高了查询速度.

### 小结

关系数据库通过外键可以实现一对多, 多对多和一对一的关系. 外键既可以通过数据库来约束, 也可以不设置约束, 仅依靠应用程序的逻辑来保证.

## 索引

在关系数据库中, 如果有上万甚至上亿条记录, 在查找记录的时候, 想要获得非常快的速度, 就需要使用`索引`.

`索引`是关系数据库中对某一列或多个列的值进行`预排序`的数据结构. 通过使用`索引`, 可以让数据库系统不必扫描整个表, 而是直接定位到符合条件的记录, 这样就大大加快了查询速度.

例如, 对于`students`表：

    id    class_id    name    gender    score
    1    1    小明    M    90
    2    1    小红    F    95
    3    1    小军    M    88

如果要经常根据`score`列进行查询, 就可以对`score`列创建索引：

```sql
ALTER TABLE students
ADD INDEX idx_score (score);
```

使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`, 使用列`score`的索引. 索引名称是任意的, 索引如果有多列, 可以在括号里依次写上, 例如：

```sql
ALTER TABLE students
ADD INDEX idx_name_score (name, score);
```

索引的效率取决于索引列的值是否散列, 即该列的值如果越互不相同, 那么索引效率越高.
反过来, 如果记录的列存在大量相同的值, 例如`gender`列, 大约一半的记录值是`M`, 另一半是`F`, 因此, 对该列创建索引就没有意义.

可以对一张表创建多个索引. 索引的优点是提高了查询效率, 缺点是在插入, 更新和删除记录时, 需要同时修改索引, 因此, 索引越多, 插入, 更新和删除记录的速度就越慢.

对于主键, 关系数据库会自动对其创建主键索引. 使用主键索引的效率是最高的, 因为主键会保证绝对唯一.

### 唯一索引

在设计关系数据表的时候, 看上去唯一的列, 例如身份证号, 邮箱地址等, 因为他们具有业务含义, 因此不宜作为主键.

但是, 这些列根据业务要求, 又具有唯一性约束：即不能出现两条记录存储了同一个身份证号. 这个时候, 就可以给该列添加一个`唯一索引`. 例如, 我们假设`students`表的`name`不能重复：

```sql
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);
```

通过`UNIQUE`关键字我们就添加了一个唯一索引.

也可以只对某一列添加一个唯一约束而不创建唯一索引：

```sql
ALTER TABLE students
ADD CONSTRAINT uni_name UNIQUE (name);
```

这种情况下, `name` 列没有索引, 但仍然具有唯一性保证.

无论是否创建索引, 对于用户和应用程序来说, 使用关系数据库不会有任何区别.
这里的意思是说, 当我们在数据库中查询时, 如果有相应的索引可用, 数据库系统就会自动使用索引来提高查询效率, 如果没有索引, 查询也能正常执行, 只是速度会变慢.
因此, 索引可以在使用数据库的过程中逐步优化.

### 小结

+ 通过对数据库表创建索引, 可以提高查询速度.
+ 通过创建唯一索引, 可以保证某一列的值具有唯一性.
+ 数据库索引对于用户和应用程序来说都是透明的.

## 查询数据

在关系数据库中, 最常用的操作就是查询. 为了便于讲解和练习, 我们先准备好了一个`students`表和一个`classes`表, 它们的结构和数据如下：

[在线练习](https://www.liaoxuefeng.com/wiki/1177760294764384/1179610544539040)

***

如果你想用MySQL练习, 可以[下载这个SQL脚本](https://github.com/michaelliao/learn-sql/blob/master/mysql/init-test-data.sql), 然后在命令行运行：

```sql
mysql -u root -p < init-test-data.sql
```

就可以自动创建`test`数据库, 并且在`test`数据库下创建`students`表和`classes`表, 以及必要的初始化数据.

和内存数据库不同的是, 对`MySQL`数据库做的所有修改, 都会保存下来. 如果你希望恢复到初始状态, 可以再次运行该脚本.

***
命令行选项:

+ `--user=user_name`, or `-u user_name`; 用于连接到服务器的`MySQL`账户的用户名.
+ `--password[=password]`, or `-p[password]`; 用于连接服务器的MySQL账户的密码. 密码值是可选的.
如果不给, `mysql`会提示输入. 如果给定, 在`--password=`或`-p`和后面的密码之间不能有空格. 如果没有指定密码选项, 则默认不发送密码.

### 基本查询

[MySQL 选择数据库](https://www.runoob.com/mysql/mysql-select-database.html)

选择数据库; `USE test;`, `test`是数据库的名称.

要查询数据库表的数据, 我们使用如下的`SQL`语句：

```sql
SELECT * FROM <表名>
```

假设表名是`students`, 要查询`students`表的所有`行`, 我们用如下`SQL`语句：

```sql
SELECT * FROM students;
```

使用`SELECT * FROM students`时, `SELECT`是关键字, 表示将要执行一个查询, `*`表示`所有列`, `FROM`表示将要从哪个表查询, 本例中是`students`表.
该`SQL`将查询出`students`表的所有数据. 注意：查询结果也是一个二维表, 它包含列名和每一行的数据.

要查询`classes`表的所有行, 我们用如下SQL语句：

```sql
SELECT * FROM classes;
```

运行上述`SQL`语句, 观察查询结果.

SELECT语句其实并不要求一定要有`FROM`子句. 我们来试试下面的`SELECT`语句：

```sql
SELECT 100+200;
```

上述查询会直接计算出表达式的结果. 虽然`SELECT`可以用作计算, 但它并不是`SQL`的强项.
但是, 不带FROM子句的`SELECT`语句有一个有用的用途, 就是用来判断当前到数据库的连接是否有效. 许多检测工具会执行一条`SELECT 1;`来测试数据库连接.

### 小结

+ 使用`SELECT`查询的基本语句`SELECT * FROM <表名>`, 可以查询一个表的所有行和所有列的数据.
+ `SELECT`查询的结果是一个二维表.

### 条件查询

使用`SELECT * FROM <表名>`可以查询到一张表的所有记录. 但是, 很多时候, 我们并不希望获得所有记录, 而是根据条件选择性地获取指定条件的记录, 例如, 查询分数在80分以上的学生记录.
在一张表有数百万记录的情况下, 获取所有记录不仅费时, 还费内存和网络带宽.

`SELECT`语句可以通过`WHERE`条件来设定查询条件, 查询结果是满足查询条件的记录. 例如, 要指定条件`分数在80分或以上的学生`, 写成`WHERE`条件就是
`SELECT * FROM students WHERE score >= 80`.

其中, `WHERE`关键字后面的`score >= 80`就是条件. `score`是列名, 该列存储了学生的成绩, 因此, `score >= 80`就筛选出了指定条件的记录：

```sql
SELECT * FROM students WHERE score >= 80;
```

因此, 条件查询的语法就是：

```sql
SELECT * FROM <表名> WHERE <条件表达式>
```

条件表达式可以用`<条件1> AND <条件2>`表达满足`条件1`并且满足`条件2`. 例如, 符合条件`分数在80分或以上`, 并且还符合条件`男生`, 把这两个条件写出来：

+ 条件1：根据`score`列的数据判断：`score >= 80`；
+ 条件2：根据`gender`列的数据判断：`gender = 'M'`, 注意`gender`列存储的是字符串, 需要用单引号括起来.

就可以写出`WHERE`条件：`score >= 80 AND gender = 'M'`：

```sql
SELECT * FROM students WHERE score >= 80 AND gender = 'M';
```

第二种条件是`<条件1> OR <条件2>`, 表示满足`条件1`或者满足`条件2`. 例如, 把上述`AND`查询的两个条件改为`OR`, 查询结果就是`分数在80分或以上`或者`男生`, 满足任意之一的条件即选出该记录：

```sql
SELECT * FROM students WHERE score >= 80 OR gender = 'M';
```

很显然`OR`条件要比`AND`条件宽松, 返回的符合条件的记录也更多.

第三种条件是`NOT <条件>`, 表示`不符合该条件`的记录. 例如, 写一个`不是2班的学生`这个条件, 可以先写出`是2班的学生`：`class_id = 2`, 再加上`NOT：NOT class_id = 2`：

```sql
SELECT * FROM students WHERE NOT class_id = 2;
```

上述`NOT`条件`NOT class_id = 2`其实等价于`class_id <> 2`, 因此, `NOT`查询不是很常用.

要组合三个或者更多的条件, 就需要用小括号`()`表示如何进行条件运算. 例如, 编写一个复杂的条件：分数在`80`以下或者`90`以上, 并且是男生：

```sql
SELECT * FROM students WHERE (score < 80 OR score > 90) AND gender = 'M';
```

如果不加括号, 条件运算按照`NOT`, `AND`, `OR`的优先级进行, 即`NOT`优先级最高, 其次是`AND`, 最后是`OR`. 加上括号可以改变优先级.

### 常用的条件表达式

***
条件    表达式举例1    表达式举例2    说明

+ 使用`=`判断相等  ;  `score = 80`  , `name = 'abc'` ;   字符串需要用单引号括起来
+ 使用`>`判断大于  ;  `score > 80`  ,  `name > 'abc'`    字符串比较根据`ASCII`码, 中文字符比较根据数据库设置
+ 使用`>=`判断大于或相等 ;   `score >= 80` ,   `name >= 'abc'`
+ 使用`<`判断小于 ;  `score < 80` ,  `name <= 'abc'`
+ 使用`<=`判断小于或相等  ;  `score <= 80`  ;  `name <= 'abc'`
+ 使用`<>`判断不相等  ;  `score <> 80`  , `name <> 'abc'`
+ 使用`LIKE`判断相似  ; `name LIKE 'ab%'`, `name LIKE '%bc%'` ;  `%`表示任意字符, 例如`'ab%'`将匹配`'ab'`, `'abc'`, `'abcd'`

表示区间的等价方法:

+ `SELECT * FROM students WHERE score >= 60 AND score <= 90`
+ `SELECT * FROM students WHERE score BETWEEN 60 AND 90;`
