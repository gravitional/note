# cpp

## 数组

`指针`--动态分配内存.
`vector`-- 面向对象的数组.
浅拷贝, 深拷贝.

`字符串常量` -- 标准库中的`字符类`.

### 数组的定义

类型说明符 数组名 [常量表达式] [常量表达式] ..... ;
数组名称的构成方法与一般变量名相同.
例:

```cpp
int a[10];
a[0] ... a[9]

int a[5][3]; // 二维数组, 5行3列
```

数组必须先定义, 后使用.
可以逐个引用数组元素.
例:

```cpp
a[0]=a[5]+a[7]-a[2*3]
b[1][2]=a[2][3]/2
```

大批量依次处理数据.

### 数组的存储与初始化

#### 一维数组的存储

`数组元素`在内存中顺次存放, 它们的地址是`连续的`. 元素间物理地址上的相邻, 对应着逻辑次序上的相邻.

数组`名字`是数组`首元素的内存地址`.
数组名是地址类型的`常量`, 不能被赋值.

#### 一维数组的初始化

列出全部元素的初始值, 例如

```cpp
static int a[10]={0,1,2,3,4,5,6,7,8,9};
```

只给一部分元素初始值, 例如

```cpp
static int a[10]={0,1,2,3,4};
```

列出全部数组元素`初值`时, 可以不指定数组长度.例如

```cpp
static int a[]={0,1,2,3,4,5,6,7,8,9};
```

#### 二维数组的存储

按行存放, 例如:

    float a[3][4];

可以理解为:

            a[0]
    a       a[1]
            a[2]

其中数组`a`的存储顺序是

    a00 a01 a02 a03         a10 a11 a12 a13 ...

多维数组以此类推.

#### 二维数组的初始化

将所有初始值写在一个`{}`内, 按顺序初始化. 例如:

```cpp
static int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
```

分行列出二维数组元素的初始值. 例如:

```cpp
static int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
```

可以只对部分元素初始化. 例如:

```cpp
static int a[3][4]={{1},{0,6},{0,0,11}};
```

列出全部初始值, 第`1`维下标个数可以省略, 例如:

```cpp
static int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12}; // 或
static int a[][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
```

如果不作任何初始化, `局部作用域`的`非静态数组`中会存在`垃圾数据`, `static`数组中的数据默认初始化为`0`.

如果只对部分元素初始化, 剩下的未显式初始化的元素, 将自动被初始化为零.

#### 一位数组应用举例

循环从键盘读入若干组选择题答案, 计算并输出答案的正确率, 直到输入`ctrl+z`为止.
每组连续输入`5`个答案, 每个答案可以是`abcd`.

### 数组作为函数的参数

`数组元素`作实参, 与`单个变量`一样.

`数组名`作`参数`, 形, 实`参数`都应是`数组名`, `类型`要一样, 传送的是数组`首地址`.
对`形参数组`的改变会直接影响到`实参数组`.

### 对象数组的定义和访问

只要对象属于同一种类型, 也可以构成数组.

+ 定义对象数组

        类名 数组名[元素个数];

+ 访问`对象`数组元素; 通过下标访问:

        数组名[下标].成员名

### 对象数组初始化

+ 数组中每一元素对象被创建时, 系统都会调用类构造函数初始化该对象.
+ 通过初始化列表赋值. 例:

    ```cpp
    Point a[2]={Point(1,2),Point(3,4)}
    ```

+ 如果没有为数组元素指定显式初始值, 数组元素便使用`默认值`初始化(调用默认`构造函数`).

数组元素的构造和析构

+ 构造数组时, `元素`所属的类未声明`构造函数`, 则采用默认`构造函数`.
+ 各元素对象的`初值`要求为相同的值时, 可以声明具有`默认形参值`的构造函数.
+ 各元素对象的`初值`要求为不同的值时, 需要声明带有`形参值`的构造函数.
+ 当数组中每一个`对象`被`删除`时, 系统都要调用一次`析构函数`.

### 基于范围的for循环

自动遍历整个`容器`, `数组`就是一种`容器`.

```cpp
int main()
{
    int array[3]={1,2,3};
    for(int &e : array){
        e += 2;
        std::cout<<e<<std::endl;
    }
    return 0;
}
```

### 指针的概念, 定义和运算

`内存空间`的访问方式:

+ 通过`变量名`访问: 把`变量名`和若干字节的`内存空间`绑定起来.
+ 通过`地址`访问.

指针的概念

指针: 内存地址, 用于间接访问`内存单元`. `地址类型`的变量.
指针变量: 用于存放`地址`的变量.
例子:

```cpp
static int i;
static int* ptr=&i; // 指向 int 变量的指针.
*ptr=3;
```

在内存用户数据区中:

+ 在内存中分配了若干字节, 用于存放`int`类型的数据, 并且给`内存空间`起了个名字`i`, 这段`内存空间`存在`起始地址`, 即`首字节`, 例如`2000`.
+ `ptr`本身也是一个变量, 存储在`内存空间`中, 例如同样占用`4`个字节. `地址`必须是在程序运行期间合法获得的.
它只允许存放通过`合法途径`获取的`地址`, `ptr`空间中存放着变量`i`, `&i` 是求地址的`运算符`.
`int* ptr` 中的`*`表明 `ptr` 是一个指针, `int` 表示`指针`指向的类型, 它决定了变量占用内存空间的长度.
+ 在表达式中, `*ptr` 中的`*`表示指针运算 -- `寻址`操作. `*ptr=3;`  赋值的时候, 占用的字节数, 取决于`ptr`的类型.

与`地址`相关的运算 -- `*` 和 `&`

指针运算符 : `*`, `指针`->`内存地址`. 也就是`寻址过程`, 根据`指针`存储的`值`寻找相应的`内存单元`, 从而访问内存单元.
地址运算符: `&`, `变量`->`内存地址`. 计算`变量`或者一段`代码`的地址, 返回它的`地址`. 返回内存`变量`和`对象`的地址.

### 指针的初始化和赋值

`指针`初始化, 可以防止访问`内存空间`出现意外的`错误`.
一般的`整数`, 不能随便放入`指针`中, 指针只能存放合法获得的内存地址.
语法形式:

    存储类型 数据类型 *指针名 = 初始地址;

例如

```cpp
int *pa=&a; // a应该已经声明过, 类型应该和指针相同.
```

注意事项:

+ 用`变量地址`作为`初值`时, 该`变量`必须在`指针`初始化之前已`声明`过, 且`变量类型`应与`指针类型`一致.
+ 可以用一个已有`合法值`的`指针`去初始化另一个`指针`变量.
+ 不要用一个`内部非静态变量`去初始化 `static` 指针.

指针变量的赋值运算

    指针名=地址

注意:

+ `地址`中存放的`数据类型`与`指针类型`必须相符.
+ 向`指针变量`赋的值必须是`地址常量`或`变量`, 不能是`普通整数`.

例如:

+ 通过地址运算`&`求得已定义的`变量`和`对象`的`起始地址`.
+ `动态内存分配`成功时返回的地址.

+ 例外: 整数`0`可以赋给`指针`, 表示`空指针`.
+ 允许定义或声明指向`void`类型的指针. 该`指针`可以被赋予`任何类型`对象的地址.
但没有规定指向的`对象`的类型, 只能用来存放`地址`, 不能用来访问指向的`对象`和`存储空间`.
例如:

    ```cpp
    void *general;
    ```

指针空值 `nullptr`.

`C++11`使用`nullptr` 关键字表示`空指针`, 取代`0`, 是表达更准确, 类型安全的`空指针`.

例子:

```cpp
#include <iostream>
using namespace std;

int main()
{
    int i;                             // 定义 int 型数 i, 非静态局部变量.
    int *ptr = &i;                     // 取 i 的地址赋给 ptr
    i = 10;                            // int 型数 赋初值
    cout << "i=" << i << endl;         //输出int 型 数的内容
    cout << "*ptr = " << *ptr << endl; //输出int型指针所指地址的内容
    return 0;
}
```

空指针

```cpp
#include <iostream>
using namespace std;
int main()
{
    //!void voidObject ; 错, 不能声明 void 类型的变量, 编译器无法处理.
    void *pv; // 可以声明 void 类型的指针
    int i = 5;
    pv = &i;                            // void 类型指针指向整型变量.
    int *pint = static_cast<int *>(pv); // void 指针转换为 int 指针
    cout << "*pint= " << *pint << endl;
    return 0;
}
```

指向常量的指针

+ `const` 指针, 加上`const` 关键字.
+ 不能通过指向`常量`的指针改变所指向`对象`的值,但指针本身可以改变, 可以指向另外的对象.
例子:

```cpp
int a;
const int *p1=&a; //p1 是指向常量的指针
int b;
p1 =&b; //正确, p1 本身的值可以改变.
*p1=1; //编译时出错, 不能通过 p1 改变所指的对象.
```

#### 指针类型的常量

+ 若声明指针常量, 则指针本身的值不能被改变
例如:

```cpp
int a;
int * const p2 = &a;
p2 = &b; // 错误, p2 是指针常量, 值不能改变.
```

### 指针的算术运算, 关系运算

#### 算术运算

+ `指针`与`整数`的`加减`运算
+ 指针 `++`, `--` 运算

+ 指针`p`加上或减去`n`; 其意义是指针指向当前位置的前方或后方第`n`个数据的`起始位置`.
+ 指针的`++`, `--` 运算 ; 意义是指向下一个或前一个`完整数据`的起始.
+ 运算的结果值取决于指针指向的`数据类型`, 总是指向一个`完整数据`的`起始位置`.
+ 当`指针`指向`连续存储`的`同类型`数据时, `指针`与`整数`的`加减运算`和`自增自减`运算才有意义.
例如:

```cpp
short a[4];
short *pa=a;
`*pa` 等同于`a[0]`,
`*(pa+1)`等同于 `a[1]`, // 前进两个字节
`*(pa+2)`等同于 `a[2]`,
```

#### 关系运算

+ 指向`相同类型`的`指针`之间可以进行各种`关系运算`.
+ 指向`不同数据`类型的`指针`, 以及`指针`与一般`整数变量`之间的关系运算是无意义的.
+ `指针`可以和`零`之间进行`等于`或`不等于`的关系运算, 判断是否为`空指针`.
例如

    p==0 或 p!=0
    