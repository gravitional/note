# Fortran-2

[Fortran语言的入门与心得](https://blog.csdn.net/xiaoxiaoxingzi/article/details/105315397)

## 惯例

### Hello world

```fortran
program main
  implicit none
  print *, 'Hello World'
end program main
```

### 一些惯例

+ `Fortran`不区分大小写
+ `Fortran`每行的末尾不必要写分号
+ 不像C语言, `fortran`不使用大括号`{ }`
+ `Fortran`有5种基本数据类型, `integer`, `real`, `character`,   `logical`,  `complex`, 其他语言一般没有复数类型, 这是`fortran`与其他语言不同的地方. 
+ `DOUBLE  PRECISION`语句在`FORTRAN90`标准中完全可以用`REAL(8)`代替, 目前很少使用. 
+ `Fortran`两种格式之间的一些遗留问题
+ 使用系统默认的隐含约定(`I-N`规则):FORTRAN中约定, 在没有强制规定变量类型的情况下, 如果变量名的首字母为`I`, `J`, `K`, `L`, `M`, `N`这`6`个字母中的一个时, 即认为该变量为整型变量, 而已其他字母开头的变量则默认为实型变量. 
+ 这就是所谓的(I-N规则). 

(I-N规则)的使用有利有弊. 

### 变量名

`real(kind=8) a` 这种格式只使用于Fortran90, Fortran77中要使用real*8或real(8)

常数parameter的声明方法--Fortran90里, `PARAMETER`可以作为一个形容词, 和变量的声明同时写在一起, 例如:

```fortran
real, parameter ::  pi=3.141592653
```

FORTRAN中乘方要使用`**`运算符, 使用乘方运算符`**`时, 一定要写成两个连续的星号. 
一般来说, 乘方运算要比等价的单个乘法运算花费更多的时间. 

算术表达式中的类型转换:

FORTRAN语言允许不同类型的算术运算量之间进行算术运算, 同类型的算术运算量之间的运算结果保持原类型不变. 

需要特别注意的是:FORTRAN语言中规定两个整数相除的商也是整数. 例如, `2/5`的结果为`0`. 

参加运算的两个算术运算量为不同类型时, 编译系统会自动将它们转换成同一类型之后才进行运算. 

### 关系运算符

`== `  `/= `  `>`   `>=`   `<`   `<= `   !Fortran90用法

`.EQ.`  `.NE.`  `.GT.`  `.GE.`  `.LT.`  `.LE. `  !Fortran77用法(左右各有一个点)

### 逻辑运算符

`5`种逻辑运算符, 新旧`FORTRAN`标准中的逻辑运算符没有任何区别, 每个运算符的左右都有一个点"`.`", 书写时不能漏写. 

`.AND.`    ` .OR.`    `.NOT.`      `.EQV.`     `.NEQV.`    !语法

逻辑与   逻辑或   逻辑非   逻辑等价   逻辑不等价   ！意义

### PAUSE,CONTINUE, STOP

+ `pause` 暂停程序执行, 按`enter`可继续执行
+ `continue` 貌似没什么用处, 可用作封装程序的标志
+ `STOP` 命令用来结束程序, 要谨慎使用

### 矢量化编程

`a`,`b`都为数组, 则可以这样用`a=sin(b)`,(内部函数都可以这样用)

数组专用:`where`命令

形式上类似于`if`,但只用于设置数组

```fortran
where
...
elsewhere
...
elsewhere
...
endwhere
```

(没有`then`)

***
`FORALL`是Fortran95添加的功能,只能用于数组操作, `forall`可以嵌套使用, 还可以在`forall`中使用`where`, 但`where`中不能使用`forall`

Fortran中传递参数的原理与c++不同, Fortran中是传址调用, 
就是传递时用的参数和子程序接受时用的参数使用一个地址, 尽管命名可以不同. 

+ 调用`function`前需要做声明
+ 调用`subroutine`则不需要
+ `Module`中有函数时必须在`contains`命令之后. 

### 全局变量

`COMMON`:有的书上叫无名公用区, 有名公用区

+ 全局变量用来定义一块共享的内存空间；
+ 全局变量不能声明成常量
+ 全局变量不能直接使用`data`命令赋初值, 要在`block data`模块中使用`data`来设置初值. 
+ COMMON语句是说明语句, 因此它应该出现在相应程序单元中的所有可执行语句之前. 

全局变量建议使用 `MOUDLE`  peng-216

### INCLUDE

peng-226

+ `INCLUDE`命令可以写在任何地方, 它只是单纯地用来插入一个文件的内容. 
+ 有时候也会应用在声明全局变量, 先把声明全局变量的程序代码编写在某个文件中, 需要使用全局变量的函数再去`INCLUDE`这个文件, 这样可以减少程序代码. 

### 如何换行

用`&`换行, 连接下一行

## 流程控制

### IF语句

```fortran
IF   (逻辑判断式)  THEN
    ...
END IF
```

***
可以包含ELSE模块

```fortran
IF   (逻辑判断式)  THEN
    …..  
ELSE
    …..
END IF
```

***

多重判断

```fortran
IF   (逻辑判断式)  THEN
    …..
ELSE IF  (逻辑判断式) THEN
    …..
ELSE IF  (逻辑判断式) THEN
    …..
END IF
```

### DO循环

peng_112

### FORTRAN77中的基本DO构造

FORTRAN77中的DO构造如下:

```fortran
DO 语句标号 , 循环控制
    循环体
语句标号  终止语句
```

Fortran 95使用`end do`来结束循环. 

循环的流程控制:

```fortran
do x = 1,2
        do y = 1,4,0.5
            z = x/y
            print *, x,y,z
        end do
    end do
```

循环中的`cycle`命令相当于`c++`里的`continue`命令, 用于结束一次循环, 
循环中的`exit`命令好比`c`里面的`break`, 用于结束循环

不使用`do`循环, 单纯用`GOTO`语句也能设计循环程序, 但不推荐使用`GOTO`语句

`fortran`有等价声明:即用`equivalence(a,b)`,这样使得`a`,`b`使用同一块内存, 这样可以节省内存, 有时可精简代码. 

### FORTRAN90/95中的基本DO构造

在FORTRAN90/95中通过引入专用循环终止语句的方式来使得循环结构更为清晰. 如下:

```fortran
DO   循环控制( 循环变量=循环初值, 循环终值, 循环增量)
    循环体
END DO
```

如:

```fortran
DO   counter=2, limit, 2
    ans=ans+counter
END DO
```

也可以使用`labled`循环

```fortran
    program ex0608
    implicit none
    integer :: i,j
    
    outter: DO i=1,3
        inner: do j=1,3
            write (*,"('(',i2,',',i2')')") i,j
        END DO inner
    END DO outter

    stop
end
```

### DO WHILE 循环

循环不一定要由计数器的增, 减来决定是否该结束循环, 它可改由一个逻辑运算来做决定, 这就是`DO-WHILE`循环的功能

```fortran
DO  WHILE  (逻辑判断式)
    …..
END DO
```

如:

```fortran
counter=2  !设置初始值
DO   while (counter<=limit)
    ans=ans+counter
    counter=counter+2
END DO
```

## 数组

### 隐DO循环

隐DO循环可以嵌套, 如：

`((A(i,j),i=1,3),j=1,3)`

`(expr,i=1,5,1)`

### 数组的说明

数组的下标必须用逗号隔开, 而不能像matlab一样既可以用逗号也可以用空格, fortran的数组元素之间不能用空格. 

与C不同, Fortran数组索引值默认从`1`开始, 而且可以在声明时改变该规则, 下标是整型常量, 变量或表达式, 可正, 可负, 也可以为`0`, 但必须在引用的数组的维数之内. 
    
如

```fortran
integer a(-3:1)      !索引值为-3, -2, -1 , 0, 1
```

***

数组的声明

Fortran 77中数组的声明, 必须使用`DIMENSION`命令

```fortran
Integer   a;         !先声明a是整型
Dimension  a(10)    !再声明a是大小为10的数组
```

***
Fortran 95中可以用简单的方法:

```fortran
Integer  a(10)
real  b(3,3)    !最简单的方法
Integer,dimension(10)::  a      !另一种方法
```

### 声明可变大小的数组

Fortran77中还没有支持可变大小的数组, 就只能先声明一个超大数组, 然后往里面写数据. 

而Fortran90的数组则可以声明可变大小的数组, 然后根据需求实时改变它的大小. 

使用可变大小的数组要经过两个步骤:

+ 第一步当然是声明, 声明时要加上`allocatable`, 数组的大小也不用赋值, 使用一个冒号`:`来代表它是一维数组就行了. 
+ 第二步, 声明完成后, 这个数组还不能使用, 因为还没有设置它的大小. 要经过`allocate`这个命令到内存中配置了足够的空间后才能使用数组. 

如:

```fortran
Integer :: students;
Integer, allocatable :: a(:) ；   ！声明一个可变大小的一维数组
Allocate(a(students));          ! 配置内存空间
```

除了一维数组外, 其他维度的数组当然也可以使用. 方法如下:

```fortran
Integer,allocatable ::a2(:,:) ；        ！用2个冒号, 代表二维数组
Integer,allocatable ::a3(:,:) ；        ！用3个冒号, 代表三维数组
```

`ALLOCATE`命令请求内存使用空间, 而`DEALLOCATE`则是逆向运行, 把用`ALLOCATE`命令所得到的内存空间释放掉, 使用这两个命令可以用来重新设置数组的大小. 

***
如何声明一个单位矩阵？

例子:声明一个`3*3`维的单位矩阵

```fortran
REAL(kind=8)  B(3,3);
DATA B / 1.0D+0, 3*0.0D+0, 1.0D+0, 3*0.0D+0, 1.0D+0/
```

数组在内存中的存放顺序也与`C`不同(正好相反), 如`a(2,2)`在内存中的存放顺序为`a(1,1),a(2,1),a(1,2),a(2,2)`;

原则是放低维的元素, 再放高维的元素, 此规则称为`column major`

矩阵输出时也是按列输出. 

FORTRAN中, 数组最多可以声明为7维. 

### 数组的引用

在FORTRAN77标准中, 数组只允许在输入输出语句中进行整体操作. 在其他场合, 只能对数组的元素通过下标索引的方式逐个进行操作. 

到了FORTRAN90标准, 这一限制被大大放宽了. 数组除了能够进行整体操作以外, 还能对数组中的片段和数组的整体进行操作. (且其引用方式与`MATLAB`很相似). 

引用数组元素的语法如下:

`数组名(下标,下标,...)`

引用数组片段的语法如下:

`数组名(下标范围, ….)`

数组片段的引用方式较为灵活, 既可以通过三元下标来进行引用, 也可以通过向量下标来进行引用. 三元下标的格式如下:

```fortran
[下界]:[上界]:[步长]
```

如:  `B(1,1:5)`   `B(1,1:10:2)`

### 数组的赋值

Fortran 77中数组的声明, 可以使用DATA命令 或隐含式循环来赋初值；

Fortran 95中可以直接设置初值；如:

```fortran
integer  ::a(5)=(/1,2,3,4,5/);
```

此时, 括号和除号之间不能有空格；

数组构造器是由括号和斜线之间的一系列值或隐DO循环组成. 其一般形式为:
`(/取值列表/)`

取值列表可以是标量, 隐DO循环或任意秩的数组. 

其中的所有值的类型都相同, 以逗号隔开. 如果列表中出现了数组, 它的值是按列来赋的. 
例:

```fortran
INTEGER A(6)
A=(/1,2,3,4,5,6/)    ! 斜杠与括号间不能有空格
```

例:

```fortran
C1=(/4,8,7,6/)            ! 标量表示
C2=(/B(I,1:5),B(I:J,7:9)/)      ! 数组表示
C3=(/(I,I=1,4)/)           ! 隐DO循环
C4=(/4,A(1:5),(I,I=1,4),7/)     ! 混合表示
```

下面是一些数组构造器的替换格式:

***
用方括号代替括号和斜线, 例如下面两个数组构造器是等价的:

例:

```fortran
INTEGER C(4)
C=(/4,8,7,6/)
C=[4,8,7,6]      原来fortran赋值数组可以使用方括号
```

### 冒号三元下标

(代替隐DO循环)来指定值的范围和步长, 例如下面两个数组构造器是等价的, 例:

```fortran
INTEGER D(3)
D=(/1:5:2/)             ! 三元下标格式
D=(/(I,I=1,5,2)/)        ! 隐DO循环格式
```

### RESHAPE语句

可以用内在函数`RESHAPE`语句把一个一维数组改变形状后赋给另一已知形状的数组. 

由于Fortran的数组顺序不同于C, Fortran中左边第一维是变化最快的, `RESHAPE`语句可以用于当Fortran过程化为C过程时将Fortran数组改序成C数组序. 

它的一般形式为:

`result=RESHAPE(input,shape,[,补充][,顺序])`. 

`input`可以是任意数据类型的数组, 它提供结果数组的元素. 
当补充被省略或其大小为`0`时, `input`的大小必须大于`result`. 

`shape`形状为`7`个元素以下的一维固定的整型数组, 它决定了结果数组的形状, 其大小为非负整数. 

`补充`为与源数组相同类型和属性的数组, 当源数组的大小比结果数组小时用来补充元素值. 

`顺序`必须是和形状数组有相同形状的整型数组,其元素为`(1,2,...,n)`的排列, `n`是形状数组的大小. 当顺序被省略时, 默认值为`(1,2,...,n)`. 

因此, `result`数组的形状与`shape`数组相同, 与`input`数组的类型和属性相同, 大小是`shape`数组元素值的乘积. 

`result`数组的元素是`input`数组的元素按`顺序`指定的维度顺序排列, 当省略`顺序`数组时, 元素按通常的顺序排列. 

`input`数组元素用完后按序用`补充`数组的元素, 必要时重复使用`补充`数组直至结果数组的所有元素均有其值. 

例：

```fortran
RESHAPE((/3,4,5,6,7,8/),(/2,3/))
``` 

```fortran
RESHAPE((/3,4,5,6,7,8/),(/2,4/),(/1,1/),(/2,1/))
```

```fortran
INTEGER AR1(2,5)
REAL F(5,3,8),C(8,3,5)
AR1=RESHAPE((/1,2,3,4,5,6/),(/2,5/),(/0,0/),(/2,1/))
! AR1的取值为     [1 2 3 4 5]
! [6 0 0 0 0]
C=RESHAPE(F,(/8,3,5/),ORDER=(/3,2,1/))   ! 将Fortran数组序化为C数组序
END
```

例:

```fortran
INTEGER B(2,3),C(8)
B=RESHAPE((/1,2,3,4,5,6/),(/2,3/))    ! 赋值给形状为(2,3)的数组
C=(/O,RESHAPE(B,(/6/)),7/)           ! 赋值给向量C之前先把B转换成向量
```

### 常用内在函数

***
内部基本函数

在FORTRAN语言的数组表达式中, 允许将数组作为内部基本函数的参数. 
此时, 内部基本函数的函数值就是一个同参数数组形状相同的数组, 例如, 

`B=SQRT(A)`,即对数组`A`的每一个元素开方. 

***
矩阵乘积函数

```fortran
C=MATMUL(A,B)
```

使用时, 数组`A`和`B`只能是维数为`1`或`2`的数组；

数组`A`和`B`中至少要有一个的维数为`2`, 也就是不能是两个向量相乘. 

***

向量点乘函数

```fortran
C=DOT_PRODUCT(A,B)
```

## 格式化输入输出

### 表控输入输出

1. 不同计算机系统对表控格式输出的规定不同, 例如对一个整型数, 有的系统规定输出占13列, 有的系统规定输出占10列, 
也有的系统不规定固定的列数而按照数据的实际长度输出, 再用一个空格作分隔符. 
2. 如果在输入数据行中出现`/`号, 表示对`READ`语句的输入到此结束, 未被赋值的变量将不予赋值. 

### WRITE命令

write命令语法

向屏幕输出字符串:

```fortran
Write(*,*)    "string"    !一般用法
Write(6,*)    "string"     !严谨一些的用法
Write(UNIT=6,FMT=*)    "string"  !最严谨的用法
```

因为屏幕的输出`UNIT`位置就是`6`. 

***
写入字符串

`Write`命令不仅可以写入屏幕与文件, 而且还可以写入字符串, fortran轨道确定程序中的`errout`文件就用到了这一功能. 

例如:

```fortran
CHARACTER*6 :: NAME=’hahaha’;
CHARACTER*60 MESS;
INTEGER::  IERR=4;
WRITE (MESS,*) IERR, NAME  ！将IERR和NAME写入到字符串MESS中
```

### FORMAT格式控制语句

语句格式:

```fortran
标号    FORMAT(格式描述符)
```

例如:     

```fortran
write(*,100)   i,j,k;
100    FORMAT(1X,i3,i5,i7),
```

其中, `1X`是换行控制符(走纸控制),`i3`表示`i`变量的值输出占`3`列, `i5`表示`j`变量的值输出占`5`列

***
格式描述符

主要介绍:I, F, E, X, 纵向走纸, '(撇号), r(重复系数), /(斜杠)等

+ `X`描述符, 作用: 用于输出空格,一般形式: `nX`
+ `I`描述符,作用: 用于整型数据的输出,一般形式: `Iw` 或 `Iw.n`
+ `F`描述符,作用:用于实数的小数形式输出,一般形式: `Fw.d`
+ `E`描述符,作用:用于实数的指数形式输出,一般形式:`Ew.d`

其中:`E`--实数的指数形式输出;

+ w--字段宽度；
+ d--数字部分的小数位数. 
+ 数值部分`＜1`

+ `A`描述符,作用:用于字符型数据的格式描述,一般形式: `Aw`或`A`,
其中`w`是字段宽度. 
+ `'`号描述符,作用:用于输出字符常量, 即把撇号内的字符串原样照打,

例如:

```fortran
write(*,100) i,j
100  format(1x,'i=',i3,'  j=',i4)
```

***
`H`描述符,作用:它的作用与撇号描述符类似, 也可以输出字符型常量,一般形式: `nH`
建议:建议最好不要使用H描述符, 而是使用撇号描述符, 避免错误

例如:  

```fortran
I=123
WTRITE(*,100),I
100  FORMAT(1X,2HI=,I3);
```

***
斜杠描述符

反斜杠`\`描述符和美元`$`描述符的作用相同, 都是在输出一个记录行后取消回车符, 常用于输出字符串与输入数据显示于屏幕同一行的情形. 

例如:

```fortran
(*,'("please enter your name",$)');
Read(*,*) My_age
```

***
重复系数`r`

在`format`语句中, 如果出现几个(或几组)相同的格式编辑符, 则可以利用重复系数而只写一个(或一组)编辑符. 

`r`--可重复使用的次数. 

例:

```fortran
write(*,100) n1,n2,x,y1,y2,y3
100   format (1x, i10, i10, f8.3, f7.2, f7.2, f7.2)
! 等价于
100Format (1x, 2i10, f8.3, 3f7.2)
```

## 函数操作

### 语句函数

语句函数的定义

```fortran
REAL(KIND=8)   X,  F
F(X)=X**2+X+1
```

***
语句函数的调用

语句函数一旦被定义后, 就可以在本程序单元中被调用. 调用的形式和调用内容函数形同, 即:

`语句函数名(实参)`

语句函数定义语句是非执行语句, 它应该放在所有可执行语句之前和所有的说明语句之后. 
语句函数只能在本程序单元中被使用. 

### 函数子程序

定义的一般形式:

```fortran
类型说明符  FUNCTION  函数名(形参表)
函数主体
函数名=表达式
END
```

### 子例行程序

子例行程序定义的一般形式:

```fortran
SUBROUTINE   函数名(形参表)
...
end
```

子例行程序的调用:

```fortran
CALL    子程序名(实参)
```

### 函数子程序与子例行程序的区别

子例行程序的名称不用来返回函数的处理结果, 因此是没有类型的. 所以不能定义子例行程序的类型. 

子例行程序必须以`SUBROUTINE`语句开头, 以`END`语句结束. 

能用函数子程序实现的功能, 都能用子例行程序来实现, 反之亦然. 因此在程序设计时, 要对具体问题选择哪种方式. 

由于不能给子例行程序名赋值, 所以在将函数子程序转换为子例行程序时, 应该增加一个变量用来带回在函数子程序中由函数名带出的子例行程序处理结果. 

子例行程序的调用需要专门的`CALL`语句. 

### 数据块子程序(BLOCK DATA)

1. 数据块子程序是非执行程序单元, 因而在其中不能出现任何可执行语句, 也不能被别的程序调用
2. 它是专门用来给有名公用区(全局变量)中的项目赋初值的子程序. 注意:`COMMON`变量不能直接在子程序或主程序中使用`DATA`命令来设置初值, 要在`BLOCK  DATA`程序模块中使用`DATA`命令来设置初值. 
3. 数据块子程序是一个完整的程序单元. 它由`BLOCK  DATA`语句开始, `END`语句结束
4. `BLOCK DATA`只能用来设置全局变量的初值, 而且在主程序执行前, 全局变量的初值内容就会设置完毕, 事实上这一段程序会在主程序执行前就会生效；
5. 全局变量不能声明成常量, 所以`BLOCK DATA`中不能出现`PARAMETER`. 

### MODULE

1. `MODULE`可以用来封装程序模块, 通常是用来把程序中具备相关功能的函数及变量封装在一起. 例如需要使用全局变量时, 可以把全局变量都声明在`MODULE`中, 需要使用这些变量的函数只要`US`E这个`MODULE`就可以使用它们. 
2. `MODULE`中的变量如果不是声明成全局变量, 这些变量被函数使用时, 只会是函数中的局部变量. 
3. `MODULE`中还可以容纳函数, 语法如下:

```fortran
Module  module_name
     ………       !先写声明相关程序代码
    contains     !从contains后开始写作函数
    subroutine sub_name
    ………
        end subroutine [sub_name]    !subroutine不能省略
    function function_name
       ……
        end function [function_name]    !function不能省略
end
```

这个做法比较符合模块化概念, 
编写大程序时, 可以把程序中属于绘图功能的部分放在`module Graphics`中, 把数值计算的部分放在`module Numerical`中. 

Visual Fortran中所提供的一些扩充函数库就用这个方法来归类, 像是数值函数库`IMSL`就放在`module IMSL`,`3D`绘图程序库`OpenGL`的函数就放在`module OpengGL`中. 

使用它们之前都要先`use IMSL` ,`use OpenGL`. 

## 文件操作

### 记录结构

一个数据文件在磁盘上的存放格式确定了文件的记录结构. 

例如, 在`DOS`或`windows`下用现有的编辑器建立一个文件`S.DAT`,其数据存放方式如下:

```fortran
1, 2, 3, 4, 5
6, 7, 8, 9, 10
11, 12, 13, 14, 15
16, 17, 18, 19, 20
```

文件中存有`4`行数据, 每行`5`个数据. 

在建立这些数据时, 当每行最后一个数据输完后, 打入了一个回车或换行标记(当然这是不可见标记). 

以上文件有`4`行, 每行末尾都有一个标记. 因此, 将每一行称为一个记录. 

可以这样说, 一个记录包括多个数据, 以回车或换行标记作为记录的结束. 
这就是记录的概念. 

文件中的记录多少, 每个记录的数据多少就是这个文件的记录方式--也称为记录结构. 

由多个数据记录按一定的结构形式存入磁盘, 就组成了文件. 

### open语句的使用

`OPEN`语句的功能是打开一个文件, 其语句的基本格式为:(前后位置可以变化)

```fortran
OPEN(UNIT=number,FILE=filename,STATUS=status,ACCESS=access,…)
```

如：

`open(unit=10,file='hello.txt')`

其中, 

`UNIT=number`

`number`必须是一个正整数, 用来给后面的文件指定一个代码(这样方便使用`write`或`read`等命令在文件上读写), 它可以使用变量或是常量来赋值. 

`Number`值最好避开`1`, `2`, `5`, `6`. 
因为`2`, `6`是默认的输出位置, 也就是屏幕. `1`, `5`则是默认的输入位置, 也就是键盘. 

***
`FILE=filename`

这个字段用来指定所要打开的文件名称, 文件名要符合操作系统规定. 最好不要使用中文名

***

```fortran
FORM='FORMATTED' OR 'UNFORMATTED'
```

```fortran
FORM字段只有两个值可以设置:'FORMATTED' 或 'UNFORMATTED'
```

```fortran
FORM='FORMATTED'      表示文件使用"文本文件"格式来保存
FORM='UNFORMATTED'   表示文件使用"二进制文件"格式来保存
```

这一栏不给定时, 默认值为`FORMATTED`

+ STATUS='NEW'或'OLD', 'REPLACE'或'SCRATCH'或'UNKNOWN'
+ STATUS='NEW'   表示这个文件原本不存在, 是第一次打开
+ STATUS='OLD'    表示这个文件原本就已经存在
+ STATUS='REPLACE  文件若已经存在, 会重新创建一次, 原本的内容会消失. 文件若不存在, 会创建新文件. 
+ STATUS=' SCRATCH'   打开一个暂存文件, 暂存文件是临时文件, 当关闭或终止程序时, 文件将被删除. 这时不需要指定文件名称, 也就是`FILE`这一栏可以省略, 因为程序本身会自动取一个文件名. 
+ STATUS='UNKNOWN' 缺省时的默认值,  文件存在则打开, 不存在则创建, 相当于`NEW`与`OLD`的综合利用. 

***
ACCESS='SEQUENTIAL'或'DIRECT', 这个字段用来设置文件读写的方法

`ACCESS='SEQUENTIAL'`  读写文件的操作会以顺序的方法来做读写, 这就是"顺序读取文件"
`ACCESS='DIRECT'`  读写文件的操作可以任意指定位置, 这就是"直接读取文件"

不赋值时, 默认值为`'SEQUENTIAL'`

+ `RECL=length`
+ `ERR=LABEL`

这个字段用来设置当文件打开发生错误时, 程序会跳跃到`LABEL`所指的行代码处来继续执行程序. 

### 直接读取文件的操作

在FORTRAN语言中, 读取文件的操作可以有"顺序读取"及"直接读取"两种方法. 

所谓的直接访问文件, 即将文件事先分区成好几个同样大小的小模块, (即指定记录号, 且在每条记录中的数据还是按顺序的), 再来进行读写的工作. 

### 读写命令WRITE与READ语句的运用

```fortran
WRITE/READ(UNIT=number,FMT=format,NML=namelist,REC=record,IOSTAT=stat,ERR=errlabel,END=ENDLABEL,ADVANCE=advance,SIZE=size)
```

```fortran
UNIT=number 指定文件代码
FMT=format   指定输入输出格式, 若为*号则表示自由格式(为了读写数据的准确, 建议使用*号)
```

***
REWIND的使用

`Rewind`语句将一个文件的操作位置重新定位在其第一条记录上. 

其语句格式为:

```fortran
REWIND(u,ERR=LABEL,IOSTAT=iocheck)
```

+ `u`,  文件编号
+ `ERR=LABEL`   遇到错误转到`LABEL`语句
+ `IOSTAT=iocheck`   返回文件打开的状态, 见`OPEN`语句. 

***
BACKSPACE语句

`Backspace`语句用于在文件数据操作中, 从当前数据位置回退到上一个数据位置. 

其语句格式为:

```fortran
BACKSPACE(UNIT=number,ERR=errlabel,IOSTAT=iostat)
```

***
`ENDFILE`语句

把当前的文件位置变成文件的结尾. 

***
`INQUIRE`语句

查询文件状态命令

## 常用的内部过程

### 通用名与专用名

调用通用名时, 函数会根据参数的类型自动确定要调用的具体函数的专用名. 

例如, 求根函数的通用名是`SQRT`, 专用名有三个:`SQRT`, `DSQRT`和`CSQRT`, 分别用于求单精度实型, 双精度实型和复型数据的根. 

当调用`SQRT`时, 如果输入的参数为单精度实型, 则会调用专用名SQRT；如果输入的参数为双精度实型, 则会调用专用名DSQRT；如果参数为复型, 则会调用专用名CSQRT. 

之所以存在通用名与专用名共存的现象, 是为了与早期的FORTRAN标准相兼容. 很多早期的标准函数都是采用专用名的形式, 例如在FORTRAN66中求实数相除的余数会调用AMOD函数而不是MOD函数. 

由于专用名一般仅限于FORTRAN子集中, 在标准FORTRAN中, 会通过接口将各种专用名写在同一个通用名的过程中, 在代码执行时会自动调用与参数类型匹配的专用函数. 

因此在编写程序时, 直接使用通用名就可以了. 

### 常用数学函数

***
绝对值函数

函数原型如下:`C=ABS(X)`

  其中, `ABS`是FORTRAN中绝对值函数的通用名. 除了这个通用名之外, 绝对值函数还有四个专用名, 如下所示:

+ `ABS`, 专用于求默认种别的实型数据的绝对值, 返回值也为默认种别的实型数据. 
+ `IABS` , 专用于求默认种别的整型数据的绝对值, 返回值也为默认种别的整型数据. 
+ `DABS `, 专用于求双精度的实型数据的绝对值, 返回值也为双精度的实型数据. 
+ `CABS `, 专用于求默认种别的复型数据的绝对值, 返回值也为默认种别的复型数据. 

***
正弦函数
函数原型如下: `C=SIN(X)` (函数中参数的单位是弧度而不是度, 注意！)

其中, `SIN`是FORTRAN中正弦函数的通用名. 除了这个通用名之外, 正弦函数还有三个专用名, 如下所示:

+ `SIN`, 专用于求默认种别的实型数据的正弦值, 返回值也为默认种别的整型数据. 
+ `DSIN`, 专用于求双精度的实型数据的正弦值, 返回值也为双精度的实型数据. 
+ `CSIN` , 专用于求默认种别的复型数据的正弦值, 返回值也为默认种别的复型数据. 

***
函数原型如下:`C=SIND(X)` (函数中参数的单位是度而不是弧度, 类似MATLAB,注意！)

其中, `SIND`是`FORTRAN`中正弦函数的通用名. 除了这个通用名之外, 正弦函数还有三个专用名, 如下所示:

+ `SIND` , 专用于求默认种别的实型数据的正弦值, 返回值也为默认种别的整型数据. 
+ `DSIND` , 专用于求双精度的实型数据的正弦值, 返回值也为双精度的实型数据. 
+ `CSIND`, 专用于求默认种别的复型数据的正弦值, 返回值也为默认种别的复型数据. 

***
余弦函数
函数原型如下:

C=COS(X) (函数中参数的单位是弧度而不是度, 注意！)

其中, `COS`是FORTRAN中正弦函数的通用名. 除了这个通用名之外, 余弦函数还有三个专用名, 如下所示:

+ `COS` , 专用于求默认种别的实型数据的余弦值, 返回值也为默认种别的整型数据. 
+ `DCOS` , 专用于求双精度的实型数据的余弦值, 返回值也为双精度的实型数据. 
+ `CCOS` , 专用于求默认种别的复型数据的余弦值, 返回值也为默认种别的复型数据. 

***
函数原型如下:
C=COSD(X) (函数中参数的单位是度而不是弧度, 类似MATLAB,注意！)

其中, COSD是FORTRAN中正弦函数的通用名. 除了这个通用名之外, 余弦函数还有三个专用名, 如下所示:

+ `COSD` , 专用于求默认种别的实型数据的余弦值, 返回值也为默认种别的整型数据. 
+ `DCOSD` , 专用于求双精度的实型数据的余弦值, 返回值也为双精度的实型数据. 
+ `CCOSD`, 专用于求默认种别的复型数据的余弦值, 返回值也为默认种别的复型数据. 

***
反正弦函数
函数原型如下:
`C=ASIN(X) `(函数中返回值的单位是弧度而不是度, 注意！)

其中, ASIN是FORTRAN中正弦函数的通用名. 除了这个通用名之外, 正弦函数还有两个专用名, 如下所示:

+ `ASIN` , 专用于求默认种别的实型数据的反正弦值, 返回值也为默认种别的整型数据. 
+ `DASIN` , 专用于求双精度的实型数据的反正弦值, 返回值也为双精度的实型数据. 

***
函数原型如下:
`C=ASIND(X)` (函数中返回值的单位是度而不是弧度, 注意！)

其中, ASIND是FORTRAN中正弦函数的通用名. 除了这个通用名之外, 正弦函数还有两个专用名, 如下所示:

+ `ASIND` , 专用于求默认种别的实型数据的反正弦值, 返回值也为默认种别的整型数据. 
+ `DASIND` , 专用于求双精度的实型数据的反正弦值, 返回值也为双精度的实型数据. 

***
`DMOD`

### 常用其他函数

`DBLE`

语法:`result=DBLE(a)`

作用:把数据转换为双精度实数, 比如 `dble(Fre)` 相当于 `Fre*1.0D0`, 也就是把 `Fre` 转换成双精度的数据

参数类型:`ALL`

函数值类型:`real(8)`

***

`date_and_time`

在想获取日期和时间时, `date`, `time`, `ctime`, `ltime`都不标准, 推举使用的`是date_and_time`, 

这是一个 `2000` 年安全的 `Fortran 95` 内例程. 

`date_and_time`子例程返回实时时钟的数据和日期. 

返回本地时间以及本地时间与通用协调时间 (UTC)(也称为格林威治标准时间, GMT)之间的时差. 

### 常用库

***
`USE DFPORT`

为了使用`portability library(DFPORT)`, 可以使用这个语句. 链接时会在`DFPORT.LIB`中查找需要的函数. 

比如为了返回命令行参数就需要这个库. 

在文件夹 `D:\源文件\Visual Fortran 6.6(33106-060-1186591-00003)\X86\DF\LIB`  中可以找到该库. 

***
`USE DFLIB`

使用Visual Fortran的绘图功能时需要`module dflib`.
