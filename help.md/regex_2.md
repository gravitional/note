# learn.regex.2.md

## 前言

`Regular Expression` 久仰大名, 以前也一直有过类似的需求, 然而之前或者用其他工具实现了, 或者暴力解决了 😅
不过辣个咸鱼没点理想呢？加上 [notepad++](https://www.jianshu.com/p/1adced676d79) 事件, 坚定了我学习`Vim`的决心.
学 `Vim` 当然也要学习 `regex` 了, 当然 `regex` 的应用远远不止在 `Vim` 当中.

此笔记参考了：[runoob-tutorial](https://www.runoob.com/w3cnote/regular-expression-30-minutes-tutorial.html#mission) , 版权归原作者所有.
出于行文简洁的考虑, 摘抄的内容不会全部一一声明,   但我会把链接都放上来, 各位谅解 🤝

这个 **part2** 主要是更加详细的解说一下**regex**的用法.

## 字符类

要想查找数字, 字母或数字, 空白是很简单的, 因为已经有了对应这些字符集合的元字符.
但是如果你想匹配没有预定义元字符的字符集合(比如元音字母` a,e,i,o,u `),应该怎么办？

很简单, 你只需要在方括号里列出它们就行了,
像`[aeiou]`就匹配任何一个英文元音字母, `[.?!]`匹配标点符号`.或?或!`.
这里的 ` . ? ! ` 都不需要转义, (**大部分元字符在中括号里面失去原来的含义**)

我们也可以轻松地指定一个字符范围, 像`[0-9]`代表的含意与`\d`就是完全一致的：一位数字；
同理`[a-z0-9A-Z_]`也完全等同于` \w `(如果只考虑英文的话).

下面是一个更复杂的表达式：` \(?0\d{2}[) -]?\d{8} `

注意：` ( `和` ) `也是元字符, 后面的分组节里会提到, 所以在这里需要使用转义.

这个表达式可以匹配几种格式的电话号码, 像` (010)88886666 `, 或` 022-22334455 `, 或` 02912345678 `等.
我们对它进行一些分析吧：首先是一个转义字符` \( `,它能出现0次或1次(` ? `),然后是一个0, 后面跟着2个数字(` \d{2} `), 然后是` ) `或` - `或` 空格 `中的一个, 它出现1次或不出现(` ? `), 最后是8个数字( ` \d{8} `).

## 分枝条件

不幸的是, 刚才那个表达式也能匹配` 010)12345678 `或 ` (022-87654321 `这样的**不正确**的格式.
要解决这个问题, 我们需要用到分枝条件. 正则表达式里的分枝条件指的是有几种规则, 如果满足其中任意一种规则都应该当成匹配, 具体方法是用|把不同的规则分隔开.

听不明白？没关系, 看例子：

` 0\d{2}-\d{8}|0\d{3}-\d{7} `这个表达式能匹配**两种**以连字号分隔的电话号码：一种是三位区号, 8位本地号(如` 010-12345678 `), 一种是4位区号, 7位本地号(` 0376-2233445 `).

注意：元字符 ` | ` 具有最低的运算优先级.

` \(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8} `这个表达式匹配**3**位区号的电话号码, 其中区号可以用小括号括起来, 也可以不用, 区号与本地号间可以用**连字号**或**空格**间隔, 也可以没有间隔. 你可以试试用分枝条件把这个表达式扩展成也支持4位区号的.

` \d{5}-\d{4}|\d{5} `这个表达式用于匹配美国的邮政编码.
美国邮编的规则是5位数字, 或者用连字号间隔的9位数字.
之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时, 要注意各个条件的顺序. 如果你把它改成` \d{5}|\d{5}-\d{4} `的话, 那么就只会匹配5位的邮编(以及9位邮编的前5位). 原因是匹配分枝条件时, 将会从左到右地测试每个条件, 如果满足了某个分枝的话, 就不会去再管其它的条件了.

所以要把长的模式放在前面.

## 分组

我们已经提到了怎么重复单个字符(直接在字符后面加上限定符就行了)；

但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做 ` 分组 `), 然后你就可以指定这个子表达式的重复次数了, 你也可以对子表达式进行其它一些操作(后面会有介绍).

` (\d{1,3}\.){3}\d{1,3} `是一个简单的**IP地址**匹配表达式.
要理解这个表达式, 请按下列顺序分析它：
` \d{1,3} `匹配1到3位的数字, ` (\d{1,3}\.){3} `匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次, 最后再加上一个一到三位的数字` (\d{1,3}) `.

注：IP地址中每个数字都不能大于 ` 255 `. 经常有人问我, ` 01.02.03.04 ` 这样前面带有` 0 `的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 ` 0 (leading zeroes) `.

不幸的是, 它也将匹配` 256.300.888.999 ` 这种不可能存在的IP地址.
如果能使用算术比较的话, 或许能简单地解决这个问题.
但是正则表达式中并不提供关于数学的任何功能, 所以只能使用冗长的分组, 选择, 字符类来描述一个正确的IP地址：

```bash
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?).
```

理解这个表达式的关键是理解` 2[0-4]\d|25[0-5]|[01]?\d\d? `, 这里我就不细说了, 你自己应该能分析得出来它的意义.

## 反义

有时需要查找某个字符, 而它不属于一个类, 这个类已经被定义过.
比如想查找除了数字以外, 其它任意字符都行的情况, 这时需要用到反义：

|   ` 代码/语法 `   |   ` 说明 `   |
| ---- | ---- |
|   ` \W `   |  `匹配任意不是字母, 数字, 下划线, 汉字的字符 `    |
|   ` \S `   |  `匹配任意不是空白符的字符 `    |
|   ` \D `   |   ` 匹配任意非数字的字符 `   |
|  ` \B `    |   ` 匹配不是单词开头或结束的位置 `   |
|  ` [^x] `    |   ` 匹配除了x以外的任意字符 `   |
|  ` [^aeiou] `    |   `  匹配除了aeiou这几个字母以外的任意字符 `   |

例子：

` \S+ ` 匹配不包含空白符的字符串.

` <a[^>]+> ` 匹配用尖括号括起来的以` a `开头的字符串.

## 后向引用

使用小括号指定一个子表达式后, 匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理.
默认情况下, 每个分组会自动拥有一个组号, 规则是：从左向右, 以分组的左括号为标志, 第一个出现的分组的组号为` 1 `, 第二个为` 2 `, 以此类推.

呃……其实, 组号分配还不像我刚说得那么简单：

1. 分组` 0 `对应整个正则表达式
2. 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配, 第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
3. 你可以使用` (?:exp) `这样的语法来避免一个分组被编号

后向引用用于重复搜索前面某个分组匹配的文本. 例如, ` \1 `代表` 分组1 `匹配的文本. 难以理解？请看示例：

` \b(\w+)\b\s+\1\b `可以用来匹配重复的单词, 像` go go `, 或者` kitty kitty `.
这个表达式首先匹配一个单词, 如果单词开始处和结束处之间有多于一个的字母或数字` (\b(\w+)\b) `, 这个单词会被捕获到编号为1的分组中,
然后匹配` 1 `个或几个空白符(` \s+ `),
最后再次匹配分组` 1 `中捕获的内容(也就是前面匹配的那个单词)(` \1 `).

你也可以自己指定子表达式的组名.

要指定一个子表达式的组名, 请使用这样的语法：` (?<Word>\w+) `,
或者把尖括号换成` ' `也行：` (?'Word'\w+) `, 这样就把` \w+ `的组名指定为` Word `了.
要反向引用这个分组捕获的内容, 你可以使用` \k<Word> `.
所以上一个例子也可以写成这样：` \b(?<Word>\w+)\b\s+\k<Word>\b `.

使用小括号的时候, 还有很多特定用途的语法. 下面列出了最常用的一些：

| ` 代码/语法 ` | ` 说明 ` |
| --------- | ---- |
|     ` (exp) `      |  ` 匹配exp,并捕获文本到自动命名的组里 `    |
|     ` (?<name>exp) `      |   ` 匹配exp,并捕获文本到名称为name的组里, 也可以写成(?'name'exp) `   |
|     ` (?:exp) `      |  ` 匹配exp,不捕获匹配的文本, 也不给此分组分配组号 `    |
|     `xxx(?=exp) `      |   `xxx 之后应该是 exp `   |
|     ` (?<=exp)xxx `      |  `xxx 之前应该是exp `    |
|    ` (?!exp) `       |   ` 匹配后面跟的不是exp的位置 `   |
|     ` (?<!exp) `      |   ` 匹配前面不是exp的位置 `   |
|     `  (?#comment) `      |  ` 这种类型的分组不对正则表达式的处理产生任何影响, 用于提供注释让人阅读 `    |

我们已经讨论了前两种语法.
第三个` (?:exp) `不会改变正则表达式的处理方式, 只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面, 也不会拥有组号.

## 零宽断言

又叫做预查.

用正则表达式去匹配一个字符实例, 如果匹配成功的话,
正则表达式里面的每个部分(一个元字符, 或者一个表达式), 都将对应字符串的一部分.
它们是一一对应的.
我们把这个过程叫做, 正则表达式的**模式**会**消耗**字符.

所以正则表达式靠前的模式(不妨叫做**先前模式**)的匹配成功与否, 会对它后面的模式匹配(不叫做**后续模式**)造成影响. 因为先前模式一旦匹配成功, 字符就被**消耗**掉了, 后续模式就匹配不到了.

但并不是所有模式都会**消耗**字符, 有些只消耗**位置**.

接下来的四个用于查找在某些内容(但并不包括这些内容)**之前或之后**的东西,
也就是说它们像`\b,^,$`那样用于指定一个位置, 这个位置应该满足一定的条件(即断言,  assertion), 因此它们也被称为**零宽断言**(意思是它们并不消耗目标字符, 只匹配位置, 实际字符串中并不出现, 所以称之为零宽).

最好还是拿例子来说明：
注：**断言**用来声明一个应该为**真**的事实. 正则表达式中只有当断言为真时才会继续进行匹配.

` (?=exp) `也叫**零宽度 正 预测先行 断言**,
它断言(认为)**先前模式**(即` (?=exp) `前面的模式)的后面能匹配表达式` exp `.

比如` \b\w+(?=ing\b) `, 能匹配以` ing `结尾的单词, 但并不包括` ing `(有人把它叫做**预查不消耗字符**).

也就是, 如果查找` I'm singing while you're dancing. ` 时, 它会匹配` sing `和` danc `.

` (?<=exp) `也叫**零宽度 正 回顾后发 断言**,
它断言**后续模式**(即` (?=exp) `后面的模式)的前面能匹配表达式` exp `.
比如, ` (?<=\bre)\w+\b `会匹配以` re `开头的单词, 但并不包括` re `.
在查找` reading a book `时, 它匹配 ` ading `.

假如你想要给一个很长的数字中每三位间加一个逗号(我们从最右边开始加起),
你可以这样查找所有需要添加逗号的部分：
(下一步可以从右边开始, 找到三个数字, 就在前面加个逗号, 这里先省略下一步)

```bash
((?<=\d)\d{3})+\b
```

用它对` 1234567890 `进行查找时结果是` 234567890 `.
字符的长度显然是` 3 `的倍数, 然后可以把开头, 结尾, 中间的三连段都加上逗号.

下面这个例子同时使用了这两种断言：
` (?<=\s)\d+ ` and ` (?=\s) `
匹配以空白符间隔的数字(再次强调, 不包括这些空白符).

```bash
(?<=\s)+\d+(?=\s)+
```

## 负向零宽断言

前面我们提到过如何禁止正则表达式匹配的结果中含有某个字符或者某一类字符(反义).

但是如果我们只是想要确保某个字符没有出现, 但并不想去匹配它时(消耗字符)怎么办？
例如, 如果我们想查找这样的单词--它里面出现了字母` q `,但是` q `后面跟的不是字母` u `.

我们可以尝试这样：

```bash
\b\w*q[^u]\w*\b
```

匹配包含后面不是字母` u `的字母` q `的单词.
但是如果多做测试(或者你思维足够敏锐, 直接就观察出来了), 你会发现,
如果` q `出现在单词的结尾的话, 像` Iraq `,` Benq `, 这个表达式就会出错(会匹配我们不需要的东西).

这是因为` [^u] `总要匹配一个字符, 所以如果` q `是单词的最后一个字符的话, 后面的` [^u] `将会匹配` q `后面的单词分隔符(可能是空格, 或者是句号或其它的什么),
后面的` \w*\b `将会匹配下一个单词, 于是` \b\w*q[^u]\w*\b `就能匹配整个` Iraq fighting `. (可咱们又不用 ` fighting `, ` peace ` 她不香吗？)

负向零宽断言能解决这样的问题, 因为它只匹配一个位置, 并不消耗任何字符.
现在, 我们可以这样来解决这个问题：

```bash
\b\w*q(?!u)\w*\b
```

零宽度负预测先行断言` (?!exp) `, 断言先前模式的后面不能匹配表达式` exp `.
例如：` \d{3}(?!\d) `匹配三位数字, 而且这三位数字的后面不能是数字；
` \b((?!abc)\w)+\b `匹配不包含连续字符串` abc `的单词.

同理, 我们可以用` (?<!exp) `, 零宽度 负 回顾后发 断言 来断言**后续模式**的前面不能匹配表达式` exp `：

` (?<![a-z])\d{7} `匹配前面不是小写字母的七位数字.

一个更复杂的例子：

` (?<=<(\w+)>).*(?=<\/\1>) `匹配不包含属性的简单` HTML `标签内里的内容.
` (?<=<(\w+)>) `指定了这样的前缀：被尖括号括起来的单词(比如可能是` <b> `),
然后是` .* `(任意的字符串),
最后是一个后缀` (?=<\/\1>) `. 注意后缀里的` \/ `, 它用到了前面提过的**字符转义**；
` \1 `则是一个反向引用, 引用的正是捕获的第一组, 前面的` (\w+) `匹配的内容, 这样如果前缀实际上是` <b> `的话, 后缀就是` </b> `了.

整个表达式匹配的是` <b> `和` </b> `之间的内容(再次提醒, 不包括` <b> `和` </b> `本身).

注：请详细分析表达式` (?<=<(\w+)>).*(?=<\/\1>) `, 这个表达式最能表现零宽断言的真正用途.

## 注释

小括号的另一种用途是通过语法` (?#comment) `来包含注释.
例如：` 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199) `.

要包含注释的话, 最好是启用**忽略模式里的空白符**选项,
这样在编写表达式时能任意的添加空格, Tab, 换行, 而实际使用时这些都将被忽略.
启用这个选项后, 在` # `后面到这一行结束的所有文本都将被当成注释忽略掉.
例如, 我们可以把前面的一个表达式写成这样：

```bash
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/", 后面是先前捕获的标签
)       # 后缀结束
```

## 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时, 通常的行为是匹配**尽可能多**的字符(在使整个表达式能得到匹配的前提下).

以这个表达式为例：` a.*b `, 它将会匹配最长的以` a `开始, 以`b` 结束的字符串. 如果用它来搜索`aabab`的话, 它会匹配整个字符串`aabab`. 这被称为`贪婪匹配`.

有时, 我们更需要`懒惰匹配`, 也就是匹配**尽可能少**的字符.
前面给出的限定符都可以被转化为`懒惰匹配模式`, 只要在它后面加上一个问号`?`. 这样` .*? `就意味着匹配任意数量的重复, 但是在能使整个匹配成功的前提下使用**最少的重复**.
作为贪婪标记的`?` 拥有和 ` + * ？` 同样的运算符优先级.

现在看看懒惰版的例子吧：

` a.*?b `匹配最短的, 以`a`开始, 以`b`结束的字符串. 如果把它应用于`aabab`的话, 它会匹配`aab`(第一到第三个字符)和`ab`(第四到第五个字符).

注：为什么第一个匹配是`aab`(第一到第三个字符)而不是`ab`(第二到第三个字符)？
简单地说, 因为正则表达式有另一条规则, 比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——**The match that begins earliest wins**.

也就是我们之前说的**消耗字符**的概念, ***早买早享受***

|   ` 代码/语法 `     |   说明   |
| ---- | ---- |
| ` *? `    |  ` 重复任意次, 但尽可能少重复 `    |
|  ` +? `    |   ` 重复1次或更多次, 但尽可能少重复 `   |
|  ` ?? `    |   ` 重复0次或1次, 但尽可能少重复 `   |
|   ` {n,m}? `   |  ` 重复n到m次, 但尽可能少重复 `    |
|   ` {n,}? `   |   ` 重复n次以上, 但尽可能少重复 `   |

## 处理选项

上面介绍了几个选项如忽略大小写, 处理多行等, 这些选项能用来改变处理正则表达式的方式. 下面是` .Net `中常用的正则表达式选项：

|  名称 |   说明   |
| ---- | ---- |
| ` IgnoreCase(忽略大小写) `   |   ` 匹配时不区分大小写.  `   |
|  ` Multiline(多行模式) `    |  ` 更改^和$的含义, 使它们分别在任意一行的行首和行尾匹配, 而不仅仅在整个字符串的开头和结尾匹配. (在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)  `    |
|  ` Singleline(单行模式) `    |   ` 更改.的含义, 使它与每一个字符匹配(包括换行符\n).   `   |
|  ` IgnorePatternWhitespace(忽略空白) `    |  ` 忽略表达式中的非转义空白并启用由#标记的注释.  `    |
|  ` ExplicitCapture(显式捕获) `    |  ` 仅捕获已被显式命名的组.  `    |

一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是. 这两个选项之间没有任何关系, 除了它们的名字比较相似(以至于让人感到疑惑)以外.

注：在` C# `中, 你可以使用` Regex(String, RegexOptions) `构造函数来设置正则表达式的处理选项.
如：` Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase); `

## 平衡组/递归匹配

注：这里介绍的平衡组语法是由` .Net Framework `支持的；
其它语言／库不一定支持这种功能, 或者支持此功能但需要使用不同的语法.

有时我们需要匹配像` ( 100 * ( 50 + 15 ) ) `这样的可嵌套的层次性结构,
这时简单地使用` \(.+\) `则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式, 懒惰模式也有下面的问题).
假如原来的字符串里的左括号和右括号出现的次数不相等, 比如` ( 5 / ( 3 + 2 ) ) ) `, 那我们的匹配结果里两者的个数也不会相等. 有没有办法在这样的字符串里匹配到最长的, 配对的括号之间的内容呢？

为了避免` ( `和` \( `把你的大脑彻底搞糊涂, 我们还是用尖括号代替圆括号吧.
现在我们的问题变成了如何把` xx <aa <bbb> <bbb> aa> yy `这样的字符串里,
最长的**配对的尖括号**内的内容捕获出来？

这里需要用到以下的语法构造：

1. ` (?'group') ` 把捕获的内容命名为` group `,并压入` 堆栈 `(` Stack `)
2. `(?'-group')` 从堆栈上弹出最后压入堆栈的名为`group`的捕获内容, 如果堆栈本来为空, 则本分组的匹配失败
3. ` (?(group)yes|no) ` 如果堆栈上存在以名为` group `的捕获内容的话, 继续匹配`yes`部分的表达式, 否则继续匹配`no`部分
4. ` (?!) ` 零宽负向先行断言, 由于没有后缀表达式, 试图匹配总是失败

注：如果你不知道堆栈是什么东西, 你就这样理解上面的三种语法吧：

第一个就是在黑板上写一个`group`, 第二个就是从黑板上擦掉一个`group`,
第三个就是看黑板上写的还有没有`group`, 如果有就继续匹配`yes`部分, 否则就匹配`no`部分.

我们需要做的是每碰到了左括号, 就在压入一个`Open`,每碰到一个右括号, 就弹出一个,
到了最后就看看堆栈是否为`空`－－如果不为空那就证明左括号比右括号多, 那匹配就应该失败.
正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符), 尽量使整个表达式得到匹配.

```bash
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号, 在黑板上写一个"Open"
            [^<>]*        #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号, 擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面, 判断黑板上还有没有没擦掉的"Open"；如果还有, 则匹配失败

>                         #最外层的右括号
```

平衡组的一个最常见的应用就是匹配`HTML`,下面这个例子可以匹配嵌套的` <div> `标签：

```bash
<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>
```

## 还有些什么东西没提到

上边已经描述了构造正则表达式的大量元素, 但是还有很多没有提到的东西. 下面是一些未提到的元素的列表, 包含语法和简单的说明.

|   ` 代码/语法 `   |    ` 说明 `  |
| ---- | ---- |
|  ` \a `    |  ` 报警字符(打印它的效果是电脑嘀一声) `    |
|   ` \b `   |  ` 通常是单词分界位置, 但如果在字符类里使用代表退格 `   |
|   ` \t `   |  ` 制表符, Tab `    |
|  ` \r `    |  ` 回车 `    |
|  ` \v `    |   ` 竖向制表符 `   |
|  ` \f `    |  ` 换页符 `    |
|  ` \n `    |  ` 换行符 `    |
|   ` \e `   |  ` Escape `    |
|  ` \0nn `    |   `ASCII代码中八进制代码为nn的字符 `   |
|   ` \xnn `   |   `ASCII代码中十六进制代码为nn的字符 `   |
|  ` \unnnn `    |  `Unicode代码中十六进制代码为nnnn的字符 `    |
|   ` \cN `   |   `ASCII控制字符. 比如\cC代表Ctrl+C `   |
|  ` \A `    |   ` 字符串开头(类似^, 但不受处理多行选项的影响) `   |
|   ` \Z `   |   `字符串结尾或行尾(不受处理多行选项的影响) `   |
|  ` \z `    |  `字符串结尾(类似$, 但不受处理多行选项的影响) `    |
|    ` \G `  |   ` 当前搜索的开头 `   |
|   ` \p{name} `   |   ` Unicode中命名为name的字符类, 例如\p{IsGreek} `   |
|  ` (?>exp) `    |  ` 贪婪子表达式 `    |
|   ` (?<x>-<y>exp) `   |   ` 平衡组 `   |
|   ` (?im-nsx:exp) `   |   ` 在子表达式exp中改变处理选项 `   |
|   ` (?im-nsx) `   |   ` 为表达式后面的部分改变处理选项 `   |
|   ` (?(exp)yes|no) `   |   ` 把exp当作零宽正向先行断言, 如果在这个位置能匹配, 使用yes作为此组的表达式；否则使用no `   |
|   ` (?(exp)yes) `   |   ` 同上, 只是使用空表达式作为no `   |
|   ` (?(name)yes|no) `   |   ` 如果命名为name的组捕获到了内容, 使用yes作为表达式；否则使用no `   |
|  `  (?(name)yes) `   |   ` 同上, 只是使用空表达式作为no `  |

## 匹配规则与字符簇

### 基本模式匹配

模式, 是正则表达式最基本的元素, 它们是一组描述字符串特征的字符.
模式可以很简单, 由普通的字符串组成, 也可以非常复杂, 往往用特殊的字符表示一个范围内的字符, 重复出现, 或表示上下文. 例如：

```regex
^once
```

这个模式包含一个特殊的字符`^`, 表示该模式只匹配那些以`once`开头的字符串.
例如该模式与字符串`once upon a time`匹配, 与`There once was a man from NewYork`不匹配.
正如如`^`符号表示开头一样, `$`符号用来匹配那些以给定模式结尾的字符串.

```regex
bucket$
```

这个模式与`Who kept all of this cash in a bucket`匹配, 与`buckets`不匹配. 字符 `^`和`$` 同时使用时, 表示精确匹配(字符串与模式一样). 例如：

```regex
^bucket$
```

只匹配字符串`bucket`. 如果一个模式不包括`^`和`$`, 那么它与任何包含该模式的字符串匹配. 例如：模式

```regex
once
```

与字符串

```regex
There once was a man from NewYork
Who kept all of his cash in a bucket.
```

是匹配的.

在该模式中的字母`o-n-c-e`是字面的字符, 也就是说, 他们表示该字母本身, 数字也是一样的.

其他一些稍微复杂的字符, 如标点符号和白字符(空格, 制表符等), 要用到转义序列. 所有的转义序列都用反斜杠(`\`)打头. 制表符的转义序列是 `\t`. 所以如果我们要检测一个字符串是否以制表符开头, 可以用这个模式：

```regex
^\t
```

类似的, 用`\n`表示`新行`, `\r`表示回车. 其他的特殊符号, 可以用在前面加上反斜杠, 如反斜杠本身用`\\`表示, 句号`.`用`\.`表示, 以此类推.

### 字符簇

在`Internet`的程序中, 正则表达式通常用来验证用户的输入. 当用户提交一个`FORM`(表格)以后, 要判断输入的电话号码, 地址, EMAIL地址, 信用卡号码等是否有效, 用普通的基于字面的字符是不够的.

所以要用一种更自由的描述我们要的模式的办法, 它就是`字符簇`. 要建立一个表示`所有元音字符的字符簇`, 就把所有的元音字符放在一个`方括号`里：

```regex
[AaEeIiOoUu]
```

这个模式与任何元音字符匹配, 但只能表示一个字符. 用`连字号`可以表示一个字符的范围, 如：

+ ``[a-z]` ; 匹配所有的小写字母
+ `[A-Z] ; 匹配所有的大写字母
+ `[a-zA-Z] ; 匹配所有的字母
+ `[0-9] ; 匹配所有的数字
+ `[0-9\.\-] ; 匹配所有的数字, 句号和减号
+ `[ \f\r\t\n] ; 匹配所有的白字符

同样的, 这些也只表示**一个字符**, 这一点**非常重要的**.
如果要匹配一个由一个小写字母和一位数字组成的字符串, 比如`z2`, `t6`或`g7`, 但不是`ab2`, `r2d3` 或`b52`的话, 用这个模式：

```regex
^[a-z][0-9]$
```

尽管`[a-z]`代表26个字母的范围, 但在这里它只能与**第一个字符**是小写字母的字符串匹配.

前面曾经提到`^`表示字符串的开头, 但它还有另外一个含义.
当在一组方括号里使用 `^` 时, 它表示**非**或**排除**的意思, 常常用来剔除某个字符. 还用前面的例子, 我们要求第一个字符不能是数字：

```regex
^[^0-9][0-9]$
```

这个模式与`&5`, `g7`及`-2`是匹配的, 但与`12`, `66`是不匹配的. 下面是几个排除特定字符的例子：

```regex
[^a-z]   : 除了小写字母以外的所有字符
[^\\\/\^] : 除了(\)(/)(^)之外的所有字符
[^\"\'] : 除了双引号(")和单引号(')之外的所有字符
```

特殊字符 `.`(点, 句号)在正则表达式中用来表示除了`新行`之外的所有字符.
所以模式 `^.5$` 与任何两个字符的, 以数字`5`结尾和以其他非`新行`字符开头的字符串匹配.
模式 `.` 可以匹配任何字符串, 除了`空串`和只包括一个`新行`的字符串.

正则表达式有一些内置的通用字符簇, 列表如下：

字符簇  描述

+ `[[:alnum:]]` :  任何字母和数字
+ `[[:alpha:]]` :  任何字母
+ `[[:blank:]]`: space and tab
+ `[[:cntrl:]]` : 控制字符 ASCII octal `000-037,177(DEL)`
+ `[[:digit:]]` :  任何数字
+ `[[:graph:]]`: 图形字符, `[:alnum:]` and `[:punct:]`.
+ `[[:lower:]]` :  任何小写字母
+ `[[:upper:]]` :  任何大写字母
+ `[[:print:]]`: 打印字符,  `[:alnum:]`, `[:punct:]`, and space
+ `[[:space:]]` :  任何空白字符
+ `[[:punct:]]` :  标点符号, 在`C` locale 和 ASCII 字符编码中,相当于`` ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~ ``
+ `[[:xdigit:]]` :  任何`16`进制的数字, `0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f`

转义字符

+ `\b` :  匹配单词边界空字符
+ `\B` :  匹配非单词边界空字符
+ `\<` :  匹配单词开头
+ `\>` :  匹配单词结尾
+ `\w` :  匹配word字符, 相当于`[[:alnum:]]`
+ `\W` :  匹配非 word 字符, 相当于`[^[:alnum:]]`
+ `\s` :  匹配空白, 相当于`[[:space:]]`
+ `\S` :  匹配非空白, 相当于`[^[:space:]]`

例如, `\brat\b` 匹配`rat`, `\Brat\B`匹配`crate`, 但不匹配`furry rat`.

`^` and `$`分别匹配一行的开头和结束.

可以指定字符的 unicode 编码. 例如, Bash命令`grep $'Λ\tω'`和`grep $'\u039B\t\u03C9'`都搜索前面提到的相同的三字符字符串`Λ ω`”.

### 确定重复出现

到现在为止, 你已经知道如何去匹配一个字母或数字, 但更多的情况下, 可能要匹配一个单词或一组数字.
一个单词有若干个字母组成, 一组数字有若干个单数组成. 跟在字符或字符簇后面的花括号`({})`用来确定前面的内容的重复出现的次数.

|   字符簇  |  描述    |
| ---- | ---- |
|    `^[a-zA-Z_]$`   |   `所有的字母和下划线`   |
|   `^[[:alpha:]]{3}$`    |   `所有的3个字母的单词`   |
|  `^a$`     |   `字母a`  |
|   `^a{4}$`   |  `aaaa`    |
|   `^a{2,4}$`    |  `aa,aaa或aaaa`    |
|   `^a{1,3}$`    |   `a,aa或aaa`  |
|   `^a{2,}$`    |   `包含多于两个a的字符串`   |
|   `^a{2,}`   |   `如：aardvark和aaab, 但apple不行`   |
|   `a{2,}`    |  `如：baad和aaa, 但Nantucket不行`   |
|   `\t{2}`    |  `两个制表符`  |
|   `.{2}`    |  `所有的两个字符`   |

这些例子描述了花括号的三种不同的用法.
一个数字 `{x}` 的意思是前面的字符或字符簇只出现`x`次 ；
一个数字加逗号`{x,}` 的意思是前面的内容出现`x`或`更多的次数` ；
两个数字用逗号分隔的数字 `{x,y}` 表示 前面的内容至少出现`x`次, 但不超过`y`次.
我们可以把模式扩展到更多的单词或数字：

```regex
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母, 数字或下划线的字符串
^[1-9][0-9]{0,}$        // 所有的正整数
^\-{0,1}[0-9]{1,}$      // 所有的整数
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
```

最后一个例子不太好理解, 是吗？
这么看吧：以一个可选的负号 `[-]?` 开头 (`^`), 跟着`1`个或更多的数字`[0-9]+`, 和一个小数点`\.`再跟上`1`个或多个数字`[0-9]+`, 并且后面没有其他任何东西`$`. 下面你将知道能够使用的更为简单的方法.

特殊字符`?`与`{0,1}` 是相等的, 它们都代表着： `0`个或`1`个前面的内容 或 前面的内容是`可选`的 . 所以`^\-{0,1}[0-9]{1,}$`可以写成 `^\-?[0-9]?$`

特殊字符`*` 与 `{0,}` 是相等的, 它们都代表着 `0个`或`多个`前面的内容 . 最后, 字符`+`与`{1,}`是相等的, 表示 `1个`或`多个`前面的内容 , 所以上面的4个例子可以写成：

```regex
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母, 数字或下划线的字符串
^[1-9][0-9]*$        // 所有的正整数
^\-?[0-9]+$          // 所有的整数
^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数
```

当然这并不能从技术上降低正则表达式的复杂性, 但可以使它们更容易阅读.

## ack 工具

[Linux ack命令使用详解 ](https://man.comptechs.cn/ack.html)

`ack` 官网：[ack is a grep-like source code search tool.](https://beyondgrep.com/)

### 安装

ubuntu下要安装`ack-grep`, 因为在`debian`系中, `ack`这个名字被其他的软件占用了.
ubuntu 20 可以直接安装

```bash
sudo apt-get install ack
```

参数说明： 这些参数在linux上的使用频率是相当高的, 尤其是你用`vim`做为IDE的话

+ `-c` ; 统计
+ `-i` ; 不区分大小写
+ `-h` ; 不显示名称
+ `-l` ; 只显文件名
+ `-n` ; 加行号
+ `-v` ; 显示不匹配
+ `-r`; 递归搜索子目录

### 实例

在记忆的时候大体上可以分为这几个部分：

+ Searching 代码搜索
+ Search output 搜索结果处理
+ File presentation 文件展示
+ File finding 文件查找
+ File inclusion/exclusion 文件过滤

***
grep常用操作

```bash
ack -r 'hello_world' # 简单用法
ack '^hello_world' . # 简单正则
ls -l | ack '.py' # 管道用法
```

***
Searching

简单的文本搜索, 默认是递归的.

```bash
ack hello
ack -i hello
ack -v hello
ack -w hello
ack -Q 'hello*'
```

***
Search File

对搜索结果进行处理, 比如只显示一个文件的一个匹配项, 或者xxx

```bash
ack --line=1       # 输出所有文件第二行
ack -l 'hello'     # 包含的文件名
ack -L 'print'     # 非包含文件名
```

***
File presentation

输出的结果是以什么方式展示呢, 这个部分有几个参数可以练习下

```bash
ack hello --pager='less -R'    # 以less形式展示
ack hello --noheading      # 不在头上显示文件
ack hello --nocolor        # 不对匹配字符着色
```

***
File finding

没错, 它可以查找文件, 以省去你要不断的结合 `find` 和 `grep` 的麻烦, 虽然在 `linux` 的思想是一个工具做好一件事.

```bash
ack -f hello.py     # 查找全匹配文件
ack -g hello.py$    # 查找正则匹配文件
ack -g hello  --sort-files     # 查找然后排序
```

***
File Inclusion/Exclusion

文件过滤, 个人觉得这是一个很不错的功能. 如果你曾经在搜索项目源码是不小心命中日志中的某个关键字的话, 你会觉得这个有用.

```bash
ack --python hello       # 查找所有python文件
ack -G hello.py$ hello   # 查找匹配正则的文件
```
