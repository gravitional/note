# perl 特殊变量

## `$_`

`for` 和 `foreach` 迭代时需指定控制变量, 例如 `for $i (...)`.

控制变量是可以省略的, 此时将使用 `Perl` 的默认标量变量 `$_`.
下面两条for迭代语句完全等价:

```perl
for(11,22,33){ say $_; }
for $_ (11,22,33) { say $_; }
```

`Perl` 的很多操作都允许省略操作目标,
此时将使用默认变量 `$_` 作为这些操作的操作目标.

## `&/`

`chomp`: 移除尾部换行符, 如果尾部没有换行符, 则不做任何事.

实际上, `chomp` 移除的是 `$/` 变量值对应的字符,
该变量表示 `输入记录分隔符`, 默认为换行符, 因此默认移除字符串尾部换行符.

## `$"`

实际上, 双引号内插数组时,
是使用内置变量 `$"` 的值作为数组元素分隔符的, 该变量默认值为空格:

## `$,`

`print`/`say` 输出时, 默认使用内置变量 `$,` 来分隔列表各元素,
该内置变量默认值为 `undef`, 因此默认情况下各元素被输出时紧密相连.

## `,`

另外, 在一些书籍, 文档(包括官方手册)上,
将标量上下文中的列表解释为逗号操作符的效果, 这也可以.
这是因为列表总是表现为逗号分隔各元素, 必要的时候使用一个小括号包围的形式
(`qw` 列表字面量在编译后也会转换成这种小括号形式),
而逗号是一个操作符, 它的作用是计算左边的表达式, 然后丢弃,
继续计算右边的表达式, 直到计算完最后一个表达式, 返回它的结果.

```perl
# 右边先丢弃1, 再丢弃2, 返回3
my $a = (1,2,3);
my $a=3, $b=4;
```

在这里也有一个比较特殊的用法需要理解:
括号里(或列表中)使用连续逗号, 不会产生任何效果.

```perl
my $a=3,$b=4,,,,;      # 等价于$a=3,$b=4
my @a = (1,,,,3,2,,);  # 等价于(1,3,2)
((3,,),,);              # 等价于((3)), 等价于(3)
```

## `$;`

在向hash中存储数据时, 如果想要用多份数据组合起来作为 `key`,
Perl提供了简便, 安全的逗号分隔 `,` 方式, 当使用 `逗号` 分隔多份数据组合为key时,
Perl会自动将每份数据使用 `下标连接符` (默认值为 `\034`)连接起来, 最终得到的字符串作为 `key`.
`\034` 通常可以认为是安全的连接符, 它是一个 `ASCII` 中的控制字符, 几乎不会出现在文本数据中.

```perl
my %h;
my ($x, $y) = qw(x y);

$h{$x, $y, "name"} = "junmajinlong.com";
say $h{$x, $y, "name"};
say $h{"$x\034$y\034name"};  # 等价形式
```

Perl使用的下标连接符由内置变量 `$;` 控制, 该内置变量的默认值为 `\034`.
因此, 下面这种写法也和上面的写法等价.

```perl
say $h{join($;, $x, $y, "name")};
```

## `+`符号

在某些省略函数调用括号时, 为了避免可能产生的歧义,
可在第一个参数前使用 `+`, 表示让后面的表达式作为函数参数,
相当于加了函数调用的括号:

```perl
print(3+4)*4;     # (1).输出7
print ((3+4)*4);  # (2).输出28
print +(3+4)*4;   # (3).输出28, 等价于(2)
```

## Perl正则匹配相关变量

```perl
$1 $2 $3 ...
#保存了各个分组捕获的内容

$&
$MATCH
# 保存了本次匹配到的内容

$`
$PREMATCH
# 保存了本次匹配起始位置之前的内容

$'
$POSTMATCH
# 保存了本次匹配结束位置之后的内容
```

还有几个比较常用的特殊变量是:

```perl
$+
$LAST_PAREN_MATCH
# 最后一个匹配成功的分组括号所匹配的内容(PAREN是括号parentheses的缩写)

%+
%LAST_PAREN_MATCH
# 保存本次匹配过程中所有命名分组捕获的内容, hash的key是分组名称, value是分组捕获的内容

@-
@LAST_MATCH_START
@+
@LAST_MATCH_END
# 前两个数组变量保存了各个分组匹配的起始位置. 后两个数组变量保存了各个分组匹配的结束位置.
```

`@- `, `@+`这两个变量结合 `substr` 用起来可以非常强大, 
通过它们可以构造出和 `` $` ``, `$&`, `$'` 等价的值, 
且能构造出更多匹配结果. 例如:

```perl
$` == substr($var, 0, $-[0])
$& == substr($var, $-[0], $+[0] - $-[0])
$' == substr($var, $+[0])
$1 == substr($var, $-[1], $+[1] - $-[1])
$2 == substr($var, $-[2], $+[2] - $-[2])
$3 == substr($var, $-[3], $+[3] - $-[3])
```
